155484ACount3439AllenACount() - Count the instances of an item in an array1139028608Code:

;Function:  
; ACount(),  
;  
;Author  
; Allen Powell 
; 
;Version:  
; 1.0.0  
;  
;Action:  
; Counts the instances of item in an array  
;  
;Syntax:  
; ACount($array, optional $string, optional $mode) 
;  
;Parameters:  
; $array - Array of items 
; $string (Optional) - Search Item to count 
; $mode (Optional) - 0 (default) Exact Match, 1 Instr Match 
; 
;Returns 
; >-1 Number of Items found 
; -1  Error in parameters  
;  
;Dependencies 
;  Kixtart 4.52 
; 
;Remarks:  
; V1.0.0 2006/01/17 
;  
;Example:  
; 
;$items=split("ape apple green grape ape") 
; 
;? "Items in Array:  " 
;for each $item in $items 
;  "" + $Item + " "  
;next 
; 
;? "Number of Items in Array:  " + acount($items) 
;? "Number of Items in Array matching string 'ape'  :"  + acount($items,"ape") 
;? "Number of Items in Array matching string 'grape'  :" + acount($items,"grape") 
;? "Number of Items in Array matching string 'banana'  :" + acount($items,"banana") 
;? "Number of Items in Array containing string 'ap'  :"  + acount($items,"ap",1) 
;? "Number of Items in Array containing string 'ape'  :"  + acount($items,"ape",1) 
;? "Number of Items in Array containing string 'gr'  :"  + acount($items,"gr",1) 
 

function ACount($array, optional $string, optional $mode)
  $acount=-1
  if vartype($array)>8192
    if vartype($string)<>0 
      if  vartype($string)<8192
        if $mode
          $acount=ubound(ascan($array,$string,,,3))+1
        else
          $acount=ubound(ascan($array,$string,,,2))+1
        endif
      else
        exit 160
      endif
    else
      $acount=ubound($array)+1 
    endif
  else
    exit 160
  endif
endfunction
 

161271ACROBAT7FIX79KdyerACROBAT7FIX() - Cleans up Acrobat 7 Splash/Yahoo! 
buttons0Code:

 ; FUNCTION   ACROBAT7FIX()
 ; ACTION   Remove Splash Ads and Yahoo! Toolbar for Adobe Acrobat
 ; AUTHOR   Kent Dyer (leptonator@hotmail.com)
 ; CONTRIBUTORS
 ; VERSION   1.4
 ; DATE CREATED   26-April-2006
 ; DATE MODIFIED  28-April-2006
 ; Release Notes: Version 1.1, Added Admin check for the HKLM
 ;                Version 1.2, Added in FOR SPLIT NEXT to reduce code..
 ;                Version 1.3, Changed SPLIT to LEFT for Version check..
 ;                Version 1.4, Added Admin check for the HKLM
 ; KIXTART  4.02
 ; SYNTAX  ACROBAT7FIX
 ; PARAMETERS 
 ;   None needed
 ; RETURNS  Removes the Splash and Yahoo! Toolbar Button
 ; REMARKS  We had to remove these options from an Acrobat Installer
 ;  While Altiris did a great job of deploying Adobe Acrobat, the HKCU settings
 ;  are not deployed
 ;  Additional Documentation is at - http://appdeploy.com/packages/detail.asp?id=404
 ;  Look above the link for dbass
 ;  This is also helpful too - http://www.adobe.com/support/downloads/detail.jsp?ftpID=2709
 ;  The InstallShield Tuner for Adobe Acrobat.  You need to install Adobe Acrobat from your
 ;  local workstation first before deploying it.  The location the InstallShield Tuner needs is:
 ;  C:\Program Files\Adobe\Acrobat 7.0\Setup Files\RdrBig\ENU
 ;  When deploying, you will want to use something like:
 ;  MSIEXEC.EXE /i "\\SERVER\software_packages\Acrobat_70\Adobe Reader 7.0.7.msi"
 ;   /qn TRANSFORMS="\\SERVER\software_packages\Acrobat_70\Adobe Reader 7.0.7.mst"
 ; DEPENDENCIES Adobe Acrobat Version 7.x, you should not need to restart to see the changes.
 ; EXAMPLE(s)
 ;      ACROBAT7FIX

 ; KIXTART BBS  http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=161232
 FUNCTION ACROBAT7FIX
    DIM $rc,$reg,$value
    IF LEFT(GETFILEVERSION(READVALUE('HKLM\SOFTWARE\Adobe\Acrobat Reader\7.0\Installer','Path')
       +'\Reader\AcroRd32.exe'),1)='7'
      IF READVALUE('HKLM\SOFTWARE\Adobe\Acrobat Reader\7.0\FeatureLockdown','bShowAdsAllow')<>0
         $rc=WRITEVALUE('HKLM\SOFTWARE\Adobe\Acrobat Reader\7.0\FeatureLockdown','bShowAdsAllow',0,'REG_DWORD')
      ENDIF
      ;To hide the Yahoo Internet Search Toolbar:
      $reg='HKCU\Software\Adobe\Acrobat Reader\7.0\AVGeneral\cToolbars\cWebSearchView\cPositions\cInternal'
      FOR EACH $value IN SPLIT('iDockPosition iFrameB iFrameL iFrameR iFrameT iLayout iOffset iStack bWindowHidden')
           IF READVALUE($reg,$value)<>0
            $rc=WRITEVALUE($reg,$value,0,'REG_DWORD')
         ENDIF
      NEXT
      IF READVALUE($reg,'bHidden')<>1
         $rc=WRITEVALUE($reg,'bHidden',1,'REG_DWORD')
      ENDIF
      IF READVALUE($reg,'iOrder')<>32
         $rc=WRITEVALUE($reg,'iOrder',32,'REG_DWORD')
      ENDIF
   ENDIF
 ENDFUNCTION

82841ActiveService17SealeopardActiveService()- Checks whether a service is 
active0

code:

;FUNCTION      ActiveService
;
;ACTION        Checks whether a service is active
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2 (added error codes)
;              1.1
;
;DATE CREATED  2002/01/18
;
;DATE MODIFIED 2003/05/18
;
;KIXTART       4.12+
;
;SYNTAX        ACTIVESERVICE(SERVICENAME)
;
;PARAMETERS    SERVICENAME
;              Required string containing the name of the service (local or UNC)
;
;RETURNS       1 if the service is running, otherwise 0
;
;REMARKS       Requires the global variable $TOOLSDIR (name of directory containing xnet.exe)
;              Requires XNET.EXE (from the Windows NT Server Resource Kit)
;
;DEPENDENCIES  none
;
;EXAMPLE       $active=ACTIVESERVICE("service")
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000139
;
function activeservice($servicename)
  Dim $shellcommand, $xnetexe

  $activeservice=0
  $servicename=trim($servicename)
  if $servicename=''
    exit 87
  endif
  if not isdeclared($TOOLSDIR)
    global $TOOLSDIR
  endif

  if @INWIN=1
    $xnetexe=$TOOLSDIR+'\xnet.exe'
    if exist($xnetexe)
      $shellcommand='%COMSPEC% /e:1024 /c '+$xnetexe+' list "'+$servicename+'" |find /c "Running" > nul'
      shell $shellcommand
      if @error
        exit @ERROR
      else
        $activeservice=1
      endif
    else
      exit 2
    endif
  else
    $retcode=readvalue('HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices',$servicename)
    if @ERROR=0 and $retcode<>''
      $activeservice=1
    else
      $activeservice=0
    endif
  endif
  exit @ERROR
endfunction



[ 19. May 2003, 04:10: Message edited by: sealeopard ]83742ADBL17SealeopardADBL() 
- Casts an string/array to a variant of subtype double and returns the result0

code:

;FUNCTION      ADbl
;
;ACTION        Casts an string/array to a variant of subtype double and returns the result
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.3
;
;DATE CREATED  2002/11/30
;
;DATE MODIFIED 2003/03/02
;
;KIXTART       4.20
;
;SYNTAX        ADBL(STRING)
;
;PARAMETERS    STRING
;              Required string or array from which to strip leading and trailing spaces
;
;RETURNS       Input string/array with subtype Double
;
;REMARKS       Function converts an array with a maximum of 26 dimensions
;
;DEPENDENCIES  none
;
;EXAMPLE       $array[0]='12.2'
;              $array[1]='12.3'
;              $rc=adbl($array)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000314
;
function adbl($array)
  Dim $element, $maxelements, $arraydim, $rc, $a

  select
  case ubound($array,1)=-1
    $array=cdbl($array)
  case ubound($array,2)=-1
    $maxelements=val(ubound($array))
    for $element=0 to $maxelements
      $array[$element]=cdbl($array[$element])
    next
  case ubound($array,27)=-1
    $arraydim=0
    do
      $arraydim=$arraydim+1
    until ubound($array,$arraydim)=-1
    $arraydim=$arraydim-1
    if $arraydim<=26
      dim $cmd, $vars
      $vars='$sub_a'
      for $a=2 to $arraydim
        $vars=$vars+', $sub_'+chr($a+96)
      next
      $cmd='dim '+$vars+@CRLF
      for $a=1 to $arraydim
        $cmd=$cmd+'for $sub_'+chr($a+96)+'=0 to ubound($array,'+$a+')'+@CRLF
      next
        $cmd=$cmd+'$array['+$vars+']=cdbl($array['+$vars+'])'+@CRLF
      for $a=1 to $arraydim
        $cmd=$cmd+'next'+@CRLF
      next
      $rc=execute($cmd)
    endif
  case 1
  endselect

  $adbl=$array
endfunction



[ 31. May 2003, 22:42: Message edited by: sealeopard ]139687Add28BryceAdd() 
Add large numbers toghther1115912360;Function      Add() 
; 
;ACTION        Adds large numbers toghther to get around the 32bit limitation. 
; 
;AUTHOR        Rogier (Bryce just put it in a UDF, with minor edit for UDF standards) 
; 
;VERSION       1.0 first publish 
; 
;KIXTART       4.22 
; 
;SYNTAX        RETCODE = ADD(STRING1, STRING2) 
; 
;PARAMETERS    STRING1 
;              a string containing a number 
; 
;              STRING2 
;              a string containing a number 
; 
;Return        A string containing the value of the 2 numbers added toghther. 
; 
;REMARKS       See this thread For original idea 
;              http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&amp;Number=54462&amp;page=0&amp;fpart=2&amp;vc=1 
;              Also Chris S. for prompting a need for this UDF 
;              NTDoc for prof-reading! 
; 
;DEPENDENCIES  None 
; 
;              ;return a large number 
;EXAMPLE       $Return = add('11644473600','1115830523') 
;               
Function Add($val1, $val2)
	DIM $ans, $pos, $a, $carry, $str1, $str2, $pos1, $pos2
	$ans=""
	If Len($val1) > Len($val2)
		$str2 = $val1 
		$str1 = $val2
	Else
		$str1 = $val1
		$str2 = $val2
	EndIf
	$pos1=Len($str1) $pos2=Len($str2)
	If Len($str1)<>Len($str2)
		While Len($str1)<Len($str2) $str1=" "+$str1 Loop
		While Len($str2)<Len($str1) $str2=" "+$str2 Loop
	EndIf
	$pos=Len($str1) $carry=0
	While $pos>0 or $carry>0
		If $pos>0 
			$a=Val(SubSTR($str1,$pos,1))+Val(SubSTR($str2,$pos,1))
		EndIf
		$a=$a+$carry
		If $a>9 
			$carry=1 $a=$a-10
		Else 
			$carry=0
		EndIf
		$ans=""+$a+$ans 
		$pos=$pos-1 $a=0
	Loop
	$add = $ans
EndFunction
157248AddIEButton1024MartAddIEButton() - Add a button to the IE toolbar1140008711Code:


;FUNCTION:
;	AddIEButton()
;
;ACTION:
;	Add a button the the toolbar in internet explorer.
;	Links the button to any application or script file you want it to.
;
;AUTHOR:
;	Mart
;
;CONTRIBUTORS:
;	Richard H for supplying info on scripted GUID creation using GUIDmakr.dll.
;	Jens Meyer (sealeopard) for supplying the scripted creation of the GUID.
;
;	http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=83600&an=&page=0&vc=1
;	http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=156727&an=0&page=0&vc=1
;	http://msdn.microsoft.com/library/default.asp?url=/workshop/browser/ext/tutorials/button.asp
;
;VERSION:
;	1.0
;
;DATE CREATED:
;	February 13th 2006
;
;Revised:
;	None.
;
;KIXTART:
;	Developed and tested with KiXtart 4.51
;
;SYNTAX:
;	AddIEButtons($owner, $caption, $coldicon, $hoticon, $visible, $type, $filename)
;
;PARAMETERS:
;	$owner (required, string)
;		Creates the button for the current user or all users.
;		Set it to user or system.
;	$caption (required, string)
;		Name of the button.
;	$coldicon (required, string)
;		Default icon.
;	$hoticon (required, string)
;		Icon when mouse is moved over the button.
;	$visible (required, string)
;		Shows or hides the button.
;		Set it to true to show or false to hide the button.
;	$type (required, string)
;		Sets the action when the button is clicked on.
;		Application for an application or script for a script.
;	$filename (required, string)
;		Path and filename of the file to be executed when the button is clicked on.
;
;RETURNS:
;	Error codes. See @error.
;
;REMARKS:
;	None.
;
;DEPENDENCIES:
;	CreateGUID - Creates a GUID (globally unique identifier)
;		By Jens Meyer (sealeopard)
;		http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=83600&an=&page=0&vc=1
;	Internet Explorer 4 or up (tested on IE6 and IE7 beta2).
;
;EXAMPLES:
;	This example adds a button with a link to the c:\test.kix script file for the current user.
;	$rc = AddIEButton("User", "Test", "c:\cold.ico", "c:\hot.ico", "true", "Script", "c:\test.kix")
;
;	This example adds a button with a link to the c:\test.exe application for the current user.
;	$rc = AddIEButton("User", "Test", "c:\cold.ico", "c:\hot.ico", "true", "Application", "c:\test.exe")
;
;	This example adds a button with a link to the c:\test.kix script file for all users.
;	$rc = AddIEButton("System", "Test", "c:\cold.ico", "c:\hot.ico", "true", "Script", "c:\test.kix")
;
;	This example adds a button with a link to the c:\test.exe application for all users.
;	$rc = AddIEButton("System", "Test", "c:\cold.ico", "c:\hot.ico", "true", "Application", "c:\test.exe")
;
;
;KIXTART:
;
Function AddIEButton($owner, $caption, $coldicon, $hoticon, $visible, $type, $filename)
;
Dim $guid, $clsid, $owner, $caption, $coldicon, $hoticon
Dim $visible, $type, $filename, $keysystem, $keyuser, $rc
;
Select
	Case $owner = ""
		Exit 13
	Case $caption = ""
		Exit 13
	Case $coldicon = ""
		Exit 2
	Case $hoticon = ""
		Exit 2
	Case $visible = ""
		Exit 13
	Case $type = ""
		Exit 13
	Case $filename = ""
		Exit 2
EndSelect
;
$guid=createguid()
$clsid = "{1FBA04EE-3024-11D2-8F1F-0000F87ABD16}"
;
Select
	Case $owner = "system"
		$keysystem = "HKLM\Software\Microsoft\Internet Explorer\Extensions\" + $guid
		$rc= WriteValue ($keysystem, "Default Visible", $visible, "REG_SZ")
		$rc= WriteValue ($keysystem, "ButtonText", $caption, "REG_SZ")
		$rc= WriteValue ($keysystem, "HotIcon", $hoticon, "REG_SZ")
		$rc= WriteValue ($keysystem, "Icon", $coldicon, "REG_SZ")
		$rc= WriteValue ($keysystem, "CLSID", $clsid, "REG_SZ")
		Select
			Case $type = "Application"
				$rc= WriteValue ($keysystem, "Exec", $filename, "REG_SZ")
			Case $type = "Script"
				$rc= WriteValue ($keysystem, "Script", $filename, "REG_SZ")
		EndSelect
	Case $owner = "user"
		$keyuser = "HKCU\Software\Microsoft\Internet Explorer\Extensions\" + $guid
		$rc= WriteValue ($keyuser, "Default Visible", $visible, "REG_SZ")
		$rc= WriteValue ($keyuser, "ButtonText", $caption, "REG_SZ")
		$rc= WriteValue ($keyuser, "HotIcon", $hoticon, "REG_SZ")
		$rc= WriteValue ($keyuser, "Icon", $coldicon, "REG_SZ")
		$rc= WriteValue ($keyuser, "CLSID", $clsid, "REG_SZ")
		Select
			Case $type = "Application"
				$rc= WriteValue ($keyuser, "Exec", $filename, "REG_SZ")
			Case $type = "Script"
				$rc= WriteValue ($keyuser, "Script", $filename, "REG_SZ")
		EndSelect

EndSelect
;
If @ERROR
	$AddIEButton = @ERROR
Else
	$AddIEButton = 0	
EndIf
;
Exit
;
EndFunction

157254AddIEMenuItem1024MartAddIEMenuItem - Add an item in the tools or help 
menu in internet explorer1140008738Code:


;FUNCTION:
;	AddIEMenuItem()
;
;ACTION:
;	Add an item in the tools or help menu in internet explorer.
;	Links the menu item to any application or script file you want it to.
;
;AUTHOR:
;	Mart
;
;CONTRIBUTORS:
;	Richard H for supplying info on scripted GUID creation using GUIDmakr.dll.
;	Jens Meyer (sealeopard) for supplying the scripted creation of the GUID.
;
;	http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=83600&an=&page=0&vc=1
;	http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=156727&an=0&page=0&vc=1
;	http://msdn.microsoft.com/library/default.asp?url=/workshop/browser/ext/tutorials/menu.asp
;
;VERSION:
;	1.0
;
;DATE CREATED:
;	February 10th 2006
;
;Revised:
;	None.
;
;KIXTART:
;	Developed and tested with KiXtart 4.51
;
;SYNTAX:
;	AddIEMenuItem($owner, $menu, $caption, $description, $type, $filename)
;
;PARAMETERS:
;	$owner (required, string)
;		Creates the button for the current user or all users on the system.
;		Set it to user or system.
;	$menu (required, string)
;		Sets the menu where the new menu item should be created.
;		Tools or Help menu.
;	$caption (required, string)
;		Name of the menu item.
;	$description (required, string)
;		Text to display in the status bar when the mouse is moved over the menu item.
;	$type (required, string)
;		Sets the action when the menu item is clicked on.
;		Application for an application or script for a script.
;	$filename (required, string)
;		Path and filename of the file to be executed when the button is clicked on.
;
;RETURNS:
;	Error codes. See @error.
;
;REMARKS:
;		None.
;
;DEPENDENCIES:
;	CreateGUID - Creates a GUID (globally unique identifier)
;		By Jens Meyer (sealeopard)
;		http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=83600&an=&page=0&vc=1
;	Internet Explorer 4 or up (tested on IE6 and IE7 beta2).
;
;EXAMPLES:
;	This example adds a menu item to the tools menu
;	with a link to the c:\test.kix script file for the current user.
;	$rc = AddIEMenuItem("User", "Tools", "Test", "Test menu item", "script", "c:\test.kix")
;
;	This example adds a menu item to the tools menu
;	with a link to the c:\test.exe application for the current user.
;	$rc = AddIEMenuItem("User", "Tools", "Test", "Test menu item", "application", "c:\test.exe")
;
;	This example adds a menu item to the tools menu
;	with a link to the c:\test.kix script file for all users.
;	$rc = AddIEMenuItem("System", "Tools", "Test", "Test menu item", "script", "c:\test.kix")
;
;	This example adds a menu item to the tools menu
;	with a link to the c:\test.exe application for all users.
;	$rc = AddIEMenuItem("System", "Tools", "Test", "Test menu item", "application", "c:\test.exe")
;
;
;KIXTART:
;
Function AddIEMenuItem($owner, $menu, $caption, $description, $type, $filename)
;
Dim $guid, $clsid, $owner, $menu, $caption, $description
Dim $type, $filename, $keysystem, $keyuser, $rc
;
Select
	Case $owner = ""
		Exit 13
	Case $menu = ""
		Exit 13
	Case $caption = ""
		Exit 13
	Case $description = ""
		Exit 13
	Case $type = ""
		Exit 13
	Case $filename = ""
		Exit 2
EndSelect
;
$guid=createguid()
$clsid = "{1FBA04EE-3024-11D2-8F1F-0000F87ABD16}"
;
Select
	Case $owner = "system"
		$keysystem = "HKLM\Software\Microsoft\Internet Explorer\Extensions\" + $guid
		$rc= WriteValue ($keysystem, "MenuCustomize", $menu, "REG_SZ")
		$rc= WriteValue ($keysystem, "MenuStatusBar", $description, "REG_SZ")
		$rc= WriteValue ($keysystem, "MenuText", $caption, "REG_SZ")
		$rc= WriteValue ($keysystem, "CLSID", $clsid, "REG_SZ")
		Select
			Case $type = "Application"
				$rc= WriteValue ($keysystem, "Exec", $filename, "REG_SZ")
			Case $type = "Script"
				$rc= WriteValue ($keysystem, "Script", $filename, "REG_SZ")
		EndSelect
	Case $owner = "user"
		$keyuser = "HKCU\Software\Microsoft\Internet Explorer\Extensions\" + $guid
		$rc= WriteValue ($keyuser, "MenuCustomize", $menu, "REG_SZ")
		$rc= WriteValue ($keyuser, "MenuStatusBar", $description, "REG_SZ")
		$rc= WriteValue ($keyuser, "MenuText", $caption, "REG_SZ")
		$rc= WriteValue ($keyuser, "CLSID", $clsid, "REG_SZ")
		Select
			Case $type = "Application"
				$rc= WriteValue ($keyuser, "Exec", $filename, "REG_SZ")
			Case $type = "Script"
				$rc= WriteValue ($keyuser, "Script", $filename, "REG_SZ")
		EndSelect

EndSelect
;
If @ERROR
	$AddIEMenuItem = @ERROR
Else
	$AddIEMenuItem = 0	
EndIf
;
Exit
;
EndFunction

133144addItemCombo5942TDFaddItemCombo()0Code:


;FUNCTION	addItemCombo



;



;ACTION		Checks the combobox for the desired item to add.

;		The check is case insensitive; if the item to add

;		is not already listed in the combo box, it is then added.



;



;AUTHOR		TDF



;



;CONTRIBUTORS	none



;



;VERSION	1.0



;



;DATE CREATED	January 30, 2005



;



;DATE MODIFIED	-



;



;KIXTART	4.2.3



;



;SYNATX		addItemCombo($lstCtrl, $itemToAdd)



;



;PARAMETERS	$lstCtrl

;		The combobox control you wish to add the item to.

;		Type: control

;

;		$itemToAdd

;		The desired item to add to $lstCtrl.

;		Type: variant



;



;RETURNS	nothing



;



;DEPENDICIES	none



;



;Example	addItemCombo($lstURL, "http://www.kixforms.org")



;



;KIXTART BBS	



;



;		



Function addItemCombo($lstCtrl, $itemToAdd)

	Global $blnExist	



	$blnExist = "False"

	For $lstIndex = 0 to $lstCtrl.ListCount - 1

		$lstCtrl.ListIndex = $lstIndex

  		If Lcase($lstCtrl.Text) = Lcase($itemToAdd) 

  			$blnExist = "True"

  			$lstCtrl.ListIndex = $lstIndex

    			Exit

  		EndIf

	Next

	

	If $blnExist = "False"

		$lstCtrl.AddItem($itemToAdd)

		$lstCtrl.ListIndex = $lstCtrl.ListCount - 1

	EndIf

EndFunction

176965AddLocalAdmin5931apronkAddLocalAdmin() - Add users to local groups1181813821

Code:

;Function	AddLocalAdmin() - Add users to local groups
;
;Author		Arend Pronk (arendpronk@gmail.com)
;
;Action		Adds users to local PC groups.
;
;Syntax		AddLocalAdmin(Optional $pcName, Optional $pcGroup)
;
;Version  	1.0
;
;Date 		14-06-2007
;
;Parameters 	$usr - String value ie: @USERID, "ruudv" etc.
;		$pcName (Optional) - String value ie: @WKSTA, "WorkStation1" etc.
;		If not specified it will check the local PC.
;		$pcGroup (Optional) - String value, "Power users", "Administrators" etc.
;		If not specified it will check for "Administrators".
;
;Returns  	1 for True, 0 for False
; 
;Dependencies 	None
;
;KiXtart Ver.	4.53
; 
;Example(s)	? AddLocalAdmin(@USERID)
;		will show "1" if adding user to admin group on your computer was successfull, and "0" if not.
;
;		? AddLocalAdmin(@USERID,"PC1")
;		will show "1" if adding user to admin group on PC1 was successfull, and "0" if not.
;
;		? AddLocalAdmin(@USERID,"PC1","Power Users")
;		will show "1" if adding user to Power User group on PC1 was successfull, and "0" if not.
;
;		? AddLocalAdmin(@USERID,"","Power Users")
;		will show "1" if adding user to Power User group on your computer was successfull, and "0" if not.
;
Function AddLocalAdmin($usr,Optional $pcName, Optional $pcGroup)
  Dim $strNt, $strUsr, $objStr
  If $pcName = "" $pcName = "." EndIf
  If $pcGroup = "" $pcGroup = "Administrators" EndIf
  $AddLocalAdmin = 0
  $strNT = "WinNT://" + $pcName + "/" + $pcgroup + ",Group"
  $strUsr = "WinNT://" + @LDOMAIN + "/" + $usr + ",User"
  $objStr = GetObject($strNT)
  If @ERROR Exit @ERROR EndIf
  $objStr.GetInfo
  $objStr.Add($strUsr)
  If NOT @ERROR
    $AddLocalAdmin = 1
  EndIf
EndFunction
84165AddPrinter3439AllenAddPrinter() - Add IP,LPT, or COM Printers0

;Function:   
;    AddPrinter()   
;   
;Author:   
;    Allen Powell (Al_Po)   
;  
;Contributors:  
;    Glenn Barnas  
;   
;Version:   
;    1.2.0   
;   
;Version History   
;    1.2.0 2007/02/22 Added Support for LPR Printers, Removed Un-needed dimmed vars from previous versions  
;    1.1.1 2006/12/16 Fixed Code when adding network printers   
;    1.1.0 2006/11/17 Support for Novarsinstrings, All Vars Dimmed, Cleaned up code   
;    1.0.0 2003/05/07 Original   
;   
;Action:   
;    Add IP,LPT, or COM Printers locally or remotely.  Also, add PrintServer connections locally.   
;    (keywords:  Script, WMI, vbscript, batch, logon, login)  
;   
;Syntax:   
;    AddPrinter($Port,$PrinterType,optional $DriverInf,optional $PrinterDesc,optional $remotepc,optional $Default)   
;   
;Parameters:   
;       $Port: (required)     
;             IPAddress(RAW)   (xxx.xxx.xxx.xxx)   
;             IPAddress(LPR)   (xxx.xxx.xxx.xxx:LPRQueueName)  
;             LPT              (LPT1:)   
;             COM              (COM1:)   
;             PrintServer      (\\server\printer)   
;       $PrinterType: (required)   
;             Descriptor of Printer within INF file   
;             Note:  If using a PrintServer, $PrinterType value is ignored.   
;       $DriverInf: (Optional)   
;             Location and name of INF file containing print drivers   
;             Note:  If omitted, attempts to use default Windows Print Drivers   
;       $PrinterDesc: (Optional)   
;             Description of Printer   
;             Note:  If ommitted, $PrinterDesc = PrinterType   
;       $RemotePC: (Optional)   
;             PC to install Printer/Drivers on.  If omitted defaults to localpc.   
;              Note:  Ignored if $Port is a PrintServer   
;       $Default: (Optional)   
;             0 = Do not Set as Default Printer (Default)   
;             1 = Set as Default Printer   
;                         
;Returns:   
;        0 - Successful   
;        1 - Failed   
;        If Failed check @error   
;          or see below for custom errors   
;         -4 - Error connecting to RemotePC   
;         -3 - Could not open/find INF file   
;         -2 - Could not find $PrinterType in INF file     
;         -1 - Unrecognized Port   
;   
;Dependencies:   
;     Windows 2000 Professional and up   
;       rundll32 printui.dll,PrintUIEntry   
;   
;Examples:   
;$=AddPrinter("192.168.1.1","Xerox DocumentCenter 555 PCL6","\\Server\PrinterDrives\Xerox\dc555pcl\dc555x.inf","Xerox Document Centre 55  5 PCL6 in Office",REMOTEPC,1)   
;$=Addprinter("LPT1","HP LaserJet 8100 Series PS",,"HP8100 in IS(test)")   
;$=AddPrinter("192.168.1.1","HP LaserJet 8100 Series PS",,"HP8100 in IS(test)",,1)   
;$=AddPrinter('\\server\printer','_')   
;Source:   
 
 
 

function AddPrinter($Port,$PrinterType,optional $DriverInf,optional $PrinterDesc,optional $remotepc,optional $Default)
    Dim $found,$IPPrinterKey,$PrinterCMD,$ffh,$,$line,$objservice,$printserver,$LPRQueue
    $AddPrinter=1
    if $Driverinf=""
      $DriverInf="%windir%\inf\ntprint.inf"
    endif
    if exist($DriverInf)=0
      Exit -3
    endif
    shell '"%comspec%" /c type "' + $driverinf + '">"%temp%\addprinter.txt"'
    $ffh=freefilehandle()
    if open($ffh,"%temp%\addprinter.txt",0)=0
      $found=0
      $line=readline($ffh)      
      while @error=0 and $found=0
        $found=instr($line,$PrinterType)
        $line=readline($ffh)
      loop
      $=close($ffh)
      if $found=0
        exit -2
      else
        if $PrinterDesc=""
          $PrinterDesc=$PrinterType
        endif
        if $remotepc=""
          $remotepc='\\'+ @wksta
        else 
          if left($remotepc,2)<>"\\"
            $remotepc='\\' + $remotepc
          endif
        endif
        select 
          case left($Port,2)="\\"
            $printserver=1
            $printerdesc=$port
          case instr($Port,".")
            if instr($Port,":")
              $LPRQueue=split($port,":")[1]
              $Port=split($port,":")[0]
            endif
            $IPPrinterKey = $remotepc + '\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Monitors\Standard TCP/IP Port\Ports\IP_' + $Port
            if keyexist($IPPrinterKey)=0
              If $LPRQueue ; LPR  
                if WriteValue($IPPrinterKey,"Protocol","00000002","REG_DWORD") exit @error endif
                if WriteValue($IPPrinterKey,"Version","00000001","REG_DWORD")  exit @error endif
                if WriteValue($IPPrinterKey,"Double Spool","00000001","REG_DWORD")  exit @error endif
                if WriteValue($IPPrinterKey,"Queue",$LPRQueue, "REG_SZ")  exit @error endif
                if WriteValue($IPPrinterKey,"HostName","", "REG_SZ")  exit @error endif
                if WriteValue($IPPrinterKey,"IPAddress",$Port,"REG_SZ")  exit @error endif
                if WriteValue($IPPrinterKey,"HWAddress","","REG_SZ")  exit @error endif
                if WriteValue($IPPrinterKey,"PortNumber","00000203","REG_DWORD")  exit @error endif
                if WriteValue($IPPrinterKey,"SNMP Community","public","REG_SZ")  exit @error endif
                if WriteValue($IPPrinterKey,"SNMP Enabled","00000001","REG_DWORD")  exit @error endif
                if WriteValue($IPPrinterKey,"SNMP Index","00000001","REG_DWORD")  exit @error endif
              Else ; RAW  
                if WriteValue($IPPrinterKey,"Protocol","00000001","REG_DWORD") exit @error endif
                if WriteValue($IPPrinterKey,"Version","00000001","REG_DWORD")  exit @error endif
                if WriteValue($IPPrinterKey,"HostName","", "REG_SZ")  exit @error endif
                if WriteValue($IPPrinterKey,"IPAddress",$Port,"REG_SZ")  exit @error endif
                if WriteValue($IPPrinterKey,"HWAddress","","REG_SZ")  exit @error endif
                if WriteValue($IPPrinterKey,"PortNumber","00009100","REG_DWORD")  exit @error endif
                if WriteValue($IPPrinterKey,"SNMP Community","public","REG_SZ")  exit @error endif
                if WriteValue($IPPrinterKey,"SNMP Enabled","00000001","REG_DWORD")  exit @error endif
                if WriteValue($IPPrinterKey,"SNMP Index","00000001","REG_DWORD")  exit @error endif
              endif
            endif
            $objservice=Getobject("WinNT://" + substr($remotepc,3) + "/Spooler,Service")
            if @error
              exit -4
            endif
            $objservice.stop
            do
              sleep 0.2
            until $objservice.status=1   ;stopped   
            $objservice.start
            $port='IP_' + $port
          case ucase(left($Port,3))="LPT" or ucase(left($Port,3))="COM"
            if right($port,1)<>":"
              $Port=$port+":"
            endif
            if val(left(right($port,2),1))=0
              exit -1 
            endif
          case ucase(left($Port,4))="FILE"
            if right($port,1)<>":"
              $Port=$port+":"
            endif
          case 1
            exit -1
        endselect
        if $Printserver
          if addprinterconnection($port)
            exit @error    
          endif
        else
          $printercmd='rundll32 printui.dll,PrintUIEntry /if /b "' + $printerdesc + '" /c "' + $remotepc + '" ' + 
                      '/f "' + $driverinf + '" /r "' + $port + '" /m "' + $Printertype + '" /z /u '
          Shell $printercmd
        endif
        if $default
          if SetDefaultPrinter($PrinterDesc)
            exit @error
          endif
        endif 
        $AddPrinter=0
      endif
    else
      Exit -3
    endif
endfunction
143531AddToMyNetworkPlaces52NTDOCAddToMyNetworkPlaces() - Creates a 
shortcut in My Network Places1134725387

;Function	AddToMyNetworkPlaces()   
;     
;Author		NTDOC     
;     
;Action		Creates a shortcut in the My Network Places location   
;     
;Syntax		AddToMyNetworkPlaces($Name,$Location,$Comment)   
;     
;Version	1.2     
;     
;Date		2005-Jul-13     
;     
;Date Revised	2005-Dec-16  
;     
;Revised Reason Per request by Al_Po and Jimmy V. De Jesus Jr. (jvdejesus) 
;     
;Parameters	AddToMyNetworkPlaces($Name,$Location,$Comment)   
;		$Name = The name you want to give the shortcut   
;		$Location = The UNC location where it should point to   
;   	  	   example: \\someserver\somesharepoint   
;		$Comment = An optional comment to note or describe the shortcut link 
;     
;Returns	Error level   
;     
;Dependencies	Ability to create the "script.shell" object   
;     
;KiXtart Ver	Written and tested with KiXtart v4.51 on 2000/XP     
;     
;Example   
;		Dim $Newplace   
;		$Newplace=AddToMyNetworkPlaces('F-Install Folders','\\installserver\Finstall','Corporate install location for Finance Apps')   
;		'Creation error: ' + @SERROR ? 
;     
;Source     
 
 
Function AddToMyNetworkPlaces($Name,$Location,Optional $Comment)
  Dim $Nethood,$Shell,$S,$D,$T
  $AddToMyNetworkPlaces=1
  If Exist($Location)
    $Nethood=ReadValue('HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders','NetHood')
    If GetFileAttr($Nethood+'\'+$Name) & 16
    	; 'Link exists already. Exit the function. 
      Exit 80
    EndIf
    MD $Nethood+'\'+$Name
    $D=$Nethood+'\'+$Name+'\'+'Desktop.ini'
    $T=$Nethood+'\'+$Name+'\'+'target.lnk'
    $S = SetFileAttr($Nethood+'\'+$Name,1)
    $S = WriteProfileString ($D,'.ShellClassInfo','CLSID2','{0AFACED1-E828-11D1-9187-B532F1E9575D}')
    $S = WriteProfileString ($D,'.ShellClassInfo','FLAGS','2')
    $S = SetFileAttr($D,6)
    $Shell = CreateObject('wscript.shell')
    If @ERROR Exit @ERROR EndIf
    $S = $Shell.CreateShortcut($T)
    $S.TargetPath = $Location
    $S.WorkingDirectory = $Location
    If $Comment
      $S.Description = $Comment
    EndIf
    $S.Save
    If @ERROR Exit @ERROR Else $AddToMyNetworkPlaces=0 EndIf
  Else
    Exit 3
  EndIf
EndFunction
 


 
 
 
Further reading on this subject

Purge My Network Places

HOW TO: Prevent Network Share Shortcuts from Being Added to My Network Places
 
 
176036ADOwner5931apronkADOwner() - Gets or Sets an AD object's owner0;Function 
ADOwner() - Gets or Sets an AD object's owner
;
;Author Arend Pronk (arendpronk@gmail.com)
;
;Action Gets or Sets an AD object's owner
;
;Syntax ADOwner($nObject,$nArg,Optional $nUser)
;
;Version 1.0
;
;Date 07-05-2007
;
;Parameters $nObject as AD String: "CN=USER,OU=KIX,DC=KIX,DC=Local"
; $nArg as String: "Get" or "Set"
; $nUser as String: "DOMAIN\User"
;
;Returns Owner name if Arg is Get, @ERROR if Arg is Set.
; 
;Dependencies XP, AdsSecurityUtility
;
;KiXtart Ver. 4.51
; 
;Example(s) ? = ADOwner("CN=USER,OU=KIX,DC=KIX,DC=Local","Get")
; returns the Owner of "user" in the A.D.
; ? = ADOwner("CN=USER,OU=KIX,DC=KIX,DC=Local","Set","DOMAIN\NewUser)
; returns the @error level wether setting the owner to NewUser was succesfull or 
not.
;

Code:

Function ADOwner($nObject,$nArg,Optional $nUser)
  Dim $ou, $sd
  $ou = GetObject("LDAP://" + $nObject)
  If @ERROR Exit @ERROR EndIf
  $sd = $ou.Get("ntSecurityDescriptor")
  If @ERROR Exit @Error EndIf
  If $nArg = "Get" $ADOwner = $sd.Owner EndIf
  If $nArg = "Set"
    If $nUser = "" Exit 1 Else $sd.Owner = $nUser EndIf
    $ou.Put("ntSecurityDescriptor", $sd)
    $ou.SetInfo
    If @ERROR Exit @Error EndIf
    $ADOwner = @ERROR
  EndIf
EndFunction
82697ADSearch97Alex.HADSearch() - Search for name or account name in Active 
Directory0

code:


; Function ADSearch()
;
; v1.1
;
; Author: 	Heitz Alex (HeitzAlexandre@wanadoo.fr)
;
; Action: 	Search in Active Directory using LDAP
;
; Syntax:	ADSearch("Account Name", "Full Name")
;
; Parameters:	Full Name	(Optional)
;			The full name to search in the AD database
;			
;		Account Name	(Optional)
;			The account name (or ID name) to search in the AD database
;
; Dependancies: Active Directory client installed (Build-in in 2000 and XP systems)
;
; Remarks:	Working on 9x (95, 98, Me) and NTx (4, 2000, XP) systems
;		Account name of a computer has a trailing $
;		Only * wildcard is supported.
;		ADSearch can't be designed to only retreive user and computer (ADODB and LDAP limits)
;
;
; Returns:	Array of elements containing the complete following string :
;		"CN=full name,...rest of DSN...,DC=Domain,DC=Organization,DC=com or org or...,AccountName=account name,IsContainer=0|1, IsGroup=0|1
;			Iscontainer is set to 1 when AccountName is empty
;			IsGroup is set to 1 when the current element is a Group
;
; example: 	ADSearch("Computers")  return 1 array with the following value : "CN=Computers,DC=Domain,DC=Organization,DC=com|AccountName=|IsContainer=1|IsGroup=0"
;		ADSearch("P*")  return X arrays with values like this one : "CN=Username,OU=OU container name,DC=Domain,DC=Organization,DC=com|AccountName=Useraccount|IsContainer=0|IsGroup=0"
;		ADSearch(,"*$$")  return X arrays with values like this one : "CN=Computer name,CN=Computers,DC=Domain,DC=Organization,DC=com|AccountName=Computer name$|IsContainer=0|IsGroup=0"

Function ADSearch(Optional $ADFullName,Optional $ADAccountName)
Dim $AdoCon
dim $AdoCommand
dim $Recordset
dim $Filter
dim $i

select
	case len($ADFullName)>0 and len($ADAccountName)>0
		$filter=" where cn='"+$adfullname+"' and samAccountName='"+$ADAccountName+"' "

	case len($ADFullName)>0
		$filter=" where cn='"+$ADFullName+"' "

	case len($ADAccountName)>0
		$filter=" where samAccountName='"+$ADAccountName+"' "
	case 1
		; I'm sure you don't want to retreive the complete Active Directory database
		return			
endselect

$AdoCon = CreateObject("ADODB.Connection")
$AdoCon.Provider = "ADsDSOObject"

; Current credentials are used, as username and password aren't specified
$AdoCon.Open("Active Directory Provider")

; Create ADO command object for the connection.
$AdoCommand = CreateObject("ADODB.Command")
$AdoCommand.ActiveConnection = $AdoCon
$AdoCommand.CommandText ="Select  AdsPath, samAccountName, GroupType from 'LDAP://"+GetObject("LDAP://rootDSE").Get("defaultNamingContext")+"' "+$filter

; Execute the query.
$Recordset = $AdoCommand.Execute
If @error=0
	; $Recordset is 1 based
	If $Recordset.RecordCount>0
		Redim $ADSearch[$recordset.RecordCount-1]
		$Recordset.movefirst
		For $i=0 to $recordset.RecordCount-1
			; Here we'll parse the fields of the current record
			$ADSearch[$i]=substr($Recordset.Fields("AdsPath").value,8)		; To get rid of " LDAP://"
			$ADSearch[$i]=$ADSearch[$i]+"|AccountName="+$Recordset.Fields("samAccountName").value+"|"
			If len($Recordset.Fields("samAccountName").value) >0
				$ADSearch[$i]=$ADSearch[$i]+"IsContainer=0|"
			else
				$ADSearch[$i]=$ADSearch[$i]+"IsContainer=1|"
			endif
			If len($Recordset.Fields("Grouptype").value) >0
				$ADSearch[$i]=$ADSearch[$i]+"IsGroup=1"
			else
				$ADSearch[$i]=$ADSearch[$i]+"IsGroup=0"
			endif

			; Moving to the next record we have in $Recordset
			$Recordset.Movenext
		next
	endif
endif

Endfunction


Expect more AD stuff

Updated to distinguish the LDAP name than additional information. Now 
AccountName, IsContainer and IsGroup are separated with a | instead of a ,

[ 02 February 2002: Message edited by: Alex.H ]82152ADSIInstall28BryceADSIInstall() 
- Installes the ADSI COM interface on a remote workstation0

code:


function ADSIInstall($target, optional $targetadmin, optional $targetPassword)
;
; ADSIInstall, this function will intall the ADSI service onto a target NT/w2k
; computer.
;
; SYNTAX:	ADSIInstall(, [],[])
;		
; Parameters:	 is the unc name of the computer to install RCMD on
;
;		 is an optional username used to gain access to a remote 
;		target computer.
;
;		 is the password used for the 
;
; Returns:	Returns nothing but but check @error for detailed information
;
; Example:	;this will install the RCMD service on \\testserver using inherited
;		;accress rights
;		ADSIInstall("\\testserver")
;
;		;This will install the RCMD service on \\testserver even through 
;		;\\testserver is in a different DOMAIN
;		ADSIInstall("\\testserver", "houston\smithb", "1234")
;
;		;this will install the RCMD service on \\testserver using the local
;		;administrator account
;		ADSIInstall("\\testserver","administrator","1234")
;
; Remarks:	* the RCMD service must be running on the target computer, please see 
;		  here on how to install the RCMD service 
;		  http://kix.isorg.net/other_scripts/Kix2k%20Functions/RCMDInstall 
;
;		* You will need to download the ADSI install package (ads.exe) and place it in the
;		  same folder as the script.  
;		  You can find ADS.exe @ http://www.microsoft.com/NTWorkstation/downloads/Other/ADSI25.asp 
;

	DIM $target, $targetname, $targetadmin, $targetpassword, $targetsystemroot, $targetcode

	$targetcode = 'shell "%%systemroot%%\temp\ads.exe /q" del "%%systemroot%%\temp\ads.exe" del "%%systemroot%%\temp\code.kix"'

	if substr($target,1,2) <> "\\"
		exit(11)
	else
		$targetname = substr($target,3,len($target))
	endif

	IF $targetadmin <> ""
		if instr($targetadmin,"\") = 0
			use "$target\ipc$$" /user:'$targetname\$targetadmin' /password:$targetPassword
		else
			use "$target\ipc$$" /user:'$targetadmin' /password:$targetPassword
		endif
	else
		use "$target\ipc$$"
	endif
	Select
		case @error = 0
			;install ADSI onto target computer

			if exist("$target\admin$$\temp\*.*") = 0 
				md "$target\admin$$\temp"
				if @error <> 0 exit(@error) endif
			endif
			if exist("ads.exe")
				copy "ads.exe" "$target\admin$$\temp"
			else
				exit(2)
			endif
			if @error <> 0 exit(@error) endif
			
			$nul = open(1,"$target\admin$$\temp\code.kix",5)
			if @error <> 0 exit(@error) endif

			$nul = writeline(1,$targetcode)
			if @error <> 0 exit(@error) endif

			$nul = close(1)
			if @error <> 0 exit(@error) endif

			shell '%comspec% /c  RCMD $target "kix32 %%systemroot%%\temp\code.kix" > nul'
		case @error <> 0
			;unable to make an admin connection to the $target computer
			exit(@error)
	endselect
	use "$target\ipc$$" /delete
endfunction

84551ADSIinstalled172Howard BullockADSIinstalled() - Check to see if ADSI 
is installed0


;--------------------------------------------------------------------------------------------------

;FUNCTION         ADSIinstalled()

;

;AUTHOR           Howard A. Bullock (hbullock@tycoelectronics.com)

;

;VERSION          1.0

;

;ACTION           This function determines if the client has ADSI installed.

;

;SYNTAX           ADSIinstalled ()

;

;PARAMETERS       $Computer (optional) (string)

;

;REMARKS          This function returns true if the DSCLIENT or ADSI 2.5 or higher is installed.

;                 See Q216290 for more detailed information that can be determined.

;

;RETURNS          0|1 (False|True)

;

;DEPENDENCIES     NONE

;

;EXAMPLES         if ADSIinstalled()

;                    ? "ADSI aware client"

;                 endif

;

Function ADSIinstalled(optional $Computer)

    dim $key

    $key = "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Active Setup\Installed Components\{E92B03AB-B707-11d2-9CBD-0000F87A369E}"

    if vartypename($Computer) <> "Empty" and $Computer <> ""

        $key = "\\" + $Computer + "\" + $key

    endif

    if KeyExist($key)

        $ADSIinstalled = 1

    else

        $ADSIinstalled = 0

    endif

    Exit 0

Endfunction

115657ADSIUnlockUser17SealeopardADSIUnlockUser() - Unlocks a locked user 
account0Code:


;FUNCTION      ADSIUnlockUser

;

;ACTION        Unlocks a locked user account in a Windows NT 4.0 domain

;

;AUTHOR        Jens Meyer (sealeopard@usa.net)

;

;VERSION       1.1 (renamed from ADSIUnlockUser to ADSIUnlockUser)

;              1.0

;

;DATE CREATED  01/26/2004

;

;DATE MODIFIED 01/26/2004

;

;KIXTART       4.02+

;

;SYNTAX        ADSIUNLOCKUSER(USERNAME)

;

;PARAMETERS    USERNAME

;              Required string containing the username

;

;RETURNS       0 if successful, otherwise error code

;

;REMARKS       Requires WMI and the account the script runs under must be a member

;              of the 'Account Operators' group

;

;DEPENDENCIES  none

;

;EXAMPLE       $rc=ADSIUnlockUser('lockeduser')

;

;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=114340

;

function ADSIUnlockUser($username)

  dim $objUser



  $username=trim($username)

  if $username=''

    exit 87

  endif

  if not instr($username,'/')

    $username=@LDOMAIN+'/'+$username

  endif



  $objUser = getobject('WinNT://'+$username+',user')



  if @ERROR

    $ADSIUnlockUser=@ERROR

  else

    if $objUser.IsAccountLocked

      $objUser.AccountDisabled=0

      $objUser.IsAccountLocked=0

      $objUser.SetInfo

      if @ERROR

        $ADSIUnlockUser=@ERROR

      else

        if $objUser.IsAccountLocked

          $ADSIUnlockUser=5

          exit 5

        else

          $ADSIUnlockUser=0

        endif

      endif

    else

      $ADSIUnlockUser=0

    endif

  endif



  $objUser = 0

endfunction

116159ADSIUserStatus17SealeopardADSIUserStatus() - Returns user account 
status0Code:


;FUNCTION      ADSIUserStatus

;

;ACTION        Returns the status of a user account

;

;AUTHOR        Jens Meyer (sealeopard@usa.net)

;

;VERSION       1.0

;

;DATE CREATED  03/14/2004

;

;DATE MODIFIED 03/14/2004

;

;KIXTART       4.22+

;

;SYNTAX        ADSIUSERSTATUS(USERNAME [, OPT, DOMAIN])

;

;PARAMETERS    USERNAME

;              Required string containing the username

;

;              OPT

;              Optional integer

;              0 = return account status (default)

;              1 = unlock user account

;              2 = enable user account

;              3 = disable user account

;

;              DOMAIN

;              Optional string containing the domain or local computer

;              name the user is a member of

;

;RETURNS       0 = user account enabled

;              1 = user account locked

;              2 = user account disabled

;

;REMARKS       Requires WMI and the account the script runs under must be a member

;              of the 'Account Operators' group when changing the account status

;              It is not recommended to unlock a user account via the LDAP provider, instead

;              the WinNT should be used. See http://msdn.microsoft.com/library/default.asp?url=/library/en-us/adsi/adsi/ldap_account_lockout.asp

;

;DEPENDENCIES  none

;

;EXAMPLE       SELECT

;              CASE ADSIUserStatus('lockeduser')=1

;                $rc=ADSIUserStatus('lockeduser',1)

;              CASE ADSIUserStatus('lockeduser')=2

;                $rc=ADSIUserStatus('lockeduser',2)

;              ENDSELECT

;              $rc=ADSIUserStatus('lockeduser',0,'domain')

;              $rc=ADSIUserStatus('lockeduser',0,'computer')

;              $rc=ADSIUserStatus('CN=Jeff Smith,OU=Sales,DC=Fabrikam,DC=Com',0)

;

;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=114912

;

function ADSIUserStatus($user, optional $opt, optional $domain)

  dim $objUser, $strProvider



  $username=trim($user)

  $domain=trim($domain)

  $opt=val($opt)

  if $username='' or (instr($username,'/') and $domain) or (instr($user,'CN=') and $opt=1)

    exit 87

  endif



  select

  case instr($domain,'CN=')

    $strProvider='LDAP://'+$user

  case $domain

    $strProvider='WinNT://'+$domain+'/'+$user+',user'

  case 1

    $strProvider='WinNT://'+@DOMAIN+'/'+$user+',user'

  endselect



  $objUser = getobject($strProvider)



  if @ERROR

    exit @ERROR

  endif



  select

    case $opt=1

      if $objUser.IsAccountLocked

        $objUser.IsAccountLocked=0

        $objUser.SetInfo

      endif

    case $opt=2

      if $objUser.AccountDisabled

        $objUser.AccountDisabled=0

        $objUser.IsAccountLocked=0

        $objUser.SetInfo

      endif

    case $opt=3

      if not $objUser.AccountDisabled

        $objUser.AccountDisabled=1

        $objUser.SetInfo

      endif

  endselect



  select

  case $objUser.AccountDisabled

    $ADSIUserStatus=2

  case $objUser.IsAccountLocked

    $ADSIUserStatus=1

  case 1

    $ADSIUserStatus=0

  endselect



  $objUser = 0



endfunction

83193ADSUnlockUser17SealeopardADSUnlockUser() - Unlocks a locked user 
account in a Windows NT 4.0 domain0

code:

;FUNCTION      ADSUnlockUser
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Unlocks a locked user account in a Windows NT 4.0 domain
;
;SYNTAX        ADSUNLOCKUSER(USERNAME)
;
;PARAMETERS    USERNAME
;              Required string containing the username
;
;RETURNS       0 if successful, otherwise error code
;
;REMARKS       Requires ADSI and the account the script runs under must be a member
;              of the 'Account Operators' group
;
;DEPENDENCIES  none
;
;EXAMPLE       $rc=ADSUnlockUser('lockeduser')
;
;KIXTART BBS   http://81.17.37.55/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000214
;
function ADSUnlockUser($username)
  dim $objUser

  $username=trim($username)
  if $username=''
    $ADSUnlockUser=-1
    return
  endif
  if not instr($username,'/')
    $username=@LDOMAIN+'/'+$username
  endif

  $objUser = getobject('WinNT://'+$username+',user')

  if @ERROR
    $ADSUnlockUser=@ERROR
  else
    if $objUser.IsAccountLocked
      $objUser.AccountDisabled=0
      $objUser.IsAccountLocked=0
      $objUser.SetInfo
      if @ERROR
        $ADSUnlockUser=@ERROR
      else
        if $objUser.IsAccountLocked
          $ADSUnlockUser=-1
        else
          $ADSUnlockUser=0
        endif
      endif
    else
      $ADSUnlockUser=0
    endif
  endif

  $objUser = 0
endfunction



[ 14 June 2002, 13:47: Message edited by: sealeopard ]82894AllFlags487New 
Mexico MarkAllFlags() - Test to see if all the flags tested are set0

;Function AllFlags()
;
;Author New Mexico Mark (inspired by Bryce's Flags() UDF
;
;Action Given two numbers, returns a boolean true if ALL the '1'
; bits in the second number are set in the first number, else
; returns a boolean false.
;
;Syntax AllFlags(NumberToTest,TestNumber)
;
;Parameters NumberToTest and TestNumber are both numbers or numeric 
; strings that can be converted to a number (i.e. '&10')
;
;Remarks Developed to test whether one or more bits are set in a
; given number. I.e. decimal 11 is binary 1011. This means
; AllFlags() would return true for 1 (0001), 2 (0010), and 
; 8 (1000) as well as 3 (0011), 9 (1001), 10 (1010) and 
; 11 (1011).
;
; This is one of those functions that takes a lot longer to 
; test and document than to simply use.
;
;Dependencies None
;
;Example
$k=1
FOR $i = 0 TO 31
IF AllFlags(11,$k)
'AllFlags(11,$k)=' + AllFlags(11,$k) ?
ENDIF
$k=$k*2
NEXT
?
'Test against a number with the following bit pattern:' ?
'110011 = 51' ? ?
'&0 = Dec 0' ?
'AllFlags(51,&0)=' + AllFlags(51,Val('&0')) ? ?
'Test 110011 against 000011 (3)' ?
'AllFlags(51,3)=' + AllFlags(51,3) ?
'Test 110011 against 001100 (12)' ?
'AllFlags(51,12)=' + AllFlags(51,12) ?
'Test 110011 against 010010 (18)' ?
'AllFlags(51,18)=' + AllFlags(51,18) ?
'Test 110011 against 010110 (22)' ?
'AllFlags(51,22)=' + AllFlags(51,22) ? ;AnyFlags() and AllFlags() differ here
;Console output
;AllFlags(11,1)=1
;AllFlags(11,2)=1
;AllFlags(11,8)=1
;
;Test against a number with the following bit pattern:
;110011 = 51
;
;&0 = Dec 0
;AllFlags(51,&0)=0
;
;Test 110011 against 000011 (3)
;AllFlags(51,3)=1
;Test 110011 against 001100 (12)
;AllFlags(51,12)=0
;Test 110011 against 010010 (18)
;AllFlags(51,18)=1
;Test 110011 against 010110 (22)
;AllFlags(51,22)=0
;
;Source

code:


FUNCTION AllFlags($iNum,$iTst)
ÿÿÿ; Returns a boolean true if all the '1' bits in $iTst
ÿÿÿ; are also set in $iNum.
ÿÿÿ$iNum=Val($iNum) $iTst=Val($iTst)
ÿÿÿIF $iTst=0 $AllFlags=0 EXIT ENDIF
ÿÿÿ$AllFlags=(($iNum & $iTst)=$iTst)
ENDFUNCTION


[ 27 January 2002: Message edited by: New Mexico Mark ]130754AllowRemoteControlOnFirewall119LonkeroAllowRemoteControlOnFirewall() 
- control XP sp2 firewall setting, yes0 Code:

;FUNCTION

;	AllowRemoteControlOnFirewall

;

;AUTHOR

;	Jooel

;

;ACTION

;	Enable or disable remotecontrol via windows Firewall

;

;SYNTAX

;	AllowRemoteControlOnFirewall(MODE)

;

;PARAMETERS

;	MODE

;       - if non-zero, will enable

;	- if zero disables

;	- if not given, returns current mode

;

;RETURNS

;	if no MODE given, returns current state.

;

;DEPENDENCIES

;	windows XP SP2

;	Localadmin rights

;

;EXAMPLES

;	"Remotecontrol state:"

;	AllowRemoteControlOnFirewall()

;

;	"enabling (allowing) remotecontrol"

;	AllowRemoteControlOnFirewall(1)

;

;SOURCE

function AllowRemoteControlOnFirewall(optional $_m)

 if not ingroup('@wksta\'+sidtoname('S-1-5-32-544'))-1+@inwin

   exit 5 ;no rights

 endif

 if "5.1"<>@dos or "Service Pack 2"<>@csd

   exit 2 ;not possible on this system

 endif

 dim $f,$

 $f = createobject("Hnetcfg.fwmgr")

 $ = $f.LocalPolicy.CurrentProfile.RemoteAdminSettings

 if vartype($_m)

  if 0 = $_m

   $.LocalPolicy.CurrentProfile.RemoteAdminSettings = not 1

  else

   $.LocalPolicy.CurrentProfile.RemoteAdminSettings = not 0

  endif

 else

  $AllowRemoteControlOnFirewall = iif(-1 = $.enabled,1,0)

 endif

endfunction

82904AnyFlags487New Mexico MarkAnyFlags() - Test to see if any of the flags 
tested are set0

;Function   AnyFlags()
;
;Author      New Mexico Mark (inspired by Bryce's Flags() UDF
;
;Action      Given two numbers, returns a boolean true if ANY of the '1'
;      bits in the second number are set in the first number, else
;      returns a boolean false.
;
;Syntax      AnyFlags(NumberToTest,TestNumber)
;
;Parameters   NumberToTest and TestNumber are both numbers or numeric 
;      strings that can be converted to a number (i.e. '&10')
;
;Remarks Developed to test whether one or more bits are set in a
; given number. I.e. decimal 11 is binary 1011. This means
; AnyFlags() would return true for everything between 1 (0001)
; and 15 (1111) except 4 (0100).
;
;      This is one of those functions that takes a lot longer to 
;      test and document than to actually use.
;
;Dependencies   None
;
;Example
$k=1
FOR $i = 0 TO 31
   IF AnyFlags(11,$k)
      'AnyFlags(11,$k)=' + AnyFlags(11,$k) ?
   ENDIF
   $k=$k*2
NEXT
?
'Test against a number with the following bit pattern:' ?
'110011 = 51' ? ?
'&0 = Dec 0' ?
'AnyFlags(51,&0)=' + AnyFlags(51,Val('&0')) ? ?
'Test 110011 against 000011 (3)' ?
'AnyFlags(51,3)=' + AnyFlags(51,3) ?
'Test 110011 against 001100 (12)' ?
'AnyFlags(51,12)=' + AnyFlags(51,12) ?
'Test 110011 against 0010010 (18)' ?
'AnyFlags(51,18)=' + AnyFlags(51,18) ?
'Test 110011 against 0010110 (22)' ? 
'AnyFlags(51,22)=' + AnyFlags(51,22) ? ;AnyFlags() and AllFlags() differ here
;Console output
;AnyFlags(11,1)=1
;AnyFlags(11,2)=1
;AnyFlags(11,8)=1
;
;Test against a number with the following bit pattern:
;110011 = 51
;
;&0 = Dec 0
;AnyFlags(51,&0)=0
;
;Test 110011 against 000011 (3)
;AnyFlags(51,3)=1
;Test 110011 against 001100 (12)
;AnyFlags(51,12)=0
;Test 110011 against 0010010 (18)
;AnyFlags(51,18)=1
;Test 110011 against 0010110 (22)
;AnyFlags(51,22)=1
;
;Source

code:


FUNCTION AnyFlags($iNum,$iTst)
   ; Returns a boolean true if ANY of the '1' bits in $iTst
   ; are also set in $iNum.
   $iNum=Val($iNum) $iTst=Val($iTst)
   $AnyFlags=(($iNum & $iTst)<>0)
ENDFUNCTION


[ 27 January 2002: Message edited by: New Mexico Mark ]

[ 27 January 2002: Message edited by: New Mexico Mark ]166875AppendRegistry10723Mike_MalsedAppendRegistry() 
- Appends a Registry Entry1157490460Code:


;Function	AppendRegistry
;
;Action		Appends a value to the end of a Registry entry (as in a path variable)
;
;Author		Micheal Malsed
;
;Version	1.0
;
;Date Created	09-04-06
;
;		This is something of a synthesis of multiple Registry Update/Modification/Write
;		UDFs. I wanted something that would search for a value within a reg setting and
;		if not found, append it. Much like we would do with a Path environment variable.
;
;Syntax		AppendRegistry(RegKey, RegEntry, RegValue [,RegType])
;
;Parameters	RegKey - required, String containing Registry Subkey
;		RegEntry - required, String containing Entry
;		RegValue - required, String containing value
;		RegType - optional, string containing registry type, defaults to existing type.
;
;Returns	0 if RegValue is appended, 1 if already exists and error code is set if unsuccessful
;
;Example:
;	$RegKey = "HKEY_Local_Machine\SYSTEM\CurrentControlSet\Control\Session Manager\Environment"
;	$RegEntry = "Path"
;	$RegValue = "c:\Program Files\Java\jdk1.5.0_08\bin"
;
;	$Append = AppendRegistry($RegKey, $RegEntry, $RegValue)

function AppendRegistry($RegKey, $RegEntry, $RegValue, optional $RegType)
dim $CurValue 	;Current Registry Key Value
dim $CurType	;Current Registry Key Type
dim $CheckExist	;If 0, $RegValue is NOT in $CurValue, update
		;If 1, $RegValue is already updated, skip updating
		;If >1, Other error exists.

$AppendRegistry = 0

$CurValue = readvalue($RegKey, $RegEntry)
$CurType  = readtype ($RegKey, $RegEntry)
If $RegType <> ""
	$CurType = $RegType
Endif

$CheckExist = Instr($CurValue, $RegValue)

if $CheckExist = 0
	$CurValue = $CurValue + ";" + $RegValue
	writevalue($RegKey, $RegEntry, $CurValue, $CurType)
	$AppendRegistry = 0

	If @error
		exit @error
	endif

else
	? "Value Exists - not updating"
	$AppendRegistry = 1
endif

endfunction



I looked for something that would append instead of modify/replace/create a reg-entry. 
If I overlooked something. . .oops! Sorry. 

If I made any blunders, please let me know and I'll fix 'em. I remembered to Dim 
everything this time and to put everything inside code blocks, so I'm "larnin"! 

[Moderator (Jochen) changed topic title to reflect the guidelines]82028Array11ShawnArray() 
- Create 1D, 2D and 3D KiXtart Arrays0Array()

Action:

Creates one,two or three dimensional KiXtart arrays

Syntax:

Array($dx,[$dy,[$dz]])

Parameters:

$dx : The upper bounds of the first dimension

$dy : Optional - The upper bounds of the second dimension

$dz : Optional - The upper bounds of the third dimension

Returns:

An uninitialized one,two or three dimensional array

Remarks:

Avoid the tempation to rename this function MakeArray(). This function name 
is already reserved by KiXtart for future use !

Dependencies:

KiXtart 4.0 (Final)

Example(s):

$array = Array(9) ; create a single array with 10 elements (0-9)
$array = Array(9,9) ; create a two dimensional array with 100 elements (0-9) * 
10
$array = Array(9,9,9) ; create a three dimensional array with 1000 elements (0-9) 
* 10 * 10

*** Look for more information posted seperately in the scripts section (end of 
post) ...

Source:

code:


Function Array($dx,optional $dy,optional $dz)
 dim $i
 dim $x[$dx]
 if vartypename($dy) = "long"
  dim $y[$dy]
  if vartypename($dz) = "long"
   dim $z[$dz]
   for $i = 0 to ubound($y)
    $y[$i] = $z
   next
  endif
  for $i = 0 to ubound($x)
   $x[$i] = $y
  next
 endif
 $array = $x
EndFunction

Scripts:

code:

; Example of loading and iterating over multi-dimensional arrays in KiXtart


; The following example loads a unique value into each element of a three dimensional array


$array = array(9,9,9)
for $x = 0 to 9
 for $y = 0 to 9
  for $z = 0 to 9
   $array[$x][$y][$z] = "$x-$y-$z" ; the unique value is a string representation of the indexes
  next
 next
next


; Now re-iterate through the array and verify unique values


for $x = 0 to 9
 for $y = 0 to 9
  for $z = 0 to 9
   if $array[$x][$y][$z] <> "$x-$y-$z"
    ?"ERROR IN ARRAY !!!"
   endif
  next
 next
next

Author:

Shawn Tassie (shawn.tassie@cgi.ca)

[ 24 November 2001: Message edited by: Shawn ]83833arraycomp175Darren_Warraycomp() 
- Compares two 1 Dimensional Arrays0

code:

  
;Function:	arraycomp
;
;Author:	Darren Whittington
;
;Contributors:	jpols, Lonkero  
;
;Version:	1.2 (25th of Febuary 2003)
;
;Modifications:
;
; 		1.1 Modified coding, added optional parameter 
; 		to return matching or non matching elements.
; 		1.2 Modified coding to accommodate spaces in array values
;
;Action:	Compares two 1 Dimensional Arrays
;
;Syntax:	ArrayComp(Array1,Array2,optional Switch)
;
;Parameters:
;		$Array1	- Source Array
;		$Array2	- Comparison Array
;		1 = Switch to toggle on matching
;
;Returns:
;		Strings that are in $Array2 but not in $Array1, or strings
;		common to both.
;
;Dependencies:
;		Kixtart v 4.20
;
;Remarks:
;		Not case sensative
;
;
;Examples:
;
;		$arr1 = a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
;		$arr2 = 1,2,3,4,f,g,a,34,42,23,c,z,o,r
;
;		"results for arraycomp(); elements that don't match:" ? ?
;		for each $e in arraycomp($arr1, $arr2)
;		    ":" $e ?
;		next
;
;		? "results for arraycomp(); matching elements:" ? ?
;		for each $e in arraycomp($arr1, $arr2, 1)
;		    ":" $e ?
;		next
;
;		get $ 
;

function arraycomp($array1, $array2, optional $switch)
    dim $rtnstr,$string
    for each $string in $array2
     if (ascan($array1,$string)>-1&$switch) | ascan($array1,$string)+$switch<0 $rtnstr=$rtnstr+chr(1)+$string 
     endif
    next
    $arraycomp=split(substr($rtnstr,2),chr(1))
endfunction

Discusions on function...

[ 27. February 2003, 21:32: Message edited by: Darren ]83743ArrayConverter17SealeopardArrayConverter() 
- Applies the specified command to a string/array0

code:

;FUNCTION      ArrayConverter
;
;ACTION        Applies the specified command to a string/array
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.4
;
;KIXTART       4.20
;
;DATE CREATED  2002/12/01
;
;DATE MODIFIED 2003/03/02
;
;SYNTAX        ARRAYCONVERTER(STRING,CMD)
;
;PARAMETERS    STRING
;              Required string or array to which the command will be applied
;
;              CMD
;              Required command to be performed (ABS,ASC,CDBL,CHR,CINT,CSTR,
;              DECTOHEX,FIX,INT,LEN,LCASE,LTRIM,RTRIM,SIDTONAME,TRIM,UCASE,VAL)
;
;RETURNS       Input string/array with applied specified command
;
;REMARKS       Function converts an array with a maximum of 26 dimensions. See also AVal(), ADbl(), and ATrim().
;
;DEPENDENCIES  none
;
;EXAMPLE       $array[0]='12.2'
;              $array[1]='12.3'
;              $rc=ArrayConverter($array,'FIX')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000315
;
function arrayconverter($array,$action)
  Dim $a, $arraydim, $rc, $cmds, $cmd, $vars

  $cmds='ABS,ASC,CDBL,CHR,CINT,CSTR,DECTOHEX,FIX,INT,LEN,LCASE,LTRIM,RTRIM,SIDTONAME,TRIM,UCASE,VAL'
  if ascan($cmds,$action)=-1
    $arrayconverter=$array
    return
  endif

  select
  case ubound($array,1)=-1
    $cmd='$array='+$action+'($array)'
    $rc=execute($cmd)
  case ubound($array,2)=-1
    for $a=0 to ubound($array)
      $cmd='$array['+$a+']='+$action+'($array['+$a+'])'
      $rc=execute($cmd)
    next
  case ubound($array,27)=-1
    $arraydim=0
    do
      $arraydim=$arraydim+1
    until ubound($array,$arraydim)=-1
    $arraydim=$arraydim-1
    if $arraydim<=26
      $vars='$sub_a'
      for $a=2 to $arraydim
        $vars=$vars+', $sub_'+chr($a+96)
      next
      $cmd='dim '+$vars+@CRLF
      for $a=1 to $arraydim
        $cmd=$cmd+'for $sub_'+chr($a+96)+'=0 to ubound($array,'+$a+')'+@CRLF
      next
        $cmd=$cmd+'$array['+$vars+']='+$action+'($array['+$vars+'])'+@CRLF
      for $a=1 to $arraydim
        $cmd=$cmd+'next'+@CRLF
      next
      $rc=execute($cmd)
    endif
  case 1
  endselect
  $arrayconverter=$array
endfunction



[ 31. May 2003, 22:42: Message edited by: sealeopard ]83595ArrayDim17SealeopardArrayDim() 
- Returns the number of dimensions/elements in an array0

code:

;FUNCTION      ArrayDim
;
;ACTION        Returns the number of dimensions/elements in an array
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.1
;
;DATE CREATED  2002/10/24
;
;DATE MODIFIED 2003/03/02
;
;KIXTART       4.12
;
;SYNTAX        ARRAYDIM(ARRAY [, DIMS])
;
;PARAMETERS    ARRAY
;              Required array of which the number of dimensions will be counted
;
;              DIMS
;              Optional boolean value to count number of elements in each array dimension
;
;RETURNS       Number of dimensions, or array with number of elements in each dimension
;
;REMARKS       none
;
;DEPENDENCIES  none
;
;EXAMPLE       dim $a[1,2,3,4,5]
;              $numberdims=ArrayDim($a)
;              $dims=ArrayDim($a,1)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000286
;
function arraydim($array, optional $dims)
  dim $a

  if vartype($array) & 8192
    $a=0
    do
      $a=$a+1
    until ubound($array,$a)=-1
    $arraydim=$a-1
    if val($dims)
      dim $b[$arraydim-1]
      for $a=1 to $arraydim
        $b[$a-1]=ubound($array,$a)
      next
      $arraydim=$b
    endif
  else
    $arraydim=-1
  endif
endfunction



[ 31. May 2003, 22:41: Message edited by: sealeopard ]82429ArrayEnumGroup17SealeopardArrayEnumGroup() 
- Creates an array of groups of which the current user is a member0

code:

;NAME          ARRAYENUMGROUP
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Creates an array of groups of which the current user is a member
;   
;SYNTAX        ARRAYENUMGROUP()
;  
;PARAMETERS    none
;
;RETURNS       Array containing the group names
; 
;REMARKS       none
;
;DEPENDENCIES  none
;  
;EXAMPLE       $retcode=arrayenumgroup()
;
function arrayenumgroup()
  dim $retcode, $valuecounter, $currentvalue, $valuearray
  
  $valuecounter=0
  do
    $currentvalue=enumgroup($valuecounter)
    if $currentvalue<>259 and @ERROR=0
      redim preserve $valuearray[$valuecounter]
      $valuearray[$valuecounter]=$currentvalue
      $valuecounter=$valuecounter+1
    endif
  until $currentvalue=259 or @ERROR
  
  $arrayenumgroup=$valuearray
endfunction



[ 18. July 2003, 14:51: Message edited by: sealeopard ]82422ARRAYENUMKEY17SealeopardARRAYENUMKEY() 
- Creates an array of names of the subkeys contained in a registry key0

code:

;NAME          ArrayEnumKey
;
;ACTION        Creates an array of names of the subkeys contained in a registry key or subkey
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2 (added error codes)
;              1.1
;
;DATE CREATED  2001/12/05
;
;DATE MODIFIED 2003/05/17
;
;KIXTART       4.12+
;
;SYNTAX        ARRAYENUMKEY($subkey)
;
;PARAMETERS    SUBKEY
;              Required string containing the key or subkey for which the subkeys will be enumerated
;
;RETURNS       Array containing the subkeys
;
;REMARKS       none
;
;DEPENDENCIES  none
;
;EXAMPLE       $retcode=arrayenumkey('HKEY_USERS')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000064
;
function arrayenumkey($regsubkey)
  dim $retcode, $subkeycounter, $currentsubkey, $subkeyarray

  if not keyexist($regsubkey)
    exit 87
  endif

  $subkeycounter=0
  do
    $currentsubkey=enumkey($regsubkey,$subkeycounter)
    if not @ERROR
      redim preserve $subkeyarray[$subkeycounter]
      $subkeyarray[$subkeycounter]=$currentsubkey
      $subkeycounter=$subkeycounter+1
    endif
  until @ERROR

  $arrayenumkey=$subkeyarray
  exit 0
endfunction



[ 19. May 2003, 00:22: Message edited by: sealeopard ]82425ArrayEnumValue17SealeopardArrayEnumValue() 
- Creates an array of names of the registry entries contained in a r0

code:

;NAME          ArrayEnumValue
;
;ACTION        Creates an array of names of the registry entries contained in a registry key or subkey
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2 (added error codes)
;              1.1
;
;DATE CREATED  2001/12/05
;
;DATE MODIFIED 2003/05/17
;
;KIXTART       4.12+
;
;SYNTAX        ARRAYENUMVALUE($subkey)
;
;PARAMETERS    SUBKEY
;              Required string containing the key or subkey for which the registry entries will be enumerated
;
;RETURNS       Array containing the registry values
;
;REMARKS       none
;
;DEPENDENCIES  none
;
;EXAMPLE       $retcode=arrayenumvalue('HKEY_USERS')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000065
;
function arrayenumvalue($regsubkey)
  dim $retcode, $valuecounter, $currentvalue, $valuearray

  if not keyexist($regsubkey)
    exit 87
  endif

  $valuecounter=0
  do
    $currentvalue=enumvalue($regsubkey,$valuecounter)
    if not @ERROR
      redim preserve $valuearray[$valuecounter]
      $valuearray[$valuecounter]=$currentvalue
      $valuecounter=$valuecounter+1
    endif
  until @ERROR

  $arrayenumvalue=$valuearray
  exit 0
endfunction



[ 19. May 2003, 00:22: Message edited by: sealeopard ]84047ArrayGetFileVersion17SealeopardArrayGetFileVersion() 
- Retreive all file version information into an array0

code:

;FUNCTION      ArrayGetFileVersion
;
;ACTION        Retreive all file version information into an array
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;CONTRIBUTORS  Kyder,LLigetfa
;
;VERSION       1.0
;
;KIXTART       4.12+
;
;SYNTAX        ARRAYGETFILEVERSION(FILE)
;
;PARAMETERS    FILE
;              Required string for which you want to get the version string
;
;
;RETURNS       Array of fileversion information, otherwise error code
;
;REMARKS       See GetFileVersion() for element indices
;
;DEPENDENCIES  none
;
;EXAMPLE       $rc = ARRAYGETFILEVERSION("c:\temp\test.sys")
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000393
;
function ArrayGetFileVersion($sFile)
  dim $a[12], $b[12], $c
  $a='Comments','CompanyName','FileDescription','FileVersion','InternalName',
'Language','LegalCopyright','LegalTrademarks','OriginalFilename','PrivateBuild',
'ProductName','ProductVersion','SpecialBuild'
  if exist($sFile)
    for $c=0 to ubound($a)
      $b[$c]=getfileversion($sFile,$a[$c])
    next
  else
    exit 2
  endif
  $ArrayGetFileVersion=$b
endfunction



[ 23. April 2003, 18:24: Message edited by: sealeopard ]83990ArrayPack31RadimusArrayPack() 
- strip out null items from arrays1120967982;FUNCTION ArrayPack
;
;ACTION removes null or blank or ' ' elements from an array and returns an array 
of the remainder
;
;AUTHOR Radimus
;
;CONTRIBUTORS 
;
;VERSION 1.0
;
;DATE CREATED 4/14/2003
;
;DATE MODIFIED 
;
;KIXTART 4
;
;SYNTAX ArrayPack($array)
;
;PARAMETERS $array
; Array of elements
;
;RETURNS Array of elements without empty values
; @error 1 = bad array input
; @error 2 = no elements in packed array ( ubound($Arraypack)=-1 )
;
;REMARKS used to strip out null elements, specifically for wmiQuery and others
;
;DEPENDENCIES kix 4.x+
;
;EXAMPLE $array='sfa','dfa','','dgwrfh','','sf','wrrw','','','wrgwrb'
; for each $item in arraypack($array)
; ? $item
; next
;
;KIXTART BBS http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000000
;
Code:


 Function ArrayPack($array)
    dim $loop, $element
    dim $arrTemp[0]

    If Not VarType($Array) & 8192    Exit 1        EndIf
    $loop = -1

    for each $element in $array
        if $element > ' '
            $loop = $loop + 1
            redim preserve $arrTemp[$loop] 
            $arrTemp[$loop] = $element
            endif
        next
    if ubound($arrTemp) = -1    Exit 2        Endif
    $ArrayPack = $arrTemp
    endFunction

154530AScanRev588SchuliebugAScanRev()0 Code:

 ;Function	AScanRev()
 ;
 ;Author	Jan Schuleburg (schuliebug@hotmail.com)
 ;
 ;Action	Scans which element of an array is in a string.
 ;
 ;Syntax	AScanRev(string,Array)
 ;
 ;Version	1.0
 ;
 ;Date           02-Januari-2006
 ;
 ;Date Revised   
 ;
 ;Parameters 	String: string to search in 
 ;		Array: one dimensional array
 ;
 ;Remarks	None
 ;
 ;Returns	First element of array in string
 ; 
 ;Dependencies 	None
 ;
 ;KiXtart Ver	4.02
 ; 
 ;Example(s)	$Array="This","is","a","sample","array"
 ;              $=AScanRev("Sample string to search in",$Array)
 ;              $ will return 2 ('a' is in the sample string)
 ; 
 Function AScanRev($String,$Array)
   Dim $Cnt

   $AScanRev=-1
   For $Cnt=0 To UBound($Array)
	If InStr($String,$Array[$Cnt])>0
		$AScanRev=$Cnt
		$Cnt=UBound($Array)
	EndIf
   Next
 EndFunction

83918Associate2980Glenn BarnasAssociate() - create a file / command 
association - Local or remote1202076184When we install software (like Kix) we 
often need to create file associations. My "customize" script installs Kix and 
other support tools, performs some basic identification changes (PROMPT, My 
Computer, etc) and - of course - creates Open and Edit associations for Kix. 
Since I wrote Customize to either act locally or "Push" its changes to a remote 
server, I wrote many functions that work against the local system by default but 
can operate against a remote system if specified.

UDF Updated 2008/02/03 - editing UDF content corrupted post - latest code added 
below.





;; 
;;====================================================================== 
;; 
;;FUNCTION       Associate() 
;; 
;;ACTION         Create, Update, Add, or Delete OPEN and EDIT associations to file extensions. Supports System (default) or  
;;               per-user associations. Can define system associations remotely. 
;; 
;;AUTHOR         Glenn Barnas (original code) & Mart (HKCU support) 
;; 
;;VERSION        2.0 - Updated by Mart to handle Per User associations, added variable validation,  
;;                     Updated by Glenn to handle Delete action, code cleanup to current coding standards 
;;               1.0 - Original release - 2003 
;; 
;;SYNTAX         Associate(Extension, Type [, Description] [, OPEN command [, EDIT command] [, Add] [, System] [, Icon] [, UFlag]) 
;; 
;;PARAMETERS     Extension    - REQUIRED - String, File extension to associate 
;;               Type         - REQUIRED - String, Short FileType description (no spaces) 
;;               Description  - OPTIONAL - String, Description of File Type 
;;               OPEN Command - OPTIONAL - String, Command to OPEN (execute) the associated file 
;;               EDIT Command - OPTIONAL - String, Command to EDIT the associated file [optional] 
;;               ADD          - OPTIONAL - Boolean, if set, adds a new Extension to an existing 
;;                              association definition. Should be 0 if defining a new association. 
;;               System       - OPTIONAL - String, System where association is to be made - null for local system 
;;               Icon         - OPTIONAL - String, String with "PATH,INDEX" format specifying Icon file, optional Icon index.  
;;               UFlag        - OPTIONAL - Boolean, Perform HKCU instead of HKLM association 
;; 
;; 
;;REMARKS        Specifying a null Open Command will delete the association 
;; 
;;RETURNS        nothing 
;; 
;;DEPENDENCIES   none 
;; 
;;TESTED WITH    NT4, W2K, WXP, W2K3, Vista, X64 
;; 
;;EXAMPLES       ; Create an association for Kix open/edit 
;;               Associate('.KIX', 'KixScript', 'Kixtart Script', 'Kix32.exe', 'notepad.exe') 
;; 
;;               ; Add a .SCR extension to the KixScript association 
;;               Associate('.SCR', 'KixScript', '', '', '', 1) 
;; 
;;               ;Create current user association on local system. 
;;               Associate('.KIX', 'KixScript', 'KiXtart script file', 'kix32.exe', 'notepad.exe',,,$Icon,1) 
;; 
;;               ;Delete current user association on local system. 
;;               Associate('.KIX', 'KixScript',,,,,,,1) 
;; 
;;               ;Delete system association on local system. 
;;               Associate('.KIX', 'KixScript') 
;;               Associate('.SCR', 'KixScript') 
; 
Function Associate($_Extension, $_Type, OPTIONAL $_Description, OPTIONAL $_OCmd,  OPTIONAL $_ECmd,  OPTIONAL $_AddFlag,  OPTIONAL $_Target, OPTIONAL $_ICON, OPTIONAL $_UFlag)
 
  Dim $_WSPath
  Dim $_Root
  Dim $_RTN
 
  ; make sure the "dot" is specified 
  If Left($_Extension, 1) <> '.'
    $_Extension = '.' + $_Extension
  EndIf
 
  ; required Extension and Type args can't be null 
  If Not $_Extension Or Not $_Type
    Exit 87
  EndIf
 
  ; Clear Current User flag if target hostname is defined - HKCU only works interactively on the local machine 
  If $_Target $_UFlag = 0 EndIf
 
  ; insure that "$_Target" has the right format if it's specified 
  $_Target =  IIf(CStr($_Target) <> '', '\\' + Join(Split(CStr($_Target), '\'), '', 3) + '\', '')
 
  ; Define the registry root path 
  $_Root = IIf($_UFlag, 'HKEY_CURRENT_USER\SOFTWARE\Classes\', 'HKEY_CLASSES_ROOT\')
 
  ; Obtain the Windows System Path value from the target system - use this reg entry 
  ; instead of the %SystemRoot% variable so it is relative to the target and not the 
  ; local machine. 
  $_WSPath = ReadValue($_Target + 'HKEY_Local_Machine\SOFTWARE\Microsoft\Windows NT\CurrentVersion',  'SystemRoot')
 
  ; Delete and then define the Extension if the Open command is specified or Add mode is active 
  $_RTN = DelTree($_Target + $_Root + $_Extension)
  If $_OCmd or $_AddFlag 
    $_RTN = WriteValue($_Target + $_Root + $_Extension, '', $_Type, 'REG_SZ')
  EndIf
 
  ; just return if we're adding a new Extension to an existing association 
  If $_AddFlag
    Exit 0
  EndIf
 
  ; Create the definitions for the OPEN command 
  $_RTN = DelTree($_Target + $_Root + $_Type)
  If $_OCmd
    $_RTN = WriteValue($_Target + $_Root + $_Type, '', $_Description, 'REG_SZ')
    $_RTN = WriteValue($_Target + $_Root + $_Type + '\Shell\Open\Command', '', $_OCmd, 'REG_EXPAND_SZ')
 
    ; Use specific or standard icon 
    If $_Icon
      $_RTN = WriteValue($_Target + $_Root + $_Type + '\DefaultIcon', '', $_Icon, 'REG_SZ')
    Else
      $_RTN = WriteValue($_Target + $_Root + $_Type + '\DefaultIcon', '', $_WSPath + '\system32\SHELL32.dll,21', 'REG_SZ')
    EndIf
 
    ; Create the association for the EDIT command, if specified 
    If $_ECmd <> ''
      $_RTN = WriteValue($_Target + $_Root + $_Type + '\Shell\Edit\Command', '', $_ECmd, 'REG_EXPAND_SZ')
    EndIf
  EndIf
 
  Exit 0
 
EndFunction
 
 


82216ATrim17SealeopardATrim() - Strips leading/trailing spaces from an 
array0

code:

;FUNCTION      ATrim
;
;ACTION        Strips leading and trailing spaces from an input string or array and returns the result
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.3
;
;DATE CREATED  2001/11/26
;
;DATE MODIFIED 2003/03/02
;
;KIXTART       4.20
;
;SYNTAX        ATRIM(STRING)
;
;PARAMETERS    STRING
;              Required string or array from which to strip leading and trailing spaces
;
;RETURNS       Input string/array without leading and trailing spaces
;
;REMARKS       Function converts an array with a maximum of 26 dimensions
;
;DEPENDENCIES  none
;
;EXAMPLE       $array[0]=' String1'
;              $array[1]=' String2 '
;              $rc=atrim($array)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000031
;
function atrim($array)
  Dim $element, $maxelements, $arraydim, $rc, $a

  select
  case ubound($array,1)=-1
    $array=trim($array)
  case ubound($array,2)=-1
    $maxelements=val(ubound($array))
    for $element=0 to $maxelements
      $array[$element]=trim($array[$element])
    next
  case ubound($array,27)=-1
    $arraydim=0
    do
      $arraydim=$arraydim+1
    until ubound($array,$arraydim)=-1
    $arraydim=$arraydim-1
    if $arraydim<=26
      dim $cmd, $vars
      $vars='$sub_a'
      for $a=2 to $arraydim
        $vars=$vars+', $sub_'+chr($a+96)
      next
      $cmd='dim '+$vars+@CRLF
      for $a=1 to $arraydim
        $cmd=$cmd+'for $sub_'+chr($a+96)+'=0 to ubound($array,'+$a+')'+@CRLF
      next
        $cmd=$cmd+'$array['+$vars+']=trim($array['+$vars+'])'+@CRLF
      for $a=1 to $arraydim
        $cmd=$cmd+'next'+@CRLF
      next
      $rc=execute($cmd)
    endif
  case 1
  endselect

  $atrim=$array
endfunction



[ 31. May 2003, 22:40: Message edited by: sealeopard ]83620Autologon31RadimusAutologon() 
- enable/disable autologon0modified UDF combining the DisableAutoLogon() and 
EnableAutoLogon() UDFs
$type=1 to set autologon
$type=0 to clear autologon
$type=-1 to check autologon setting

sets @error if parameters not correct

examples:
$status=autologon(1, @domain, $username, $password)
$status=autologon(0)
$status=autologon(-1)

code:

function autologon($type, optional $domain, optional $username, optional $password)
	Dim $regsubkey

	if @INWIN=1
		$regsubkey='HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon'
	else
		$regsubkey='HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Winlogon'
		endif

	Select
		case $Type=1 and $domain and $username and $password
			$enable=writevalue($regsubkey,'AutoAdminLogon',1,'REG_SZ')
			$enable=writevalue($regsubkey,'DefaultDomainName',$domain,'REG_SZ')
			$enable=writevalue($regsubkey,'DefaultPassword',$password,'REG_SZ')
			$enable=writevalue($regsubkey,'DefaultUsername',$username,'REG_SZ')
			$enable=writevalue($regsubkey,'DontDisplayLastUserName',0,'REG_SZ')
			$autologon=1
		case $Type=0
			$disable=writevalue($regsubkey,'AutoAdminLogon',0,'REG_SZ')
			$disable=writevalue($regsubkey,'DefaultDomainName','','REG_SZ')
			$disable=writevalue($regsubkey,'DefaultPassword','','REG_SZ')
			$disable=writevalue($regsubkey,'DefaultUsername','','REG_SZ')
			$disable=writevalue($regsubkey,'DontDisplayLastUserName',1,'REG_SZ')
			$autologon=0
		case $Type=-1
			$autologon=readvalue($regsubkey,'AutoAdminLogon')
		case 1
			exit 1
			return
		endselect
	endfunction



[ 28. October 2002, 15:17: Message edited by: Radimus ]83063AVal17SealeopardAVal() 
- Converts an array of strings into an array of values0

code:

;FUNCTION      AVal
;
;ACTION        Converts an array of strings into an array of values
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.4
;
;DATE CREATED  2002/05/03
;
;DATE MODIFIED 2003/03/02
;
;KIXTART       4.20
;
;SYNTAX        AVAL(ARRAY)
;
;PARAMETERS    ARRAY
;              Required string or array to be converted to values
;
;RETURNS       Input string/array of values
;
;REMARKS       Function converts an array with a maximum of 26 dimensions
;
;DEPENDENCIES  none
;
;EXAMPLE       $array[0]='1'
;              $array[1]='2'
;              $retcode=aval($array)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000192
;
function aval($array)
  Dim $element, $arraydim, $rc, $a

  select
  case ubound($array,1)=-1
    $array=val($array)
  case ubound($array,2)=-1
    for $element=0 to ubound($array)
      $array[$element]=val($array[$element])
    next
  case ubound($array,27)=-1
    $arraydim=0
    do
      $arraydim=$arraydim+1
    until ubound($array,$arraydim)=-1
    $arraydim=$arraydim-1
    if $arraydim<=26
      dim $cmd, $vars
      $vars='$sub_a'
      for $a=2 to $arraydim
        $vars=$vars+', $sub_'+chr($a+96)
      next
      $cmd='dim '+$vars+@CRLF
      for $a=1 to $arraydim
        $cmd=$cmd+'for $sub_'+chr($a+96)+'=0 to ubound($array,'+$a+')'+@CRLF
      next
      $cmd=$cmd+'$array['+$vars+']=val($array['+$vars+'])'+@CRLF
      for $a=1 to $arraydim
        $cmd=$cmd+'next'+@CRLF
      next
      $rc=execute($cmd)
    endif
  case 1
  endselect

  $aval=$array
endfunction



[ 31. May 2003, 22:39: Message edited by: sealeopard ]84238BackupOptions119LonkeroBackupOptions() 
- set/get some NTbackup options0


;Function:

;	BackupOptions()

;

;Author:

;	Lonkero

;

;Version:

;	1.0

;

;Version History:

;	1.0	(12.5.2003)	- initial Release

;

;Action:

;	Set or Get NTBackup Option(s)

;

;Syntax:

;	BackupOptions(OPTION [,VALUE])

;

;Parameters:

;	OPTION

;		Optional

;		if not specified, returns all possible settable options

;

;	VALUE

;		Optional

;		if not specified, returns current setting

;

;Remarks:

;	not sure anyone else needs this than me, but hey...   

;

;Returns:

;	depending on the parameters:

;		options that can be set (in array) or

;		current value for some option or

;		errorcode when setting option

;

;Dependencies:

;	Windows NT based machine   

;

;Examples:

;	1.

;	"Open File 'Agent' is "

;	if BackupOptions('Backup Files inuse')

;	 "turned on"

;	else

;	 "not on"

;	endif

;

;	2.

;	"current backup-settings:" ?

;	for each $setting in BackupOptions()

;	 ? $setting " : " BackupOptions($setting)

;	next

;

;Source:

function BackupOptions(optional $0,optional $1)

 dim $,$_,$!,$2,$3,$4

 $='hkcu\software\microsoft\ntbackup\'

 $_=$+'user interface'

 $!=$+'Backup engine'



 $=-1 do $=$+1 $2=$2+'\'+$4 $4=enumvalue($_,$) until @error

 $4=''

 $=-1 do $=$+1 $3=$3+'\'+$4 $4=enumvalue($!,$) until @error

 if vartype($0)

  select

   case instr($2,$0) and vartype($1)

    $BackupOptions=writevalue($_,$0,$1,'reg_sz')

   case instr($3,$0) and vartype($1)

    $BackupOptions=writevalue($!,$0,$1,'reg_sz')

   case instr($2,$0)

    $BackupOptions=readvalue($_,$0)

   case instr($3,$0)

    $BackupOptions=readvalue($!,$0)

   case 1

    $BackupOptions='Incorrect Option'

    exit 6

  endselect

  if vartype($1) exit $BackupOptions endif

 else  

  for each $ in split($2+$3,'\')

   if len($)

    $BackupOptions=$BackupOptions+'\'+$

   endif

  next

  $BackupOptions=split(substr($BackupOptions,2),'\')

 endif

endfunction

157161BackupSystemState52NTDOCBackupSystemState() - Utilize NTBACKUP to 
automate SystemState backups0

;Function	BackupSystemState() - Utilize NTBACKUP to automate SystemState backups 
;  
;Author		NTDOC  
;  
;Contributors	  
;  
;Action		Helps to automate the process of performing a SystemState backup  
;  
;Syntax		BackupSystemState($Folder) 
;  
;Version	1.0  
;  
;Date		2006-Feb-13  
;  
;Date Revised	xxxx-xxx-xx  
;  
;Revision Reason  
;		  
;  
;Parameters	The folder location where the backups should be stored 
;  
;Remarks	Tested on XP Pro / Server 2003 
;  
;Returns	Errorlevel 
;  
;Dependencies	KiXtart v4.5  
;		Written and tested with KiXtart v4.52 beta 2  
;  
;Notes		To successfully backup the system state this should only be run on 
;		Windows XP or Server 2003 or Vista, all prior versions of Windows will 
;		not backup the system state properly with NTBACKUP alone. 
; 
;Example 
;		BackupSystemState('\\SERVER01\SHARE\BACKUPS\') 
;		If @ERROR 
;		  'Error backing up system state ' + @ERROR + ' : ' + @SERROR ? 
;		Else  
;		  'Backing up system state was successful ' + @ERROR + ' : ' + @SERROR ? 
;		EndIf  
; 
;Source  
 
Function BackupSystemState($Folder)
  Dim $Job
  If Not InStr(Right($Folder,1),'\') Exit 3 EndIf
  $Job = Trim(Join(Split(@DATE,'/'),'-'))+'_'+Trim(Join(Split(@TIME,':'),''))+'-SystemState'
  SHELL 'ntbackup backup systemstate /j '+ $Job +' /f ' + $Folder + $Job+'.bkf'
  Exit @ERROR
EndFunction
 
116653Base2Dec288jtokachBase2Dec( ) - Converts value or string to decimal1080073682;FUNCTION 
Base2Dec() 
; 
;ACTION Converts a value or string to decimal 
; 
;AUTHOR James Tokach 
; 
;CONTRIBUTERS Richard H. 
; 
;VERSION 1.0 
; 
;DATE CREATED 2004/10/23 
; 
;DATE MODIFIED N/A 
; 
;KIXTART Tested only with 4.22 
; 
;SYNTAX $ReturnCode = Base2Dec($Value, $Base) 
; 
;PARAMETERS $Value 
; String or Integer, value to be converted 
; 
; $Base 
; Base to convert from 
; 
;RETURNS The converted value 
; 
;REMARKS This was oringally posted by Richard H. 
; http://www.kixtart.org/ubbthreads/showthreaded.php?Cat=&Number=112061&page=36&view=collapsed&sb=3&o=all&vc=1 
; 
;DEPENDENCIES None 
; 
;EXAMPLE base2dec("0000000c",16) ; Returns 12 
; base2dec(0,16) ; Returns zero 
; 
;KIXTART BBS http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=115413&page=0&view=collapsed&sb=5&o=all&fpart=&vc=1 
; 
Function Base2Dec($Value,$Base) 
If $Value=0 
$Base2Dec=0 
Else 
While $Value 
$Base2Dec=CDbl($Base)*$Base2Dec+Execute("Exit &"+Left($Value,1)) 
$Value=SubStr($Value,2) 
Loop 
EndIf 
EndFunction119906Base64119LonkeroBase64() - encode/decode string with base641085140263Code:


;FUNCTION  

;	Base64()  

;  

;AUTHOR  

;	Lonkero (Jooel_Nieminen@hotmail.com)  

;  

;ACTION  

;	encodes/decodes input string with base64

;  

;VERSION  

;	1.1

;  

;VERSION HISTORY  

;	1.1 

;		21. may 2004

;		 - Fixed to comply with RFC2045 line-wrapping and special character handling

;	1.0 

;		20. may 2004

;		 - Initial release

;  

;SYNTAX  

;	Base64(STRING [, MODE])

;  

;PARAMETERS  

;  

;	STRING

;		- string To translate

;	MODE

;		- (optional) 0/1, 0 For encode, 1 For decode

;  

;RETURNS  

;	the converted input

;  

;REMARKS  

;	none  

;  

;DEPENDENCIES  

;	kix 4.10

;  

;EXAMPLEs 

;	base64("Hello") ?

;	base64(base64("Hello"),1) ?

;	">" base64("Hello World!") "<" ?

;	">" base64(base64("Hello World!"),1) "<" ?

;	Get $ 

;  

;SOURCE  

Function base64($s,optional $m)

 DIM $,$x,$b,$!,$y,$n,$o

 $o=IIf($m,8,6)

 $m=IIf($m,0,1)

 For $!=1 To Len($s)

	$n=''

	$=ASC(SubSTR($s,$!,1))

	if ($=43|($>46&$<58)|($>64&$<91)|($>96&$<123)|$m)

		$=$+(0=$m)*(19*($=43)+16*($=47)+4*($>47)-69*($>64)-6*($>96))

		While $

			$x=INT($-(INT($/2)*2))

			$=($-$x)/2

			$n=''+$x+$n

		Loop

		$b=$b+Right('00000000'+$n,IIf($m,8,6))

	EndIf

 Next

 For $!=1 To Len($b) Step $o

	$y=1 $n=''

	$=Left(SubSTR($b,$!,$o)+'0000000',$o)

      For $x=$o To 1 Step -1

		$n=$y*SubSTR($,$x,1)+$n

		$y=$y*2

	Next

	$base64=$base64+CHR($n+($m)*(65*($n<26)+71*($n>25)-75*($n>51)-14*($n>61)+4*($n>62)))

 Next

 ;this section not needed. here just to support standard presentation.

 If $m

	;adds "=" to the end to meet standard

	For $=1 To (4-Len($base64) mod 4) mod 4

		$base64=$base64+'='

	Next

	;and cuts lines (For the same reason ;))

	$!=''

	For $=1 To Len($base64) step 76

		 $!=$!+substr($base64,$,76)+@crlf ;If 76>Len($base64)-$

	Next

	$base64=Left($!,-2)

 EndIf

EndFunction

83326BaseConverter119LonkeroBaseConverter() - for base2-base36 conversions1086397537 
Code:

;Function BaseConverter()

;

;Authors

;	Howard Bullock

;	BrianTX

;	Shawn Tassie

;	Jooel Nieminen

;

;Version 1.0.1

;

;Version history

;	1.0.1 (5.6.2004) - fixed annoying variable scope problem

;	1.0 (7.7.2002) - initial kixgolf code

;

;Action Converts bases 2-36 from any to any

;

;Syntax BaseConverter($Value, $From, $To)

;

;Parameters

;	$Value - String or Integer, Value to be converted

;	$From - Integer, Base where convert from

;	$To - Integer, Base to convert to

;

;Remarks

;	Code was produces as kixgolf-competition.

;	For More info see topics:

;		http://81.17.37.55/board/ultimatebb.php?ubb=get_topic;f=2;t=003447

;		http://81.17.37.55/board/ultimatebb.php?ubb=get_topic;f=2;t=003458

;		http://81.17.37.55/board/ultimatebb.php?ubb=get_topic;f=2;t=003470

;	Thanks to:

;		Sealeopard - our host on the competition

;		Kholm - for participating

;

;Returns

;	on success: Value converted to specified base

;	on error: nothing. sets error to 1

;

;Dependencies

;	None

;

;Example

;	"Value 44680832201 is in base10" ?

;	"when converted to base36 it's '"

;	BaseConverter('44680832201', 10, 36)

;	"'"

;

;Source

Function BaseConverter($v,$f,$t)

 dim $,$e,$y,$n,$x,$z

   $=0

   $t=$+$t

   $f=$+$f

   $e=($f>36)|($t>36)|($f<2)|($t<2)   

   $y=1.

   for $n=len($v) to 1 step -1

      $x=ASC(UCASE(substr($v,$n,1)))

      $z=($x-48-($x>64)*7)

      IF ($z<0)|(($x>57)&($x<65))|$e|($z>($f-1))

       EXIT 1

      ENDIF

      $=$y*$z+$

      $y=$y*$f

   next

   $n=""

   While $

      $x=INT($-(INT($/$t)*$t))

      $=($-$x)/$t

      $n=CHR($x+48+($x>9)*7)+$n

   Loop

   $BaseConverter=$n

Endfunction

82213BinaryIP28BryceBinaryIP() - converts an IP# to it's binary value.1111597110Code:


; Binary IP
;   Returns a binary string repesenting an ip address.
;
; Requirements: NONE
;
; SYNTAX: BinaryIP("IPNUMBER",[optional reverse flag])
;   IPNUMBER	can be any ip address OR a binary string representing 
;		an IP address if the reverse flag is used.
;
function BinaryIP($IP, optional $reverse)
	DIM $item, $bitsize, $octet, $byte, $factor, $dec
	$bitsize = 128
	if not $reverse $ip = split($IP,".") endif
	select 
		case $reverse
			$binaryip = ""
			if len($ip) <> 32 exit(87) endif
			for $i = 1 to 32 step 8	
				$Octet = substr($ip,$i,8)
				$factor = 1
				$dec = 0
				While $octet <> ""
					$byte = Val(SubStr($octet, Len($octet), 1))
					$octet = SubStr($octet, 1, Len($octet) - 1)
					$dec = $dec + ($byte * $factor)
					$factor = $factor * 2
				Loop
				$binaryip = $binaryip + $dec + "."
			next
			$binaryip = join(split($binaryip,"."),".",4)
		case UBOUND($ip) <> 3
			$BinaryIP = 0
			exit(87)
		case 1
			for each $octet in $ip
				if VAL($octet) <0 OR VAL($octet) > 255
					$BinaryIP = 0
					exit(87)
				endif
				while $bitsize > 0
					if val($octet) & $bitsize
						$Binary = $Binary + "1"
					else
						$Binary = $Binary + "0"
					endif
					$bitsize = $bitsize / 2
				loop
				$binaryIP = $binaryIP + "$binary"
				$bitsize = 128
				$binary = ""
			next
	endselect
	exit(0)
endfunction

83899Blank_Template31RadimusBlank_Template() - Empty shell to use when 
posting UDFs0Code tags left off to make copy/pasting easier

;FUNCTION Name_of_UDF
;
;ACTION Short description of purpose
;
;AUTHOR Name of author
;
;CONTRIBUTORS Name(s) of contributor(s)
;
;VERSION UDF version
;
;KIXTART Minimum required Kixtart version
;
;SYNTAX NAME_OF_UDF(PARAMETER 1, PARAMETER2 [, PARAMETER3])
;
;PARAMETERS PARAMETER1
; Description of first parameter
;
; PARAMETER2
; Description of second parameter
;
; PARAMETER3
; Description of optional first parameter
;
;RETURNS Type of return value
;
;REMARKS Additional remarks about the UDF
;
;DEPENDENCIES DependUDF @ http://www.kixtart.org/board/...
; Name and URL of UDFs that this UDF depends on
;
;EXAMPLE A short functional example demonstrating the UDF
;
;KIXTART BBS http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000000
; URL the UDF was posted under
;
function Name_of_UDF($parameter 1, $parameter2, optional $parameter3)

endfunction157884Bool2980Glenn BarnasBool() - convert Y/N type values to 
boolean values0



;; 
;;====================================================================== 
;; 
;;FUNCTION       Bool() 
;; 
;;ACTION         return True if Flag is "non-zero", "T", "Y", or "ON" 
;; 
;;AUTHOR         Glenn Barnas 
;; 
;;SYNTAX         Bool(flag [,other_true] [,default]) 
;; 
;;PARAMETERS     Flag    - REQUIRED, a text string - can be null 
;; 
;;               Extra   - OPTIONAL, a string of other "true" matches, comma-delimited. 
;;                         "En*" will match the leftmost 2 chars 
;; 
;;               Default - OPTIONAL, a default value to use if Flag is null 
;; 
;;REMARKS        Returns TRUE if any of the following condidions are met: 
;;			First char of flag is "Y"  (yes) 
;;			First char of flag is "T"  (true) 
;;			First char of flag is a non-zero digit 
;;			Flag text is "ON" 
;;			Flag text matches optional Extra value 
;; 
;;RETURNS        1 if the flag evaluates to a "true" boolean, 0 otherwise 
;; 
;;DEPENDENCIES   none 
;; 
;;TESTED WITH    W2K, WXP, W2K3 
;; 
;;EXAMPLES       If Bool(ReadProfileString('config.ini', 'sect', 'setting') 
;;                 'Setting is on!' ? 
;;               EndIf 
;; 
;;               ; In this configuration, the default is T, and the config.ini value is 
;;               ; used to turn it off. If the setting in the ini file is not defined,  
;;               ; the default value is used. 
;;               $Default = 'T' 
;;               If Bool(ReadProfileString('config.ini', 'sect2', 'setting'), '', $Default) 
;;                 'Setting is on!' ? 
;;               EndIf 
;  
Function Bool($_Flag, OPTIONAL $_Extra, OPTIONAL $_Default)
 
  ; Handle embedded ReadLine errors passed to this wrapper func 
  If @ERROR Exit @ERROR EndIf
 
  Dim $_XV, $_aXV, $bT, $bF
 
  $bT = Not 0				; TRUE value 
  $bF = Not $bT				; FALSE value 
 
  ; set default value if defined and test value (Flag) is not defined 
  If $_Flag = '' And $_Default <> ''
    $_Flag = $_Default
  EndIf  
 
  $_Flag = UCase($_Flag)		; force uppercase chars 
 
  $Bool = $bF				; default to FALSE 
 
  If $_Extra
    $_Extra = 'ON,TRUE,T,YES,Y,' + $_Extra
  Else
    $_Extra = 'ON,TRUE,T,YES,Y'		; default test values 
  EndIf
 
  ; Handle the numeric test 
  If Val($_Flag) <> 0			; flag is non-zero 
    $Bool = $bT
  EndIf
 
 
  ; process string comparisons 
  If Not $Bool
    $_aXV = Split($_Extra, ',')		; get array of string match values 
    For Each $_XV in $_aXV		; then compare each one 
      If InStr($_XV, '*')		; is it a substring compare? 
        If UCase(Left($_XV, InStr($_XV, '*') - 1)) = Left($_Flag, InStr($_XV, '*') - 1)
          $Bool = $bT
        EndIf
      Else				; or a direct compare 
        If UCase($_XV) = $_Flag
          $Bool = $bT
        EndIf
      EndIf
    Next
  EndIf
 
  Exit 0				; always successful  
 
EndFunction
 
 
 


This was developed when users did not consistently set parameters in an ini file. 
Some used "y", "t", "1", or even "Enabled" to represent TRUE values. I got tired 
of custom coding this, so created a UDF with the most common "true" values. 

The optional args allow you to extend the list of "true" values, and permit a 
default to be used should the Flag value be a null string. This might occur when 
you have a default value, then read a specific value from an INI file that isn't 
defined. In this case, the default would be returned.82446BSort11ShawnBSort() 
- Bubble sort for one dimensional arrays0BSort()

Action:

Bubble sort for kixtart arrays

Syntax:

$array = bsort(array[,order])

Parameters:

Array (Required) - A single dimensional kixtart array

Order (Optional) - The sort order (0/1). If omitted or set to zero, the
array will be sorted in ascending order. If set to 1, the array will be sorted
in descending order.

Returns:

The sorted array

Remarks:

To my knowledge, this is as good (fast) as bubble sorts get. Would love to 
comnpare benchmarks and/or get feedback in terms of performance improvements.

Dependencies:

kixtart 4.0 (final)

Example(s):

code:

$array = Peach,Pumpkin,Orange,Grape,Lime,Apple,Rasberry,Cherry,Lemon
 
$array = bsort($array) ; sort ascending
for each $element in $array
 ? $element
next
 
$array = 1,2,3,4,5
 
$array = bsort($array,1) ; sort descending
for each $element in $array
 ? $element
next
 
$array = bsort(split("Z Q G A D M U V N C B T W J X S K R H I L E F P O Y"))
 
for each $letter in $array
 $letter
next

Source:

code:

function bsort($array, optional $order)
 dim $i,$j,$m
 if ubound($array)
  for $i = 0 to ubound($array)
   $m = $array[$i]
   for $j = $i + 1 to ubound($array)
    if ($array[$j] < $m and not $order) or ($array[$j] > $m and $order)
     $m = $array[$j]
     $array[$j] = $array[$i]
     $array[$i] = $m
    endif
   next
  next
  $bsort = $array
 else
  $bsort = 0
 endif
endfunction

Scripts:

code:

break on
 
; BENCHMARK
 
; create an array and seed with rnd numbers
 
srnd(1)
dim $array[500]
for $i = 0 to ubound($array)
 $array[$i] = rnd(100)
next
 
$start = @ticks
 
$array = bsort($array)
 
?"elapsed=" @ticks - $start
 
exit 1

Author:

-Shawn

[ 20. June 2003, 02:56: Message edited by: Shawn ]134572BT2Dec119LonkeroBT2Dec() 
- Balanced ternary to Decimal Converter0Code:


FUNCTION 
;	BT2Dec()
; 
;AUTHOR 
;	Lonkero
; 
;ACTION 
;	Balanced ternary to Decimal Converter
; 
;VERSION 
;	1.0
; 
;VERSION HISTORY 
;	1.0 
;		25th feb 2005
;		Initial public version.
; 
;SYNTAX 
;	 BT2Dec( BT_STRING) 
; 
;PARAMETERS 
;	BT_STRING
;	 The number to convert
; 
;RETURNS
;	Decimal representation of the number
; 
;REMARKS  
;	thanks to golf...
;  
;DEPENDENCIES 
;	kixtart 4.22
;
;EXAMPLE
;	BT2Dec("111")
;	BT2Dec("-10-1-111")
;	get $ 
;
;SOURCE  
Function BT2Dec($)
dim $a,$b
 $a=1
 while $
  $b=0>right($,2)
  $BT2Dec=$BT2Dec-2*$a*$b+$a*right($,1)
  $=left($,-1-$b)
  $a=$a*3
 loop
EndFunction

82082CalcLogicalSubnet172Howard BullockCalcLogicalSubnet() - Returns the 
logical subnet ID0 Code:

;Function   CalcLogicalSubnet ($IP, $SNmask)

;

;Author     Howard A. Bullock (hbullock@tycoelectronics.com)

;

;Contributors

;

;Action     Returns the subnet for a specific IP ans mask.

;

;Syntax     $result = CalcLogicalSubnet("12.1.2.122", "255.255.255.128")

;

;Version    2.1

;

;Date     2001/11/24

;

;Date Revised   2004/9/25

;

;Parameters     IP - in 'x.x.x.x' format

;               SNmask - in 'x.x.x.x' format

;

;Remarks    This UDF does not find or return the required subnet mask.

;           Since EnumIPinfo() does not return values for such as the subnet

;           mask for many computers, I have written another UDF to insure that

;           the proper data exists to use this function. See GetIPinfo().

;

;Returns    The logical subnet where a computer resides for a given IP address and

;           subnet mask.

;

;           Sets @error to one of three exit codes upon exit

;           0 = The command completed successfully

;           1 = Improperly formatted IP address

;           2 = Octet out range (0-255)

;

;Dependencies   None

;

;KiXtart Ver    4.02

;

;Example(s) $IP = "192.163.0.4"

;           $SNmask = "255.255.255.128"

;           $LogicalSubnet = CalcLogicalSubnet ($IP, $SNmask)

;           call $LogicalSubnet + ".kix" ;yields call "192.163.0.0.kix"

;

;           $IP = "192.163.0.150"

;           $SNmask = "255.255.255.128"

;           $LogicalSubnet = CalcLogicalSubnet ($IP, $SNmask)

;           call $LogicalSubnet + ".kix" ;yields call "192.163.0.128.kix"

;

Function CalcLogicalSubnet ($IP, $SNmask)



    dim $prevSet[2];Holds previous value of settings

    $prevSet[0] = setoption("Explicit","ON")

    $prevSet[1] = setoption("NoVarsInStrings","ON")



    dim $i         ;Counter for looping through 4 octets of the IP and subnet mask

    dim $arrayIP   ;Holds the string representation of the IP address octets.

    dim $arraySN   ;Holds the string representation of the subnet mask octet.

    dim $Subnet    ;Holds the string that becomes the logical subnet.

    dim $x, $y     ;Holds value of IP and SNmask octet.

    dim $ExitCode  ;Holds the value of the exit code that will be used.



    $arrayIP = split($IP, ".")

    $arraySN = split($SNmask, ".")



    $ExitCode = 0

    If UBound($arrayIP) = 3 and UBound($arraySN) = 3

        For $i=0 to 3

            $x = Val(LTrim($arrayIP[$i]))

            $y = Val(LTrim($arraySN[$i]))

            If $x >= 0 and $x < 256 and $y >= 0 and $y < 256

                $Subnet = "" + $Subnet + ($x & $y) + "."

            Else

                $ExitCode = 2

                $i = 4  ;abort loop on error

            Endif

        Next

        $CalcLogicalSubnet = substr($Subnet, 1, len($Subnet)-1)

    Else

        $ExitCode = 1

    Endif

    if $ExitCode

        $CalcLogicalSubnet = ""

    endif



    $prevSet[0] = setoption("Explicit",$prevSet[0])

    $prevSet[1] = setoption("NoVarsInStrings",$prevSet[1])

    Exit($ExitCode)

Endfunction

115793CalcNetworkID17SealeopardCalcNetworkID() - Calculates the Network ID1078869862Code:


;FUNCTION      CalcNetworkID()

;

;AUTHOR        Jens Meyer (sealeopard@usa.net)

;

;ACTION        Calculates the Network ID based on IP address and subnet mask

;

;VERSION       1.0

;

;DATE CREATED  2004/03/09

;

;DATE MODIFIED 2004/03/09

;

;KIXTART       4.20+

;

;SYNTAX        CALCNETWORKID(IP,SUBNETMASK)

;

;PARAMETERS    IP

;              Required string containing the IP address in octet form

;

;              SUBNETMASK

;              Required string containing a subnetmask in octet form

;

;

;REMARKS       none

;

;DEPENDENCIES  none

;

;RETURNS       Network ID, otherwise empty string

;

;EXAMPLE       $rc=calcnetworkid('168.192.1.1','255.255.255.0')

;

;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=114498

;

Function CalcNetworkID($asIP,$asSubnet)

  dim $asNetworkID[3], $iOctet



  $asIP=split($asIP,'.')

  $asSubnet=split($asSubnet,'.')



  if ubound($asIP)<>3 or ubound($asSubnet)<>3

    exit 0

  endif



  for $iOctet=0 to 3

    $asNetworkID[$iOctet]= val(trim($asIP[$iOctet])) & val(trim($asSubnet[$iOctet]))

  next

  $CalcNetworkID=join($asNetworkID,'.')

Endfunction

149553CDOMAIL79KdyerCDOMAIL() - Send SMTP mail using CDO0Code:

 ;Function	CDOMAIL()
 ;
 ;Author	kdyer (leptonator@hotmail.com)
 ;
 ;Contributors	Howard Bullock, Ceej
 ;
 ;Action	Sends an e-mail using CDO
 ;
 ;Syntax	CDOMAIL(to,from,subject,body,attachment)
 ;
 ;Version	1.0
 ;
 ;Date           08-October-2005
 ;
 ;Date Revised   08-October-2005
 ;
 ;Parameters 	to 
 ;		must be In the form of "user@@company.com"
 ;              from
 ;		must be In the form of "user@@company.com"
 ;              subject
 ;		subject of the message
 ;              body
 ;		body text of the message
 ;              OPTIONAL attachment
 ;		attachment to the message
 ;
 ;Remarks	another way to e-mail via script.  If you run VirusScan
 ;		8.0, you will have to unblock port 25 blocking
 ;              Based on the FAQ
 ;              How do I send e-mail from KiXtart? (SMTP)
 ;              http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=81626&an=0&page=1#81626
 ; If you run VirusScan, the above URL may give you a
 ; false positive :(
 ;
 ;Returns	Sends a e-mail using no external program
 ; 
 ;Dependencies 	cdo
 ;
 ;KiXtart Ver	4.02
 ; 
 ;Example(s)
 ; Attachment.. 
 ;CDOMAIL('user@@company.com','user@@company.com','Subject','body',
 ;"C:\Somefolder\somefile.txt")
 ; No Attachment
 ;CDOMAIL('user@@company.com','user@@company.com','Subject','body')
 FUNCTION CDOMAIL($to,$from,$subject,$body,OPTIONAL $attachment)
    DIM $objEmail,$msweb,$smtp
    $objEmail=CreateObject('CDO.Message')
    IF @ERROR<>0
       ?'CDO is not found - Please install First.'
       SLEEP 2
       EXIT
    ENDIF
    $objEmail.From=$from
    $objEmail.To=$to
    $objEmail.Subject=$subject
    $msweb='http://schemas.microsoft.com/cdo/configuration/'
    $smtp='smtp.company.com'
    $objEmail.Textbody=$body
    IF $attachment
       $objEmail.AddAttachment($attachment) ;Attach a File
    ENDIF
    $objEmail.Configuration.Fields.Item($msweb+'sendusing').value=2
    $objEmail.Configuration.Fields.Item($msweb+'smtpserver').value=$smtp
    $objEmail.Configuration.Fields.Item($msweb+'smtpserverport').value=25
    $objEmail.Configuration.Fields.Update
    $objEmail.Send
    ?"ERROR @ERROR: @SERROR"
 ENDFUNCTION

83428Cerror119LonkeroCerror() - translates com-errors0

;Function:

;	Cerror()

;

;Author:

;	Lonkero

;

;Version:

;	1.2 (26th of august 2003)

;

;Version history:

;	1.1 (26th of august 2002)

;

;Action: returns understandable error code of the com-error returned by object.

;

;Syntax Cerror()

;

;Parameters:

;	none

;

;Returns: the errorcode translated

;

;Dependencies: kix 4.20

;

;Remarks:

;	this new code is total re-write and actually a direct evolution version

;	of http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000376
;

;Example:

;	$=createobject("kixtart.former")

;	cerror @error " " @serror

;

;Source:

Function Cerror()

    exit Iif(@error<0,VAL("&"+Right(DecToHex(@error),4)),@error)

Endfunction

[ 26. August 2003, 04:46: Message edited by: Lonkero ]83696ChangeDriveLabels13MightyR1ChangeDriveLabels() 
- changes the drivelabel in explorer0Code:


;****************************************************************************

;

;SCRIPT        : Function ChangeDriveLabels()

;

;AUTHOR        : Patrick Rutten (MightyR1@hotmail.com)

;

;CONTRIBUTORS  : 

;

;ACTION        : Changes DriveLabel in Explorer or removes them

;

;SYNTAX        : $RC=ChangeDriveLabels($drive, Optional $label, Optional $erase)

;

;VERSION       : 1.0.2 - 2003-03-05 Dimmed the locally used variables on request

;                   of the moderator

;                1.0.1 - 2003-02-25 Made it a real UDF (according to Lonkero),

;                   so no messageboxes, just exit when OS <> W2k

;                1.0.0 - 2002-11-27 Initial Release

;

;PARAMETERS    : $drive - Drive to change, must be a..z (not checked)

;                Optional $label - new label for the drive

;                Optional $erase - write new label or not, if supplied then erase

;

;REMARKS       : 

;

;RETURNS       : Nothing

;

;DEPENDENCIES  : 

;

;KIXTART VER   : KiXtart 4.12

; 

;EXAMPLE(S)    : 

;                Break on CLS

;                $RC=ChangeDriveLabels("p","P - privé") ; -- Sets the label

;                Get $key

;                $RC=ChangeDriveLabels("p","bla",1) ; -- Removes the label

;                Exit 0

;

;KNOWN ISSUES  : 

;

;****************************************************************************

;

;

Function ChangeDriveLabels ($drive, Optional $label, Optional $erase)

 

 Dim $centry, $cexpr, $char, $csubkey, $ctype, $element, $empty

 Dim $key, $leng, $new, $newchar, $RC, $subkey, $ventry

 Dim $vsubkey, $vtype

 

 If 2=@inwin OR 0=InStr(@producttype,"Windows 2000")

;  $RC=MessageBox("Unsupported OS. W2k only.","KiXtart message", 16, 5)

  Exit 1

 EndIf

 

 $subkey="HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\MountPoints\"

 $centry="cache"

 $ctype="REG_BINARY"

 $empty="00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00"+","+

  "00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00"+","+

  "00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00"+","+

  "00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00"+","+

  "00,00"

 $ventry="version"

 $vtype="REG_DWORD"

 

 $drive=Ucase($drive)

 	

 $cexpr=Split($empty,",")

 

 $leng=Len($label)

 $new=""

 $element=0

 For $char=1 to $leng

  $newchar=DecToHex(ASC(SubStr($label,$char,1)))

  $cexpr[$element]=$newchar

  $element=$element+2

 Next

 	

 If ""=$erase

  $cexpr=Join($cexpr,"")

 Else

  $cexpr=Join(Split($empty,","),"")

 EndIf

 

 $csubkey=$subkey+$drive+"\_LabelFromReg"

 $RC=WriteValue($csubkey,$centry,$cexpr,$ctype)

 

 $vsubkey=$csubkey

 $RC=DelValue($vsubkey,$ventry)

 

EndFunction

140531ChangeOwner52NTDOCChangeOwner() - Change registered User and Owner 
for OS0

;Function		ChangeOwner() 
; 
;Author			NTDOC (ntdoc@@@@@kixhelp.com) 
; 
;Action			Sets or returns the Registered User and Organization 
;			for the operating system 
; 
;Syntax			ChangeOwner(Optional $Action,$Owner,$Org,$sComputer) 
; 
;Version		1.0 
; 
;Date			2005-May-28 
; 
;Date Revised		xxxx-xxx-xx 
; 
;Revision Reason 
; 
;Parameters		$Action 0 OR 1,   0 = read the values 1 = Set the values 
;			$Owner = Name to modify the registered owner to 
;			$Org = Name to modify the registered organization to 
;			$sComputer = Name of the computer to run script against 
;			If left blank it runs against the local computer 
; 
;Remarks		Tested on 2000/XP 
; 
;Returns		The registered owner and organization or error level 
; 
;Dependencies		None 
; 
;KiXtart Ver		Written and tested with KiXtart 2010 4.50 Release Candidate 1 
; 
;Example 
;			Dim $CO,$Type 
;			$CO = ChangeOwner(0,@FullName,'My Company') 
;			; Notice that $Action is set to 0 which means to read the values 
;			If VarType($CO) > 0 
;			; Notice that if you set the value there is nothing to read. 
;			; The VarType checks if you are reading or setting the values 
;			; to prevent an error that would happen if you were to use a 
;			; setting value for action and then tried to display the results 
;				  ? 'Owner: ' + $CO[0] 
;				  ? 'Organization: ' + $CO[1] 
;			EndIf 
; 
;Source 
 
 

Function ChangeOwner(Optional $Action,$Owner,$Org,$sComputer)
  Dim $Key,$Set
  If Not $sComputer $sComputer = ''
  Else
    $sComputer = '\\'+Join(Split($sComputer,'\'),'',3)+'\'
  EndIf
  $Key = $sComputer+'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion'
  If $Action
    If $Owner
      $Set = WriteValue($Key,'RegisteredOwner',$Owner,REG_SZ)
      If @ERROR Exit @ERROR EndIf
    EndIf
    If $Org
      $Set = WriteValue($Key,'RegisteredOrganization',$Org,REG_SZ)
      If @ERROR Exit @ERROR EndIf
    EndIf
  Else
    $Owner = ReadValue($Key,'RegisteredOwner')
    $Org = ReadValue($Key,'RegisteredOrganization')
    $ChangeOwner = $Owner,$Org
  EndIf
EndFunction
 

 158245ChangeVLKey5931apronkChangeVLKey() - Change the Volume License Key 
on a Machine1147100044Code:


;Function 	ChangeVLKey() - Change the Volume License Key on a Machine
;
;Author   	Arend Pronk (arendpronk@chello.nl)
;
;Contributors 	Shawn Tassee and NTDOC, they've both contributed to the endproduct
;   		of this Function. Thanks guys :)
;
;Thanks	 	Benny69 for testing this function on a NON-VLK machine.
;
;Syntax		ChangeVLKey($VOL_PROD_KEY)
;
;Version  	1.1
;
;Date  		09-03-2006
;
;Changed  	Due to analytical reviews this function has been optimised
;
;Parameters 	$VOL_PROD_KEY should be in the forms of "ABCDEFGHIJKLMNOPQRSTUVWX"
;    		no hyphens in the string.
;
;Remarks  	Windows XP,2003 and up, OS version HAS to be a VLK Version (Volume License Key)
;
;Returns  	0 for success and @error for failure
; 
;Dependencies 	None
;
;KiXtart Ver.	4.51
; 
;Example(s)	$x = ChangeVLKey("123AB123AB123AB123AB")
;

Function ChangeVLKey($VOL_PROD_KEY)
  Dim $obj, $objects, $x
  ;Key is without hyphens (ABCDEFGHIJKLMNOPQRSTUVWXY) 
  $objects = GetObject("winmgmts:{impersonationLevel=impersonate}").InstancesOf("win32_WindowsProductActivation")
  If @Error <> 0
    Exit @Error
  EndIf
  For Each $obj in $objects
    $x = $obj.SetProductKey($VOL_PROD_KEY)
    $ChangeVLKey = @error
  Next
  Exit @error
EndFunction

83196CharCount1633Will SCharCount() - Returns the number of times a 
character appears in a string0

code:

 
;Function CharCount()
;
;Author - William R. Schwab
;
;Version - 1.0
;
;Action - Returns the number of times a character appears in a string
;
;Syntax - CharCount ("string", "character")
;
;Parameters
;             string - this is the string you want to find how many of a certain character is in it.
;             character - this is the character you want to search the string for
;
;
;Returns
;             Returns the number of times the character appears in the string.
;
;Dependencies
;             None
;
;Example(s)
;             $x=CharCount("This is a test", "t")
;                          This would return a value of 3
;             $y=CHR(9)+"W"+CHR(9)+"L"+CHR(9)+"Pct"+CHR(9)+"GB"
;             $yCharCount($y, CHR(9))
;                          This would return a value of 4
;
;
;Source

FUNCTION CharCount ($ExpStr1, $ExpChr1)
;Counts number of times a character appears in a text string
;
;
;Declares local variable $nc, locstring, $findchar
dim $nc, $strlencnt, $locstring, $findchar

;Assigns value passed to function to a local variable $locstring
$locstring=$ExpStr1

;Assigns value passed to function to a local variable $findchar
$findchar=$ExpChr1

;Assigns counters to zero
$strlencnt=1
$nc=0

;While the variable $strlencnt is less then or equal to the length of the string $locstring do the following
WHILE $strlencnt <= LEN($locstring)

IF SUBSTR($locstring, $strlencnt, 1) = $findchar

	$nc=$nc+1
ENDIF

$strlencnt=$strlencnt+1
LOOP

;Returns the number of times 
$CharCount=$nc

;End of function
ENDFUNCTION
 

143722CharCount119LonkeroCharCount() - Returns the number of times a 
character appears in a string1121615515Code:


/*
Function	CharCount()
Author		Lonkero
Version		1.0
Action		Returns the number of times a character appears in a string
Syntax		CharCount ("string", "character")
Parameters
		string - this is the string you want to find how many of a certain character is in it.
		character - this is the character you want to search the string for
  
Returns		Returns the number of times the character appears in the string.
Dependencies	None
Remarks		When saw the charcount() UDF already in UDF lib, I HAD to make it different :)
Examples
		; This would return a value of 3
		$x=CharCount("This is a test", "t")

		; This would return a value of 4
		$y=CHR(9)+"W"+CHR(9)+"L"+CHR(9)+"Pct"+CHR(9)+"GB"
		CharCount($y, CHR(9))
##############################################################################################
*/
Function CharCount($Str, $Chr)
 $CharCount=ubound(split($Str,$Chr))
EndFunction

83473CheckAccess953Chris S.CheckAccess() - Use WMI to Check User's Registry 
Access Permissions0

code:

;
;Function	CheckAccess()
;
;Author		Christopher Shilt (christopher.shilt@relizon.com)
;
;Version	1.0
;
;Version History
;		9/5/2002 Version 1.0
;
;Action 	Uses the WMI StdRegProv to query the user's rights to various
;		permissions in the registry.
;
;Syntax		CheckAccess(optional "Key", "Path", optional "Permission Flags", optional "Computer")
;
;Parameters 
; 		KEY		: OPTIONAL. Use standard registry key names. Default: 
;					    HKEY_LOCAL_MACHINE
;
;		PATH		: REQUIRED. Path to registry key to query.
;
;		PERMISSIONS	: OPTIONAL. Permission flags to test for. See remarks for options.
;					    Default: "QS"
;
;		COMPUTER	: OPTIONAL. Specifies the computer name to query against.
;					    options. Default: local PC
;
;Remarks
;		Q = KEY_QUERY_VALUE
;		S = KEY_SET_VALUE
;		C = KEY_CREATE_SUB_KEY
;		E = KEY_ENUMERATE_SUB_KEYS
;		N = KEY_NOTIFY
;		L = KEY_CREATE_LINK
;		D = DELETE
;		R = READ_CONTROL
;		W = WRITE_DAC
;		O = WRITE_OWNER
;
;Returns	0 indicates that the user has all permissions specified.
; 
;Dependencies	KiX 4.02 (or higher)
;		WMI Enabled PC
; 
;Example:
;		If CheckAccess(,"System\CurrentControlSet\Services\LanmanServer\Parameters") = 0
;			"User has Query and Set Value permissions." ?
;		Else
;			"User cannot write to this key." ?
;		Endif
;
;Source

Function CheckAccess(Optional $Key, $Path, Optional $Access, Optional $strComputer)
	Dim $Perms
	Select
	Case $Key = "HKEY_CLASSES_ROOT"   $Key = &80000000
	Case $Key = "HKEY_CURRENT_USER"   $Key = &80000001
	Case $Key = "HKEY_LOCAL_MACHINE"  $Key = &80000002
	Case $Key = "HKEY_USERS"	  $Key = &80000003
	Case $Key = "HKEY_CURRENT_CONFIG" $Key = &80000005
	Case $Key = "HKEY_DYN_DATA"	  $Key = &80000006
	Case 1				  $Key = &80000002
	EndSelect
	If instr($Access, "Q") $Perms = $Perms + &1	Endif
	If instr($Access, "S") $Perms = $Perms + &2	Endif
	If instr($Access, "C") $Perms = $Perms + &4	Endif
	If instr($Access, "E") $Perms = $Perms + &8	Endif
	If instr($Access, "N") $Perms = $Perms + &10	Endif
	If instr($Access, "L") $Perms = $Perms + &20	Endif
	If instr($Access, "D") $Perms = $Perms + &10000	Endif
	If instr($Access, "R") $Perms = $Perms + &20000	Endif
	If instr($Access, "W") $Perms = $Perms + &40000	Endif
	If instr($Access, "O") $Perms = $Perms + &80000	Endif
	If $strComputer = "" $strComputer = "."	Endif
	$objRegistry = GetObject("winmgmts:{impersonationLevel=impersonate}!\\" + $strComputer + "\root\default:StdRegProv")
	If @ERROR $CheckAccess = 1 $Perms = "" Exit(1) Endif
	$CheckAccess = $objRegistry.CheckAccess($Key, $Path, $Perms)
	$objRegistry = "" Exit(0)
EndFunction

82693CheckDatabase17SealeopardCheckDatabase() - check and update the 
computer .INI database for a specific value0

code:

;FUNCTION      CheckDatabase
;
;ACTION        check and update the computer .INI database for a specific value
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.3
;
;KIXTART       4.12+
;
;SYNTAX        CHECKDATABASE(FILE, SECTION, KEY, VALUE ,NEW, [NOWARN])
;
;PARAMETERS    FILE
;              Filename of computer database
;
;              SECTION
;              Required string containing the section within the database
;
;              KEY
;              Required string containing the keyname within the section
;
;              VALUE
;              Required string containing the key value
;
;              WARN
;              Optional flag denoting whether to send a warning message or not
;
;RETURNS       0 if successful, otherwise error code
;
;REMARKS       Requires the global variable $ALERTSERVER (name of the alert server)
;
;DEPENDENCIES  none
;
;EXAMPLE       $rc=checkdatabase('computers.ini','COMP1','Operating System','Windows 98 SE',1)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000111
;
function checkdatabase($file, $section, $key, $value, optional $warn)
  Dim $rc

  $value=trim($value)
  $warn=val($warn)

  $rc=trim(readprofilestring($file,$section,$key))
  if $rc<>$value
    ; value has changed
    if $rc=''
      $rc='[empty]'
    endif
    if $warn and $ALERTSERVER
      $rc=sendmessage($ALERTSERVER, 'Key "'+$key+'" in section ['+$section+'] has changed from '+$rc+' to '+$value)
    endif
    ; write updated value into database
    $rc=writeprofilestring($file,$section,$key,$value)
  endif

  $checkdatabase=@ERROR
  exit @ERROR
endfunction



[ 21. April 2003, 01:07: Message edited by: sealeopard ]82853CheckLinks17SealeopardCheckLinks() 
- Checks and updates shortcuts to server applications0

code:

;FUNCTION      CheckLinks
;
;ACTION        Checks and updates shortcuts to server applications
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2
;
;KIXTART       4.12+
;
;SYNTAX        CHECKLINKS($COMMONPROGRAMS,$LINKDIRECTORY)
;
;PARAMETERS    $COMMONPROGRAMS
;              required string containing the location of the common programs folder
;
;              $LINKDIRECTORY
;              required string containing the location of the links
;
;RETURNS       0 if successful, otherwise error code
;
;REMARKS       This is kind-of a folder synchronization routine but with the difference that all files in $LINKDIRECTORY
;              are copied into $COMMONPROGRAMS and all files in $COMMONPROGRAMS that are not in $LINKDIRECTORY are deleted
;              $LINKDIRECTORY consists of folders with the servernames and the folders contain the links (*.LNK,*.PIF)
;
;DEPENDENCIES  DISPLAYTEXT()    @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000036
;              FULLFILE()       @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000028
;              DIRLIST()        @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000090
;              ISINARRAY()      @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000098
;
;EXAMPLE       $retcode = checklinks('c:\windows\start menu\programs','\\SERVER\links')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000143
;
function checklinks($commonprogramsfolder, $linksdirectory)
  Dim $retcode, $localshortcutdir, $oldlinks, $appservers, $shortcutdir, $entry
  Dim $linkssource, $shortcut, $shortcutlist, $extensions[1], $fileext
  Dim $sourceshortcut, $destinationshortcut, $comparison

  $extensions[0]='lnk'
  $extensions[1]='pif'

  $localshortcutdir=fullfile($commonprogramsfolder,'Applications')
  if not exist($localshortcutdir)
    $retcode=displaytext('Creating directory for shortcuts',1)
    md $localshortcutdir
  endif
  for each $fileext in $extensions
    $oldlinks=fullfile($localshortcutdir,'*.'+$fileext)
    if exist($oldlinks)
      $retcode=displaytext('Deleting obsolete shortcuts',1)
      del $oldlinks
    endif
  next

  $appservers=dirlist(fullfile($linksdirectory,'*.*'))
  for each $entry in $appservers
    if $entry<>''
      $sourcelinks=fullfile($linksdirectory,$entry)
      if (getfileattr($sourcelinks) & 16)
        $entry=ucase($entry)
        $retcode=displaytext('Checking links to application server '+$entry)

        $shortcutdir=fullfile($localshortcutdir,$entry)
        if not exist($shortcutdir)
          $retcode=displaytext('Creating shortcut directory '+$shortcutdir,1)
          md $shortcutdir
        endif

        for each $fileext in $extensions
          ; shortcuts on maintenance server
          $shortcutlist=dirlist(fullfile($sourcelinks,'*.'+$fileext))
          for each $shortcut in $shortcutlist
            if $shortcut<>''
              $sourceshortcut=fullfile($sourcelinks,$shortcut)
              $destinationshortcut=fullfile($shortcutdir,$shortcut)
              $comparison=comparefiletimes($sourceshortcut,$destinationshortcut)
              select
              case $comparison=-3 or $comparison=-1 or $comparison=1
                $retcode=displaytext('Adding shortcut for '+left($shortcut,instrrev($shortcut,'.')-1))
                copy $sourceshortcut $destinationshortcut
              case $comparison=-2
                $retcode=displaytext('Deleting obsolete shortcut for '+left($shortcut,instrrev($shortcut,'.')-1))
                del $destinationshortcut
              case $comparison=0
                $retcode=displaytext('Shortcut for '+left($shortcut,instrrev($shortcut,'.')-1)+' does not require updating',1)
              endselect
            endif
          next
          ; shortcuts on local client
          $shortcutlist=dirlist(fullfile($shortcutdir,'*.'+$fileext))
          for each $shortcut in $shortcutlist
            if $shortcut<>''
              $sourceshortcut=fullfile($sourcelinks,$shortcut)
              $destinationshortcut=fullfile($shortcutdir,$shortcut)
              $comparison=comparefiletimes($sourceshortcut,$destinationshortcut)
              if $comparison=-2
                $retcode=displaytext('Deleting obsolete shortcut for '+left($shortcut,instrrev($shortcut,'.')-1))
                del $destinationshortcut
              endif
            endif
          next
        next
      endif
    endif
  next
endfunction



[ 20. April 2003, 23:54: Message edited by: sealeopard ]82912CheckNAVExpiration17SealeopardCheckNAVExpiration() 
- Checks expiration date of Norton Antivirus 2001 Liveupdate0

code:


;FUNCTION      CheckNAVExpiration
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Checks the expiration date of the Norton Antivirus 2001 Liveupdate Subscription
;
;SYNTAX        CheckNAVExpiration()
;
;PARAMETERS    none
;
;RETURNS       0 if subscription is current, otherwise 1
;
;REMARKS       none
;
;DEPENDENCIES  FULLFILE()    @ http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000028 
;              DATEMATH()    @ http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000102 
;              SERIALDATE()  @ http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000089 
;              ERR()         @ http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000107 
;              DISPLAYTEXT() @ http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000036 
;
;EXAMPLE       $retcode=CHECKNAVEXPIRATION()
;
;KIXTART BBS   http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000159 
;
function checknavexpiration
  Dim $retcode, $regsubkey, $regentry, $navfolder, $subscription, $subscriptiondate, $subscriptionlength
  Dim $textstring, $searchstring, $subscriptionexpire, $dayswarning, $warningstring
  
  $retcode=displaytext('Checking expiration date for LiveUpdate Subscription')
  
  $checknavexpiration=0
  $dayswarning=0
  $searchstring='Subscriptions.61D460E0-07C0-11d3-A985-00A0244D507A.SUBSCRIPTION_LENGTH'
  $warningstring='Subscriptions.61D460E0-07C0-11d3-A985-00A0244D507A.WARNING_LENGTH'
  $subscriptionlength=0
  $regsubkey=$HKLM+'\SOFTWARE\Symantec\InstalledApps\'
  $regentry='NAV'
  if keyexist($regsubkey)
    $navfolder=readvalue($regsubkey,$regentry)
    $subscription=fullfile($navfolder,'navsess.txt')
    if exist($subscription)
      $subscriptiondate=getfiletime($subscription)
      $subscriptiondate=left($subscriptiondate,instr($subscriptiondate,' '))
      if open(1,$subscription,2)=0
        while @ERROR=0 and $subscriptionlength=0
          $textstring=readline(1)
          if instr($textstring,$searchstring)
            $subscriptionlength=val(right($textstring,len($textstring)-len($searchstring)-1))
          endif
        loop
        close(1)
        
        if open(1,$subscription,2)=0
          while @ERROR=0 and $dayswarning=0
            $textstring=readline(1)
            if instr($textstring,$warningstring)
              $dayswarning=val(right($textstring,len($textstring)-len($warningstring)-1))
            endif
          loop
          $retcode=close(1)
        else
          $retcode=err('Error opening file '+$subscription)
        endif
        
        if $dayswarning=0
          $retcode=err('Unable to acquire Liveupdate Expiration Warning lead time on '+@WKSTA)
          $dayswarning=30
        endif
        if $subscriptionlength=0
          $retcode=err('Unable to acquire Liveupdate Subscription length on '+@WKSTA)
        else
          $retcode=displaytext('Timestamp on '+$subscription+' = '+$subscriptiondate)
          $retcode=displaytext('Length of LiveUpdate subscription = '+$subscriptionlength)
          $retcode=displaytext('Liveupdate Expiration Warning lead time = '+$dayswarning)

          $subscriptionexpire=datemath($subscriptiondate,$subscriptionlength)
          $retcode=displaytext('Liveupdate Subscription expires on '+$subscriptionexpire)

          $subscriptionexpire=1+(serialdate($subscriptionexpire)-serialdate(@DATE))
          select
          case $subscriptionexpire<0
            $checknavexpiration=1
            $retcode=displaytext('LiveUpdate subscripting has expired')
          case $subscriptionexpire<$dayswarning
            $checknavexpiration=1
            $retcode=displaytext('LiveUpdate subscripting expires in '+$subscriptionexpire+' days')
          case 1
            $checknavexpiration=0
            $retcode=displaytext('LiveUpdate subscription is current and will expire in '+$subscriptionexpire+' days')
          endselect
        endif
      else
        $retcode=err('Error opening file '+$subscription)
      endif
    else
      $retcode=err('Cannot find file '+$subscription)
    endif    
  else
    $retcode=err('Cannot find registry key '+$regsubkey)
  endif
endfunction

[ 29 January 2002: Message edited by: sealeopard ]82868CheckNICs17SealeopardCheckNICs() 
- Checks/Updates a NICs TCP/IP settings0

code:

;FUNCTION      CheckNICs()
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Checks a NIC for correct TCP/IP settings
;
;VERSION       1.11 (changed DisplayText parameter order)
;              1.1
;
;DATE CREATED  2002/01/18
;
;DATE MODIFIED 2003/05/31
;
;KIXTART       4.12+
;
;SYNTAX        CHECKNICS(DNS,WINS,DEFAULTGATEWAY,SUBNETMASK,IPMASK,NTDOMAIN,DOMAIN)
;
;PARAMETERS    DNS
;              Required array containing the DNS server addresses
;
;              WINS
;              Required array containing the WINS server addresses
;
;              DEFAULTGATEWAY
;              Required string containing the default gateway IP address
;
;              SUBNETMASK
;              Required string containing the subnetmask
;
;              IPMASK
;              Required string containing the network ID
;
;              NTDOMAIN
;              Required string containing the Windows domain name the computer is part of
;
;              DOMAIN
;              Required string containing the domain name
;
;REMARKS       Requires the global variable $OS_SHORT (Win9x, WinNT, Win2K, WinXP)
;              This UDF has not been tested with NICs using DHCP
;
;DEPENDENCIES  UPDATEREGISTRY() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000110
;              ARRAYENUMKEY()   @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000064
;              DISPLAYTEXT()    @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000036
;              ISINSUBNET()     @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000053
;
;RETURNS       0 if successful, otherwise error code
;
;EXAMPLE       $retcode=checknics('10.10.0.2','10.10.0.3','10.10.0.1','255.255.255.0','10.10.0.0','NT-DOMAIN','COMPANY.COM')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000148
;
function checknics($dns,$wins,$defaultgateway,$subnetmask,$ipmask,$ntdomain,$domain)
  Dim $retcode, $networkadapters, $netcardnumber, $index, $ipaddress, $tcpipsettings
  Dim $ipaddressnumber, $multi_ipaddress, $multi_subnetmask, $hklm, $ntdomainsubkey, $ntdomainvalue

  $hklm='HKEY_LOCAL_MACHINE'

  select
  case $OS_SHORT='Win9x'

    ; check the Windows NT domain setting
    if $ntdomain<>''
      $retcode=updateregistry($hklm+'\System\CurrentControlSet\Services\VxD\VNETSUP','Workgroup',$ntdomain,'REG_SZ')
      if $retcode
        $REBOOTREQUIRED=1
      endif
    endif

    ; check DNS and domain settings
    $tcpipsettings=$hklm+'\System\CurrentControlSet\Services\VxD\MSTCP'
    $dnsstring=join($dns,',')
    $retcode=updateregistry($tcpipsettings,'NameServer',$dnsstring,'REG_SZ')
    if $retcode
      $REBOOTREQUIRED=1
    endif

    $retcode=updateregistry($tcpipsettings,'Domain',$domain,'REG_SZ')
    if $retcode
      $REBOOTREQUIRED=1
    endif

    ; enumerate all network cards
    $networkadapters=arrayenumkey($hklm+'\Enum\Network\MSTCP')
    for $index=0 to ubound($networkadapters)
      $networkadapters[$index]=readvalue($hklm+'\Enum\Network\MSTCP\'+$networkadapters[$index],'Driver')
    next

    ; check each network card if it makes connections to the local network
    for each $netcardnumber in $networkadapters
      if $netcardnumber<>''
        $netcardnumber=$hklm+'\System\CurrentControlSet\Services\Class\'+$netcardnumber
        $ipaddress=readvalue($netcardnumber,'IPAddress')
        if $ipaddress<>'' and $ipaddress<>'0.0.0.0'
          $retcode=displaytext('Checking NIC with IP address '+$ipaddress,1)
          if isinsubnet($ipaddress,$ipmask,$subnetmask)
            ; process only network card connected to the correct network
            $retcode=displaytext('NIC '+$ipaddress+' is part of the subnet '+$ipmask+' for subnetmask '+$subnetmask,1)
            ; check subnetmask
            $retcode=updateregistry($netcardnumber,'IPMask',$subnetmask,'REG_SZ')
            if $retcode
              $REBOOTREQUIRED=1
            endif

            ; check defaultgateway
            $retcode=updateregistry($netcardnumber,'DefaultGateway',$defaultgateway,'REG_SZ')
            if $retcode
              $REBOOTREQUIRED=1
            endif

            ; check WINS
            $retcode=updateregistry($netcardnumber,'Nameserver1',$wins[0],'REG_SZ')
            if $retcode
              $REBOOTREQUIRED=1
            endif
            if ubound($wins)>0
              $retcode=updateregistry($netcardnumber,'Nameserver2',$wins[1],'REG_SZ')
              if $retcode
                $REBOOTREQUIRED=1
              endif
            endif
            if ubound($wins)>1
              $retcode=displaytext('Only two WINS servers are needed!')
            endif
          else
            $retcode=displaytext('NIC '+$netcardnumber+' ('+$ipaddress+') is not part of the subnet '+$subnetmask,1)
          endif
        endif
      endif
    next

  case $OS_SHORT='WinNT'

    ; check DNS and domain name
    $tcpipsettings=$hklm+'\System\CurrentControlSet\Services\TcpIP\Parameters'
    $retcode=updateregistry($tcpipsettings,'Domain',$domain,'REG_SZ')
    if $retcode
      $REBOOTREQUIRED=1
    endif
    $dnsstring=join($dns,' ')

    $retcode=updateregistry($tcpipsettings,'NameServer',$dnsstring,'REG_SZ')
    if $retcode
      $REBOOTREQUIRED=1
    endif

    ; enumerate all network cards
    $networkadapters=arrayenumkey($hklm+'\System\CurrentControlSet\Services\NetBT\Adapters')

    ; check each network card if it makes connections to the local network
    for each $netcardnumber in $networkadapters
      $updateipregistries=0
      $tcpipsettings=$hklm+'\System\CurrentControlSet\Services\'+$netcardnumber+'\Parameters\TCPIP'
      $multi_ipaddress=readvalue($tcpipsettings,'IPAddress')
      $multi_ipaddress=split($multi_ipaddress,'|')
      $multi_subnetmask=readvalue($tcpipsettings,'SubnetMask')
      $multi_subnetmask=split($multi_subnetmask,'|')
      for $ipaddressnumber=0 to ubound($multi_ipaddress)
        $ipaddress=$multi_ipaddress[$ipaddressnumber]
        if $ipaddress<>'' and $ipaddress<>'0.0.0.0'
            $retcode=displaytext('Checking NIC with IP address '+$ipaddress,1)
          if isinsubnet($ipaddress,$ipmask,$subnetmask)
            $updateipregistries=1
            $retcode=displaytext('NIC '+$ipaddress+' is part of the subnet '+$ipmask+' for subnetmask '+$subnetmask,1)
            ; check subnetmask
            if $multi_subnetmask[$ipaddressnumber]<>$subnetmask
              $retcode=displaytext('Subnetmask for IP address '+$ipaddress+' has changed from '+$multi_subnetmask[$ipaddressnumber]+' to '+$subnetmask,1)
              $multi_subnetmask[$ipaddressnumber]=$subnetmask
            endif
          endif
        endif
      next
      if $updateipregistries=1
        ; check subnetmask
        $multi_subnetmask=join($multi_subnetmask,'|')
        $retcode=updateregistry($tcpipsettings,'SubnetMask',$multi_subnetmask,'REG_MULTI_SZ')
        if $retcode
          $REBOOTREQUIRED=1
        endif

        ; check defaultgateway
        $retcode=updateregistry($tcpipsettings,'DefaultGateway',$defaultgateway+'|','REG_MULTI_SZ')
        if $retcode
          $REBOOTREQUIRED=1
        endif

        $tcpipsettings=$hklm+'\System\CurrentControlSet\Services\NetBT\Adapters\'+$netcardnumber
        ; check WINS
        $retcode=updateregistry($tcpipsettings,'Nameserver',$wins[0],'REG_SZ')
        if $retcode
          $REBOOTREQUIRED=1
        endif
        if ubound($wins)>0
          $retcode=updateregistry($tcpipsettings,'NameserverBackup',$wins[1],'REG_SZ')
          if $retcode
            $REBOOTREQUIRED=1
          endif
        endif
        if ubound($wins)>1
          $retcode=displaytext('Only two WINS servers are needed!')
        endif

        $updateipregistries=0
      endif
    next

  case $OS_SHORT='Win2K'
    ; enumerate all network cards
    $networkadapters=arrayenumkey($hklm+'\System\CurrentControlSet\Services\TcpIP\Parameters\Interfaces')

    ; check each network card if it makes connections to the local network
    for each $netcardnumber in $networkadapters
      $tcpipsettings=$hklm+'\System\CurrentControlSet\Services\'+$netcardnumber+'\Parameters\TCPIP'
      $ipaddress=readvalue($tcpipsettings,'IPAddress')
      $ipaddress=split($ipaddress,'|')
      $ipaddress=$ipaddress[0]
      if $ipaddress<>'' and $ipaddress<>'0.0.0.0'
        $retcode=displaytext('Checking NIC with IP address '+$ipaddress,1)
        if isinsubnet($ipaddress,$ipmask,$subnetmask)
          ; process only network card connected to the correct network
          $retcode=displaytext('NIC '+$ipaddress+' is part of the subnet '+$ipmask+' for subnetmask '+$subnetmask,1)
          ; check subnetmask (commented out because of problems with multi-IP NICs)
          ;$retcode=updateregistry($tcpipsettings,'SubnetMask',$subnetmask+'|','REG_MULTI_SZ',1)
          ; check defaultgateway
          $retcode=updateregistry($tcpipsettings,'DefaultGateway',$defaultgateway+'|','REG_MULTI_SZ')
          if $retcode
            $REBOOTREQUIRED=1
          endif

          $tcpipsettings=$hklm+'\System\CurrentControlSet\Services\Tcpip\Parameters\Interfaces\'+$netcardnumber
          ; check subnetmask (commented out because of problems with multi-IP NICs)
          ;$retcode=updateregistry($tcpipsettings,'SubnetMask',$subnetmask+'|','REG_MULTI_SZ',1)
          ; check defaultgateway
          $retcode=updateregistry($tcpipsettings,'DefaultGateway',$defaultgateway+'|','REG_MULTI_SZ')
          if $retcode
            $REBOOTREQUIRED=1
          endif

          $tcpipsettings=$hklm+'\System\CurrentControlSet\Services\NetBT\Parameters\Interfaces\TcpiP_'+$netcardnumber
          ; check WINS
          $wins=join($wins,'|')
          $retcode=updateregistry($tcpipsettings,'NameserverList',$wins,'REG_MULTI_SZ')
          if $retcode
            $REBOOTREQUIRED=1
          endif

          $tcpipsettings=$HKLM+'\System\CurrentControlSet\Services\Tcpip\Parameters\Interfaces\'+$netcardnumber
          ;check domain
          $retcode=updateregistry($tcpipsettings,'Domain',$domain,'REG_SZ')
          if $retcode
            $REBOOTREQUIRED=1
          endif

          ; check DNS
          $dnsstring=join($dns,',')
          $retcode=updateregistry($tcpipsettings,'NameServer',$dnsstring,'REG_SZ')
          if $retcode
            $REBOOTREQUIRED=1
          endif
        else
          $retcode=displaytext('NIC '+$netcardnumber+' ('+$ipaddress+') is not part of the subnet '+$subnetmask,1)
        endif
      endif
    next

  case $OS_SHORT='WinXP'
    ; not implemented due to a lack of access to a Windows XP computer
  endselect

  $checknics=@ERROR

endfunction



[ 30. July 2003, 21:46: Message edited by: sealeopard ]82867CheckUpdateOnReboot17SealeopardCheckUpdateOnReboot() 
- Checks the PendingFileRenameOperations registry value0

code:

;FUNCTION      CheckUpdateOnReboot
;
;ACTION        Checks whether the PendingFileRenameOperations registry value contains a value
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2
;
;KIXTART       4.12+
;
;SYNTAX        CHECKUPDATEONREBOOT()
;
;PARAMETERS    none
;
;REMARKS       Registry controls file replacements on reboot for files that are otherwise locked
;
;RETURNS       Returns 1 if PendingFileRenameOperations contains a value, otherwise 0
;
;DEPENDENCIES  none
;
;EXAMPLE       $Retcode=CheckUpdateOnReboot()
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000147
;
function checkupdateonreboot()
  Dim $iRC

  $checkupdateonreboot=0

  if @INWIN=1
    $iRC=readvalue('HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager','PendingFileRenameOperations')
  else
    $iRC=readprofilestring('%WINDIR%\wininit.ini','rename','')
  endif
  if $iRC<>'' and @ERROR=0
    $checkupdateonreboot=1
  endif
endfunction



[ 20. April 2003, 23:59: Message edited by: sealeopard ]82283Choice11ShawnChoice() 
- Prompts the user for a choice0I imagine not all folks have the reskit or 
want to run/install choice.exe from their netlogon shares ... this might be a 
handy alternative. Plus it simplifies the coding of screen menus by moving the 
logic outside of the main loop ...

Choice()

Action:

Prompts the user for a choice

Syntax:

Choice("prompt"[,"choices"])

Parameters:

Prompt (Required): Prompt string to display

Choices (Optional): Specifies allowable keys. Default is YN

Returns:

Function returns the key user presses in choices (converted to uppercase)
otherwise a null string "" if canceled by user

@ERROR is set to 0 (zero) if choice canceled otherwise set to offset of key 
user presses in choices

Remarks:

Ideas for extra features include:

1) Supply a default value (maybe hilite default in bold)
2) Color options
3) Allow optional XY coords for screen menu usage

Dependencies:

KiXtart 4.0 (Final)

Example(s):

$Number = Choice("Pick a number","12345")
?"You selected $Number"

If Choice("Continue") = "n"
?"Stop..."
endif


Source:

code:


Function Choice($prompt,optional $choices)
 dim $i,$c,$opts,$key
 if not $choices
  $choices = "YN"
 endif
 for $i = 1 to len($choices)
  $opts = $opts + substr($choices,$i,1) + ","
 next
 $prompt = $prompt+" ["+substr($opts,1,len($opts)-1) + "] ? "
 ? $prompt
 while 1
  get $c
  if asc($c) = 3 ; ^c
   $choice = ""
   exit 0
  endif
  $key = instr($choices,$c)
  if $key
   $c = ucase($c)
   $c ; echo
   $choice = $c
   exit $key
  else
   beep
  endif
 loop
EndFunction

Author:

Shawn Tassie (shawn.tassie@cgi.ca)

[ 29 November 2001: Message edited by: Shawn ]119515CitrixConnect79KdyerCitrixConnect() 
- Check clients for published App0Code:


 ; FUNCTION   CitrixConnect()
 ; ACTION   Check for and if needed connect to a Citrix Published app
 ; AUTHOR   Kent Dyer (leptonator@hotmail.com)
 ; CONTRIBUTORS
 ; VERSION   1.3
 ; DATE CREATED   13-May-2004
 ; DATE MODIFIED  20-May-2005
 ; Release Notes: Added Options for Default Farm, Secondary and Tertiary IPs
 ;         Version 1.2 adds the ability to create PASS-THROUGH connections
 ;         Version 1.3 Corrects variables, Fix DIM Statement, add examples
 ; KIXTART  4.02
 ; SYNTAX  CitrixConnect($farm,$ip,$code)
 ; PARAMETERS
 ;   farm
 ;   Farm with the Published App
 ;   ip
 ;   IP Address for the Farm
 ;   code
 ;   Code used for application set
 ;   passthrough
 ;   Optional - Setup Clients to use passThrough
 ;   default
 ;   Optional - Setup this newly created connection for being the default
 ;   ip1
 ;   Optional - Add a Secondary IP for the connection
 ;   ip2
 ;   Optional - Add a Tertiary IP for the connection
 ; RETURNS  Icon(s) for clients to use for Citrix
 ; REMARKS  This was driven by the need to get people up an rolling on a published app quickly
 ; DEPENDENCIES Citrix Program Neighborhood
 ; EXAMPLE(s)
 ; $desktop=READVALUE('HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders','Desktop')
 ; IF 0=EXIST($desktop+'\Your Published App.lnk')
 ;    CITRIXCONNECT('Your Farm','1.2.3.4','72j3cmxa',1,1,'5.6.7.8') ;Default Pass-Through, with second IP
 ; ENDIF

 ;      CITRIXCONNECT('Your Farm','1.2.3.4','72j3cmxa',,1,'5.6.7.8') ;Default Local Login, with second IP

 ;      CITRIXCONNECT('Your Farm','1.2.3.4','72j3cmxa',,,'5.6.7.8') ;Local Login, with second IP

 ;      CITRIXCONNECT('Your Farm','1.2.3.4','72j3cmxa',1,,'5.6.7.8') ;PassThrough, with second IP

 ;      CITRIXCONNECT('Your Farm','1.2.3.4','72j3cmxa',1) ;PassThrough

 ; KIXTART BBS  http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=118343
 FUNCTION CITRIXCONNECT($farm,$ip,$code,OPTIONAL $passthrough,OPTIONAL $default,OPTIONAL $ip1,OPTIONAL $ip2)
    DIM $appdt,$citrfl,$pn,$prf,$appsrv,$rc,$section
    $appdt=ReadValue('HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders','AppData')
    $citrfl=$appdt+'\ICAClient'
    $prf=SubStr($appdt,1,Len($appdt)-17)
    $pn=$citrfl+'\PN.INI'
    $appsrv=$citrfl+'\APPSRV.INI'
    IF NOT Exist($citrfl)
       MD $citrfl
    ENDIF
    $rc=WriteProfileString($pn,'Program Neighborhood',$farm,$code)
    IF $ip<>ReadProfileString($pn,$farm,'TcpBrowserAddress')
       $rc=WriteProfileString($pn,$farm,'TcpBrowserAddress',$ip)
    ENDIF
    IF $ip1
       IF READPROFILESTRING($pn,$farm,'TcpBrowserAddress2')<>$ip1
          $rc=WRITEPROFILESTRING($pn,$farm,'TcpBrowserAddress2',$ip1)
       ENDIF
    ENDIF
    IF $ip2
       IF READPROFILESTRING($pn,$farm,'TcpBrowserAddress3')<>$ip2
          $rc=WRITEPROFILESTRING($pn,$farm,'TcpBrowserAddress3',$ip2)
       ENDIF
    ENDIF
    IF 'TCP/IP'<>ReadProfileString($pn,$farm,'TransportDriver')
       $rc=WriteProfileString($pn,$farm,'TransportDriver','TCP/IP')
    ENDIF
    IF $farm<>ReadProfileString($pn,$farm,'PNName')
       $rc=WriteProfileString($pn,$farm,'PNName',$farm)
    ENDIF
    IF @userid<>ReadProfileString($pn,$farm,'Username')
       $rc=WriteProfileString($pn,$farm,'Username',@userid)
    ENDIF
    IF @ldomain<>ReadProfileString($pn,$farm,'Domain')
       $rc=WriteProfileString($pn,$farm,'Domain',@ldomain)
    ENDIF
    IF 1<>ReadProfileString($pn,$farm,'DPAPIPassword')
       $rc=WriteProfileString($pn,$farm,'DPAPIPassword',1)
    ENDIF
    IF 'Off'<>ReadProfileString($pn,$farm,'SSLEnable')
       $rc=WriteProfileString($pn,$farm,'SSLEnable','Off')
    ENDIF
    IF '*:443'<>ReadProfileString($pn,$farm,'SSLProxyHost')
       $rc=WriteProfileString($pn,$farm,'SSLProxyHost','*:443')
    ENDIF
    IF 0<>ReadProfileString($pn,$farm,'SSLNoCACerts')
       $rc=WriteProfileString($pn,$farm,'SSLNoCACerts',0)
    ENDIF
    IF 'COM'<>ReadProfileString($pn,$farm,'SSLCiphers')
       $rc=WriteProfileString($pn,$farm,'SSLCiphers','COM')
    ENDIF
    IF 1<>ReadProfileString($pn,$farm,'PNProtocolMask')
       $rc=WriteProfileString($pn,$farm,'PNProtocolMask',1)
    ENDIF
    IF 0<>ReadProfileString($pn,$farm,'ZLMouseMode')
       $rc=WriteProfileString($pn,$farm,'ZLMouseMode',0)
    ENDIF
    IF 'Off'<>ReadProfileString($pn,$farm,'PNCacheRefresh')
       $rc=WriteProfileString($pn,$farm,'PNCacheRefresh','Off')
    ENDIF
    IF ReadProfileString($appsrv,'WFClient','SSOnUserSetting')<>'On'
       $rc=WriteProfileString($appsrv,'WFClient','SSOnUserSetting','On')
    ENDIF
    IF $passthrough
       ; -- PASSTHROUGH IS ENABLED
       IF '000100'<>ReadProfileString($pn,$farm,'UIpassword')
          $rc=WriteProfileString($pn,$farm,'UIpassword','000100')
       ENDIF
       IF ReadProfileString($pn,$section,'UIFlags')<>10
          $rc=WriteProfileString($pn,$section,'UIFlags',10)
       ENDIF
       $rc=WriteProfileString($pn,$farm,'SavePNPassword','')
       $rc=WriteProfileString($pn,$farm,'UseLocalUserAndPassword','')
    ELSE
       IF 'On'<>ReadProfileString($pn,$farm,'SavePNPassword')
          $rc=WriteProfileString($pn,$farm,'SavePNPassword','On')
       ENDIF
       IF 'On'<>ReadProfileString($pn,$farm,'UseLocalUserAndPassword')
          $rc=WriteProfileString($pn,$farm,'UseLocalUserAndPassword','On')
       ENDIF
       $rc=WriteProfileString($pn,$farm,'UIpassword','')
    ENDIF
    IF 0=InStr(ReadProfileString($appsrv,'WFClient','LogFileWin32'),@userid)
       $rc=WriteProfileString($appsrv,'WFClient','LogFileWin32',$prf+'\Application Data\ICAClient\wfcwin32.log')
    ENDIF
    IF $default
       IF $farm<>ReadProfileString($appsrv,'WFClient','PNDefault')
          $rc=WriteProfileString($appsrv,'WFClient','PNDefault',$farm)
       ENDIF
    ENDIF
    IF 0=InStr(ReadProfileString($appsrv,'WFClient','PersistentCachePath'),@userid)
       $rc=WriteProfileString($appsrv,'WFClient','PersistentCachePath',$prf+'\Application Data\ICAClient\Cache')
    ENDIF
    RUN '"C:\Program Files\Citrix\ICA Client\pn.exe" /PN "'+$farm+'"'
    $rc=SetFocus('Citrix Program Neighborhood - '+$farm)
    SLEEP 1
    $rc=SetFocus('Connecting to '+$farm)
    SLEEP 2
    $rc=SetFocus('Citrix Program Neighborhood')
    $rc=SendKeys('{ENTER}')
    SLEEP 2
    $rc=SendKeys('{F5}')
 ENDFUNCTION


151095CITRIXFARMDEL79KdyerCITRIXFARMDEL() - Delete a Farm from Citrix 
Program Neighborhood0Code:


 ;Function	CITRIXFARMDEL()
 ;
 ;Author	Kent Dyer (leptonator@hotmail.com)
 ;
 ;Action	Deletes a Farm from Citrix program Neighborhood.
 ;
 ;Syntax	CITRIXFARMDEL("A Citrix Farm")
 ;
 ;Version	1.0
 ;
 ;Date          05-November-2005
 ;
 ;Date Revised  05-November-2005
 ;
 ;Parameters 	FarmName 
 ;		Name of Citrix Farm you want to delete from Program Neighborhood
 ;
 ;Remarks	Needed to remove a Citrix Farm that is going away.
 ;
 ;Returns	Removes the specified farm from Citrix
 ; 
 ;Dependencies 	Citrix Program Neighborhood
 ;
 ;KiXtart Ver	4.02
 ; 
 ;Example(s)	CITRIXFARMDEL("Your Farm Name")
 ; 
 FUNCTION DELFARM($FARMNAME)
    DIM $PATH,$INIFL,$RC
    $PATH=READVALUE('HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders','AppData')
    $PATH=$PATH+'\ICAClient'
    $INIFL=$PATH+'\PN.INI'
    IF EXIST($INIFL) AND READPROFILESTRING($INIFL,'Program Neighborhood',$FARMNAME)<>''
       $RC=WRITEPROFILESTRING($INIFL,'Program Neighborhood',$FARMNAME,'')
       $RC=WRITEPROFILESTRING($INIFL,$FARMNAME,'','')
    ENDIF
 ENDFUNCTION

138077CITRIXPASSTHROUGH79KdyerCITRIXPASSTHROUGH() - Change Citrix Clients 
to pass through0Code:


 ; Function CITRIXPASSTHROUGH()
 ;
 ; Author  Kent Dyer (leptonator@hotmail.com)
 ;
 ; Contributors Chris Walter
 ;               http://thethin.net/archive3.cfm?id=156013
 ;               Cleaned up the code from this page
 ;
 ; Action  Change Citrix Program Neighborhood from Standard Mode to pass-through
 ;
 ; Syntax  CITRIXPASSTHROUGH()
 ;
 ; Version 1.3
 ;
 ; Date           15-April-2005
 ;
 ; Date Revised   17-June-2005
 ;
 ; Parameters  None
 ;
 ; Remarks Once the change is made, you have to logoff and back in to
 ;         "see" the change.  Instead of having your users be required to
 ;         login and update passwords every xx days, this picks up on the locally
 ;         logged in user and passes the credentials through to Citrix
 ;
 ;         Version 1.1 - Add in logic to update the Farm Registrations to use pass-through
 ;         Version 1.2 - Missed two items in the DIM Statement
 ;         Version 1.3 - Added check to insure that Citrix Program Neighborhood exists (PN.EXE)
 ;
 ; Returns Nothing
 ;
 ; Dependencies  Citrix Program Neighborhood - Rights to change Registry at HKLM
 ;
 ; KiXtart Ver 4.02
 ;
 ; Example(s) CITRIXPASSTHORUGH
 ; KIXTART BBS  http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=137223
 FUNCTION CITRIXPASSTHROUGH()
    DIM $appdt,$pnfl,$appfl,$cappfl,$regkey,$test,$x,$section,$val,$orig
    IF EXIST('C:\Program Files\Citrix\ICA Client\pn.exe')
       $appdt=ReadValue('HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders','AppData')
       $pnfl=$appdt+'\ICAClient\pn.ini'
       $appfl=$appdt+'\ICAClient\APPSRV.INI'
       $regkey='HKLM\SYSTEM\CurrentControlSet\Control\NetworkProvider\Order'
       $test=READVALUE($regkey,'ProviderOrder')
       $x=WriteProfileString($appfl,'WFClient','SSOnUserSetting','On')
       $x=WriteProfileString($appfl,'Metaframe','UseLocalUserAndPassword','On')
       FOR EACH $section IN split(ReadProfileString($pnfl,'',''),chr(10))
          IF $section<>'' AND $section<>'Program Neighborhood' AND $section<>'WFClient'
             ;?$section
             FOR EACH $val IN Split(ReadProfileString($pnfl,$section,''),Chr(10))
                ; -- Remove the local user setttings
                $x=WriteProfileString($pnfl,$section,'UseLocalUserAndPassword','')
                $x=WriteProfileString($pnfl,$section,'SavePNPassword','')
                ; -- Enable Pass-Thru
                IF ReadProfileString($pnfl,$section,'UIFlags')<>10
                   $x=WriteProfileString($pnfl,$section,'UIFlags',10)
                ENDIF
                IF ReadProfileString($pnfl,$section,'UIpassword')<>'000100'
                   $x=WriteProfileString($pnfl,$section,'UIpassword','000100')
                ENDIF
             NEXT
          ENDIF
       NEXT
       IF NOT INSTR(ReadValue($regkey,'ProviderOrder'),'PnSson')
          $orig=ReadValue($regkey,'ProviderOrder')
          $x=WriteValue($regkey,'ProviderOrder',$orig+',PnSson','REG_SZ')
          $orig=ReadValue('HKLM\SYSTEM\CurrentControlSet\Control\NetworkProvider\HWOrder','ProviderOrder')
          $x=WriteValue('HKLM\SYSTEM\CurrentControlSet\Control\NetworkProvider\HWOrder','ProviderOrder',$orig+',PnSson','REG_SZ')
          ;$x=WriteValue('HKLM\SYSTEM\CurrentControlSet\Services\PnSson','IsEnabled',1,'REG_DWORD')
          ;$x=WriteValue('HKLM\SYSTEM\CurrentControlSet\Services\PnSson','Type',4,'REG_DWORD')
          $x=WriteValue('HKLM\SYSTEM\CurrentControlSet\Services\PnSson\NetworkProvider','Class',2,'REG_DWORD')
          $x=WriteValue('HKLM\SYSTEM\CurrentControlSet\Services\PnSson\NetworkProvider','Name','Citrix Single Sign on','REG_SZ')
          $x=WriteValue('HKLM\SYSTEM\CurrentControlSet\Services\PnSson\NetworkProvider', 'ProviderPath',
          'C:\Program Files\Citrix\ICA Client\pnsson.dll','REG_SZ')
          $x=WriteValue('HKLM\SYSTEM\CurrentControlSet\Services\PnSson\Enum',0,'Root\LEGACY_PNSSON\0000','REG_SZ')
          $x=WriteValue('HKLM\SYSTEM\CurrentControlSet\Services\PnSson\Enum','Count',1,'REG_DWORD')
          $x=WriteValue('HKLM\SYSTEM\CurrentControlSet\Services\PnSson\Enum','NextInstance',1,'REG_DWORD')
          ;$x=WriteValue('HKLM\SYSTEM\CurrentControlSet\Services\PnSson\Enum','Service','PnSson','REG_SZ')
          ; -- Now, let's change Citrix Configuration to be sure that all "Farms" are re-configured for pass-through
          $x=MessageBox('We will now log you off and you need to log back on again','Process is complete')
          $x=LogOff(0)
       ENDIF
    ENDIF
 ENDFUNCTION


151096CITRIXREFRESH79KdyerCITRIXREFRESH() - Refresh a Farm in Citrix 
Program Neighborhood1131445835Code:


 ;Function	CITRIXREFRESH()
 ;
 ;Author	Kent Dyer (leptonator@hotmail.com)
 ;
 ;Action	Refreshes a Published Application set in
 ;		a Citrix program Neighborhood.
 ;
 ;Syntax	CITRIXREFRESH("A Citrix Farm")
 ;
 ;Version	1.1
 ;
 ;Date           05-November-2005
 ;
 ;Date Revised   07-November-2005
 ;
 ;Parameters 	FarmName 
 ;		Name of Citrix Farm you to refresh
 ;
 ;Remarks	Needed to Update a published application set.  While opening
 ;              another application in a published application set also refreshes
 ;              it, this does it at login to show any new icons the client needs
 ;
 ;Returns	Refreshes the specified farm in Citrix
 ; 
 ;Dependencies 	Citrix Program Neighborhood
 ;
 ;KiXtart Ver	4.02
 ; 
 ;Example(s)	CITRIXREFRESH("Your Farm Name")
 ; 
 FUNCTION CITRIXREFRESH($FARMNAME)
   DIM $rc
   RUN 'C:\Program Files\Citrix\ICA Client\pn.exe /PN '+$FARMNAME
   $rc=SETFOCUS('Citrix Program Neighborhood - '+$FARMNAME)
   SLEEP '.5'
   $RC=SendKeys('{F5}')
   $rc=''
   $rc=SETFOCUS('Citrix Program Neighborhood - '+$FARMNAME)
   $rc=''
   $RC=SendKeys('~{F4}y')
   $rc=''
 ENDFUNCTION




[edit: typos edited on Kents behalf by Jochen]82624CleanDirectory17SealeopardCleanDirectory() 
- Cleans up the temporary directories (or any arbitrary directory)1144984597Code:


;FUNCTION      CleanDirectory
;
;ACTION        Cleans up the temporary directory
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.42 (fixed a bug in the COUNTONLY counter resulting in all files being counted) 
;              1.41 (fixed bug in the OLDERAS parameter)
;              1.4  (added COUNTONLY flag)
;              1.31 (added flag to also delete hidden and system files)
;              1.3
;
;DATE CREATED  2001/12/18
;
;DATE MODIFIED 2006/04/13
;
;KIXTART       4.20+
;
;SYNTAX        CLEANDIRECTORY(DIRECTORY, FILTER [,DAYS, COUNTONLY])
;
;PARAMETERS    DIRECTORY
;              Required string/array containing the directory(s) to be cleaned
;
;              FILTER
;              Required string/array containing file filters for deletable files/folders, wildcards are supported
;
;              DAYS
;              Optional integer indicating how old a file/folder must be before it is deleted
;
;              COUNTONLY
;              Optional boolean preventing the files/folders to be deleted. UDF will only return the number of files
;              that match the age threshold.
;
;REMARKS       The function will recursively delete all matching files and empty subdirectories
;
;DEPENDENCIES  FULLFILE()    @ http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=81757
;              DATEMATH()    @ http://www.scriptlogic.com/kixtart/FunctionLibrary_ViewFunction.aspx?ID=DateMath
;
;RETURNS       Returns comma-separated number of deleted directories and files, otherwise 0
;
;EXAMPLE       $rc=cleandirectory('c:\temp','*.TMP',7)
;
;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=82117
;
function cleandirectory($directories, $filter, optional $olderas, optional $countonly)
  Dim $rc, $timediff, $filename, $filefilter, $tempdir
  Dim $filecount, $dircount

  $dircount=0
  $filecount=0

  $olderas=iif(val($olderas)>0,val($olderas),0)
  $countonly=iif(val($countonly),1,0)

  if not (vartype($directories) & 8192)
    $directories=split($directories,'')
  endif
  if not (vartype($filter) & 8192)
    $filter=iif(trim($filter),$filter,'*.*')
    $filter=split($filter,'')
  endif

  for each $tempdir in $directories
    if $tempdir<>'' and exist($tempdir)
      for each $filefilter in $filter
        if $filefilter<>''
          $filefilter=fullfile($tempdir,$filefilter)
          $filename=dir($filefilter,1)
          While $filename<>'' and @ERROR = 0
            if $filename<>'.' and $filename<>'..'
              $filename=fullfile($tempdir,$filename)
              if getfileattr($filename) & 16
                $rc=cleandirectory($filename,$filter,$olderas,$countonly)
                if instr($rc,',')
                  $rc=split($rc,',')
                  $dircount=$dircount+$rc[0]
                  $filecount=$filecount+$rc[1]
                endif
                $rc=setfileattr($filename,128)
                if not $countonly
                  rd $filename
                  if not @ERROR
                    $dircount=$dircount+1
                  endif
                endif
              else
                $timediff=datemath(@DATE,left(getfiletime($filename),10))
                if $timediff>=$olderas
                  if $countonly
                    $filecount=$filecount+1
                  else
                    $rc=setfileattr($filename,128)
                    del $filename /c /f /h
                    if not @ERROR
                      $filecount=$filecount+1
                    endif
                  endif
                endif
              endif
            endif
            $filename=Dir('',1)
          loop
        endif
      next
    endif
  next

  $cleandirectory=''+$dircount+','+$filecount
endfunction

155893CleanUpDesktop52NTDOCCleanUpDesktop() Deletes typically unwanted .lnk 
files1140066803

;Function	CleanUpDesktop()   
;    
;Author		NTDOC   
;    
;Contributors       
;    
;Action		Deletes typically unwanted .lnk files for some programs   
;    
;Syntax		CleanUpDesktop()     
;    
;Version	1.02   
;    
;Date		2006-Jan-24    
;    
;Date Revised	2006-Feb-15    
;    
;Revision Reason  
;		1.01 Removed the IF construct and removed the /c switch, changed original post date to  
;		the year 2006 instead of 2005  
;		1.02 Added more links to be removed.  AOL,Remote Assistance.  (see UDF for all deletes) 
;    
;Parameters	None   
;    
;Remarks	Normally one would never modify a UDF, however for the purposes of this UDF one   
;		might want to modify or add to it as required.    
;		WARNING! As with any modifications one should know what they're doing before   
;		modifying any script or UDF.  This type of operation would normally be done by   
;		a script alone, but I got tired of writing for different uses and users and    
;		trying to find the script again so I posted it as a UDF.   
;    
;Further Info	None   
;   
;Returns	@ERROR (but only of last operation, wasn't too worried about it being   
;		bullet-proof.  If the user has Admin rights it should work, if not then   
;		some of the links won't be removed - not a big deal for me.)    
;    
;Dependencies	KiXtart 4.x   
;    
;KiXtart Ver	Written and tested with KiXtart v4.52 Beta 2 on Windows XP/2003   
;    
;Example            
;		Break On   
;		Dim $SO   
;		$SO=SetOption('Explicit','On')   
;		$SO=SetOption('NoVarsInStrings','On')   
;		$SO=SetOption('NoMacrosInStrings','On')   
;   
;		CleanUpDesktop()    
;    
;Source    
 
Function CleanUpDesktop()
  Dim $Disable
  $Disable = DelValue('HKLM\SOFTWARE\Microsoft\Active Setup\Installed Components\{44BBA840-CC51-11CF-AAFA-00AA00B6015C}','StubPath')
  $Disable = DelValue('HKCU\Software\Microsoft\Windows\CurrentVersion\Run','MSMSGS')
  DEL '%APPDATA%\Microsoft\Internet Explorer\Quick Launch\Windows Media Player.lnk' /f
  DEL '%APPDATA%\Microsoft\Internet Explorer\Quick Launch\Launch Outlook Express.lnk' /f
  DEL '%USERPROFILE%\Start Menu\Programs\Outlook Express.lnk' /f
  DEL '%ALLUSERSPROFILE%\Start Menu\Microsoft Update.lnk' /f
  DEL '%ALLUSERSPROFILE%\Start Menu\Set Program Access and Defaults.lnk' /f
  DEL '%ALLUSERSPROFILE%\Start Menu\Windows Catalog.lnk' /f
  DEL '%ALLUSERSPROFILE%\Start Menu\Windows Update.lnk' /f
  DEL '%ALLUSERSPROFILE%\Start Menu\Programs\MSN Explorer.lnk' /f
  DEL '%ALLUSERSPROFILE%\Start Menu\Programs\Windows Messenger.lnk' /f
  DEL '%USERPROFILE%\Start Menu\Programs\Remote Assistance.lnk' /f
  DEL '%USERPROFILE%\Start Menu\Programs\Windows Media Player.lnk' /f
  DEL '%USERPROFILE%\Favorites\MSN.com.url' /f
  DEL '%USERPROFILE%\Favorites\Radio Station Guide.url' /f
  DEL '%USERPROFILE%\Favorites\Links\Customize Links.url' /f
  DEL '%USERPROFILE%\Favorites\Links\Free Hotmail.url' /f
  DEL '%USERPROFILE%\Favorites\Links\Windows Marketplace.url' /f
  DEL '%USERPROFILE%\Favorites\Links\Windows Media.url' /f
  DEL '%USERPROFILE%\Favorites\Links\Windows.url' /f
  DEL '%USERPROFILE%\Favorites\Try AOL*.lnk' /f
  DEL '%USERPROFILE%\Favorites\Links\Try AOL*.lnk' /f
  DEL '%ALLUSERSPROFILE%\Start Menu\Try AOL*.lnk' /f
  DEL '%ALLUSERSPROFILE%\Desktop\Try AOL*.lnk' /f
  DEL Join(Split('%USERPROFILE%','\',2),'\')+'\Default User\Start Menu\Programs\Outlook Express.lnk' /f
  DEL Join(Split('%USERPROFILE%','\',2),'\')+'\Default User\Start Menu\Programs\Remote Assistance.lnk' /f
  Exit @ERROR
EndFunction
 
 
83711ClearIE52NTDOCClearIE() - Clears IE Cache and History1108272076Code:


;Function          ClearIE()

;

;Author            NTDOC

;

;Contributors      Code snipets from many members

;

;Version           1.3

;

;Reason            Changed code to cleaner method to support remote systems and add note code may not work now days.

;

;Date              2002/11/28

;

;Date Revised      2005/02/11

;

;Action            Attempts to clear IE Internet Cache and History

;

;Parameters        ClearIE(optional name of computer to run against) runs against local box if none supplied

;

;Remarks           Code probably will no longer work since too many services now run on 2000/XP that are required but also

;                  lock the INDEX.DAT files.  By the time you kill all the processes locking INDEX.DAT the system will become

;                  unstable.  

;

;Dependencies      WMI, 

;                  ARRAYENUMKEY() - Creates an array of names of the subkeys contained in a registry

;                  http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=81940

;                  EndProc() - Terminate a process using WMI

;                  http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=82164

;

;KiXtart           4.22

; 

;Example

;                  ClearIE('workstation5')

;

;Source

  

  

Function ClearIE(optional $sComputer)

	Dim $UserKeys,$Key,$Value,$Cache,$Process,$Processes

	If Not $sComputer $sComputer = @WKSTA EndIf

	$sComputer = '\\' + $sComputer + '\'

	$UserKeys=ArrayEnumKey($sComputer+'HKU')

	$Processes='anydvd.exe','clonecdtray.exe','daemon.exe','iexplore.exe','pgptray.exe','msmsgs.exe','msnmsgr.exe',

							'explorer.exe','aim.exe','wmplayer.exe','msimn.exe'

	For Each $Process In $Processes

		EndProc($Process,$sComputer)

		SLEEP 1

	Next

	For Each $Key In $UserKeys

	  If Not InStr($Key,'.DEFAULT') And Not InStr($Key,'Classes')

			$Cache=$sComputer+Join(Split(ReadValue($sComputer+'HKU'+$Key+'\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders','Cache'),':'),Chr(36))

			If Exist($Cache+'\Content.IE5')

				SHELL '%COMSPEC% /C RD /s /q ' + '"' + $Cache+'\Content.IE5'+'"' +' >nul 2>nul'

				If @ERROR $ClearIE=@ERROR Exit $ClearIE EndIf

			EndIf

		EndIf

	Next

EndFunction

82970CnvtBase2487New Mexico MarkCnvtBase2() - Generalized base conversion0

;Function CnvtBase2()
;
;Author New Mexico Mark
;
;Action Within the numeric and string limits of KiXtart, converts any
; numeric base to any other numeric base.
;
;Syntax CnvtBase2(Number, OldBase, NewBase [,NoHex] [,ForceSep])
;
;Parameters Number - expression that evaluates to a number, numeric string,
; or array of digits with least significant digit in 
; element 0 and an optional sign "-" in the highest
; element in the array.
; OldBase - The base of the number supplied.
; NewBase - The base to convert that number to
; NoHex - Boolean true to forces the function to use only
; characters 0-9 for return AND submitted values
; ForceSep- Always include separation characters between
; returned digits
;
;Remarks I originally developed CnvtBase to convert any base 2-36 to
; any other base 2-36. However, in order to handle bases greater
; than 16, I used the alphabetic characters G-Z. The problems
; with that approach are:
; 1. Symbols beyond F for higher bases are not standardized.
; 2. I still had an upper limit of base 36.
; 3. There would have to be too much programming outside the
; function in order to handle these characters correctly.
; My solution is as follows:
; For bases 2-16, alphanumeric characters 0-9 and A-F may be
; supplied as a number (base 10 and below), string (bases 2-16)
; or array of digits with the least significant digit in element
; zero of the array.
; The number in the new base is returned as a string. If any
; digit in the returned string exceeds the maximum value for
; that base (9 for base 10 or 15 for base 16), separation
; characters will be included.
; For consistency, the function may be forced to include a
; separation character for any returned number.
; Other Notes:
; 1. The maximum *base 10* value of the supplied number cannot
; exceed KiXtart's 31-bit numeric limit. If this happens, the
; function will not necessarily have an error, but it will
; return incorrect results.
; 2. Error code 0 indicates function success, -1 for failure.
;
;Dependencies None
; 
;Example(s)
$T1='190ACF'
$T2='-190'
'CnvtBase2(0,10,16) = ' + CnvtBase2(0,10,16) ?
'CnvtBase2(0,10,16,1) = ' + CnvtBase2(0,10,16,1) ?
'CnvtBase2(0,10,16,1,1) = ' + CnvtBase2(0,10,16,1,1) ?
'CnvtBase2("$T1",16,2) = ' + CnvtBase2($T1,16,2) ?
'CnvtBase2("$T1",16,2,1) = ' + CnvtBase2($T1,16,2,1) ?
'CnvtBase2("$T1",16,2,1,1) = ' + CnvtBase2($T1,16,2,1,1) ?
'CnvtBase2("110010000101011001111",16,2) = ' + CnvtBase2('110010000101011001111',2,16) ?
'CnvtBase2("110010000101011001111",16,2,1) = ' + CnvtBase2('110010000101011001111',2,16,1) ?
'CnvtBase2($T2,10,16,1) = ' + CnvtBase2($T2,10,16,1) ?
'CnvtBase2($T2,10,16) = ' + CnvtBase2($T2,10,16) ?
'CnvtBase2(2147483647,10,16) = ' + CnvtBase2(2147483647,10,16) ?
'CnvtBase2(2147483647,10,16,0,1) = ' + CnvtBase2(2147483647,10,16,0,1) ?
'CnvtBase2(2147483647,10,16,1,1) = ' + CnvtBase2(2147483647,10,16,1,1) ?
'CnvtBase2(2147483647,10,32) = ' + CnvtBase2(2147483647,10,32) ?
'Using CnvtBase2 to convert 4500 seconds to H:M:S' ?
'CnvtBase2(4500,10,60,1) = ' + CnvtBase2(4500,10,60,1) ?
'Converting 4:15:30 to seconds...' ?
'CnvtBase2("4:15:30",60,10) = ' + CnvtBase2('4:15:30',60,10) ?
EXIT
;Console displays (from examples)
;CnvtBase2(0,10,16) = 0
;CnvtBase2(0,10,16,1) = 0
;CnvtBase2(0,10,16,1,1) = 0
;CnvtBase2("190ACF",16,2) = 110010000101011001111
;CnvtBase2("190ACF",16,2,1) = 110010000101011001111
;CnvtBase2("190ACF",16,2,1,1) = 1:1:0:0:1:0:0:0:0:1:0:1:0:1:1:0:0:1:1:1:1
;CnvtBase2("110010000101011001111",16,2) = 190ACF
;CnvtBase2("110010000101011001111",16,2,1) = 1:9:0:10:12:15
;CnvtBase2(-190,10,16,1) = -11:14
;CnvtBase2(-190,10,16) = -BE
;CnvtBase2(2147483647,10,16) = 7FFFFFFF
;CnvtBase2(2147483647,10,16,0,1) = 7:F:F:F:F:F:F:F
;CnvtBase2(2147483647,10,16,1,1) = 7:15:15:15:15:15:15:15
;CnvtBase2(2147483647,10,32) = 1:31:31:31:31:31:31
;Using CnvtBase2 to convert 4500 seconds to H:M:S
;CnvtBase2(4500,10,60,1) = 1:15:0
;Converting 4:15:30 to seconds...
;CnvtBase2("4:15:30",60,10) = 15330
;Source

code:


FUNCTION CnvtBase2($vNum,$iOB,$iNB,OPTIONAL $bNoHex, OPTIONAL $bForceSep)
ÿÿÿ; Generalized base conversion.
ÿÿÿ; SYNTAX: CnvtBase2(number or array,oldbase,newbase,[NoHex])
ÿÿÿ; Number=number (base 2-16 only) or array of digits w/MSD in
ÿÿÿ; element 0
ÿÿÿ; Oldbase=integer specifying the base of the supplied number
ÿÿÿ; Newbase=integer specifying the base to convert that number to
ÿÿÿ; NoHex=boolean true to use only characters 0-9 for return values
ÿÿÿ; ForceSep=boolean true to always separate digits with colons
ÿÿÿ; RETURNS: A string. If highest digit > 9 (or F if HEX allowed),
ÿÿÿ; or ForceSep is true, the digits will be delimited with colons
ÿÿÿDIM $sDigits,$sSign,$sTmp,$sDigit,$sBx,$sSep
ÿÿÿDIM $iPos,$iDigVal,$iB10,$iPlcNum,$i,$iLen ; $iB10=base 10 value
ÿÿÿ$iOB=0+$iOB $iNB=0+$iNB
ÿÿÿIF $iOB < 2 OR $iNB < 2 EXIT -1 ENDIF
ÿÿÿ; Make vNum an array if necessary
ÿÿÿIF VarType($vNum) < 8192
ÿÿÿÿÿÿIF InStr($vNum,':') > 0
ÿÿÿÿÿÿÿÿÿ$vNum = Split($vNum,':')
ÿÿÿÿÿÿELSE
ÿÿÿÿÿÿÿÿÿ$sTmp = '' + $vNum
ÿÿÿÿÿÿÿÿÿ$iLen = Len($sTmp)
ÿÿÿÿÿÿÿÿÿREDIM PRESERVE $vNum[$iLen-1]
ÿÿÿÿÿÿÿÿÿFOR $i = 1 TO $iLen
ÿÿÿÿÿÿÿÿÿÿÿÿ$vNum[$i - 1] = SubStr($sTmp,$i,1)
ÿÿÿÿÿÿÿÿÿNEXT
ÿÿÿÿÿÿENDIF
ÿÿÿENDIF
ÿÿÿIF $iNB > 16 OR ($iNB > 10 AND $bNoHex) OR $bForceSep
ÿÿÿÿÿÿ$sSep = ':' 
ÿÿÿELSE 
ÿÿÿÿÿÿ$sSep = ''
ÿÿÿENDIF
ÿÿÿ$iPos=0 $iDigVal=0 $iB10=0 $i=0
ÿÿÿ$vRemain='' $sBx='' $sSign='' $sDigit=''
ÿÿÿ$sDigits='0123456789ABCDEF'
ÿÿÿ$iLen=UBound($vNum)
ÿÿÿ; Preserve the sign, if supplied
ÿÿÿIF $vNum[0] = '-' OR $vNum[0] = '+'
ÿÿÿÿÿÿ$sSign = $vNum[0]
ÿÿÿÿÿÿFOR $i = 1 TO $iLen
ÿÿÿÿÿÿÿÿÿ$vNum[$i-1] = $vNum[$i]
ÿÿÿÿÿÿNEXT
ÿÿÿÿÿÿREDIM PRESERVE $vNum[$iLen - 1]
ÿÿÿÿÿÿ$iLen=UBound($vNum)
ÿÿÿENDIF
ÿÿÿ$iPlcNum  = 1
ÿÿÿ$iPos     = 0
ÿÿÿWHILE $iPos <= $iLen ; Convert to base 10
ÿÿÿÿÿÿ$sDigit = '' + $vNum[$iLen-$iPos]
ÿÿÿÿÿÿIF Len($sDigit) = 1
ÿÿÿÿÿÿÿÿÿ$iDigVal = InStr($sDigits,$sDigit) - 1
ÿÿÿÿÿÿELSE
ÿÿÿÿÿÿÿÿÿ$iDigVal = 0 + $sDigit
ÿÿÿÿÿÿENDIF
ÿÿÿÿÿÿIF $iDigVal > ($iOB - 1) EXIT -1 ENDIF
ÿÿÿÿÿÿ$iB10    = 0 + $iB10 + ($iDigVal * $iPlcNum)
ÿÿÿÿÿÿ$iPlcNum = $iPlcNum * $iOB
ÿÿÿÿÿÿ$iPos    = $iPos + 1
ÿÿÿLOOP
ÿÿÿ$iPos=0
ÿÿÿWHILE $iB10 > 0 ; Convert to new base
ÿÿÿÿÿÿ$vRemain = $iB10 - (($iB10 / $iNB) * $iNB)
ÿÿÿÿÿÿIF $bNoHex OR $vRemain > 15
ÿÿÿÿÿÿÿÿÿ$sBx = $sSep + $vRemain + $sBx
ÿÿÿÿÿÿELSE
ÿÿÿÿÿÿÿÿÿ$sBx = $sSep + SubStr($sDigits,$vRemain+1,1) + $sBx
ÿÿÿÿÿÿENDIF
ÿÿÿÿÿÿ$iPos = $iPos + 1
ÿÿÿÿÿÿ$iB10 = $iB10 / $iNB
ÿÿÿLOOP
ÿÿÿIF Len($sBx) > 1 AND $sSep = ':' $sBx = SubStr($sBx,2) ENDIF
ÿÿÿIF $sSign <> '' ; Add the sign back in
ÿÿÿÿÿÿ$sBx = $sSign + $sBx
ÿÿÿENDIF
ÿÿÿIF $sBx = '' $sBx='0' ENDIF
ÿÿÿ$CnvtBase2 = $sBx
ÿÿÿEXIT 0
ENDFUNCTION


[ 08 February 2002: Message edited by: New Mexico Mark ]135402Codec2980Glenn 
BarnasCodec() - encode/decode text (text obfuscation)0

;; 
;;====================================================================== 
;; 
;;FUNCTION       codec() 
;; 
;;ACTION         encodes or decodes text strings 
;; 
;;AUTHOR         Glenn Barnas 
;; 
;;VERSION        1.1 
;; 
;;DATE CREATED   2005/03/10 
;; 
;;DATE MODIFIED  2006/11/26 - used decimal character values for comparison in arrays 
;; 
;;SYNTAX         codec(key,direction,data,extra) 
;; 
;;PARAMETERS     key 		- numeric key for seeding the codec engine 
;;               direction 	- 0 for encode, 1 for decode 
;;               data		- text string to encode/decode 
;;               extra		- string of extra parsing chars  
;;		 		(so chars like tab, CR, & LF can be included when needed) 
;; 
;;REMARKS        The "direction" value is not strict - clear text can be  
;;               encoded with either 0 or 1 values, but must be decoded with 
;;               the opposite value. 
;; 
;;               Multiple encoding levels are possible by recursive calling 
;; 
;;RETURNS        String - either encoded or decoded 
;; 
;;DEPENDENCIES   none 
;; 
;;TESTED WITH    NT4, W2K, WXP 
;; 
;;EXAMPLES       $D = 'My pAssw0rd' 
;;               $D = Codec(5493, 0, $D)	; encoded - safe to write to file 
;;               $D = Codec(5493, 1, $D)	; decoded 
;;              
; 
Function Codec($_Key, $_Direction, $_Data, OPTIONAL $_Extras)
 

  Dim $_, $_Ch, $_F, $_P, $_Ch, $_CSV, $_MAX
 

  ; Set this to 95 plus the number of special characters defined below 
  $_MAX = 95 + Len($_Extras)	; size of character array 
 

  Dim $_C[$_MAX], $_E[$_MAX], $_U[$_MAX]
 

  ; ### SPECIAL CHARACTER DEFINITIONS ### 
  $_ = 96
  For $_P = 1 to Len($_Extras)
    $_C[$_] = SubStr($_Extras, $_P, 1)
    $_ = $_ + 1
  Next
 

  ; Insure Direction is 0 or 1 
  $_Direction = IIf(Val($_Direction) = 0, 0, 1)
 

  ; Load the clear string into the key array specified by the direction 
  For $_ = 0 to 95		; handle the 96 printable characters 
    $_C[$_] = $_ + 32		; define the clear-text character 
    $_U[$_] = 0			; set the unencoded flag 
  Next
 

  ; Using the supplied key, generate a code string 
  SRnd($_Key)			; Seed the random number generator to a known sequence 
  $_ = 0			; encode array pointer 
  While $_ <= $_MAX		; do while positions are not encoded 
    $_Ch = Rnd($_MAX)		; Get a random character position 
    If $_U[$_Ch] = 0		; Has it been used? 
      $_U[$_Ch] = 1		; flag it if it hasn't 
      $_E[$_] = $_C[$_Ch]		; Add the char to the encode array 
      $_ = $_ + 1			; increment the encode array pointer 
    EndIf
  Loop
 

  ; convert the data string 
  $Codec = ''			; initialize the output string 
  For $_ = 1 to Len($_Data)	; loop through each character in the input data 
    $_Ch = Asc(SubStr($_Data, $_, 1))	; Get the next character 
    If $_Direction		; decoding? 
      $_P = AScan($_E, $_Ch)	; lookup the char in the encode array 
      If $_P = -1		; not found - output as is (CR, LF, or control char) 
        $Codec = $Codec + Chr($_Ch)
      Else			; found - output the corresponding char from the clear array 
        $Codec = $Codec + Chr($_C[$_P])
      EndIf
    Else			; or encoding? 
      $_P = AScan($_C, $_Ch)
      If $_P = -1		; not found - output as is (CR, LF, or control char) 
        $Codec = $Codec + Chr($_Ch)
      Else			; found - output the corresponding char from the encode array 
        $Codec = $Codec + Chr($_E[$_P])
      EndIf
    EndIf
  Next
 

  Exit 0
 

EndFunction
 

 

 


I looked at Rot-13 and Vigne UDFs and they did not provide adequate obfuscation 
for my needs. I have to embed a user ID and password for a scheduled task tool 
and can't leave it in clear text in the file. Since our passwords are "complex", 
I needed something that would encode / obfuscate all displayable characters, 
including spaces.

The key is any numeric value, used to seed the encoding engine. Direction is not 
really important, so long as you use ZERO in one direction and NonZERO in the 
other. 

The Extras value can be used when encoding the contents entire files - set it to 
"CHR(9)+Chr(10)+Chr(13)" - the byte count of the file will remain the same, but 
viewing with Type or Notepad will show more or fewer lines than the original, 
and line lengths will appear to be changed as well. 

82486CombSort11ShawnCombSort() - The combsort algorithm for kixtart arrays1108585108CombSort() 

Action: 

Sort a kixtart array using the combsort algorithm (the smart bubble). 

Syntax: 

array = csort( array [, order ]) 

Parameters: 

Array (Required) - A single dimensional kixtart array 

Order (Optional) - The sort order (0/1). If omitted or set to zero, the 
array will be sorted in ascending order. If set to 1, the array will be sorted 
in descending order. 

Returns: 

The sorted array 

Remarks: 

Who was it that boasted they had the fastest version of a bubble sort ? 

Just as we thought that the last word had been said about sorting, a 
breakthrough comes along and spoils everything. In the April 1991 issue of BYTE 
magazine, Stephen Lacey and Richard Box show that a simple modification to 
bubble sort makes it a fast and efficient sort method on par with heapsort and 
quicksort. 

In a bubble sort, each item is compared to the next; if the two are out of order, 
they are swapped. This method is slow because it is susceptible to the 
appearance of what Box and Lacey call turtles. A turtle is a relatively low 
value located near the end of the table. During a bubble sort, this element 
moves only one position for each pass, so a single turtle can cause maximal 
slowing. Almost every long table of items contains a turtle. 

Their simple modification of bubble sort which they call `combsort' eliminates 
turtles quickly by allowing the distance between compared items to be greater 
than one. This distance (gap) - the $G - is initially set to the array size. 
Before each pass, $G is divided by 1.3 (the shrink factor). If this causes it to 
become less than 1, it is simply set to 1, collapsing combsort into bubble sort. 
An exchange of items moves items by $G positions rather than only one position, 
causing turtles to jump rather than crawl. [Svalgaard 2001]. If I was going to 
implement a non-recursive sorting algorithm in a script, this would be it (imho). 
I think there may be room for even more optimization (maybe from a kixtart 
specific standpoint) -Shawn 

Dependencies: 

kixtart 4.0 (final) 

Example(s): 

Code:


$array = Peach,Pumpkin,Orange,Grape,Lime,Apple,Rasberry,Cherry,Lemon

 

$array = combsort($array) ; sort ascending

for each $element in $array

 ? $element

next

 

$array = 1,2,3,4,5

 

$array = combsort($array,1) ; sort descending

for each $element in $array

 ? $element

next

 

$array = combsort(split("Z Q G A D M U V N C B T W J X S K R H I L E F P O Y"))

  

for each $letter in $array

 $letter

next



Code: 

Code:


function combsort($v, optional $o)

 dim $i,$j,$m,$s,$g

 $n=ubound($v)

 $g=$n

 if $g

  while $g > 1 or not $s

   $g=($g*1000)/1279

   if $g < 1

    $g=1

   endif

   $s=1

   for $i = 0 to $n-$g

    $j=$i+$g

    if ($v[$i] > $v[$j] and not $o) or ($v[$i] < $v[$j] and $o)

     $m = $v[$i]

     $v[$i] = $v[$j]

     $v[$j] = $m

     $s=0

    endif

   next

  loop

  $combsort = $v

 else

  $combsort = 0

 endif

endfunction



Author: 

-Shawn 

83119COMNetView17SealeopardCOMNetView() - Enumerate all computers in your 
domain0

code:

;FUNCTION      COMNetView()
;
;ACTION        Enumerate all joined computers in a domain
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.3 (added error codes, changes variable redim algorithm)
;              1.2
;
;DATE CREATED  2002/05/14
;
;DATE MODIFIED 2003/06/24
;
;KIXTART       4.12+
;
;SYNTAX        COMNetView([Domain])
;
;PARAMETERS    DOMAIN
;              Specifies the domain to enumerate. If domain is omitted, returns a
;              list of all joined computers in the current domain.
;
;RETURNS       An array of strings representing all the computers in the domain
;
;REMARKS       This function returns all computers that have joined the specified domain
;              independent of whether the computer is on- or off-line. It will not return
;              computers running the Windows 9x operating system since they technically do
;              not join the domain. To include Windows 9x computers in this list, please use
;              either NetView() or NetView2()
;
;DEPENDENCIES  none
;
;EXAMPLE       for each $computer in COMNetView()
;                ? ''+$computer
;              next
;
;KIXTART BBS   http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000201
;
Function COMNetView(optional $domain)
  Dim $list, $objDomain, $objComputername, $filter[0]

  ; this function seems to only work on Windows 2000/XP computers
  ; even in a Windows NT 4.0 domain
  if val(@INWIN)<>1 or val(@DOS)<5
    exit 196
  endif

  $domain = trim($domain)
  if $domain=''
    $domain=@DOMAIN
  endif

  $filter[0]='Computer'

  $objDomain = GetObject('WinNT://' + $domain + ',domain')
  if @ERROR
    exit @ERROR
  endif
  $objDomain.Filter=$filter
  if @ERROR
    exit @ERROR
  endif
  For Each $objComputername In $objDomain
    redim preserve $list[ubound($list)+1]
    $list[ubound($list)] = $objComputername.Name
  Next

  $objDomain = 0

  $COMNetView = $list

  exit @ERROR
EndFunction



[ 25. July 2003, 19:34: Message edited by: sealeopard ]83164CompAcctPswdAge953Chris 
S.CompAcctPswdAge() - KiX/ADSI method of listing computer account password age0This 
is my first attempt at an "official" UDF, so be kind. 

I like Howard's ideas so much that I just feel the need to convert them to KiX. 
Sorry, Howard. 

I ran this along side of Howard's MachAcctPWage Perl script and the results were 
the same. Howard's ran faster, but mine can be customized a little easier for us 
KiXers.

It has only been tested in an NT 4 environment. I welcome any feedback. 

code:

;
;Function	CompAcctPswdAge()
;
;Author		Christopher Shilt (christopher.shilt@relizon.com)
;
;Version	1.1
;
;Version History
;		11 June 2002 Added at 60 password age minimum for deletion of computer account.
;		Thanks, Howard.
;
;		11 June 2002 Version 1.0;
;Action 	Enumerates domain and returns password age with option to
;		delete computer account.
;
;Syntax		CompAcctPswdAge(DOMAIN, optional MINIMUM PASSWORD AGE ,optional DELETE)
;
;Parameters 
; 		DOMAIN		: REQUIRED. The domain you want to enumerate.
;
;		MINPSWDAGE	: OPTIONAL. Enter the minimum password age you want the function
;				  to return. If not set, will display all computer accounts.
;		DELETE		: OPTIONAL. Boolean. If DELETE = "1" then the computer account will
;				  be deleted providing that MINPSWDAGE is set and Password Age is
;				  over 60 days.
;
;Remarks
;		Output is tab-delimited with the use of REDIRECTOUTPUT in mind.
;		Deletion of computer account requires the appropriate admin rights on network.
;
;Returns	The Computer Name, the number of days of "Password Age," and (optionally) whether the
;		account was deleted.
; 
;Dependencies	KiX 4.02
;		ADSI (Included with Windows 2000, available for download from Microsoft for other OS's)
; 
;Example:
;		;List all Computer Accounts:		
;		$rc=execute(CompAcctPswdAge(YourDomain))
;
;		;List all Computer Accounts with passwords older than 60 days:
;		$rc=execute(CompAcctPswdAge(YourDomain,60))
;
;		;Delete all Computer Accounts with passwords older than 90 days:
;		$rc=execute(CompAcctPswdAge(YourDomain,90,1))
;
;Source
function CompAcctPswdAge($Domain, OPTIONAL $MinPswdAge, OPTIONAL $delete)
	$Computers=GetObject("WinNT://$Domain")
	$Computers.filter="Computer",""
	for each $Computer in $Computers
		$Account=GetObject("WinNT://$Domain/"+$Computer.name+"$$")
		$PasswordAge=$Account.get("PasswordAge")
		$PasswordAge=$PasswordAge/86400
		if $MinPswdAge=""
			? $Computer.name "	" $PasswordAge
		else
			if $PasswordAge > $MinPswdAge
				? $Computer.name "	" $PasswordAge
				if $delete = 1 AND $PasswordAge > 60
					$Computers.Delete("Computer", $Computer.name)
					"	Deleted"
				endif
			endif
		endif
	next
endfunction



[ 28. October 2002, 14:32: Message edited by: Chris S. ]131864CompareStrings3755GavenCompareStrings() 
- compare two strings using wild cards1104758685Code:


;  Function:     CompareStrings()

;

;  Author:       Gaven Henderson, Gaven@GavDogg.net

;

;  Action:       CompareStrings will compare two strings using wild cards.

;

;  Syntax:       comparestrings($String1, $String2)

;

;  Parameters:   String1 - String with wild cards

;                          ? - single character wild card

;                          * - multi-character wild card

;                String2 - String to search

;

;  Returns:      Returns 1 if match, 0 if not a match.

;

;  Dependencies: comparestringsnc() and findall() - included below

;

;  Remarks:      The multi-character wild card must match at least one character

;                CompareString("a*b","ab")=0 no match

;

;  Version:      1.1

;

;  Post Date:    January 03, 2005

;

;  KiXtart Ver:  Designed on 4.22 but should work on any version.

;

;  Examples:     comparestrings("kixtart rules", "kixtart rules") returns 1

;                comparestrings("kixtart", "kixtart rules") returns 0

;                comparestrings("kix*", "kixtart rules") returns 1

;                comparestrings("*ta?t*","kixtart rules") returns 1

;                comparestrings("*x?a*l?s","kixtart rules") returns 1

;                comparestrings("*r?les","kixtart rules") returns 1

;                comparestrings("*t??t*","kixtart rules") returns 1

;                comparestrings("ki*r??es","kixtart rules") returns 1

;                comparestrings("kix?", "kixtart rules") returns 0

;                comparestrings("*t?t*","kixtart rules") returns 0

;                comparestrings("ki*r?es","kixtart rules") returns 0

;                comparestrings("a?c*a?c","abcdefabcghiabc") returns 1

;                comparestrings("a?c*a?c*a?c","abcdefabcghiabc") returns 1

;                comparestrings("a?c*a?c*a?c*a?c","abcdefabcghiabc") returns 0

;

Function comparestrings($a,$b)

	Dim $c,$d,$e,$f,$g,$x[],$y,$z[0]

	$comparestrings=0

	$f=$a

	If $a="" Exit 1 EndIf

	If Len($a)>Len($b) Exit EndIf

	If $a="*"

		$comparestrings=1

		Exit

	EndIf

	If Join(Split($a,"?"),"")=""

		If Len($a)=Len($b) $comparestrings=1 Else $comparestrings=0 EndIf

		Exit

	EndIf

	While $a<>""

		$c=InStr($a,"?")

		$d=InStr($a,"*")

		If $c=0 And $d=0

			$z[UBound($z)]=$a

			$a=""

		Else

			If $c=0 $c=$d+1 EndIf

			If $d=0 $d=$c+1 EndIf

			If $c>1 And $d>1

				If $c<$d

					$z[UBound($z)]=Left($a,$c-1)

					$a=Right($a,Len($a)-$c+1)

				Else

					$z[UBound($z)]=Left($a,$d-1)

					$a=Right($a,Len($a)-$d+1)

				EndIf

			Else

				$e=Left($a,1)

				$a=Right($a,Len($a)-1)

				While Left($a,1)="?" Or Left($a,1)="*"

					$e=$e+Left($a,1)

					$a=Right($a,Len($a)-1)

				Loop

				If InStr($e,"*")>0 $z[UBound($z)]="*" Else $z[UBound($z)]=$e EndIf

			EndIf

		EndIf

		ReDim Preserve $z[UBound($z)+1]

	Loop

	If UBound($z)=1

		If $z[0]=$b $comparestrings=1 Else $comparestrings=0 EndIf

		Exit

	EndIf

	ReDim Preserve $z[UBound($z)-1]

	If Left($z[UBound($z)],1)<>"?" And $z[UBound($z)]<>"*" And Right($b,Len($z[UBound($z)]))<>$z[UBound($z)] Exit EndIf

	If Left($z[0],1)<>"?" And $z[0]<>"*" And Left($b,Len($z[0]))<>$z[0] Exit EndIf

	If Left($z[UBound($z)],1)="?" And Left(Right($b,Len($z[UBound($z)])+Len($z[UBound($z)-1])),Len($z[UBound($z)-1]))<>$z[UBound($z)-1] Exit EndIf

	If Left($z[0],1)="?" And Right(Left($b,Len($z[0])+Len($z[1])),Len($z[1]))<>$z[1] Exit EndIf

	If UBound($z)<3

		$comparestrings=1

		Exit

	EndIf

	ReDim $y[UBound($z),0]

	For $c=0 To UBound($z)

		If Left($z[$c],1)<>"?" And $z[$c]<>"*"

			$x=findall($b,$z[$c])

			If @Error Exit EndIf

			If UBound($y,2)<UBound($x) ReDim Preserve $y[UBound($z),UBound($x)] EndIf

			For $d=0 To UBound($x) $y[$c,$d]=$x[$d] Next

		EndIf

	Next

	If $z[0]="*"

		$c=0

		For $d=0 To UBound($y,2) If $y[1,$d]>1 $c=1 EndIf Next

		If $c=0 Exit EndIf

	EndIf

	If $z[UBound($z)]="*"

		$c=0

		For $d=0 To UBound($y,2) If $y[UBound($z)-1,$d]<=Len($b)-Len($z[UBound($z)-1]) $c=1 EndIf Next

		If $c=0 Exit EndIf

	EndIf

	If UBound($y,2)>0

		If $z[0]="*"

			If $y[1,0]=1 $y[1,$c]="" EndIf

		Else

			If Left($z[0],1)="?" $y[1,0]=Len($z[0])+1 EndIf

			For $c=1 To UBound($y,2)

				$y[0,$c]=""

				$y[1,$c]=""

			Next

		EndIf

		If $z[UBound($z)]="*"

			For $c=0 To UBound($y,2)

				If $y[UBound($z),UBound($y,2)]>Len($b)-Len($z[UBound($z)-1]) $y[UBound($z),UBound($y,2)]="" EndIf

			Next

		Else

			If Left($z[UBound($z)],1)="?"

				$y[UBound($z)-1,0]=Len($b)-Len($z[UBound($z)])-Len($z[UBound($z)-1])+1

			Else

				$y[UBound($z),0]=Len($b)-Len($z[UBound($z)])+1

			EndIf

			For $c=1 To UBound($y,2)

				$y[UBound($z),$c]=""

				$y[UBound($z)-1,$c]=""

			Next

		EndIf

	EndIf

	If $z[UBound($z)]="*" Or Left($z[UBound($z)],1)="?" ReDim Preserve $z[UBound($z)-1] EndIf

	$x=""

	ReDim Preserve $x[UBound($z)]

	For $c=0 To UBound($x) For $d=0 To UBound($y,2) If $x[$c]="" And $y[$c,$d]<>"" $x[$c]=$y[$c,$d] EndIf Next Next

	While @Error=0

		$comparestrings=1

		For $c=1 To (UBound($z)-1)

			If $z[$c]="*" If $x[$c+1]<=$x[$c-1]+Len($z[$c-1]) $comparestrings=0 EndIf EndIf

			If Left($z[$c],1)="?" If $x[$c+1]<>$x[$c-1]+Len($z[$c-1])+Len($z[$c]) $comparestrings=0 EndIf EndIf

		Next

		If $comparestrings=1 Exit Else $comparestrings=0 EndIf

		$x=comparestringsnc($y,$x)

	Loop

EndFunction

Function comparestringsnc($a,$b)

	Dim $c,$d,$e

	$c=UBound($b)

	While 1

		$e=$b[$c]

		For $d=UBound($a,2) To 0 Step -1 If $a[$c,$d]>$b[$c] $e=$a[$c,$d] EndIf Next

		If $e=$b[$c]

			For $d=UBound($a,2) To 0 Step -1 If $a[$c,$d]<>"" $b[$c]=$a[$c,$d] EndIf Next

			$c=$c-2

			If $c<0 Exit 1 EndIf

		Else

			$b[$c]=$e

			$comparestringsnc=$b

			Exit

		EndIf

	Loop

EndFunction

Function findall($a,$b)

	Dim $c,$d

	$c=Split($a,$b)

	If UBound($c)=0 Exit 1 EndIf

	ReDim $findall[UBound($c)-1]

	$findall[0]=Len($c[0])+1

	If UBound($c)=1 Exit EndIf

	For $d=2 To UBound($c) $findall[$d-1]=$findall[$d-2]+Len($b)+Len($c[$d-1]) Next

EndFunction

82864CompareVersions17SealeopardCompareVersions() - Compares two multi-segment 
version strings1184464487

Code:

;NAME           CompareVersions
;
;ACTION         Compares two multi-segment version strings
;
;AUTHOR         Scriptlogic (http://www.scriptlogic.com)
;               rewritten and improved by Jens Meyer
;               additioal improvements by Witto
;               unlimited number of subversions can be compared
;
;VERSION        1.4  (updated by Witto to better handle level 1 comparisons)
;               1.31 (minor code changes)
;               1.3
;
;DATE CREATED   2002/01/18
;
;DATE MODIFIED  2004/03/10
;
;KIXTART        4.20+
;
;SYNTAX         COMPAREVERSIONS(VERSION1,VERSION2,[LIMIT])
;
;PARAMETERS     VERSION1
;               Required string containing first version string to compare
;
;               VERSION2
;               Required string containing second version string to compare
;
;               LIMIT
;               Optional integer comparing the first X segments of the version strings
;
;REMARKS        Based on a Scriptlogic UDF posted at
;               http://www.scriptlogic.com/kixtart/FunctionLibrary_ViewFunction.aspx?ID=CompareVersions
;
;               Allows either a '.' or ',' as segment separator.
;               Unlimited segments with unlimited digits per segment
;               Neither the number of segments nor the length of each segment in each version string
;               need to be identical (i.e. a version of "4" will match a version of "4.00" and "5.1" will match "5.10")
;
;RETURNS        -2   One or more versions strings were not supplied
;               -1   First version string is older than the second version string
;               0   Version strings are the same.
;               1   First version string is newer that the second version string
;
;EXAMPLE        $Version1 = '5.00.2920.0000' ; IE 5.01 w/o any SP
;               $Version2 = '5.00.3105.0106' ; IE 5.01 w/ SP1
;               $result=CompareVersions($Version1,$Version2)
;
;KIXTART BBS    http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=82314
;
Function compareversions($Ver1, $Ver2, OPTIONAL $Limit)
    Dim $sourcever, $destver, $level, $maxlevel, $pad, $maxpad
    
    If Trim($ver1)='' Or Trim($ver2)=''
        $compareversions=-2
        Exit -2
    EndIf
    
    If VarType($limit)
        $limit=Val($limit)
    Else
        $limit=999
    EndIf
    
    If InStr($ver1,'.')
        $sourcever=Split($ver1,'.')
    Else
        $sourcever=Split($ver1,',')
    EndIf
    If InStr($Ver2,'.')
        $destver=Split($ver2,'.')
    Else
        $destver=Split($ver2,',')
    EndIf
    
    $level=0
    $maxlevel=UBound($sourcever)
    If $maxlevel<UBound($destver)
        $maxlevel=UBound($destver)
    EndIf
    ReDim preserve $sourcever[$maxlevel], preserve $destver[$maxlevel]
    Do
        $ver1=Trim($sourcever[$level])
        $ver2=Trim($destver[$level])
        If Len($ver1)>Len($ver2)
            $maxpad=Len($ver1)
        Else
            $maxpad=Len($ver2)
        EndIf
        For $pad=1 to $maxpad
            If $level = 0
                $ver1='0'+$ver1
                $ver2='0'+$ver2
            Else
                $ver1=$ver1+'0'
                $ver2=$ver2+'0'
            EndIf
        Next
        If $Level = 0
            $ver1=Right($ver1,$maxpad)
            $ver2=Right($ver2,$maxpad)
        Else
            $ver1=Left($ver1,$maxpad)
            $ver2=Left($ver2,$maxpad)
        EndIf
        Select
            Case $ver1>$ver2
                $compareversions=1
            Case $ver1<$ver2
                $compareversions=-1
            Case 1
                $compareversions=0
        EndSelect
        $level=$level+1
    Until $level>$maxlevel Or $compareversions<>0 Or $level>$limit
    Exit 0
EndFunction

84466Compress119LonkeroCompress() - fast compress and decompress of scripts0

;Function:

;	Compress()

;

;Author:

;	Lonkero

;

;Version:

;	1.0 (21-08-2003)

;

;Version hisotry:

;	1.0 (21-08-2003) first published version

;

;Action:

;	Compresses and uncompresses scriptfiles

;

;Syntax:

;	Compress(SOURCE,TARGET,MODE)

;

;Parameters:

;	SOURCE	- the file to read from

;	TARGET	- the file to save results to

;	MODE	- if 1 -> compress, if 0 or blank -> decompress

;

;Returns:

;	nothing. check @error for possible problems

;

;Dependencies:

;	none

;

;Remarks:

;	should work on all ascii text-files but optimized for kixtart scripts.

;	left out the on the fly inline compress/decompress to get this fast out.

;	so, be waiting for that.

;

;Example:   

;	"compressing kixtart piXaso painter:" ?

;	Compress(@scriptdir+"\paint.kix",@scriptdir+"\paint.kix.kxc",1)

;	@serror

;	"Running painter from compressed:"

;	Compress(@scriptdir+"\paint.kix.kxc","%temp%\paint.kix.tmp")

;	call "%temp%\paint.kix.tmp"

;

;Source:

function compress($file,$targetfile,optional $mode)

 dim $,$f,$raw,$pal[0],$_,$s,$mo,$e,$c,$a,$o1,$o2,$i,$lf,$b

 $lf=chr(10) $b=chr(1)

 $f=freefilehandle

 $=open($f,$file)

 if @error exit @error endif

 do $raw=$raw+$lf+readline($f) until @error

 $=close($f)

 $raw=split($raw,$lf)

  $f=freefilehandle

  $=open($f,$targetfile,5)

  if @error exit @error endif

 if $mode

  $mo=",	$$ .*+-/<>()=&@@?|[]'"+'";'

  $raw[0]="KXc"

  for $a=1 to ubound($raw)

   $=""

   $i=$raw[$a] $_=len($i) $!=0

   do $!=$!+1

    $c=substr($i,$!,1)

    select

     case $c=""

     case $c="'" $o1=iif($o1 or $o2,0,1) $=$+$c

     case $c='"' $o2=iif($o2 or $o1,0,1) $=$+$c

     case $c=";" if $o1 or $o2 $=$+$c else $!=$_ endif

     case instr($mo,$c) $=$+$c

     case 1

      $s="" do $s=$s+$c $!=$!+1 $c=substr($i,$!,1) until instr($mo,$c) or $!>$_ $!=$!-1

      $e=ascan($pal,$s)

      if -1=$e

       $e=ubound($pal)+1

       redim preserve $pal[$e]

       $pal[$e]=$s

      endif

      $=$+$e

    endselect

   until $!=>$_

   $raw[$a]=$

  next

  $=writeline($f,join($raw)+$lf+join($pal))

 else

  if 3<>ubound($raw) exit 13 endif

  $pal=split($raw[2]) $raw=substr($raw[1],4)

  $mo="0123456789"

  for $=0 to len($raw)

   $!=substr($raw,$,1)

   if instr($mo,$!)

    $s="" do $s=$s+$! $=$+1 $!=substr($raw,$,1) until not instr($mo,$!) or @error

    $_=$_+$pal[$s]

    $=$-1

   else

    $_=$_+$!

   endif

  next

  $=writeline($f,$_)

 endif

  $=close($f)

endfunction
84539ComputerInGroup31RadimusComputerInGroup() - returns if the PC is a 
member of a specified group0

code:

;Function        ComputerInGroup()
;
;Author          Radimus  (really Howard Bullock's code)
;
;Contributors    Almost entirely written by Howard Bullock
;                I just stuffed it into UDF format and posted it
;
;Action          Returns a 1 if the @wksta is a member of domain group 
;
;Syntax          ComputerInGroup($group,optional $Domain)
;
;Version         1.00
;
;Date            2003-Sep-03
;
;Date Revised    
;
;Revision Reason 1.00
;
;Parameters      $group      = name of group to test for
;                $domain     = optional parameter for testing a different domain than current
;
;Remarks         see Ingroup(), but for computer accounts instead of user accounts
;                             
;Returns         1 if in specified group
;                0 if not
;                @error =1 for bad group or domain
;
;Dependencies    ADSI
;
;KiXtart Ver     Written and tested with KiXtart v4.21 
;
;Example         If ComputerInGroup('domain computers')=1
;                     ? 'Computer is a member'
;                endif


Function ComputerInGroup($group,optional $Domain)
	Dim $oGrp
	if not $domain		$domain=@domain		endif
	$oGrp = GetObject("WinNT://" + $domain + "/"  + $group + ",group" )
	if @error	exit 1		endif

	if $oGrp.IsMember("WinNT://" + $domain + "/"  + @wksta + "$$" )
		$ComputerInGroup=1
	else
		$ComputerInGroup=0
		endif
	endfunction
  



[ 03. September 2003, 21:57: Message edited by: Radimus ]84556ContinuousLiveUpdate109gibilixContinuousLiveUpdate() 
- Enable and configure this feature of Symantec AV 8.x0Can you please test 
this UDF and give me suggestions/feedbak on the UDF and the functionality itself? 

Sorry if I made mistakes in the post, it is the first time I post an UDF.

Thank you very much

Gibilix

code:

 
FUNCTION ContinuousLiveUpdate(OPTIONAL $ConfigFile)
    ;FUNCTION      ContinuousLiveUpdate
    ;
    ;AUTHOR        Fabrizio Gibilaro (monserrato@iol.it)
    ;
    ;ACTION        Configure the Continuous LiveUpdate feature available in Symantec AntiVirus 8.x
    ;
    ;SYNTAX        ContinuousLiveUpdate("ConfigurationFile")
    ;
    ;PARAMETERS    Configuration file
    ;              Optional string containing the configuratin ini file with it's path.
    ;              If not provided the DEFAULT ini file will be used.
    ;
    ;RETURNS       0 if successful, otherwise error code:
    ;               -1          Missing or incorrect data in configuration file
    ;               >0          Error returned by WriteValue function
    ;
    ;REMARKS       Requires Symantec AntiVirus 8.x
    ;              Continuous LiveUpdate checks every X minutes for an internet connection to be
    ;              available to download virus definition files if they are out of date more than Y days.
    ;              Configuration is controlled by a simple ini file.
    ;              This feature can be useful to keep up to date Unmanaged Laptops.
    ;
    ;DEPENDENCIES  none
    ;
    ;EXAMPLE       $rc=ContinuousLiveUpdate('\\server1\depShare\AV\Liveupdate\CLU.INI')
    ;
 

    DIM $PatternManagerKey,$ConfigFile,$enable,$maxDaysOldAllowed,$checkInterval,$r    $PatternManagerKey="HKLM\Software\Intel\LANDesk\VirusProtect6\CurrentVersion\PatternManager"
    
    ; This must point to your DEFAULT configuration file (placed in a read only share)
    IF $ConfigFile=""
        $ConfigFile="Q:\updates\logon\scripts\AntiVirus\CLU\CLU.ini"
    ENDIF
    
    ; Sample configuration file:
    ;
    ; [ContinuousLiveUpdate]
    ; Enable=1
    ; MaxDaysOldAllowed=5        <--- It starts checking for new VDF after the current pattern is older than 5 days
    ; CheckInterval=30           <--- Tries to contacts LiveUpdate site every 30 minutes
    
    ; Read configuration parameters
    $enable=readprofilestring($ConfigFile,"ContinuousLiveUpdate","Enable")
    IF $enable=0 or $enable=1
        $r=writevalue($PatternManagerKey,"EnableAdminForcedLU",$enable,"REG_DWORD")
    ELSE
        $err=-1
    ENDIF
    
    IF $enable=1
        $maxDaysOldAllowed=readprofilestring($ConfigFile,"ContinuousLiveUpdate","MaxDaysOldAllowed")
        IF $maxDaysOldAllowed<>""
            $r=writevalue($PatternManagerKey,"MaxDefsDaysOldAllowed",$maxDaysOldAllowed,"REG_DWORD")
            $err=@error
        ELSE
            $err=-1
        ENDIF
    
        $checkInterval=readprofilestring($ConfigFile,"ContinuousLiveUpdate","CheckInterval")
        IF $checkInterval<>""
            $r=writevalue($PatternManagerKey,"AdminForcedLUCheckInterval",$checkInterval,"REG_DWORD")
            $err=@error
        ELSE
            $err=-1
        ENDIF
    ENDIF

    $ContinuousLiveUpdate=$err
        
ENDFUNCTION

154136Convert2Array4959GargoyleConvert2Array() - Text file to array file1135710982Code:


;FUNCTION 	Convert2array
; 
;ACTION 	Take a plain text file and convert it into an array
;			that allows for use of includes
; 
;AUTHOR 	Gargoyle
; 
;CONTRIBUTORS 	Many for the suggestions on how to create this
;					so that you can then tokenize the data and still
;					"include"/"call".
; 
;VERSION 	1.0.2
; 
;DATE CREATED 	12.23.05
; 
;DATE MODIFIED 	12.27.05
; 
;KIXTART			Only tested with 4.51
; 
;SYNTAX 	Convert2array(FileToConvert,FileToSave,ArrayName)
; 
;PARAMETERS 	
;		File to Convert
; 		Name of the input file, if not in the scriptdirectory 
;		specify full path name
; 
; 		File to Save
; 		Name of the output file, if you don't want it in the 
;		script directory specify the full path.
; 
; 		Array Name
; 		What name to you want to assign to the created array elements
; 
;RETURNS 	@Error
; 
;REMARKS 	
; 
;DEPENDENCIES 	
; 		
;KIXTART BBS 	
; http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=153660&an=0&page=0#153660		 
; 


Function Convert2Array($IN,$Out,$Name)
Dim $Read, $Count, $FH, $Array[], $, $nul
$FH = FreeFileHandle()
$Count = 0
If Open($FH,$IN,2) = 0
	$Read = ReadLine($FH)
		While @ERROR = 0
			ReDim Preserve $Array[$Count]
			$Array[$Count] = $Read
			$Count = $Count + 1
			$Read = ReadLine($FH)
		Loop
	$Nul = Close($FH)
Else 
	        Exit @Error
EndIf

If Open($FH,$OUt,5) = 0
	For $ = 0 to Ubound($Array)
		$nul = WriteLine($FH,"$"+$Name+"["+$+"] = '" + $Array[$] + "'"+@CRLF)
	Next
	$nul = Close($FH)
Else
	Exit @Error
EndIf
$Convert2Array = @Error
EndFunction

83518ConvertFromWMIDate17SealeopardConvertFromWMIDate() - Converts a string 
in WMI date format into KiXtart format1167261717

Code:

;FUNCTION      ConvertFromWMIDate()
;
;ACTION        Converts a string in WMI date format into KiXtart format
;
;VERSION       1.0
;
;KIXTART VER   4.12
;
;AUTHOR        Jens Meyer
;
;SYNTAX        RETCODE = CONVERTFROMWMIDATE(WMIDATE)
;
;PARAMETERS    WMIDATE
;              date/time string in WMI format
;
;RETURN        date/time string in KiXtart format
;
;REMARKS       none
;
;DEPENDENCIES  KiX 4.x
;
;EXAMPLE       $datetime = ConvertFromWMIDate('20020922123500.000000-240')
;
;KIXTART BBS   http://www.kixtart.org/forums/ubbthreads.php?ubb=showflat&Number=83518
;
function ConvertFromWMIDate($wmidate)
  if instr($wmidate,'.')
    $ConvertFromWMIDate=left($wmidate,4)+'/'+substr($wmidate,5,2)+'/'+substr($wmidate,7,2)+' '
    $ConvertFromWMIDate=$ConvertFromWMIDate+substr($wmidate,9,2)+':'+substr($wmidate,11,2)+':'+substr($wmidate,13,2)
  else
    $ConvertFromWMIDate=''
  endif
endfunction
83517ConvertToWMIDate17SealeopardConvertToWMIDate() - Converts a KiXtart 
date/time string into a WMI date/time string0

code:

;FUNCTION      ConvertToWMIDate()
;
;ACTION        Converts a KiXtart date/time string into a WMI date/time string
;
;AUTHOR        Jens Meyer
;
;VERSION       1.2 (shortened code by using SPLIT, added error checking)
;              1.1
;
;DATE CREATED  2002/09/23
;
;DATE MODIFIED 2003/05/26
;
;KIXTART VER   4.12
;
;SYNTAX        RETCODE = CONVERTTOWMIDATE([DATETIME])
;
;PARAMETERS    DATETIME
;              Optional string containing either a date and/or a time. If only a time is passed, the current
;              date will be used. Format must be 'YYY/MM/DD HH:MM:SS', 'YYY/MM/DD', or 'HH:MM:SS'
;
;RETURN        WMI date/time string for either current date/time or for date/time conbination passed into function
;
;REMARKS       none
;
;DEPENDENCIES  WMI
;
;EXAMPLE       ; converts current date/time
;              $wmidate = ConvertToWMIDate()
;              ; converts time for current date
;              $wmidate = ConvertToWMIDate('00'10'32')
;              ; converts date (midnight)
;              $wmidate = ConvertToWMIDate('2002/09/22')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000268
;
function ConvertToWMIDate(optional $datetime)
  dim $date, $time, $timezone
  dim $objWMIService, $colItems, $objItem

  $objWMIService = getObject('winmgmts:{impersonationLevel=impersonate}!//./root/cimv2')
  if @ERROR
    exit @ERROR
  endif
  $colItems = $objWMIService.ExecQuery('Select CurrentTimeZone from Win32_ComputerSystem')

  for each $objItem in $colItems
    $timezone = $objItem.CurrentTimeZone
  next

  $objWMIService = 0
  $colItems = 0
  $objItem = 0

  if $datetime
    $datetime=trim($datetime)
  else
    $datetime=@DATE+' '+@TIME
  endif

  select
  case instr($datetime,' ')
    $datetime=split($datetime,' ')
    $date=$datetime[0]
    $time=$datetime[1]
  case instr($datetime,'/')
    $date=$datetime
    $time='00:00:00'
  case instr($datetime,':')
    $date=@DATE
    $time=$datetime
  case 1
    $date=@DATE
    $time=@TIME
  endselect
  $datetime=join(split($date,'/'),'')+join(split($time,':'),'')+'.000000'+$timezone

  $ConvertToWMIDate=$datetime
  exit @ERROR
endfunction



[ 27. May 2003, 01:35: Message edited by: sealeopard ]119568CookieControl119LonkeroCookieControl() 
- control cookie handling1084549214Code:


;FUNCTION 

;	CookieControl() 

; 

;AUTHOR 

;	Lonkero (Jooel_Nieminen@hotmail.com) 

; 

;ACTION 

;	Allow/disallow or set to default state cookies from given domain.

; 

;VERSION 

;	1.1 

; 

;VERSION HISTORY 

;	1.1 

;		14. May 2004

;		added deny and clear.

;	1.0 

;		14. May 2004

;		Initial public version.

; 

;SYNTAX 

;	 CookieControl( ADDY [, SET]) 

; 

;PARAMETERS 

; 

;	ADDY

;	 - the address-space who's cookies should be allowed

;	SET (optional)

;	 - if specified:

;		1 - allow cookies from this domain

;		2 - use defaults for this domain

;		5 - deny cookies from this domain

;	 - if not specified, returns the current state

; 

;RETURNS

;	nothing when SET specified.

;	if state not specified, returns current state (same numbers as in set).

; 

;REMARKS  

;	been in production at work. thought someone else might find it usefull too.

;	oh, tested only on IE6 so if problems found, let me know.

;  

;DEPENDENCIES 

;	kixtart 4.20 

; 

;EXAMPLE  

;	"allowing cookies from kixtart.org"

;	AllowCookie("kixtart.org",1) 

;	? "and denying them right away"

;	AllowCookie("kixtart.org",5) 

;	? "hey, why not just remove the setting"

;	AllowCookie("kixtart.org",2) 

;  

;SOURCE  

function CookieControl($,optional $1)

 if $1

  if $1=2

   $=delkey("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\P3P\History\"+$)

  else

   $=writevalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\P3P\History\"+$,"",$1,"REG_DWORD")

  endif

 else

  $CookieControl=readvalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\P3P\History\"+$,"")

  if not $CookieControl $CookieControl=2 endif

 endif

endfunction 

84164Coord119LonkeroCoord() - calculates destination coordinates0

code:

;FUNCTION
;		coord()
;
;AUTHOR
;		Lonkero (Jooel_Nieminen@hotmail.com)
;
;ACTION
;		calculates destination coordinates for given start, distance and degree
;
;VERSION	1.2
;
;CHANGES
;		1.2 (07.4.2003) - moved sub-function to sub-script and published in UDF forum
;		1.1 (04.2.2003) - fixed bugs
;		1.0 (03.2.2003) - initial release
;
;SYNTAX
;		 coord(X,Y,DISTANCE,DEGREE)
;
;PARAMETERS
;
;		X		- Starting x-position
;		Y		- Starting y-position
;		DISTANCE	- length of the space between start and destination
;		DEGREE		- the degree for the direction of the destination (0-360)
;
;RETURNS
;		Destination coordinates in 2 element array X,Y
;
;REMARKS
;		sure, it does not look so good on console as there is not so many lines etc...
;		but fire it with KiXforms and you see it's power!
;
;DEPENDENCIES
;		kixtart ;)
;
;EXAMPLE
;		for $=0 to 350 step 10
;		 $a=coord(11,11,10,$)
;		 at($a[1],$a[0]) "."
;		next
;
;SOURCE
function coord($x,$y,$dist,$deg)
 dim $,$1,$2,$3,$4
 select case $deg=0 $coord=$x,$y+$dist 
  case $deg=90 $coord=$x+$dist,$y
  case $deg=180 $coord=$x,$y-$dist
  case $deg=270 $coord=$x-$dist,$y
  case $deg<90 $2=$deg gosub sides $coord=$x+$4[1],$y+$4[0]
  case $deg<180 $2=$deg-90 gosub sides $coord=$x+$4[0],$y-$4[1]
  case $deg<270 $2=$deg-180 gosub sides $coord=$x-$4[1],$y-$4[0]
  case 1 $2=$deg-270 gosub sides $coord=$x-$4[0],$y+$4[1]
 endselect
 :sides
  $1=0.+$dist*$dist
  $3=90.-$2
  do $=0.01+$ until $1<($*$2)*($*$2)+($*$3)*($*$3)
  $4=$*$3,$*$2
 return
endfunction

84736CopyList2761CitrixManCopyList() - Copies contents of a KiXforms list 
to clipboard0

;FUNCTION 	CopyList() 

;  

;ACTION		Copies the contents of a KiXforms listbox to the clipboard 

;  

;AUTHOR 	Shane Ptomey (CitrixMan) 

;  

;CONTRIBUTORS 	Shawn & Sealeopard 

;  

;VERSION 	1.0 

;  

;DATE CREATED 	11/11/2003 

;  

;DATE MODIFIED 	 

;  

;KIXTART 	wkix32.exe v4.11 

; 

;KIXFORMS	kixforms.dll v2.30 Beta 3 (2.3.0.41) 

;  

;SYNTAX 	CopyList(FORM NAME,LIST NAME,Optional USER FRIENDLY LIST NAME)  

;  

;PARAMETERS 	FORM NAME 

; 		Name of Form that you want to copy the listbox from...Must be passed with 2 $'s as so... $$formname 

;  

; 		LIST NAME 

; 		Name of the listbox that you want to copy...Must be passed with 2 $'s as so... $$listname 

;  

; 		USER FRIENDLY LIST NAME  

; 		User Friendly name of the listbox that you want to copy...Optional 

;  

;RETURNS 	Nothing 

;  

;REMARKS 	 

;  

;DEPENDENCIES 	KiX and KiXforms 

;  

;KIXTART BBS 	http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=2&t=004646 

; 

;EXAMPLE 
;		Break On 

;		$Form = CreateObject("Kixtart.Form") 

;		$TestList = $Form.Controls.ListBox 

;		$TestList.AddItem ("Test Line 1") 

;		$TestList.AddItem ("Test Line 2") 

;		$TestList.AddItem ("Test Line 3") 

;		$ListCopyButton = $Form.Controls.ToolButton ("",250,10,15,15) 

;		$ListCopyButton.Icon = 8 

;		$ListCopyButton.onclick = "CopyList ($$Form,$$TestList,'TEST LIST')" 

;		$ListCopyButton.ToolTipText = "Copy List To ClipBoard" 

;		$ListCopyButton.BorderStyle = 0 

;		$ListCopyButton.FlatStyle = 1 

;		$Form.Center 

;		$Form.Show 

;		While $Form.Visible 

;		  $=Execute($Form.DoEvents()) 

;		Loop 

;		Exit 

; 

; 

FUNCTION CopyList($formname,$listname,OPTIONAL $friendlylistname)

   Dim $formname, $listname, $friendlylistname, $x, $HiddenBox

   If $listname.ListCount > 0

      $HiddenBox = $formname.TextBox("",0,0,-1,-1)

      If $friendlylistname

         $HiddenBox.Text = $friendlylistname+@CRLF+"--------------------"

      Endif

      For $x=0 to $listname.ListCount-1

         $listname.ListIndex = $x

         If Len ($HiddenBox.Text) > 0

            $HiddenBox.Text = $HiddenBox.Text+@CRLF+$listname.Text

         Else

            $HiddenBox.Text = $listname.Text

         Endif

      Next

      $HiddenBox.SelectionStart = 0

      $HiddenBox.SelectionLength = Len ($HiddenBox.Text)

      $HiddenBox.Copy

   Endif

ENDFUNCTION

[ 11. November 2003, 23:14: Message edited by: CitrixMan ]118135CopyListView2761CitrixManCopyListView() 
- Used To Copy KiXforms ListView0Code:

;FUNCTION 	CopyListView() 

;  

;ACTION		Copies either all contents or selected item of a KiXforms listview to the clipboard 

;

;AUTHOR 	Shane (CitrixMan) 

;  

;CONTRIBUTORS 	Shawn & Sealeopard & Jochen

;

;VERSION 	1.0

;

;DATE CREATED 	04/15/2004

;  

;DATE MODIFIED	none

;

;KIXTART Ver 	wkix32.exe v4.11

;

;KIXFORMS Ver	kixforms.dll v2.30 Beta 3 (2.3.0.41)

;

;SYNTAX 	CopyListView(FORM NAME,LIST VIEW NAME,ENTIRE OR SELECTED (1 or 0),DELIMITER,Optional USER FRIENDLY LIST NAME)

;  

;PARAMETERS 	FORM NAME 

; 		Name of Form that you want to copy the listbox from...Must be passed with 2 $'s as so... $$formname 

;  

; 		LIST VIEW NAME 

; 		Name of the listview that you want to copy...Must be passed with 2 $'s as so... $$listviewname 

;  

; 		ENTIRE OR SELECTED

; 		Whether to copy entire list or just selected item...Must be 1 or 0...1=entire 0=selected item 

;

; 		DELIMITER

; 		Delimiter that is used to separate the columns

;

; 		USER FRIENDLY LIST NAME  

; 		User Friendly name of the listbox that you want to copy...Optional

;

;RETURNS 	Nothing

;

;REMARKS	none

;

;DEPENDENCIES 	KiX and KiXforms

;  

;KIXFORM BBS 	http://www.kixforms.org/forum/viewtopic.php?t=439

; 

;EXAMPLE 

;		Break On 

;		$Form = CreateObject("Kixtart.Form") 

;		$ListView = $Form.Controls.ListView("") 

;		$ListView.AutoArrange = "True" 

;		$ListView.FullRowSelect = "True" 

;		$ListView.MultiSelect = "True" 

;		$ListView.HideSelection = "False" 

;		$Column1 = $ListView.Columns.Add("Column 1",100,0) 

;		$Column2 = $ListView.Columns.Add("Column 2",100,0) 

;		$Item1 = $ListView.Items.Add("line 1 - Col 1") 

;		$Item1.SubItems(1).Text = "line 1 - Col 2" 

;		$Item2 = $ListView.Items.Add("line 2 - Col 1") 

;		$Item2.SubItems(1).Text = "line 2 - Col 2" 

;		$Item3 = $ListView.Items.Add("line 3 - Col 1") 

;		$Item3.SubItems(1).Text = "line 3 - Col 2" 

;		$ListCopyButton = $Form.Controls.ToolButton ("",250,10,15,15) 

;		$ListCopyButton.Icon = 8 

;		$ListCopyButton.onclick = "CopyListView ($$Form,$$ListView,1,'	','Test List')"

;		$ListCopyButton.ToolTipText = "Copy List To ClipBoard" 

;		$ListCopyButton.BorderStyle = 0 

;		$ListCopyButton.FlatStyle = 1 

;		$Form.Center 

;		$Form.Show 

;		While $Form.Visible 

;		  $=Execute($Form.DoEvents()) 

;		Loop 

;		Exit 1 

; 

; 

FUNCTION CopyListView($formname,$listviewname,$entire,$delimiter,OPTIONAL $friendlylistname) 

   Dim $item,$x,$copylistviewhiddenbox, $i 

   If $listviewname 

      $copylistviewhiddenbox = $formname.TextBox("",0,0,-1,-1) 

      If $friendlylistname 

         $copylistviewhiddenbox.Text = $friendlylistname+@CRLF+"--------------------" 

      Endif 

      If $entire 

         For Each $item in $listviewname.Items 

            If Len ($copylistviewhiddenbox.Text) > 0 

               $copylistviewhiddenbox.Text = $copylistviewhiddenbox.Text+@CRLF+$item.Text 

               for $i = 1 to $listviewname.Columns.Count - 1 

                   $copylistviewhiddenbox.Text = $copylistviewhiddenbox.Text+$delimiter+$item.SubItems($i).Text 

               next 

            Else 

               $copylistviewhiddenbox.Text = $item.Text 

               for $i = 1 to $listviewname.Columns.Count - 1 

                   $copylistviewhiddenbox.Text = $copylistviewhiddenbox.Text+$delimiter+$item.SubItems($i).Text 

               next 

            Endif 

         Next 

      Else 

         For Each $item in $listviewname.SelectedItems 

            If Len ($copylistviewhiddenbox.Text) > 0 

               $copylistviewhiddenbox.Text = $copylistviewhiddenbox.Text+@CRLF+$item.Text 

               for $i = 1 to $listviewname.Columns.Count - 1 

                   $copylistviewhiddenbox.Text = $copylistviewhiddenbox.Text+$delimiter+$item.SubItems($i).Text 

               next 

            Else 

               $copylistviewhiddenbox.Text = $item.Text 

               for $i = 1 to $listviewname.Columns.Count - 1 

                   $copylistviewhiddenbox.Text = $copylistviewhiddenbox.Text+$delimiter+$item.SubItems($i).Text 

               next 

            Endif 

         Next 

      Endif 

      $copylistviewhiddenbox.SelectionStart = 0 

      $copylistviewhiddenbox.SelectionLength = Len ($copylistviewhiddenbox.Text) 

      $copylistviewhiddenbox.Copy 

   Endif 

ENDFUNCTION

166519CopyToClipboard5694WittoCopyToClipboard() Copy string to Clipboard1156877310

;ACTION 	Copy string to Clipboard  
;  
;AUTHOR 	Wim Rotty  
;  
;CONTRIBUTORS 	  
;  
;VERSION 	1.0.0.0  
;		1.0.0.1	Added return value and error 
;  
;DATE CREATED 	2006-08-28  
;  
;DATE MODIFIED 2006-08-28  
;  
;KIXTART 	Tested with Kixtart version 4.53 Beta 2  
;  
;SYNTAX 	CopyToClipboard($strCopy) 
;  
;PARAMETERS 	$strCopy: String of text you want to copy to the clipboard  
; 		  
;  
;RETURNS	True	(-1)		success  
;		False		failure  
;  
;REMARKS 	This code is borrowed from the scripting guys pages and wrapped up in an UDF  
;		Hey, Scripting Guy! Can I Copy Script Output to the Clipboard?  
;		http://www.microsoft.com/technet/scriptcenter/resources/qanda/aug04/hey0813.mspx  
;  
;DEPENDENCIES 	I presume Internet Explorer has to be at least version 5  
; 		  
;EXAMPLE 	CopyToClipboard("This text has been copied to the clipboard.")  
;  
;KIXTART BBS 	http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=166778&an=0&page=0#166778  
; 		  
;  

Function CopyToClipboard($strCopy)
	Dim $objIE
	$objIE = CreateObject("InternetExplorer.Application")
	$objIE.Navigate("about:blank")
	$CopyToClipboard = $objIE.document.parentwindow.clipboardData.SetData("Text",$strCopy)
	$objIE.Quit
	Exit @ERROR
EndFunction
137125CountFiles52NTDOCCountFiles() - Counts the number of specified files 
in a folder0

;Function	CountFiles()  
;  
;Author		NTDOC  
;  
;Contributors	Lonkero 
;  
;Action		Counts the number of specified files in a given folder  
;		(not recursive, i.e. does not support sub-folders)  
;  
;Syntax		CountFiles($Folder,$Type)  
;  
;NOTE	 
; 
;Version	1.0  
;  
;Date		2005/04/04  
;  
;Date Revised  
;  
;Reason Revised  
;  
;Remarks	You must not supply a trailing backslash to the folder name.  i.e.   
;		C:\TEMP is valid  C:\TEMP\ is not. 
;  
;Returns	The the number of specified files  
;  
;Dependencies	None 
;  
;KiXtart	Ver 4.2x  
;  
;Example:  
;		$Folder = '\\SERVER\SHARE\ExpenseReports' 
;		$Archives = CountFiles($Folder,'*.XLS')   
;		;Check to see how many Excel files exist 
;		? 'There are ' + $Archives + ' Excel files in the folder.' ? 
;		If $Archives > 200 ; If more then 200 files exist then print out message 
;		  ? 'Warning... There are now more then 200 Excel files in the ' + 
;		  $Folder + ' directory.   ' 
;		  ? 'You should consider cleaning up or moving some to a CD or DVD' ? 
;		EndIf 
; 
;CODE 
 

Function CountFiles($Folder,$Type)
  Dim $Index,$File
  $Index = 0
  $File = Dir($Folder+'\'+$Type)
  While @ERROR = 0
    If Not (GetFileAttr($File) & 16)
      $Index = $Index + 1
    EndIf
   $File = Dir()
  Loop
  $CountFiles=$Index
EndFunction
 
83492CPUNAME1989WaltzCPUNAME() - Translate 'family' & 'model' to CPU 'name'0Thanks 
to all for their valued input to this routine. Refer to http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=1;t=005581 
for thread history.
Updated to include a check for Intel as the CPU vendor. 

code:

;FUNCTION	CPUNAME()
;
;AUTHOR		Waltz
;
;CONTRIBUTOR	Torgeir Bakken
;
;ACTION		Translates Intel CPU 'family' and 'model' registry identifiers to an Intel CPU 'name'
;
;SYNTAX		CPUNAME($machine)
;
;VERSION	1.1
;
;PARAMETERS 	REQUIRED: $machine 	- string containing the name of the computer to query
;			  		- if a null string is passed, @WKSTA is queried
;
;REMARKS	- Why: To mimic KiXtart @CPU Macro for remote PCs
;		- Caveat: All the literature maintains that using Family and Model is NOT reliable
;		- Employs: a registry read,instead of a WMIQUERY() on Win32_Processor Description, as
;		  	WMI Win32_Processor Identifier may not return expected result
;		  	e.g. some P III processors are reported as 'Unknown Intel P6 processor'
;		  	reference: MS KB Article - Q289514
;		- Does not differentiate between processors of the same type
;		- Applies only to Intel Family(s) 5, 6, and 15
;		- Source: Intel Processor Identification and CPUID Instruction
;				Family	Model		Type
;				5	< 4		Pentium
;				5	>= 4		Pentium MMX
;				6	< 3		Pentium Pro
;				6	>= 3 < 5	Pentium II
;				6	== 5		Pentium II or Celeron
;				6	== 6		Celeron
;				6	>= 6		Pentium III
;				15	>= 0		Pentium 4 
;		
;
;RETURNS	- string containing Intel CPU 'Name'
;		- @ERROR return codes
;		
;DEPENDENCIES 	- None
;
;KIXTART VER	- KIX32 4.10a
; 
;EXAMPLES
;		? "Example 1 - Parameter is a null string" ?
;			$cpuname = CPUNAME("")
;        		IF @ERROR = 0
;     				? " Computer "+@WKSTA+" has Processor Type "+$cpuname
;			ELSE
;				? " CPUNAME() failed with : "+@error+" : "+@serror
;			ENDIF
;		?
;		
;		? "Example 2 - Parameter is a valid computer name" ?
;			$machine = remote_PC_foobar123
;			$cpuname = CPUNAME($machine)
;        		IF @ERROR = 0
;     				? " Computer "+$machine+" has Processor Type "+$cpuname
;			ELSE
;				? " CPUNAME() failed with : "+@error+" : "+@serror
;			ENDIF
;		?		
FUNCTION CPUNAME($machine)
	DIM $rv_cpu, $rv_cpu_vendor, $cpu_id_array, $cpu_family, $cpu_model, $k
	IF $machine = ""	$machine = @WKSTA	ENDIF
	$rv_cpu_vendor=READVALUE("\\$machine\HKEY_LOCAL_MACHINE\Hardware\Description\System\CentralProcessor\0","VendorIdentifier")
        IF $rv_cpu_vendor <> "GenuineIntel"
		$cpuname = "Unknown : Non-Intel"
		EXIT (0)
	ELSE
		$rv_cpu_vendor = SUBSTR($rv_cpu_vendor,8)
	ENDIF
	$rv_cpu=READVALUE("\\$machine\HKEY_LOCAL_MACHINE\Hardware\Description\System\CentralProcessor\0","Identifier")
	IF @ERROR <> 0	EXIT (@ERROR)	ENDIF
	$cpu_id_array = SPLIT($rv_cpu)
	FOR $k = 0 TO UBOUND($cpu_id_array)
		IF TRIM(($cpu_id_array[$k])) == "Family"
			$cpu_family = CINT($cpu_id_array[$k+1])
		ENDIF
		IF TRIM(($cpu_id_array[$k])) == "Model"
			$cpu_model = CINT($cpu_id_array[$k+1])
		ENDIF
	NEXT
	SELECT
	  CASE $cpu_family = 5 AND $cpu_model < 4
		$cpuname = $rv_cpu_vendor+" Pentium"
	  CASE $cpu_family = 5 AND $cpu_model >= 4
		$cpuname = $rv_cpu_vendor+" Pentium MMX"
	  CASE $cpu_family = 6 AND $cpu_model < 3
		$cpuname = $rv_cpu_vendor+" Pentium Pro"
	  CASE $cpu_family = 6 AND $cpu_model >= 3 AND $cpu_model < 5
		$cpuname = $rv_cpu_vendor+" Pentium II"
	  CASE $cpu_family = 6 AND $cpu_model == 5
		$cpuname = $rv_cpu_vendor+" Pentium II or Celeron"
	  CASE $cpu_family = 6 AND $cpu_model == 6
		$cpuname = $rv_cpu_vendor+" Celeron"
	  CASE $cpu_family = 6 AND $cpu_model >= 7
		$cpuname = $rv_cpu_vendor+" Pentium III"
	  CASE $cpu_family = 15 AND $cpu_model >= 0
		$cpuname = $rv_cpu_vendor+" Pentium 4"
	  CASE 1
		$cpuname = $rv_cpu_vendor+" : Unknown"
	ENDSELECT
	EXIT (0)
ENDFUNCTION



[ 19. September 2002, 14:40: Message edited by: Waltz ]84441CreateADGroup172Howard 
BullockCreateADGroup() - Create any group type in a specific container0

;FUNCTION         CreateADGroup() 

; 

;VERSION          1.0 

; 

;AUTHOR           Howard A. Bullock (habullock@comcast.net) 

; 

;ACTION           Create a group of the specified type in the specified container. 

; 

;SYNTAX           CreateADGroup ($Container, $GrpName, $GrpType, $SecurityEnabled, optional $Description, optional $SAMAcctName) 

; 

;PARAMETERS       $Container (Required) -  String [dinstinguished name of container] 

;                 $GrpName (Required) -  String 

;                 $GrpType (Required) -  String [local | global | universal] 

;                 $SecurityEnabled (Required) -  Integer [0 or 1] 

;                 $Description (Optional) - String 

;                 $SAMAcctName (Optional) - String 

; 

; 

;REMARKS          SamAccountName CANNOT be longer than 20 characters. It will automatically 

;                 be trimmed if necessary. 

; 

;RETURNS          1 if success; 0 if failed; sets @error 

; 

;DEPENDENCIES     ADSI 

; 

;EXAMPLES         Create a local "distribution list" group 

;                 $DN_of_OU = "OU=test,OU=9826,OU=Departments,DC=domain,DC=com" 

;                 if CreateADGroup ($DN_of_OU, "HABtest", "local", 0, "KiXtart Test") 

;                    ? "Group successfully created" 

;                 else 

;                    ? "CreateADGroup Failed with Error: " + @error 

;                 endif 

; 

;                 Create a global "security" group 

;                 $DN_of_OU = "OU=test,OU=9826,OU=Departments,DC=domain,DC=com" 

;                 if CreateADGroup ($DN_of_OU, "HABtest2", "global", 1, "KiXtart Test") 

;                    ? "Group successfully created" 

;                 else 

;                    ? "CreateADGroup Failed with Error: " + @error 

;                 endif 

; 

; 

Function CreateADGroup ($Container, $GrpName, $GrpType, $SecurityEnabled, optional $Description, optional $SAMAcctName)



    ;ADS_GROUP_TYPE_GLOBAL_GROUP       = 0x00000002, 

    ;ADS_GROUP_TYPE_DOMAIN_LOCAL_GROUP = 0x00000004, 

    ;ADS_GROUP_TYPE_LOCAL_GROUP        = 0x00000004, 

    ;ADS_GROUP_TYPE_UNIVERSAL_GROUP    = 0x00000008, 

    ;ADS_GROUP_TYPE_SECURITY_ENABLED   = 0x80000000 



    Dim $oOU, $oNewGrp, $error



    $CreateADGroup = 0



    Select

        Case $GrpType = "local"        $GrpType = &00000004

        Case $GrpType = "global"       $GrpType = &00000002

        Case $GrpType = "universal"    $GrpType = &00000008

        Case 1

            ;WriteLog2($LogFile, "Function: CreateADGroup - Parameter(GrpType) Error: " + @error + "  " + @serror 

            exit 87

    EndSelect

    If not ($SecurityEnabled = 1 or $SecurityEnabled = 0)

        ;WriteLog2($LogFile, "Function: CreateADGroup - Parameter(SecurityEnabled) Error: " + @error + "  " + @serror) 

        exit 87

    EndIf

    If $SecurityEnabled

        $GrpType = $GrpType | &80000000

    EndIF



    If VarTypeName($SAMAcctName) = "Empty"

        $SAMAcctName = $GrpName

    EndIf

    If Len($SAMAcctName) > 20 

        ; "SamAccountName CANNOT be bigger than 20 characters" 

        $SAMAcctName = left($SAMAcctName, 20)

        ;WriteLog2($LogFile, "Function: CreateADGroup - Trimming SAMAcctName to 20 characters") 

    EndIf





    $oOU = GetObject("LDAP://" + $Container)

    $error = @error

    If $error = 0

        $oNewGrp = $oOU.Create("group", "CN=" + $GrpName)

        $oNewGrp.Put("sAMAccountName", $SAMAcctName)

        $oNewGrp.Put("GroupType", $GrpType)

        If VarTypeName($Description) <> "Empty"

            $oNewGrp.Put("Description", $Description)

        Endif

        $oNewGrp.SetInfo

        $error = @error

        If $error <> 0

            ;WriteLog2($LogFile, "Function: CreateADGroup - SetInfo Error: " + @error + "  " + @serror) 

        EndIf

    Else

        ;WriteLog2($LogFile, "Function: CreateADGroup - Get OU Error: " + @error + "  " + @serror) 

    EndIf

    $oOU = 0

    $oNewGrp = 0

    if $error = 0

        $CreateADGroup = 1

    endif

    exit $error

EndFunction



[ 23. October 2003, 14:29: Message edited by: Howard Bullock ]120687createBKS119LonkerocreateBKS() 
- create selections file for NTBackup1131146822

;Function:	createBKS() 
; 
;Authors:	Lonkero 
; 
;Version:	1.1 (5th of nov 2005) 
;		 - uses kixforms .net now instead of kixbin.dll 
;		1.0 (6th of june 2004) 
; 
; 
;Action:	creates NTBACKUP bks (backup selections) file 
; 
;Syntax:	createBKS(FILE, PATHS) 
; 
;Parameters: 
;		FILE	- file to create (if exists, will be overwritten) 
;		PATHS	- (array) the include paths/files for the selections file 
; 
;Returns: 
;		Nothing 
; 
;Dependencies: 
;		KiXforms .net 
; 
;Remarks: 
;		if file exists, it will be overwritten. 
; 
;Example:	 
;		$paths="c:\","f:\digi","f:\programfiles\authoring\myprojects" 
;		createBKS("c:\ntbackuptasks\weekly.bks",$paths) 
; 
;Source: 
function createBKS($file,$paths)
dim $kixbin,$i,$bytes,$kf
 $kf=createobject("kixforms.system")
 $kixbin=$kf.FileStream($file, $kf.FileMode_Create, $kf.FileAccess_ReadWrite, $kf.FileShare_none)
 $paths=join($paths,@crlf)
 for $i=1 to len($paths)
  $kixbin.writeByte(substr($paths,$i,1))
 next
endfunction
84561CreateGUID17SealeopardCreateGUID - Creates a GUID (globally unique 
identifier)0

code:

;FUNCTION      CreateGUID
;
;ACTION        Creates a GUID (globally unique identifier)
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;CONTRIBUTORS  Mark A. (ScriptLogic BBS)
;
;VERSION       1.1 (renamed from GetGUID to CreateGUID to prevent naming conflict)
;              1.0
;
;DATE CREATED  2003/09/19
;
;DATE MODIFIED 2003/09/19
;
;KIXTART       4.22 RC-1
;
;SYNTAX        CREATEGUID([FORMAT])
;
;PARAMETERS    FORMAT
;              Optional integer denoting the GUID format
;              1 = remove curly parentheses
;              2 = remove curly parentheses and dashes
;
;RETURNS       GUID
;
;REMARKS       none
;
;DEPENDENCIES  requires IE4.0+
;
;EXAMPLE       $guid=createguid()
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000461
;
function CreateGUID(optional $format)
  $createguid = CreateObject("Scriptlet.TypeLib").guid
  if @ERROR exit @ERROR endif
  select
    case $format=1
      $createguid=right(left($createguid,-1),-1)
    case $format=2
      $createguid=join(split(right(left($createguid,-1),-1),'-'),'')
  endselect
  exit @ERROR
endfunction



[ 29. September 2003, 02:43: Message edited by: sealeopard ]83606CreateShare31RadimusCreateShare() 
- creates remote shares0this is based on the UDF from KiXscripts.com, but it a 
bit more enhanced, as it will create the remote folder, if it doesn't exist.

Syntax: CreateShare($Server, $ShareName, $SharePath, optional $Domain)

Example:

code:

$server	="server1"
$folder	="c:\test\share"
$share	="Test Share"
CreateShare($server, $share, $folder)

Dependancies: MakePath() , Replace() 

code:

Function CreateShare($Server, $ShareName, $SharePath, optional $Domain)

	if not $domain		$domain	="@domain"	endif
	if not $server		$server	="@wksta"	endif

	$unc	=REPLACE("$folder",":","$$")
	$uncpath="\\$server\$unc"
	if not exist("$uncpath")
		$path=makepath("$uncpath")
		endif 

	$FService	= GetObject ("WinNT://$Domain/$Server/LanmanServer,FileService")
	$FileShare	= $FService.Create ("FileShare", $ShareName)
	$FileShare.Path = $SharePath
	$FileShare.MaxUserCount = -1	; -1 allows unlimited connections.  Any other positive number
	$FileShare.SetInfo
	$FService	= 0
	$FileShare	= 0										
	EndFunction



[ 25. October 2002, 14:42: Message edited by: Radimus ]180382CreateShareWMI5931apronkCreateShareWMI() 
- Creates a Share (Properly)0

Code:

;Function	CreateShareWMI() - Creates a Share (Properly)
;
;Author		Arend Pronk (arendpronk@gmail.com)
;
;Action		Creates a Share properly so other UDF's can get ACL info from it.
;
;Syntax		CreateShareWMI($strFolder, $strName, Optional $intMaxAllowed, Optional $strDescription, Optional $strPassword)
;
;Version  	1.0
;
;Date 		11-09-2007
;
;Parameters 	$strFolder (Mandatory) - String value ie: "C:\MyShare"
;		$strName (Mandatory) - String value ie: "MyShare"
;		$intMaxAllowed (Optional) - Integer value ie: 0 (for unlimited), 1 (or more for the allowed users at once)
;		$strDescription (Optional - String value ie: "My First Share"
;		$strPassword (Optional) - String value ie: "MyPassword"
;
;Returns  	0 When no errors occur, @ERROR when errors occur.
; 
;Dependencies 	Windows Management Instrumentation (WMI) 
;
;KiXtart Ver.	4.53
; 
;Example(s)	? CreateShareWMI("D:\ShareTest","ShareTest",2,"Test Share")
;		will create a share from the folder "D:\ShareTest" with the sharename "ShareTest", 2 maximum allowed users
;		and with a Description that says "Test Share"
;
Function CreateShareWMI($strFolder, $strName, Optional $intMaxAllowed, Optional $strDescription, Optional $strPassword)
  Dim $objWMIService, $objNewShare, $SD
  $objWMIService = GetObject("winmgmts:\\.\root\cimv2")
  $objNewShare = $ObjWMIService.Get("Win32_Share")
  $SD = $objWMIService.Get("Win32_SecurityDescriptor").SpawnInstance_()
  $=$objNewShare.Create($strFolder,$strName,0,$intMaxAllowed,$strDescription,$strPassword,$SD)
  $CreateShare = @ERROR
EndFunction


You might think "Another Share creation script, haven't we got enough of those?". 
The answer is basically yes, however none of the existing scripts add SD info so 
that the ACL list of the share can be read or manipulated. For instance my 
SharePerms UDF and jooel's SharePerms UDF (yes 2 UDF's with the same name) won't 
work with any other script. They do with this UDF because it does set a SD (SecurityDescriptor).

Future versions will include remote PC support, I haven't got the time to test 
and implement it now.134168CSV2980Glenn BarnasCSV() - convert between array 
and CSV string0I have several Kix scripts for data collection and 
consolidation, and created this to output CSV format data for use by Excel. 
Added the CSV to Array after I needed to modify some of the data that was 
generated.

Basically, if you feed it an array of data, it returns a string delimited with 
commas. If any field contains a comma, that field is enclosed in quotes. 
Conversely, if you feed it a CSV string, it will return an array of fields split 
on the commas that are not inside of quotes.




;; 
;;====================================================================== 
;; 
;;FUNCTION       csv() 
;; 
;;ACTION         Converts between CSV record and array 
;; 
;;AUTHOR         Glenn Barnas  
;; 
;;VERSION	 1.1 - 2006/12/06 
;;               added @ERROR test so when used as $X=csv(ReadLine(2)) 
;;               the error from the embedded ReadLine would be acted upon. 
;; 
;;SYNTAX         csv(record) 
;; 
;;PARAMETERS     record - data to be converted 
;;                      If String - returns array of fields 
;;                      If Array - returns comma-delimited string 
;;                      Fields are delimited with commas. If a field contains a comma, 
;;                      that field is enclosed in double-quotes (") 
;; 
;;REMARKS         
;; 
;;RETURNS        CSV format string or array of fields 
;; 
;;DEPENDENCIES   none 
;; 
;;TESTED WITH    NT4, W2K, WXP 
;; 
;;EXAMPLES       ; Load an array from a CSV record 
;;                      $Array = CSV('this,that,"a,whole,lot,of,things"') 
;;                      ; create a CSV record from an array 
;;                 $Ary = 'that','this','several,common,things' 
;;                      $Record = CSV($Ary) 
;; 
 
 
Function CSV($_Record)
 
  ; Handle embedded ReadLine errors passed to this wrapper func 
  If @ERROR Exit @ERROR EndIf
 
  Dim $_C, $_D, $_DF, $_F, $_I, $_L, $_Q, $_QC, $_QP, $_QT, $_Tmp
 
  $_D = Chr(5)					; invisible delimiter 
  $_Q = Chr(4)					; invisible quote 
  $_DF = 0					; Delimiter status 
  $_Tmp = ''
 
  If VarType($_Record) > 8192			; have array, convert to record 
 
    For $_F = 0 to UBound($_Record)
      $_Tmp = ''
      ; Convert embedded quotes to double quotes 
      $_L = Len($_Record[$_F])
      For $_I = 1 to $_L
        $_C = SubStr($_Record[$_F], $_I, 1)
        $_Tmp = $_Tmp + $_C
        If $_C = '"' $_Tmp = $_Tmp + '"' EndIf
      Next
      $_Record[$_F] = $_Tmp
 
      ; encase field in quotes if needed 
      If InStr($_Record[$_F], ',') Or InStr($_Record[$_F], '"')
        $_Record[$_F] = '"' + $_Record[$_F] + '"'
      EndIf
      If $_F < UBound($_Record)			; add ',' to all but last field 
        $_Record[$_F] = $_Record[$_F] + ','
      EndIf
      $CSV = $CSV + $_Record[$_F]			; create the output record 
    Next
 
  Else						; have record, convert to array 
 
    ; Handle embedded quotes 
    ; Triple quotes - have to handle leading vs trailing 
    $_QC = 1
    $_QT = 0
    While $_QC
      $_QP = InStr($_Record, '"""')
      If $_QP > 0
	If $_QT = 0
	  $_Record = Left($_Record, $_QP) + $_Q + SubStr($_Record, $_QP + 3)
          $_QT = Not $_QT
	Else
	  $_Record = Left($_Record, $_QP - 1) + $_Q  + SubStr($_Record, $_QP + 2)
          $_QT = Not $_QT
        EndIF
      Else
	$_QC = 0
      EndIf
    Loop
 
    ; double quotes - become single quotes in the data field 
    $_QC = 1
    While $_QC
      $_QP = InStr($_Record, '""')
      If $_QP > 0
	$_Record = Left($_Record, $_QP - 1) + $_Q + SubStr($_Record, $_QP + 2)
      Else
	$_QC = 0
      EndIf
    Loop
 
    $_L = Len($_Record)
    For $_I = 1 to $_L
      $_C = SubStr($_Record, $_I, 1)
      Select
        Case $_C = '"'				; quoted data, (re)set flag 
          $_DF = Not($_DF)
        Case $_C = ',' And Not $_DF		; valid delimiter, add special delimiter to string 
          $_Tmp = $_Tmp + $_D
        Case 1					; normal data, add character to string 
          $_Tmp = $_Tmp + $_C
      EndSelect
    Next
 
    $CSV = Split(Join(Split($_Tmp, $_Q), '"'), $_D); prepare to return the array 
 
  EndIf
 
EndFunction
 
 
 


83061cTime17SealeopardcTime() - Converts a cTime time into Kixtart format0

code:

;FUNCTION      cTime()
;
;ACTION        Converts a cTime time into Kixtart format
;
;AUTHOR        Richard Howarth
;              Modified by Sealeopard
;
;VERSION       1.2
;
;KIXTART       4.12+
;
;SYNTAX        RETCODE = CTIME(SECONDS[, OFFSET])
;
;PARAMETERS    SECONDS
;              time in cTime format seconds
;
;              OFFSET
;              local time offset in hours
;
;RETURN        date and time in KiXtart format, i.e. 'YYYY-MM-DD HH:MM:SS'
;
;REMARKS       The algorithm used here is base in part on the following document:
;              http://www.capecod.net/~pbaum/date/date0.htm
;              Originally posted by Richard Howarth at
;              http://81.17.37.55/board/ultimatebb.cgi?ubb=get_topic;f=4;t=000186
;
;DEPENDENCIES  none
;
;EXAMPLE       $retcode = cTime('1015861584',6)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000191
;
Function cTime($iSeconds,optional $iOffset)
  Dim $iEpoch, $iDays, $iZ, $iH, $iA, $iB, $iC
  Dim $iYear, $iMonth, $iDay, $iHour, $iMinutes

  $iEpoch=719163

  ; Adjust time for local
  $iSeconds=Val($iSeconds)+(Val($iOffset*3600))
  $iDays=$iSeconds/86400
  $iSeconds=$iSeconds-($iDays*86400)

  $iDays=$iDays+$iEpoch

  $iZ=$iDays + 306
  $iH=100*$iZ-25
  $iA=$iH/3652425
  $iB=$iA-$iA/4
  $iYear=(100*$iB+$iH)/36525
  $iC=$iB+$iZ-365*$iYear-$iYear/4
  $iMonth=(5*$iC+456)/153
  $iDay=$iC-(153*$iMonth-457)/5

  if $iMonth > 12
    $iYear=$iYear + 1
    $iMonth = $iMonth - 12
  endif

  $iHour=$iSeconds / 3600
  $iMinutes=($iSeconds-$iHour*3600)/60
  $iSeconds=$iSeconds-$iHour*3600-$iMinutes*60
  $cTime=''+$iYear+'/'+right('00'+$iMonth,2)+'/'+right('00'+$iDay,2)
  $cTime=$cTime+' '+right('00'+$iHour,2)+':'+right('00'+$iMinutes,2)+':'+right('00'+$iSeconds,2)
EndFunction



[ 02. March 2003, 17:06: Message edited by: sealeopard ]82473DateCalc29JochenDateCalc() 
- Calculates Days between or returns calculated Date (Days as modifier) 0 Code:

 ;FUNCTION         DateCalc()
;
;AUTHOR           Jochen Polster (jochenDOTpolsterATgmxDOTnet)
;                 based on date algorithms by Peter Baum to be found here :
;                 http://www.capecod.net/~pbaum/date/date0.htm
;
;VERSION          1.12
;
;VERSION HISTORY  1.0  2001/12/10 Initial release
;
;                 1.1  2004/02/18 Added support for single digit month/day input
;                                 and optional single digit month/day date return
;
;                 1.11 2004/02/20 Minor Variable handling fix
;
;                 1.12 2005/03/31 Finally supports "NoVarsInStrings" and "Explicit" set to "ON" in
;                                 all possible variations
;
;ACTION           Calculates days between 2 dates or returns a date string calculated from
;                 a given date and a given amount of days ( Addition of positive or negative
;                 integer value )
;
;SYNTAX           DateCalc( Date1, Date2|Modifier, [SingleDigit] )
;
;PARAMETERS       Date1 (Required)
;                  -  (Gregorian) Date string in Format : YYYY/M[M]/D[D]
;
;                 Date2|Modifier (Required)
;                  - either a second (Gregorian) date string (YYYY/M[M]/D[D]) to calculate days between
;                    or a positive/negative amount of days to calculate with
;
;                 SingleDigit (Optional)
;                  - if not zero date will be returned unpadded, eg. 2004/2/9
;
;REMARKS          Date format must be KiX friendly : YYYY/M[M]/D[D] (2001/11/20)
;                 To calculate a date less than given assign a negative integer (ie. -45 )
;
;RETURNS          Either a positive integer value of days between two given dates,
;                 or a (Gregorian) date string.
;
;DEPENDENCIES     None !
;
;EXAMPLES
;                 break on
;                 call "[path]DateCalc.udf"
;
;                 "boot.ini last modified : " + DateCalc(@date,substr(getfiletime("c:\boot.ini"),1,10))
;                  + " days ago ..." ? ?
;
;                 $mod = 60
;                 "in/before $mod day(s) it was/will be " + DateCalc(@date,$mod) ? ?
;
;                 get $

function DateCalc($date1, $DateOrMod, optional $SingleDigit)

    dim $_intDate1, $_intYear1, $_intMonth1, $_intDay1
    dim $_intDate2, $_intYear2, $_intMonth2, $_intDay2

    $date1 = split($date1,'/')
    if ubound($date1) <> 2
        exit 1
    endif

    $_intYear1  = val($date1[0])
    $_intMonth1 = val($date1[1])
    $_intDay1   = val($date1[2])

    if $_intMonth1 < 3
        $_intMonth1 = $_intMonth1 + 12
        $_intYear1  = $_intYear1  - 1
    endif

    $_intDate1 = $_intDay1 + ( 153 * $_intMonth1 - 457 ) / 5 + 365 * $_intYear1 +
                 $_intYear1 / 4 - $_intYear1 / 100 + $_intYear1 / 400 - 306

    select

        case vartype($DateOrMod) = 3

            $_intDate2  = $_intDate1 + $DateOrMod
            if instr($_intDate2,'-') $_intDate2 = val(substr($_intDate2,2,len($_intDate2)-1)) endif

            $_intYear2  = ( 100 * ( ( ( 100*($_intDate2+306)-25)/3652425)
                                     - ( ((100*($_intDate2+306)-25)/3652425)/4)
                                   ) + (100*($_intDate2+306)-25)
                           ) / 36525

            $_intMonth2 = (   5 * ( ( ( 100*($_intDate2+306)-25)/3652425)
                                     - ( ((100*($_intDate2+306)-25)/3652425)/4)
                                     + ($_intDate2+306) - 365 * $_intYear2 - $_intYear2 / 4
                                   ) + 456
                           ) / 153

            $_intDay2   = ( ( ( 100*($_intDate2+306)-25)/3652425)
                                     - ( ((100*($_intDate2+306)-25)/3652425)/4)
                                     + ($_intDate2+306) - 365 * $_intYear2 - $_intYear2 / 4
                           )         - ( 153 * $_intMonth2 - 457
                                        ) / 5

            if $_intMonth2 > 12 $_intYear2 = $_intYear2 + 1 $_intMonth2 = $_intMonth2 - 12 endif

            if not $SingleDigit
                if len($_intYear2 ) < 4
                    $_ = execute("for $i=1 to 4-len($$_intYear2) $$_intYear2 = '0' + $$_intYear2 next")
                endif
                $_intMonth2 = right("0" + $_intMonth2,2)
                $_intDay2   = right("0" + $_intDay2,2)
            endif

            $DateCalc = '' + $_intYear2 + '/' + $_intMonth2 + '/' + $_intDay2

        case vartype($DateOrMod) = 8

            $DateOrMod = split($DateOrMod,'/')

            if ubound($DateOrMod) <> 2
                exit 1
            endif

            $_intYear2  = val($DateOrMod[0])
            $_intMonth2 = val($DateOrMod[1])
            $_intDay2   = val($DateOrMod[2])

            if $_intMonth2 < 3
                $_intMonth2 = $_intMonth2 + 12
                $_intYear2  = $_intYear2  - 1
            endif

            $_intDate2 = $_intDay2 + ( 153 * $_intMonth2 - 457 ) / 5 + 365 * $_intYear2 +
                         $_intYear2 / 4 - $_intYear2 / 100 + $_intYear2 / 400 - 306

            $DateCalc  = $_intDate1 - $_intDate2

            ;comment the next line if you wish to return negative results also !!!
            if instr($DateCalc,'-') $DateCalc = val(substr($DateCalc,2,len($DateCalc)-1)) endif

        case 1

            exit 1

    endselect

endfunction
 

83904DateTimeDiff17SealeopardDateTimeDiff() - Calculates the time 
difference between two date-times-groups0

code:

;FUNCTION      DateTimeDiff
;
;ACTION        Calculates the time difference between two date-times-groups
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.1
;
;KIXTART       4.20
;
;SYNTAX        DATETIMEDIFF(DTG1 [,DTG2])
;
;PARAMETYERS   DTG1
;              Required string as a date-time-group (DTG) in one of the following formats:
;              "YYYY/MM/DD HH:MM[:SS.MSECS]"
;              "YYYY/MM/DD" which assumes that HH:MM[:SS.MSECS] = 00:00:00.000
;              "HH:MM[:SS.MSECS]" which assumes that "YYY/MM/DD" = @DATE
;
;              DTG2
;              Optional string as date-time-group (DTG) in one of the following formats:
;              "YYYY/MM/DD HH:MM[:SS.MSECS]"
;              "YYYY/MM/DD" which assumes that HH:MM[:SS.MSECS] = @TIME
;              "HH:MM[:SS.MSECS]" which assumes that "YYY/MM/DD" = @DATE
;              DTG2 will default to the current date and time if not provided in the form of
;              @DATE+' ' +@TIME+'.'+@MSECS
;
;
;
;RETURNS       Returns difference DTG2-DTG1 as "YYYY/MM/DD HH:MM[:SS.MSECS]"
;
;REMARKS       none
;
;DEPENDENCIES  SERIALTIME() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000039
;              SERIALDATE() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000089
;
;EXAMPLE       $rc=DATETIMEDIFF('23:20:33','01:01:01.245')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000374
;
function datetimediff($time1,$time2)
  Dim $date1, $date2, $datediff, $timediff

  $datetimediff=''

  if not instr($time1,' ')
    select
    case instr($time1,'/')
      $time1=$time1+' 00:00:00.000'
    case instr($time1,':')
      $time1=@DATE+' '+$time1
    case 1
      exit 87
    endselect
  endif

  if not instr($time2,' ')
    select
    case instr($time2,'/')
      $time2=$time2+' '+@TIME+'.'+right('000'+@MSECS,3)
    case instr($time2,':')
      $time2=@DATE+' '+$time2
    case 1
      $time2=@DATE+' '+@TIME+'.'+right('000'+@MSECS,3)
    endselect
  endif

  $time1=split($time1,' ')
  $date1=$time1[0]
  $time1=$time1[1]
  $time2=split($time2,' ')
  $date2=$time2[0]
  $time2=$time2[1]

  $datediff=serialdate($date2)-serialdate($date1)
  $timediff=serialtime($time2)-serialtime($time1)
  if $timediff=>86400
    $timediff=$timediff-86400
    $datediff=$datediff+1
  endif
  $datediff=serialdate(serialdate('0000/00/00')+$datediff-1)
  $timediff=serialtime($timediff)

  $datetimediff=$datediff+' '+$timediff
  exit 0
endfunction



[ 11. March 2003, 15:28: Message edited by: sealeopard ]83785DateTimeMath17SealeopardDateTimeMath() 
- Calculates the difference between two date-time strings0

code:

;FUNCTION      DateTimeDiff (formerly DateTimeMath)
;
;ACTION        Calculates the time difference between two date-times-groups
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.1
;
;KIXTART       4.20
;
;SYNTAX        DATETIMEDIFF(DTG1 [,DTG2])
;
;PARAMETYERS   DTG1
;              Required string as a date-time-group (DTG) in one of the following formats:
;              "YYYY/MM/DD HH:MM[:SS.MSECS]"
;              "YYYY/MM/DD" which assumes that HH:MM[:SS.MSECS] = 00:00:00.000
;              "HH:MM[:SS.MSECS]" which assumes that "YYY/MM/DD" = @DATE
;
;              DTG2
;              Optional string as date-time-group (DTG) in one of the following formats:
;              "YYYY/MM/DD HH:MM[:SS.MSECS]"
;              "YYYY/MM/DD" which assumes that HH:MM[:SS.MSECS] = @TIME
;              "HH:MM[:SS.MSECS]" which assumes that "YYY/MM/DD" = @DATE
;              DTG2 will default to the current date and time if not provided in the form of
;              @DATE+' ' +@TIME+'.'+@MSECS
;
;
;
;RETURNS       Returns difference DTG2-DTG1 as "YYYY/MM/DD HH:MM[:SS.MSECS]"
;
;REMARKS       none
;
;DEPENDENCIES  SERIALTIME() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000039
;              SERIALDATE() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000089
;
;EXAMPLE       $rc=DATETIMEDIFF('23:20:33','01:01:01.245')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000374
;
function datetimediff($time1,$time2)
  Dim $date1, $date2, $datediff, $timediff

  $datetimediff=''

  if not instr($time1,' ')
    select
    case instr($time1,'/')
      $time1=$time1+' 00:00:00.000'
    case instr($time1,':')
      $time1=@DATE+' '+$time1
    case 1
      exit 87
    endselect
  endif

  if not instr($time2,' ')
    select
    case instr($time2,'/')
      $time2=$time2+' '+@TIME+'.'+right('000'+@MSECS,3)
    case instr($time2,':')
      $time2=@DATE+' '+$time2
    case 1
      $time2=@DATE+' '+@TIME+'.'+right('000'+@MSECS,3)
    endselect
  endif

  $time1=split($time1,' ')
  $date1=$time1[0]
  $time1=$time1[1]
  $time2=split($time2,' ')
  $date2=$time2[0]
  $time2=$time2[1]

  $datediff=serialdate($date2)-serialdate($date1)
  $timediff=serialtime($time2)-serialtime($time1)
  if $timediff=>86400
    $timediff=$timediff-86400
    $datediff=$datediff+1
  endif
  $datediff=serialdate(serialdate('0000/00/00')+$datediff-1)
  $timediff=serialtime($timediff)

  $datetimediff=$datediff+' '+$timediff
  exit 0
endfunction



[ 27. April 2003, 19:01: Message edited by: sealeopard ]122378DayOfWeek360kasulDayOfWeek() 
- Weekdayname or ~number for a date0 Code:

 

;Function:

;    DayOfWeek()

;

;Author:

;    Klaus Ubben (kasul)

;

;Action:

;    Calculate the Day of the Week for a given date

;

;Syntax:

;    DayOfWeek(date[,format])

;

;Version:

;    1.0

;

;Date:

;    2004/07/08

;

;Parameters:

;    $date: (required)  

;             a date in a Kix-friendly Syntax, one-digit month/day allowed

;

;    $format: (optional)

;             a Number to control OutputFormat                         

;             - negative Values lead to String Output

;		               -1 - Short String (e.g. "THU")

;							     -2 - Full String (e.g. "Thursday")

;                  -any other negative Value => same as 0

;							- positive (and 0) Values lead to numeric Output

;						        offsetting the Start of the Week:

;                   -0 - output from 0 to 6, Sunday=0, Monday=1,...

;                   -1 - output from 0 to 6, Monday=0, Tuesday=1,...			

;             - missing

;                   same as 0

;      

;Returns:

;    the Day of the Week for the given Day

;

;Dependencies:

;    none

;       

;Remarks:

;    Should work fine for dates between 1300/01/01 and 2999/12/31, but never tested every Day ;-)

;

;

;Examples:

;    ? DayOfWeek('2004/07/08')			; gives 4

;    ? DayOfWeek('2004/07/08',0)    ; the same, gives 4

;    ? DayOfWeek('2004/07/08',1)    ; Start of the Week is Monday, gives 3 

;    ? DayOfWeek('2004/07/08',-1)    ; gives "THU"

;    ? DayOfWeek('2004/07/08',-2)    ; gives "Thursday"

;

;Source:



Function DayOfWeek($date,optional $format)

  Dim $century, $year, $wd

  $date=Split($date,'/')

  If Ubound($date) <> 2 Exit 1 EndIf

  If Len($date[0]) <> 4 Exit 1 EndIf

  $century=CInt(Left($date[0],2))

  $year=CInt(Right($date[0],2))

  If $century<13 OR $century>29 Exit 1 EndIf

  $wd=(CInt($date[2])+CInt(SubStr("510351362402",CInt($date[1]),1))+CInt(SubStr("0532",(($century-13) mod 4)+1,1))+($year/4)+$year) mod 7

  Select 

    Case CInt($format)=-1

      $DayOfWeek=Split('SUN,MON,TUE,WED,THU,FRI,SAT',',')[$wd]

    Case CInt($format)=-2

      $DayOfWeek=Split('Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday',',')[$wd]

    Case 1

      If CInt($format)>=0

        $wd=$wd-($format mod 7)

        If $wd<0 $wd=$wd+7 EndIf

      EndIf

      $DayOfWeek=$wd

  EndSelect

EndFunction





 

83788DBCommand17SealeopardDBCommand() - Executes a SQL statement and 
returns a recordset if applicable0

code:

;FUNCTION      DBCommand()
;
;ACTION        Executes a SQL statement and returns an array of records if applicable
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.1
;
;KIXTART       4.12+
;
;SYNTAX        RETCODE = DBCOMMAND(DSN, SQL)
;
;PARAMETERS    DSN
;              Database connection string (ODBC format)
;
;              SQL
;              SQL statement to be executed
;
;RETURN        2-D array of records or an empty string (SELECT) or 0 if other SQL
;              statement (CREATE, INSERT, UPDATE, DELETE, DROP,...)  was executed successfully.
;
;REMARKS       See also DBConnOpen(), DBConnClose(), DBRecordsetOpen(), DBRecordsetClose(), DBGetRecordset(), DBExecuteSQL()
;
;DEPENDENCIES  none
;
;EXAMPLE       $dsn='DRIVER={Microsoft Access Driver (*.mdb)}; DBQ=test.mdb'
;              $sql="INSERT INTO Table1 VALUES('eee','fff')"
;              $recordset = DBCommand($dsn,$sql)
;              ? 'Error = '+@ERROR+' - '+@SERROR
;              $sql="SELECT Field1, Field2 FROM Table1"
;              $recordset = DBCommand($dsn,$sql)
;              ? 'Error = '+@ERROR+' - '+@SERROR
;              for $row=0 to ubound($recordset,1)
;                for $column=0 to ubound($recordset,2)
;                  ? 'Field(row='+$row+', column='+$column+') ='+$recordset[$row,$column]
;                next
;              next
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000328
;
function DBCommand($ConnDSN,$sql)
  Dim $objConn, $adStateOpen
  dim $Conntimeout, $CmdTimeout
  dim $cmdCommand, $rsRecordset
  dim $Records, $FinalRecords
  dim $adCmdText, $adLockReadOnly, $adOpenStatic
  dim $row, $rows, $column, $columns

  $ConnDSN=trim($ConnDSN)
  if not $ConnDSN
    exit 87
  endif
  $sql=trim($sql)
  if not $sql
    exit 87
  endif

  ; default database parameters
  $adStateOpen=1
  $ConnTimeout=15
  $CmdTimeout=30
  $adCmdText = 1
  $adOpenStatic = 3
  $adLockReadOnly = 1

  ; open the database connection
  $objConn = CreateObject("ADODB.Connection")
  if @ERROR
    exit @ERROR
  endif
  $objConn.ConnectionTimeout = $ConnTimeout
  if @ERROR
    exit @ERROR
  endif
  $objConn.CommandTimeout = $CmdTimeout
  if @ERROR
    exit @ERROR
  endif
  $objConn.Open($ConnDSN)
  if @ERROR
    exit @ERROR
  endif
  if not $objConn.State=$adStateOpen
    $objConn=''
    $DBCommand=''
    exit @ERROR
  endif

  ; create the database command object
  $cmdCommand = CreateObject('ADODB.Command')
  if @ERROR
    exit @ERROR
  endif
  $cmdCommand.ActiveConnection = $objConn
  if @ERROR
    exit @ERROR
  endif
  $cmdCommand.CommandType = $adCmdText
  if @ERROR
    exit @ERROR
  endif
  $cmdCommand.CommandText = $sql
  if @ERROR
    $DBCommand=@ERROR
    exit @ERROR
  endif

  if instr($sql,'SELECT')=1
    ; create the recordset object
    $rsRecordSet = CreateObject('ADODB.Recordset')
    if @ERROR
      exit @ERROR
    endif
    $rsRecordset.CursorType = $adOpenStatic
    if @ERROR
      exit @ERROR
    endif
    $rsRecordset.LockType = $adLockReadOnly
    if @ERROR
      exit @ERROR
    endif
    $rsRecordset.Open($cmdCommand)
    if @ERROR
      exit @ERROR
    endif

    if $rsRecordset.EOF and $rsRecordSet.BOF
      ; recordset is empty
      $FinalRecords=''
    else
      if @ERROR
        exit @ERROR
      endif

      ; retrieve all records at once and transpose into tabular format
      $Records = $rsRecordset.GetRows()
      $columns=ubound($records,1)
      $rows=ubound($records,2)
      redim $FinalRecords[$rows,$columns]
      for $row=0 to $rows
        for $column=0 to $columns
          $FinalRecords[$row,$column]=$records[$column,$row]
        next
      next
    endif

    ; close recordset
    if $rsRecordset.state=$adStateOpen
      $rsRecordset.Close()
      if @ERROR
        exit @ERROR
      endif
    endif

    $rsRecordset=''
    $cmdCommand=''

    $DBCommand=$FinalRecords
  else
    $rsRecordset=$cmdCommand.Execute()
    $cmdCommand=''
    $rsRecordset=''
    if @ERROR
      exit @ERROR
    endif

    $DBCommand=0
  endif

  ; close the database connection
  If $objConn.State = $adStateOpen
    $objConn.Close()
    if @ERROR
      exit @ERROR
    endif
  EndIf
  $objConn=''

  exit 0
endfunction



[ 02. March 2003, 17:04: Message edited by: sealeopard ]83093DBConnClose17SealeopardDBConnClose() 
- Closes a connection to a database0

code:

;FUNCTION      DBConnClose()
;
;ACTION        Closes a connection to a database that has previously been opened with DBConnOpen()
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.1
;
;KIXTART       4.12+
;
;SYNTAX        RETCODE = DBCONNCLOSE(CONNECTION)
;
;PARAMETERS    CONNECTION
;              open connection object to a data source from DBConnOpen()
;
;RETURN        0 if successful, otherwise error code
;
;REMARKS       See also DBConnOpen(), DBRecordsetOpen(), DBRecordsetClose(), DBGetRecordset(), DBCommand(), DBExecuteSQL()
;
;DEPENDENCIES  none
;
;EXAMPLE       $retcode = DBConnClose($objConn)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000195
;
Function DBConnClose($objConn)
  Dim $adStateOpen

  $adStateOpen = 1

  If vartype($objConn)=9
    If $objConn.State = $adStateOpen
      $objConn.Close()
      if @ERROR
        exit @ERROR
      endif
    EndIf
    $objConn=''
  else
    exit 87
  endif

  $DBConnClose=0
  exit 0
EndFunction



[ 02. March 2003, 17:00: Message edited by: sealeopard ]83073DBConnOpen17SealeopardDBConnOpen() 
- Open a connection to a database using ADODB1153191465Code:


;FUNCTION      DBConnOpen()
;
;ACTION        Open a connection to a database using ADODB
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.11 (minor code changes)
;              1.1
;
;DATE CREATED  2002/09/05
;
;DATE MODIFIED 2004/03/07
;
;KIXTART       4.20+
;
;SYNTAX        RETCODE = DBCONNOPEN(DSN [,CONNTIMEOUT, CMDTIMEOUT])
;
;PARAMETERS    DSN
;              Database connection string (ODBC format)
;
;              CONNTIMEOUT
;              Optional integer denoting the time in seconds until a connection times out, defaults to 15 seconds
;
;              CMDTIMEOUT
;              Optional integer denoting the time in seconds until a command times out, defaults to 30 seconds
;
;RETURN        Connection object if successful, otherwise empty string
;
;REMARKS       See also DBConnClose(), DBRecordsetOpen(), DBRecordsetClose(), DBGetRecordset(), DBCommand(), DBExecuteSQL()
;
;              Example connection strings (requires appropriate ODBC drivers)::
;
;              Microsoft Access        : "DRIVER={Microsoft Access Driver (*.mdb)}; UID=; PWD=; DBQ=database.mdb"
;              Microsoft SQL Server    : "DRIVER={SQL Server};SERVER=servername;UID=user;PWD=password;DATABASE=mydatabase"
;              Microsoft Visual FoxPro : "DRIVER={Microsoft Visual FoxPro Driver}; UID=; PWD=; DBQ=database.dbc"
;              Oracle                  : "DSN=test;UID=username;PWD=password"
;              For other connection strings please see http://www.connectionstrings.com
;
;DEPENDENCIES  none
;
;EXAMPLE       $objConn = DBConnOpen('DRIVER={Microsoft Access Driver (*.mdb)}; UID=; PWD=; DBQ=database.mdb')
;
;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=82470
;
Function DBConnOpen($ConnDSN, optional $ConnTimeout, optional $CmdTimeout)
  Dim $objConn

  $ConnTimeout=iif(vartype($ConnTimeout),val($ConnTimeout),15)
  $CmdTimeout=iif(vartype($CmdTimeout),val($CmdTimeout),30)

  $ConnDSN=trim($ConnDSN)
  if not $ConnDSN
    exit 87
  endif

  $objConn = CreateObject("ADODB.Connection")
  if @ERROR
    exit @ERROR
  endif

  $objConn.ConnectionTimeout = $ConnTimeout
  if @ERROR
    exit @ERROR
  endif

  $objConn.CommandTimeout = $CmdTimeout
  if @ERROR
    exit @ERROR
  endif

  $objConn.Open($ConnDSN)
  if @ERROR
    exit @ERROR
  endif

  if not $objConn.State=1
    $objConn=''
    $DBConnOpen=''
    exit @ERROR
  endif
  $DBConnOpen=$objConn
  exit 0
EndFunction

83094DBExecuteSQL17SealeopardDBExecuteSQL() - Executes a SQL command on a 
database1117886896Code:


;FUNCTION      DBExecuteSQL()
;
;ACTION        Executes a SQL command on a database
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.11 (minor code changes)
;              1.1
;
;DATE CREATED  2002/09/05
;
;DATE MODIFIED 2004/03/07
;
;KIXTART       4.20+
;
;SYNTAX        RETCODE = DBEXECUTESQL(CONNECTION, SQL [,CMDTYPE])
;
;PARAMETERS    CONNECTION
;              open connection object to a data source from DBConnOpen()
;
;              SQL
;              SQL command to be executed
;
;              CMDTYPE
;              Optional integer defining the command type (e.g. SQL statement, stored procedure)
;
;RETURN        0 if successful, otherwise error code
;
;REMARKS       See also DBConnOpen(), DBConnClose(), DBRecordsetOpen(), DBRecordsetClose(), DBGetRecordset(), DBCommand()
;
;              This routine does not return a recordset as the result of the SQL
;              statement. Therefore, it should only be used with SQL commands
;              like INSERT INTO, UPDATE. For SELECT statements one should rather
;              use DBGetRecordset() or DBComand().
;
;DEPENDENCIES  none
;
;EXAMPLE       $objConn = DBConnOpen('DRIVER={Microsoft Access Driver (*.mdb)}; UID=; PWD=; DBQ=database.mdb')
;              $retcode = DBExecuteSQL($objConn,"INSERT INTO Demo(Field1,Field2) VALUES('Value1','Value2')")
;              $retcode = DBConnClose($objConn)
;
;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=82477
;
function DBExecuteSQL($objConn, $sql, optional $cmdType)
  dim $cmdCommand, $rsRecordset
  dim $adCmdUnspecified, $adCmdText, $adCmdTable, $adCmdStoredProc, $adCmdUnknown, $adCmdFile, $adCmdTableDirect

  $adCmdUnspecified = -1
  $adCmdText        = 1
  $adCmdTable       = 2
  $adCmdStoredProc  = 4
  $adCmdUnknown     = 8
  $adCmdFile        = 256
  $adCmdTableDirect = 512

  $cmdType=iif(vartype($cmdType),val($cmdType),$adCmdText)

  if vartype($objConn)<>9 or $sql=''
    exit 87
  endif

  $cmdCommand = CreateObject('ADODB.Command')
  if @ERROR
    exit @ERROR
  endif

  $cmdCommand.ActiveConnection = $objConn
  if @ERROR
    exit @ERROR
  endif

  $cmdCommand.CommandType = $cmdType
  if @ERROR
    exit @ERROR
  endif

  $cmdCommand.CommandText = $sql
  if @ERROR
    exit @ERROR
  endif

  $rsRecordset=$cmdCommand.Execute()
  $rsRecordset=''
  $cmdCommand=''
  $DBExecuteSQL=@ERROR
  exit @ERROR
endfunction

83114DBGetRecordset17SealeopardDBGetRecordset() - Retrives a recordset from 
a database as the result of a SQL query0

code:

;FUNCTION      DBGetRecordset()
;
;ACTION        Retrives a recordset from a database as the result of a SQL query
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.1
;
;KIXTART       4.12+
;
;SYNTAX        RETCODE = DBGETRECORDSET(CONNECTION, SQL [,CMDTYPE, CURTYPE, LOCKTYPE])
;
;PARAMETERS    CONNECTION
;              open connection object to a data source from DBConnOpen()
;
;              SQL
;              SQL query to be executed
;
;              CMDTYPE
;              optional integer value denoting the command type
;
;              CURTYPE
;              optional integer value denoting the cursor type
;
;              LOCKTYPE
;              optional integer value denoting the lock type
;
;RETURN        2-D array of records or an empty string if the SQL query results in an empty recordset.
;
;REMARKS       See also DBConnOpen(),  DBConnClose(), DBRecordsetOpen(), DBRecordsetClose(), DBCommand(), DBExecuteSQL()
;
;DEPENDENCIES  none
;
;EXAMPLE       $objConn = DBConnOpen('DRIVER={Microsoft Access Driver (*.mdb)}; UID=; PWD=; DBQ=database.mdb')
;              $recordset = DBGetRecordset($objConn,"SELECT Field1, Field2 FROM Table1 WHERE Field1<>'' ORDER BY Field1")
;              $retcode = DBConnClose($objConn)
;              for $row=0 to ubound($recordset,1)
;                for $column=0 to ubound($recordset,2)
;                  ? 'Field ='+$recordset[$row,$column]
;                next
;              next
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000197
;
function DBGetRecordset($objConn, $sql, optional $cmdType, optional $curType, optional $lockType)
  dim $cmdCommand, $rsRecordset
  dim $Records, $FinalRecords
  dim $adCmdUnspecified, $adCmdText, $adCmdTable, $adCmdStoredProc, $adCmdUnknown, $adCmdFile, $adCmdTableDirect
  dim $adLockUnspecified, $adLockReadOnly, $adLockPessimistic, $adLockOptimistic, $adLockBatchOptimistic
  dim $adOpenUnspecified, $adOpenForwardOnly, $adOpenKeyset, $adOpenDynamic, $adOpenStatic
  dim $adClipString, $adStateOpen
  dim $row, $rows, $column, $columns

  $adClipString = 2
  $adStateOpen = 1

  ; permitted values for database locking
  $adLockUnspecified     = -1
  $adLockReadOnly        = 1
  $adLockPessimistic     = 2
  $adLockOptimistic      = 3
  $adLockBatchOptimistic = 4

  ; permitted values for database cursor
  $adOpenUnspecified = -1
  $adOpenForwardOnly = 0
  $adOpenKeyset      = 1
  $adOpenDynamic     = 2
  $adOpenStatic      = 3

  ; permitted values for database query types
  $adCmdUnspecified = -1
  $adCmdText        = 1
  $adCmdTable       = 2
  $adCmdStoredProc  = 4
  $adCmdUnknown     = 8
  $adCmdFile        = 256
  $adCmdTableDirect = 512

  $sql=trim($sql)

  if vartype($cmdType)
    $cmdType=val($cmdType)
  else
    $cmdType=$adCmdText
  endif

  if vartype($curType)
    $curType=val($curType)
  else
    $curType=$adOpenStatic
  endif

  if vartype($lockType)
    $lockType=val($lockType)
  else
    $lockType=$adLockReadOnly
  endif

  if vartype($objConn)<>9 or $sql=''
    exit 87
  endif

  $cmdCommand = CreateObject('ADODB.Command')
  if @ERROR
    exit @ERROR
  endif

  $rsRecordSet = CreateObject('ADODB.Recordset')
  if @ERROR
    exit @ERROR
  endif

  $cmdCommand.ActiveConnection = $objConn
  if @ERROR
    exit @ERROR
  endif

  $cmdCommand.CommandType = $cmdType
  if @ERROR
    exit @ERROR
  endif

  $rsRecordset.CursorType = $curType
  if @ERROR
    exit @ERROR
  endif

  $rsRecordset.LockType = $lockType
  if @ERROR
    exit @ERROR
  endif

  $cmdCommand.CommandText = $sql
  if @ERROR
    exit @ERROR
  endif

  $rsRecordset.Open($cmdCommand)
  if @ERROR
    exit @ERROR
  endif

  if $rsRecordset.EOF and $rsRecordSet.BOF
    $FinalRecords=''
  else
    if @ERROR
      exit @ERROR
    endif

    $Records = $rsRecordset.GetRows()

    ; transpose the array
    $rows=ubound($records,2)
    $columns=ubound($records,1)
    redim $FinalRecords[$rows,$columns]
    for $row=0 to $rows
      for $column=0 to $columns
        $FinalRecords[$row,$column]=$records[$column,$row]
      next
    next
  endif

  if $rsRecordset.state=$adStateOpen
    $rsRecordset.Close()
    if @ERROR
      exit @ERROR
    endif
  endif

  $rsRecordset=''
  $cmdCommand=''

  $DBGetRecordSet=$FinalRecords
  exit 0
endfunction



[ 02. March 2003, 17:02: Message edited by: sealeopard ]83118DBRecordsetClose17SealeopardDBRecordsetClose() 
- Closes a recordset that has beeen previously opened with DBRecor0

code:

;FUNCTION      DBRecordsetClose()
;
;ACTION        Closes a recordset that has beeen previously opened with DBRecordsetOpen()
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.1
;
;KIXTART       4.12+
;
;SYNTAX        RETCODE = DBRECORDSETCLOSE(RECORDSET)
;
;PARAMETERS    RECORDSET
;              the recordset that is to be closed
;
;RETURN        0 if successful, otherwise error code
;
;REMARKS       See also DBConnOpen(), DBConnClose(), DBRecordsetOpen(), DBGetRecordset(), DBCommand(), DBExecuteSQL()
;
;DEPENDENCIES  none
;
;EXAMPLE       $objConn = DBConnOpen('DRIVER={Microsoft Access Driver (*.mdb)}; UID=; PWD=; DBQ=database.mdb')
;              $recordset = DBRecordsetOpen($objConn,'SELECT * FROM Table')
;              $retcode = DBRecordsetClose($recordset)
;              $retcode = DBConnClose($objConn)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000199
;
function DBRecordsetClose($rsRecordset)
  Dim $adStateOpen

  $adStateOpen = 1

  if $rsRecordset.state=$adStateOpen
    $rsRecordset.Close()
    if @ERROR
      exit @ERROR
    endif
  endif

  $rsRecordset=''
  $DBRecordsetClose=''
  exit 0
endfunction



[ 02. March 2003, 17:03: Message edited by: sealeopard ]83117DBRecordsetOpen17SealeopardDBRecordsetOpen() 
- Opens a recordset object from a database0

code:

;FUNCTION      DBRecordsetOpen()
;
;ACTION        Opens a recordset object from a database
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.1
;
;KIXTART       4.12+
;
;SYNTAX        RETCODE = DBRECORDSETOPEN(CONNECTION, SQL [,CMDTYPE, CURTYPE, LOCKTYPE])
;
;PARAMETERS    CONNECTION
;              open connection object to a data source from DBConnOpen()
;
;              SQL
;              SQL query to be executed
;
;              CMDTYPE
;              optional integer value denoting the command type
;
;              CURTYPE
;              optional integer value denoting the cursor type
;
;              LOCKTYPE
;              optional integer value denoting the lock type
;
;RETURN        Recordset object
;
;REMARKS       See also DBConnOpen(), DBConnClose(), DBRecordsetClose(), DBGetRecordset(), DBCommand(), DBExecuteSQL()
;
;              The recordset object must be closed with DBRECORDSETCLOSE()
;
;DEPENDENCIES  none
;
;EXAMPLE       $objConn = DBConnOpen('DRIVER={Microsoft Access Driver (*.mdb)}; UID=; PWD=; DBQ=database.mdb')
;              $recordset = DBRecordsetOpen($objConn,'SELECT * FROM Table')
;              $retcode = DBRecordsetClose($recordset)
;              $retcode = DBConnClose($objConn)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000198
;
function DBRecordsetOpen($objConn, $sql, optional $cmdType, optional $curType, optional $lockType)
  dim $cmdCommand, $rsRecordset
  dim $adCmdUnspecified, $adCmdText, $adCmdTable, $adCmdStoredProc, $adCmdUnknown, $adCmdFile, $adCmdTableDirect
  dim $adLockUnspecified, $adLockReadOnly, $adLockPessimistic, $adLockOptimistic, $adLockBatchOptimistic
  dim $adOpenUnspecified, $adOpenForwardOnly, $adOpenKeyset, $adOpenDynamic, $adOpenStatic
  dim $adClipString, $adStateOpen

  $adClipString = 2
  $adStateOpen = 1

  ; permitted values for database locking
  $adLockUnspecified     = -1
  $adLockReadOnly        = 1
  $adLockPessimistic     = 2
  $adLockOptimistic      = 3
  $adLockBatchOptimistic = 4

  ; permitted values for database cursor
  $adOpenUnspecified = -1
  $adOpenForwardOnly = 0
  $adOpenKeyset      = 1
  $adOpenDynamic     = 2
  $adOpenStatic      = 3

  ; permitted values for database query types
  $adCmdUnspecified = -1
  $adCmdText        = 1
  $adCmdTable       = 2
  $adCmdStoredProc  = 4
  $adCmdUnknown     = 8
  $adCmdFile        = 256
  $adCmdTableDirect = 512

  if vartype($cmdType)
    $cmdType=val($cmdType)
  else
    $cmdType=$adCmdText
  endif

  if vartype($curType)
    $curType=val($curType)
  else
    $curType=$adOpenStatic
  endif

  if vartype($lockType)
    $lockType=val($lockType)
  else
    $lockType=$adLockReadOnly
  endif

  $sql=trim($sql)

  if vartype($objConn)<>9 or $sql=''
    exit 87
  endif

  $cmdCommand = CreateObject('ADODB.Command')
  if @ERROR
    exit @ERROR
  endif

  $rsRecordSet = CreateObject('ADODB.Recordset')
  if @ERROR
    exit @ERROR
  endif

  $cmdCommand.ActiveConnection = $objConn
  if @ERROR
    exit @ERROR
  endif

  $cmdCommand.CommandType = $cmdType
  if @ERROR
    exit @ERROR
  endif

  $rsRecordset.CursorType = $curType
  if @ERROR
    exit @ERROR
  endif

  $rsRecordset.LockType = $lockType
  if @ERROR
    exit @ERROR
  endif

  $cmdCommand.CommandText = $sql
  if @ERROR
    exit @ERROR
  endif

  $rsRecordset.Open($cmdCommand)
  if @ERROR
    exit @ERROR
  endif

  $DBRecordsetOpen=$rsRecordset

  $rsRecordset=''
  $cmdCommand=''
  exit 0
endfunction



[ 02. March 2003, 17:03: Message edited by: sealeopard ]84603DCList17SealeopardDCList() 
- Returns a list of DCs or sets the DC authentication order0

;FUNCTION      DCList() 

; 

;AUTHOR        Jens Meyer (sealeopard@usa.net) 

; 

;ACTION        Returns a list of DCs or sets the DC authentication order 

; 

;VERSION       1.0 initial release 

; 

;DATE CREATED  2003/10/06 

; 

;DATE MODIFIED 2003/10/06 

; 

;KIXTART       4.02+ 

; 

;SYNTAX        DCLIST([NETWORKIDS,TOOLPATH]) 

; 

;PARAMETERS    NETWORKIDS 

;              Optional (n,1)-array containing the subnets and their corresponding comma-delimited DCs 

; 

;              TOOLPATH 

;              Optional string pointing to the directory the executables are located in. 

; 

;REMARKS       Uses SetPrfDC from Windows NT 4.0 Service Pack 4/5/6a CD (SETPRFDC.EXE). 

;              Uses NLTest from Windows NT 4.0 Rsource Kit (NLTEST.EXE). 

;              SETPRFDC will set the preferred domain controller to authenticate from. It requires administrative 

;              privileges in order to do so and the setting will be lost upon reboot. The preferred solution is 

;              to designate the preferred DCs in the HOSTS file directly. See the HOSTS/LMHOSTS file for the correct 

;              syntax. 

; 

;DEPENDENCIES  ISINSUBNET()  @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000053 

; 

;RETURNS       0 if successful, otherwise error code 

; 

;EXAMPLE       $asNetworkIDs[0,0]='192.168.1.0/24' 

;              $asNetworkIDs[0,1]='BDC1,BDC2,PDC' 

;              $iRC=DCList($asNetworkIDs) 

;              ? ''+@ERROR+' - '+@SERROR 

;              ? 'iRC = '+$iRC 

;              $asDCs=DCList() 

;              for each $sDC in $asDCs 

;                ? 'DC = '+$sDC 

;              next 

; 

;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000467 

; 

function DCList(optional $asNetworkIDs, optional $sToolPath)

  dim  $sToolExe, $iSubnetIndex, $asDCList, $sCmd, $bSet, $iHandle, $sTmpFile, $sLine

  

  select

  case vartype($asNetworkIDs) & 8192

    $bSet=1

    $sToolExe='setprfdc.exe'

    if not (ingroup(''+@wksta+'\'+sidtoname('S-1-5-32-544'))-1+@inwin)

      $DCList=5

      exit 5

    endif

  case vartype($asNetworkIDs)

    $DCList=87

    exit 87

  case 1

    $bSet=0

    $sToolExe='nltest.exe'

  endselect       

  

  if $sToolPath

    if right($sToolPath,'\')

      $sToolExe=$sToolPath+$sToolExe

    else

      $sToolExe=$sToolPath+'\'+$sToolExe

    endif

  endif 



  if $bSet

    $iSubnetIndex=0

    $bSet=0

    do

      $bSet=isinsubnet(@IPADDRESS0,$asNetworkIDs[$iSubnetIndex,0])

      $iSubnetIndex=$iSubnetIndex+1

    until $bSet or $isubnetIndex>ubound($asNetworkIDs,1)

    if $bSet and $asNetworkIDs[$iSubnetIndex-1,1]

      $sCmd='%COMSPEC% /C '+$sToolExe+' '+@LDOMAIN+' '+join(split($asNetworkIDs[$iSubnetIndex-1,1],','),' ')+' >NUL 2> NUL'

      shell $sCmd

      $DCList=@ERROR

      exit @ERROR

    else

      $DCList=87

      exit 87

    endif

  else

    $sTmpFile='%TEMP%\prfdc.tmp'

    $sCmd='%COMSPEC% /C '+$sToolExe+' /dclist:'+@LDOMAIN+' >'+$sTmpFile+' 2> NUL'

    shell $sCmd

    $iHandle=freefilehandle()

    if open($iHandle,$sTmpFile)=0

      while not @error

        if $sLine

          redim preserve $DCList[ubound($DCList)+1]

          $DCList[ubound($DCList)]=$sLine

        endif

        $sLine = readline($iHandle)

      loop

      $iHandle=close($iHandle)

      $DCList[0]=''

      $DCList[1]=''

      $DCList[ubound($DCList)]=''

      $DCList=split(substr(join(split(join($DCList,''),' '),''),3),'\\')

    endif

    del $sTmpFile

    exit @ERROR

  endif

endfunction



[ 06. October 2003, 21:25: Message edited by: sealeopard ]147488DC_List46kholmDC_List() 
- Return an array of domain controllers0This will return an array of names for 
the domain controllers in the logon domain in NT4 format aka. sAMAccountName
Code:

;Function DC_List()
;
;Author: kholm
;
;Action: Returns an array of names for the domain controllers in the logon domain (sAMAccountNames)
;
;Syntax:	DC_List()
;
;Version	1.2
;
;Parameters  NONE
;
;Dependencies Active directory
; 
;Example:
;$DCs = DC_List()
;For Each $mbr In $DCs
;	$mbr ?
;Next
;Get $x

Function DC_List()
	Dim $DomCN,$oConn,$oCmd,$oRecSet,$i

	$DomCN = GetObject('LDAP://rootDSE').Get('configurationNamingContext') ; Get configuration path 

	$oConn = CreateObject('ADODB.Connection')
	$oConn.Provider = 'ADsDSOObject'
	$oConn.Open('Active Directory Provider')

	$oCmd = CreateObject('ADODB.Command')
	$oCmd.ActiveConnection = $oConn
	$oCmd.CommandText = "Select distinguishedName from 'LDAP://" + $DomCN + "' where objectClass='nTDSDSA'" 

	$oRecSet = $oCmd.Execute
	$oRecSet.MoveFirst

	While Not $oRecSet.EOF
		ReDim Preserve $DC_List[$i]
		$DC_List[$i] = SubStr(Split($oRecSet.Fields('distinguishedName').Value,',')[1],4)
		$i = $i + 1
		$oRecSet.MoveNext
	Loop
EndFunction


-Erik83979DecimalSymbol119LonkeroDecimalSymbol() - Returns the decimal 
symbol specified in regional settings0


;FUNCTION	DecimalSymbol

;

;ACTION		Returns decimal symbol specified in the regional settings

;

;AUTHOR		Lonkero

;

;VERSION	1.0 (2003 april 11th)

;

;SYNTAX		DecimalSymbol

;

;PARAMETERS	none

;

;RETURNS	decimal symbol specified in the regional settings

;

;DEPENDENCIES	none

;

;EXAMPLE

;		"regional decimal symbol is:"

;		?

;		decimalsymbol

;

;SOURCE

function DecimalSymbol()

 dim $,$!

 $!=0.5

 for $=1 to 255

  if $!="0"+chr($)+"5"

   $DecimalSymbol=chr($)

  endif

 next

 if not $DecimalSymbol exit 1 endif

endfunction



edited to work as copy&paste to notepad

[ 28. April 2003, 12:20: Message edited by: Lonkero ]155348DefaultAutoexecNT52NTDOCDefaultAutoexecNT() 
- Creates a new Default AUTOEXEC.NT file0

;Function	DefaultAutoexecNT() - Creates a new Default AUTOEXEC.NT file 
;     
;Author		NTDOC 
;     
;Contributors		 
;     
;Action		Creates new AUTOEXEC.NT file with all default / OEM settings 
;     
;Syntax		DefaultAutoexecNT($Ext,$Bak) 
;		$Ext = AUTOEXEC. and any extension you want (default is NT) 
;		$Bak = AUTOEXEC. and the name of the extension you want rename AUTOEXEC.NT to 
;     
;Version	1.0 
;     
;Date		2006-01-15 
;     
;Date Revised	xxxx-xx-xx    
;     
;Revision Reason	 
;     
;Parameters	$Ext and $Bak (extension of the AUTOEXEC. file to create and extension for backup) 
;     
;Remarks	Tested on XP with KiXtart 4.52 Beta 2 only 
;               Rarely does anyone ever modify this file, but there are some recent MALWARE programs that have 
;               started modifying this file and the CONFIG.NT file.  You might be able to copy the one from the 
;               repair folder, but it could be damaged from MALWARE too.  You could copy from another computer as  
;               well, but this makes a quick inline repair. 
;     
;Returns	Nothing 
;     
;Dependencies	KiXtart v4.52 beta 2, Administrative rights  
;			 
;Example 
; 
;	Select 
;         Case Exist('%SYSTEMROOT%\SYSTEM32\CONFIG.BAK') 
;           DefaultAutoexecNT('NT','BAK01') 
;         Case Exist('%SYSTEMROOT%\SYSTEM32\CONFIG.BAK01') 
;           DefaultAutoexecNT('NT','BAK02')   
;         Case Exist('%SYSTEMROOT%\SYSTEM32\CONFIG.BAK02') 
;           DefaultAutoexecNT('NT','BAK03') 
;         Case 1 
;           DefaultAutoexecNT('NT','BAK') 
;       EndSelect 
; 
;Source 
 
Function DefaultAutoexecNT($Ext,$Bak)
  Dim $File,$FileBackup,$WL
  Dim $Handle,$OpenFile,$CloseFile
  $File = '%SYSTEMROOT%\SYSTEM32\AUTOEXEC.'+$Ext
  $FileBackup = '%SYSTEMROOT%\SYSTEM32\AUTOEXEC.'+$Bak
  If Exist($FileBackup)
  ;Assumes a valid backup already exists so we will now create all new default file 
  Else
    If Exist($File)
  	  Move $File $FileBackup
  	  If @ERROR Exit @ERROR EndIf
    EndIf
  EndIf
  $WL='@echo off'+ @CRLF+
  @CRLF+
  'REM AUTOEXEC.BAT is not used to initialize the MS-DOS environment.'+@CRLF+
  'REM AUTOEXEC.NT is used to initialize the MS-DOS environment unless a'+@CRLF+
  'REM different startup file is specified in an application'+"'"+'s PIF.'+@CRLF+
  @CRLF+
  'REM Install CD ROM extensions'+@CRLF+
  'lh %SystemRoot%\system32\mscdexnt.exe'+@CRLF+
  @CRLF+
  'REM Install network redirector (load before dosx.exe)'+@CRLF+
  'lh %SystemRoot%\system32\redir'+@CRLF+
  @CRLF+
  'REM Install DPMI support'+@CRLF+
  'lh %SystemRoot%\system32\dosx'+@CRLF+
  @CRLF+
  'REM The following line enables Sound Blaster 2.0 support on NTVDM.'+@CRLF+
  'REM The command for setting the BLASTER environment is as follows:'+@CRLF+
  'REM    SET BLASTER=A220 I5 D1 P330'+@CRLF+
  'REM    where:'+@CRLF+
  'REM        A    specifies the sound blaster'+"'"+'s base I/O port'+@CRLF+
  'REM        I    specifies the interrupt request line'+@CRLF+
  'REM        D    specifies the 8-bit DMA channel'+@CRLF+
  'REM        P    specifies the MPU-401 base I/O port'+@CRLF+
  'REM        T    specifies the type of sound blaster card'+@CRLF+
  'REM                 1 - Sound Blaster 1.5'+@CRLF+
  'REM                 2 - Sound Blaster Pro I'+@CRLF+
  'REM                 3 - Sound Blaster 2.0'+@CRLF+
  'REM                 4 - Sound Blaster Pro II'+@CRLF+
  'REM                 6 - SOund Blaster 16/AWE 32/32/64'+@CRLF+
  'REM'+@CRLF+
  'REM    The default value is A220 I5 D1 T3 and P330.  If any of the switches is'+@CRLF+
  'REM    left unspecified, the default value will be used. (NOTE, since all the'+@CRLF+
  'REM    ports are virtualized, the information provided here does not have to'+@CRLF+
  'REM    match the real hardware setting.)  NTVDM supports Sound Blaster 2.0 only.'+@CRLF+
  'REM    The T switch must be set to 3, if specified.'+@CRLF+
  'SET BLASTER=A220 I5 D1 P330 T3'+@CRLF+
  @CRLF+
  'REM To disable the sound blaster 2.0 support on NTVDM, specify an invalid'+@CRLF+
  'REM SB base I/O port address.  For example:'+@CRLF+
  'REM    SET BLASTER=A0'+@CRLF
  $Handle = FreeFileHandle()
  $OpenFile = Open($Handle, $File,5)
  $WL = WriteLine($Handle,$WL + @CRLF)
  $CloseFile = Close($Handle)
  Exit @ERROR
EndFunction
 
155347DefaultConfigNT52NTDOCDefaultConfigNT() - Creates a new Default 
CONFIG.NT file0

;Function	DefaultConfigNT() - Creates a new Default CONFIG.NT file 
;     
;Author		NTDOC 
;     
;Contributors		 
;     
;Action		Creates new CONFIG.NT file with all default / OEM settings 
;     
;Syntax		DefaultConfigNT($Ext,$Bak) 
;		$Ext = CONFIG. and any extension you want (default is NT) 
;		$Bak = CONFIG. and the name of the extension you want rename CONFIG.NT to 
;     
;Version	1.0 
;     
;Date		2006-01-15 
;     
;Date Revised	xxxx-xx-xx    
;     
;Revision Reason	 
;     
;Parameters	$Ext and $Bak (extension of the CONFIG. file to create and extension for backup) 
;     
;Remarks	Tested on XP with KiXtart 4.52 Beta 2 only 
;               Rarely does anyone ever modify this file, but there are some recent MALWARE programs that have 
;               started modifying this file and the AUTOEXEC.NT file.  You might be able to copy the one from the 
;               repair folder, but it could be damaged from MALWARE too.  You could copy from another computer as  
;               well, but this makes a quick inline repair. 
;     
;Returns	Nothing 
;     
;Dependencies	KiXtart v4.52 beta 2, Administrative rights  
;			 
;Example 
; 
;	Select 
;         Case Exist('%SYSTEMROOT%\SYSTEM32\CONFIG.BAK') 
;           DefaultConfigNT('NT','BAK01') 
;         Case Exist('%SYSTEMROOT%\SYSTEM32\CONFIG.BAK01') 
;           DefaultConfigNT('NT','BAK02')   
;         Case Exist('%SYSTEMROOT%\SYSTEM32\CONFIG.BAK02') 
;           DefaultConfigNT('NT','BAK03') 
;         Case 1 
;           DefaultConfigNT('NT','BAK') 
;       EndSelect 
; 
;Source 
 
Function DefaultAutoexecNT($Ext,$Bak)
  Dim $File,$FileBackup,$WL
  Dim $Handle,$OpenFile,$CloseFile
  $File = '%SYSTEMROOT%\SYSTEM32\AUTOEXEC.'+$Ext
  $FileBackup = '%SYSTEMROOT%\SYSTEM32\AUTOEXEC.'+$Bak
  If Exist($FileBackup)
  ;Assumes a valid backup already exists so we will now create all new default file 
  Else
    If Exist($File)
  	  Move $File $FileBackup
  	  If @ERROR Exit @ERROR EndIf
    EndIf
  EndIf
  $WL='@echo off'+ @CRLF+
  @CRLF+
  'REM AUTOEXEC.BAT is not used to initialize the MS-DOS environment.'+@CRLF+
  'REM AUTOEXEC.NT is used to initialize the MS-DOS environment unless a'+@CRLF+
  'REM different startup file is specified in an application'+"'"+'s PIF.'+@CRLF+
  @CRLF+
  'REM Install CD ROM extensions'+@CRLF+
  'lh %SystemRoot%\system32\mscdexnt.exe'+@CRLF+
  @CRLF+
  'REM Install network redirector (load before dosx.exe)'+@CRLF+
  'lh %SystemRoot%\system32\redir'+@CRLF+
  @CRLF+
  'REM Install DPMI support'+@CRLF+
  'lh %SystemRoot%\system32\dosx'+@CRLF+
  @CRLF+
  'REM The following line enables Sound Blaster 2.0 support on NTVDM.'+@CRLF+
  'REM The command for setting the BLASTER environment is as follows:'+@CRLF+
  'REM    SET BLASTER=A220 I5 D1 P330'+@CRLF+
  'REM    where:'+@CRLF+
  'REM        A    specifies the sound blaster'+"'"+'s base I/O port'+@CRLF+
  'REM        I    specifies the interrupt request line'+@CRLF+
  'REM        D    specifies the 8-bit DMA channel'+@CRLF+
  'REM        P    specifies the MPU-401 base I/O port'+@CRLF+
  'REM        T    specifies the type of sound blaster card'+@CRLF+
  'REM                 1 - Sound Blaster 1.5'+@CRLF+
  'REM                 2 - Sound Blaster Pro I'+@CRLF+
  'REM                 3 - Sound Blaster 2.0'+@CRLF+
  'REM                 4 - Sound Blaster Pro II'+@CRLF+
  'REM                 6 - SOund Blaster 16/AWE 32/32/64'+@CRLF+
  'REM'+@CRLF+
  'REM    The default value is A220 I5 D1 T3 and P330.  If any of the switches is'+@CRLF+
  'REM    left unspecified, the default value will be used. (NOTE, since all the'+@CRLF+
  'REM    ports are virtualized, the information provided here does not have to'+@CRLF+
  'REM    match the real hardware setting.)  NTVDM supports Sound Blaster 2.0 only.'+@CRLF+
  'REM    The T switch must be set to 3, if specified.'+@CRLF+
  'SET BLASTER=A220 I5 D1 P330 T3'+@CRLF+
  @CRLF+
  'REM To disable the sound blaster 2.0 support on NTVDM, specify an invalid'+@CRLF+
  'REM SB base I/O port address.  For example:'+@CRLF+
  'REM    SET BLASTER=A0'+@CRLF
  $Handle = FreeFileHandle()
  $OpenFile = Open($Handle, $File,5)
  $WL = WriteLine($Handle,$WL + @CRLF)
  $CloseFile = Close($Handle)
  Exit @ERROR
EndFunction
 
 137763Deflate5829grundakDeflate() - Removes whitespace from a string.1113502774Code:


;Function  deflate()
;
;Author  Grundak (grundak@gmail.com)
;
;Contributors  (See Remarks)
;
;Action  Removes whitespace from a string.
;
;Syntax  deflate($inflated_string)
;
;Version  2.0
;
;Date  2005-04-14
;
;Date Revised  (2005-04-14 -- deflate_v2.0)
;              (2005-04-12 -- deflate_v1.0 [Original])
;
;Parameters  $inflated_string
;    can be zero-length ""
;    can contain zero or more whitespace characters
;    can contain whitespace at beginning, middle, and/or end of the string.
;
;Remarks
;         ============
;         deflate_v2.0
;         ============
;         whitespace consists of char($n) where $n = {9,10,13,32}
;         After some discussion in the UDF forum, I decided to to re-write and
;           re-submit this function based on the SplitJoining (or JoinSplitting)
;           method. I guess credit as contributors to this UDF should probably go
;           to all who contributed to the discussion on the forum. Thanks, all.
;         I suspect future versions of this UDF will only change which characters
;           are considered whitespace.
;
;         ============
;         deflate_v1.0
;         ============
;         This version of the function used trim() to remove all spaces from a string.
;           Earlier (pre-release) versions used ltrim() and rtrim() instead of trim()
;           and substr() instead of left() and right()
;         Note: trim() removes not only spaces, but tabs, and other whitespace
;           as well, however, trim() does not remove others, such as chr(13)
;           (carriage returns.)
;         Example #3, below, is from the KiXtart.org Online Reference for the CHR() function.
;           Note the different behavior of deflate() with regards to examples #3 and #4.
;         I did test this with
;           SetOption("NoVarsInStrings","ON") and
;           SetOption("Explicit","ON")
;           If I missed something please let me know.
;
;Returns  Returns the string, without any whitespace.
;
;Dependencies  None
;
;KiXtart Ver  4.22
; 
;Example(s)  $my_IP_address=deflate("127.  0.  0.  1")
;            $deflated_text=deflate($text_to_deflate)
;            $Message=deflate("Hello " + @USERID + chr(13) + chr(10) + "Welcome to our network.")
;            $Message=deflate("Hello " + @USERID +           chr(10) + chr(9) + "Welcome to our network.")
;
;KiXtart BBS  http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=136923&an=0&page=0#136923
;
FUNCTION deflate($inflated_string)

;
; Dim variables
;
dim $whitespace_characters
dim $char
dim $temp_string

;
; Initialize variables
;
$whitespace_characters = 9,10,13,32
$temp_string = $inflated_string

;
; Deflate the string
;
for each $char in $whitespace_characters
  $temp_string=join(split($temp_string,chr($char)),'')
next

$deflate = $temp_string

ENDFUNCTION ; deflate($inflated_string)

82648Delay29JochenDelay() - 'sleep' in milliseconds (CAUTION : CPU 
intensive !!!)0Code:


;FUNCTION           Delay()
;
;AUTHOR             Jochen Polster (jochenDOTpolsterATgmxDOTnet)
;                   with friendly support by Shawn Tassie
;
;ACTION             halts script execution for specified amount of milliseconds
;
;SYNTAX             Delay(milliseconds)
;
;PARAMETERS         milliseconds (Required)
;                    -  integer amount of milliseconds
;
;REMARKS            if passed parameter is divisible by 1000,
;                   better use sleep instead ;) ... found no way to prevent the
;                   function of being leaky regarding CPU time !
;
;RETURNS            Nothing
;
;DEPENDENCIES       None
;
;EXAMPLES           break on
;                   call "path\Delay.udf"
;                   $ = setoption("HideCursor","on")
;                   at(5,10) "Spinner"
;                   at(7,10) "'S' - slow"
;                   at(8,10) "'M' - medium"
;                   at(9,10) "'F' - fast"
;                   at(10,10)"'Q' - quit"
;                   $wait = 100
;                   while $k <> "q"
;                       $c = $c + 1
;                       select  case $c = 1 at(5,19)'\'
;                               case $c = 2 at(5,19)'|'
;                               case $c = 3 at(5,19)'/'
;                               case 1      at(5,19)'-' $c = 0
;                       endselect
;                       if kbhit()
;                           get $k
;                           select  case $k = 's' $wait = 180
;                                   case $k = 'm' $wait = 100
;                                   case $k = 'f' $wait = 50
;                           endselect
;                       endif
;                       delay($wait)
;                   loop
;
;SOURCE

function delay($ms)
    if vartype($ms) = 3
        dim $t
        if instr(@ticks,'-')      ;uptime > 25 days
            $t = @ticks - $ms
            do until $t >= @ticks
        else
            $t = @ticks + $ms
            do until $t <= @ticks
        endif
    endif
endfunction


82099DelDir315hqvuDelDir() - Delete all files and subdirectories1192018659 
Moderators Note: This can be replaced by KiXtarts rd /s command nowadays 


I was looking around for a way of deleting all files and subdirectories of a 
given directory and the only I have found is by shelling out to deltree.exe so 
here's a simple UDF that will do just that from within KIX

Code:

Function DelDir($Pathname)
	Dim $Filename
	$Filename = Dir($Pathname + "\*.*")
	While $Filename <> "" And @ERROR = 0
		If $Filename <> "." And $Filename <> ".."
			If (GetFileAttr($Pathname + "\" + $Filename) & 16)
				DelDir($Pathname + "\" + $Filename)
				SetFileAttr($Pathname + "\" + $Filename, 128)
				Rd ($Pathname + "\" + $Filename)
			Else
				SetFileAttr($Pathname + "\" + $Filename, 128)
				Del ($Pathname + "\" + $Filename)
			EndIf
		EndIf
		$Filename = Dir()
	Loop
EndFunction
83337DeleteFF259RyanDeleteFF() - Deleting Folders and Files using FSO 
returns Errorcode0Hello there,

My first UDF for the board.

Now I wrote the whole code inside the Function.

About the standard, it's not clear to me what the standard is. Is there a 
template? I also think everyone has his or her own style and creativity.

I'm also wondering how everybody else is dealing with functions. Are you storing 
every UDF for a program in a different file, and calling the file at the moment 
the function is needed, or making one big file with all the UDF's in it.

Ryan

code:

;
;     Function                   : DeleteFF($strPath, $strMethod, Optional $blnForce)
;
;     Description                : UDF for Cleaning Up Folders & Files
;
;     Script Language            : KiXtart
;     Version                    : 4.02 or higher
;
;     Script Dependecy           : Microsoft Windows Scripting Host 5.6
;                                  (see http://msdn.microsoft.com/scripting for download)
;
;     Parameters                 : $strPath = full path name to folder or file.
;                                  $strMethod = File to delete file.
;                                               Folder to delete folder
;                                               Content to delete folder content.
;                                  $blnForce = optional, forces to delete, if read-only, hidden or system.
;
;     Returns                    : 0 if succesful
;
;     Examples                   : DeleteFF("fullpathname\filename", "File", "True")
;                                  DeleteFF("fullpathname\foldername", "Folder", "True")
;                                  DeleteFF("fullpathname", "Content", "False")
;
;     Written by                 : Ryan Groeneveld
;     Date                       : 13-07-2002
;

Function DeleteFF($strPath, $strMethod, Optional $blnForce)
    $strFSO                                        = "Scripting.FileSystemObject"
    If KeyExist("HKCR\" + $strFSO) = 0
        $Tmp = MessageBox("Object " + $strFSO + " is not installed !", "Error", 16)
        Return
    Else
        $objFSO                                    = CreateObject($strFSO)
        If @Error <> 0
            $Tmp = MessageBox("Object " + $strFSO + " can not be created !", "Error", 16)
            Return
        EndIf
    EndIf
    If Len($strPath) > 0
    And Exist($strPath) = 1
        ? "Deleting " + $strMethod + " " + $strPath
        Select
            Case $strMethod = "File"
                $Tmp                               = $objFSO.DeleteFile($strPath, $blnForce)
                $DeleteFF                          = @Error
            Case $strMethod = "Folder"
                $Tmp                               = $objFSO.DeleteFolder($strPath, $blnForce)
                $DeleteFF                          = @Error
            Case $strMethod = "Content"
                $strContent                        = Dir($strPath)
                While Len($strContent) > 0
                And @Error = 0
                    If $strContent <> "."
                    And $strContent <> ".."
                        If GetFileAttr($strPath + "\" + $strContent) & 16
                            $Tmp                   = $objFSO.DeleteFolder($strPath + "\" + $strContent, $blnForce)
                        Else
                            $Tmp                   = $objFSO.DeleteFile($strPath + "\" + $strContent, $blnForce)
                        Endif
                        $DeleteFF                  = @Error
                    Endif
                    $strContent                    = Dir()
                Loop
            Case 1
                Return
        EndSelect
    Else
        ? $strMethod + " " + $strPath + " doesn't exist."
    Endif
EndFunction



[ 13 July 2002, 19:20: Message edited by: ryan ]83869DelFromArray588SchuliebugDelFromArray() 
UDF0This function was previously posted in this topic. Because there were two 
functions in one post i splitted them.

Code:

;Author        Schuliebug
;
;Function        DelFromArray
;
;Parameters    1: Required, array.
;        2: Required, number indicating pointer to delete.
;
;Remarks        none.
;
;Returns        array, @error=0 if succesfull, >0 if failed
;
;Dependencies    None
;
;Example(s)    $Array = 'aaa','bbb','ccc','ddd','eee'
;        $Array = DelFromArray($Array,0)
;           returns an array containing 'bbb','ccc','ddd','eee' (delete element 0)
;
;        $Array = DelFromArray($Array,2)
;           returns an array containing 'bbb','ccc','eee' (delete element 2)
;
;        $Array = DelFromArray($Array,10)
;           returns an array containing 'bbb','ccc','eee' (no change)
;
Function DelFromArray($Array,$Pointer)
    Dim $Index,$NewIndex,$Elm

    ; Check parameters..
    If Not VarType($Array) Exit(1) EndIf
    If Not VarType($Pointer) Exit(2)
    Else If 0+$Pointer >UBound($Array) Or 0+$Pointer <0
        $DelFromArray=$Array
        Exit(3)
    EndIf EndIf

    Redim $DelFromArray[UBound($Array)-1]
    $Index=0 $NewIndex=0

    ; Loop given array..
    For Each $Elm In $Array
        If $Index<>$Pointer
            ; Add element to array..
            $DelFromArray[$NewIndex]=$Elm
            $NewIndex=$NewIndex+1
        EndIf
        $Index=$Index+1
    Next
EndFunction
124989DelODBC79KdyerDelODBC() - Removes uneeded ODBC Connections0Code:


;FUNCTION 	DelODBC

;ACTION 	Remove uneeded ODBC Connections

;AUTHOR 	Kent Dyer (leptonator@hotmail.com) 

;VERSION 	1.0

;DATE CREATED 	14-August-2004 

;DATE MODIFIED 	14-August-2004 

;KIXTART 	4.02 

;SYNTAX 	DelODBC($DSN,$user) 

;PARAMETERS 	$DSN

; 		Name of DSN to remove 

; 		$user 

; 		Optional Flag to remove a User DSN 

;RETURNS 	Not

;REMARKS 	For the System DSN, you will need to be a Power User or better to run this 

;DEPENDENCIES 	None 

;EXAMPLE 	 

;IF INSTR(READVALUE('HKLM\SOFTWARE\ODBC\ODBC.INI\ODBC Data Sources','YOUR ODBC'),'FoxPro')

;   DelODBC('YOUR ODBC') ; HKLM - System DSN

;ENDIF

;IF INSTR(READVALUE('HKCU\SOFTWARE\ODBC\ODBC.INI\ODBC Data Sources','YOUR ODBC'),'FoxPro')

;   DelODBC('YOUR ODBC',1) ; HKCU - User DSN

;ENDIF

;KIXTART BBS 	http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=123893





FUNCTION DelODBC($DSN,optional $user)

   DIM $reg,$odbckey,$rc

   IF NOT $user

      $reg='HKLM'

   ELSE

      $reg='HKCU'

   ENDIF

   $odbckey=$reg+'\SOFTWARE\ODBC\ODBC.INI\'

   IF KEYEXIST($odbckey+$DSN)

      $rc=DELTREE($odbckey+$DSN)

      $rc=DELVALUE($odbckey+'ODBC Data Sources', $DSN)

   ENDIF

ENDFUNCTION

83797DelPrinterConnections119LonkeroDelPrinterConnections()1120623753re-posting 
UDF as it seems to be needed after all.
Code:


;Function:
;        DelPrinterConnections()
;
;Author:
;        Lonkero
;
;Version:
;        1.1
;
;Version History:
;        1.0 - Fri Jan 24 2003 - old enumkey code that failed every second printer
;
;Action:
;        deletes current printer connections
;
;Syntax:
;        Delprinterconnections
;
;Remarks:
;        written for kix versions that does not support delprinterconnection("")
;
;Example:
;        "unmapping printers..."
;        DelPrinterConnections
;        ? "Done."
;
;Source:
function DelPrinterConnections() 
dim $bk,$conn 
 $bk="HKEY_CURRENT_USER\Printers\Connections" 
 do
  $conn=delkey($bk+"\"+enumkey($bk,0))
 until @error
endfunction

82058DeltaTime29JochenDeltaTime() - Calculates time differences up to 23:59:59:9990 
Code:

;FUNCTION         DeltaTime()
;
;AUTHOR           Jochen Polster (jochenDOTpolsterATgmxDOTnet)
;
;VERSION          1.1  04/07/2004 - Fixed for NoVarsInStrings = 0N
;                                   Milliseconds can now be omitted (if Zero) in one of the strings
;
;ACTION           Calculates the time difference between two given times
;
;SYNTAX           DeltaTime(Start,End)
;
;PARAMETERS       Start (Required)
;                  -  String value representing the starttime
;                     Format hh:mm:ss[:ms]
;
;                 End (Required)
;                  -  String value representing the ending time
;                     Format hh:mm:ss[:ms]
;
;REMARKS          Highest possible delta Value is 23:59:59:999 !
;                 If the diff gets higher , the result will be incorrect.
;
;RETURNS          The difference between Start - and Endtime in 'hh:mm:ss[:ms]'
;
;DEPENDENCIES     KiXtart 4.0
;
;EXAMPLES         call "PATH\DeltaTime.udf"
;                 $start = @time + ':' + @msecs
;                 for $i = 0 to 15000
;                     $ = @scriptdir
;                 next
;                 $end = @time + ':' + @msecs
;                 ? 'Start time  : $start' ?
;                 ? 'End time    : $end' ?
;                 $Duration = DeltaTime($start,$end)
;                 ? 'Duration    : $Duration' ? ?
;
;                 $start = "21:59:59" ? 'Backup Started  : $start' ?
;                 $end   = "01:00:01" ? 'Backup Ended    : $end' ?
;                 $d = DeltaTime($start,$end)
;                 ? 'Backup Duration : $d' ?
;
;                 get $k


function DeltaTime($Start,$End)
    dim $, $s, $e, $MS_Start, $MS_End, $S_Start, $S_End, $total, $deltaH, $deltaM, $deltaS, $deltaMS, $i
    $s = split($Start,":")
    $e = split($End,":")
    if ubound($s) <> ubound($e)
        if ubound($s) > ubound($e)
            redim preserve $e[ubound($e)+1]
            $e[ubound($e)] = "000"
        else
            redim preserve $s[ubound($s)+1]
            $s[ubound($s)] = "000"
        endif
    endif
    for $i = 0 to ubound($s)
        $s[$i] = val($s[$i])
        $e[$i] = val($e[$i])
    next
    if ubound($s) = 3
        $MS_Start = $s[3] + $s[2] * 1000 + $s[1] * 60000 + $s[0] * 3600000
        $MS_End   = $e[3] + $e[2] * 1000 + $e[1] * 60000 + $e[0] * 3600000
        select
            case $MS_Start > $MS_End
                $total = 86400000 - ($MS_Start - $MS_End)
            case $MS_Start < $MS_End
                $total = $MS_End - $MS_Start
            case 1
                $DeltaTime = "00:00:00:000" exit 1
        endselect
        $deltaH  = $total / 3600000
        $total   = $total - $deltaH * 3600000
        $deltaM  = $total / 60000
        $total   = $total - $deltaM * 60000
        $deltaS  = $total / 1000
        $deltaMS = $total - $deltaS * 1000
    else
        $S_Start = $s[2] + $s[1] * 60 + $s[0] * 3600
        $S_End   = $e[2] + $e[1] * 60 + $e[0] * 3600
        select
            case $S_Start > $S_End
                $total = 86400 - ($S_Start-$S_End)
            case $S_Start < $S_End
                $total = $S_End - $S_Start
            case 1
                $DeltaTime = "00:00:00" exit 1
        endselect
        $deltaH = $total / 3600
        $total  = $total - $deltaH * 3600
        $deltaM = $total / 60
        $deltaS = $total - $deltaM * 60
    endif
    $deltaH = right('0' + $deltaH, 2)
    $deltaM = right('0' + $deltaM, 2)
    $deltaS = right('0' + $deltaS, 2)
    if ubound($s) = 3
        $deltaMS = right('00' + $deltaMS, 3)
        $DeltaTime = "" + $deltaH + ":" + $deltaM + ":" + $deltaS + ":" + $deltaMS
    else
        $DeltaTime = "" + $deltaH + ":" + $deltaM + ":" + $deltaS
    endif
endfunction

82576DirList17SealeopardDirList() - Returns an array with a list of files 
in a given directory1172121517

Code:

FUNCTION      DirList
;
;ACTION        Returns an array with a list of files in a given directory
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.3  fixed bug that did not pass $options into the recursive call
;              1.2
;
;DATE CREATED  2002/01/18
;
;DATE MODIFIED 2007/02/22
;
;KIXTART       4.12
;
;SYNTAX        DIRLIST(DIRNAME [,OPTIONS])
;
;PARAMETERS    DIRNAME
;              Required string containing the directory name
;
;              OPTIONS
;              Optional value for additional options, options are set bitwise
;              1 = include directories (denoted by a backslash) that match the search mask
;              2 = include full path
;              4 = search all subdirectories
;
;RETURNS       array with a list of files, otherwise an empty string
;
;REMARKS       none
;
;DEPENDENCIES  none
;
;EXAMPLE       $dirlist = DIRLIST("c:\*.*",1+2+4)
;
;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Board=UBB12&Number=82077
;
function dirlist($dirname, optional $options)
  dim $filename, $counter, $filepath, $mask
  dim $list, $sublist, $subcounter

  $counter=-1

  $dirname=trim($dirname)
  if $dirname=''
    $dirname=@CURDIR
  endif
  if right($dirname,1)='\'
    $dirname=left($dirname,len($dirname)-1)
  endif
  if getfileattr($dirname) & 16
    $mask='*.*'
  else
    $mask=substr($dirname,instrrev($dirname,'\')+1)
    $dirname=left($dirname,len($dirname)-len($mask)-1)
  endif

  redim $list[10]
  $filename=dir($dirname+'\'+$mask)
  while $filename<>'' and @ERROR=0
    if $filename<>'.' and $filename<>'..'
      select
      case (getfileattr($dirname+'\'+$filename) & 16)
        if $options & 1
          $counter=$counter+1
          if $options & 2
            $list[$counter]=$dirname+'\'+$filename+'\'
          else
            $list[$counter]=$filename+'\'
          endif
        endif
        if ($options & 4)
          $sublist=dirlist($dirname+'\'+$filename+'\'+$mask,$options)
          if ubound($sublist)+1
            redim preserve $list[ubound($list)+ubound($sublist)+1]
            for $subcounter=0 to ubound($sublist)
              $counter=$counter+1
              if $options & 2
                $list[$counter]=$dirname+'\'+$filename+'\'+$sublist[$subcounter]
              else
                $list[$counter]=$filename+'\'+$sublist[$subcounter]
              endif
            next
          endif
        endif
      case ($options & 2)
        $counter=$counter+1
        $list[$counter]=$dirname+'\'+$filename
      case 1
        $counter=$counter+1
        $list[$counter]=$filename
      endselect
      if $counter mod 10
        redim preserve $list[$counter+10]
      endif
    endif
    $filename = dir('')
  loop

  if $counter+1
    redim preserve $list[$counter]
  else
    $list=''
  endif

  if $mask<>'*.*' and ($options & 4)
    $filename=dir($dirname+'\*.*')
    while $filename<>'' and @ERROR=0
      if $filename<>'.' and $filename<>'..'
        if (getfileattr($dirname+'\'+$filename) & 16)
          $sublist=dirlist($dirname+'\'+$filename+'\'+$mask,4)
          if ubound($sublist)+1
            redim preserve $list[ubound($list)+ubound($sublist)+1]
            for $subcounter=0 to ubound($sublist)
              $counter=$counter+1
              if $options & 2
                $list[$counter]=$dirname+'\'+$filename+'\'+$sublist[$subcounter]
              else
                $list[$counter]=$filename+'\'+$sublist[$subcounter]
              endif
            next
          endif
        endif
      endif
      $filename = dir('')
    loop
  endif

  if $counter+1
    redim preserve $list[$counter]
  else
    $list=''
  endif

  $dirlist=$list
endfunction
82153DirPlus28BryceDirPlus() - a recursive dir tool1193329141

Code:

;Function		DIRPlus()
;
;Author		Bryce Lindsay bryce@isorg.net
;
;Action		Returns an array containing directory files and folders
;
;Syntax		DIRPLUS("PATH","OPTIONS")
;
;Version		2.34
;
;Date Revised	2-10-05
;			2005.09.20 2.34 Filed the file/folder option "d" to be non language dependent, thanks Jochen
;
;Parameters	Path
;		  Full path To To a folder that you want To Return information on.
;		  "c:\program files"
;
;		  OPTIONS
;		  /S          Displays files In specified directory and all subdirectories.
;                             Use a /S# where # is equal to the subfolder depth that you want to recurse.
;
;		  /A          Displays files with specified attributes.
;		  attributes   D  Directories                R  Read-only files
;		               H  Hidden files               A  Files ready For archiving
;		               S  System files               -  Prefix meaning not
;
;		  /M          Apply mask string To filter based on InSTR(), separate Each search string witha a |
;
;		  /F          Return a given File extension like exe log or txt Seperate each extension type with a space
;
;
;Remarks	Finaly fixed this UDF For To handle multiple recursions,
;		also should have a faster responce time since it is using the FSO
;
;		***Please note that the syntax For version 2.0 of this UDF has changed.***
;
;		made some tweeks using feedback from Les! thanks!  Also NTDOC!
;
;Returns	Returns and array of FSO objects that are equal the file and folder objects of
;		the given path.  Also returns a @ERROR code For event handling.
;
;Dependencies 	FSO
;
;KiXtart Ver	4.22
;
;Example(s)	$Dir = dirplus("c:\program files") ;returns all files and folders In the "c:\program files" folder
;		$Dir = dirplus("c:\program files","/s") ;all fiels and folders including subfolders
;		$Dir = dirplus("c:\","/a-d") ;returns only a list of files In the c:\
;		$Dir = dirplus("c:\","/ad") ;returns only a list of folders In the c:\
;		$Dir = dirplus("c:\program files","/ad /s") ;returns only the folders including all subfolders.
;
;		$Dir = dirplus("g:\kix\udf","/s /ad /m dir") ; recursive subfolder search, folders only, using a mask string of "dir"
;
;		$desktop = dirplus("%userprofile%\desktop","/a-d")
;		For Each $file In $desktop
;			? $file
;			? $file.size
;		Next
;
Function DirPlus($path,optional $Options, optional $f, optional $sfflag)
	If not vartype($f)	DIM $f		EndIf
	If not vartype($sfflag)	DIM $sfflag	EndIf

	DIM $file, $i, $temp, $item, $ex1, $mask,$mask1,$maskArray,$maskarray1,
	$ex2, $code, $CodeWeight, $targetWeight, $weight, $masktrue
	DIM $tarray[0]

	$ex1 = SetOption(Explicit,on)
	$ex2 = SetOption(NoVarsInStrings,on)
	$codeWeight = 0

	If not Exist($path) 
		$temp = SetOption(Explicit,$ex1)
		$temp = SetOption(NoVarsInStrings,$ex2)
		Exit @ERROR
	EndIf

	If not vartype($f)
		$f = CreateObject("Scripting.FileSystemObject").getfolder($path)
	EndIf
	If @ERROR 
		$temp = SetOption(Explicit,$ex1)
		$temp = SetOption(NoVarsInStrings,$ex2)
		Exit @ERROR
	EndIf

 	For Each $temp In Split($options,"/")
		$temp=Trim($temp)
		Select
		   Case left($temp,1) = "s"
			If not vartype($sfflag)
				If Val(right($temp,-1)) = 0
					$sfflag = -1
				Else
					$sfflag = Val(right($temp,-1))
				EndIf	
			EndIf
		   Case Left($temp,1) = "a"
			Select
			   Case Right($temp,-1)="d"
				$codeWeight = $codeWeight + 1
				$temp = "if $file.attributes & 16 " ;"if $file.type = 'File Folder' "
			   Case Right($temp,-1)="-d"
				$codeWeight = $codeWeight + 1
				$temp = "if ($file.attributes & 16)=0 " ;"if $file.type <> 'File Folder' "
			   Case Right($temp,-1)="s"
				$codeWeight = $codeWeight + 1
				$temp = "if $file.attributes & 4 "
			   Case Right($temp,-1)="-s"
				$codeWeight = $codeWeight + 1
				$temp = "if ($file.attributes & 4)=0 "
			   Case Right($temp,-1)="h"
				$codeWeight = $codeWeight + 1
				$temp = "if $file.attributes & 2 "
			   Case Right($temp,-1)="-h"
				$codeWeight = $codeWeight + 1
				$temp = "if ($file.attributes & 2)=0 "
			   Case Right($temp,-1)="r"
				$codeWeight = $codeWeight + 1
				$temp = "if $file.attributes & 1 "
			   Case Right($temp,-1)="-r"
				$codeWeight = $codeWeight + 1
				$temp = "if ($file.attributes & 1)=0 "
			   Case Right($temp,-1)="a"
				$codeWeight = $codeWeight + 1
				$temp = "if $file.attributes & 32 "
			   Case Right($temp,-1)="-a"
				$codeWeight = $codeWeight + 1
				$temp = "if ($file.attributes & 32)=0 "
			EndSelect
			$code = $temp + "$weight=$weight+1 endif" +@CRLF + $code

		   Case Left($temp,1) = "m"
			$maskarray = Split(Right($temp,-2),"|")
			$codeweight = $codeweight + 1
			$code = "$masktrue=0 for Each $mask in $maskarray if instr($file.name,$mask) $masktrue=1 " +
			"EndIf Next If $masktrue $weight=$weight+1 endif" + @CRLF +$code
		   Case Left($temp,1) = "f"
			$maskarray1 = Split(Right($temp,-2)," ")
			$codeweight = $codeweight + 1
			$code = "$masktrue=0 for Each $mask1 in $maskarray1 if substr($file.name,Instrrev($file.name,'.')+1)" +
			"=$mask1 $masktrue=1 EndIf Next If $masktrue $weight=$weight+1 endif" + @CRLF +$code

		EndSelect
	Next
	$code = "$weight = 0 $targetWeight = " + $codeweight + @CRLF + $code
	$code = $code + "if $weight = $targetweight Exit 1 endif"

	For Each $file In $f.subfolders
		If Execute($code)
			$tarray[$i] = $file
			$i = $i + 1
			ReDIM preserve $tarray[$i]
		EndIf
		If $sfflag
			$temp = dirplus($file,$options,$file,$sfflag-1)
			For Each $item In $temp
				$tarray[$i] = $item
				$i = $i + 1
				ReDIM preserve $tarray[$i]
			Next
		EndIf
	Next
	For Each $file In $f.files
		If Execute($code)
			$tarray[$i] = $file
			$i = $i + 1

			ReDIM preserve $tarray[$i]
		EndIf
	Next

	If $i
		ReDIM preserve $tarray[$i-1]
		$i=0
	Else
		$tarray = 0
	EndIf

	$dirplus = $tarray
	$temp = SetOption(Explicit,$ex1)
	$temp = SetOption(NoVarsInStrings,$ex2)
	Exit @ERROR
EndFunction
83678DirScan119LonkeroDirScan() - yet another dir UDF0Code:

;Function:	DirScan

;

;Author:	Jooel Nieminen

;

;Version:	1.0 (21th of November 2002)

;

;Action:	scans dir for objects (file&folder)

;

;Syntax:	DirScan($folder [,$mode [,$recursive]])

;

;Parameters:

;		$folder    - folder to scan

;		$recursive - optional, set to scan also subfolders

;		$mode      - optional, possible values are:

;			0 return full path to items (default)

;			1 return item names

;			2 return item types

;

;Returns:

;		modes 0,1 and 2: array

;		mode 3: integer

;

;Dependencies:

;		for windows 2000 and XP none

;		for windows NT and 95 IE4 with integrated shell

;

;Remarks:

;		dependency comes from shell32.dll version, mimimum

;		working version 4.71

;		reason to post is to get different source for the info.

;		before there was wsh, piping to shell and one with flat dir (no recursive) with kix's dir-function.

;		this one uses shell32.dll

;

;Example:	

;		"listing userprofiledirectory" ?

;		"items total: " dirscan("%userprofile%",3,1) ?

;		$itempaths=dirscan("%userprofile%",,1)

;		$itemtypes=dirscan("%userprofile%",2,1)

;		"all the items with type and path:" ?

;		for $counter=0 to ubound($itemtypes)

;		 $itemtypes[$counter] ": " $itempaths[$counter] ?

;		next

;

;Source:

function dirscan($folder,optional $mode,optional $recursive,optional $reserved)

dim $shell,$item,$root

if not $reserved redim $dirscan $root=$folder endif

$shell=createobject("shell.application")

for each $item in $shell.namespace($folder).items

 if $mode=1

  $dirscan=$dirscan+$item.name+chr(10)

 endif

 if $mode=2

  $dirscan=$dirscan+$item.type+chr(10)

 endif

 if not $mode

  $dirscan=$dirscan+$item.path+chr(10)

 endif

 if $recursive and $item.isfolder

   $dirscan=$dirscan+dirscan($item.path,$mode,1,1)

 endif

next

if $mode=3

  $dirscan=$shell.namespace($folder).items.count+$dirscan

else

 if $folder=$root

  $dirscan=split($dirscan,chr(10))

  redim preserve $dirscan[ubound($dirscan)-1]

 endif

endif

endfunction

84404DirWalker3755GavenDirWalker() - Given a directory returns the next 
directory according to order on disk0

code:

;  Function:     DirWalker()
;
;  Author:       Gaven Henderson, Gaven@GavDogg.net
;  
;  Action:       Given a directory returns the next directory according to order on disk.
;                Note that the function uses the Dir command with handle "2" allowing for
;                the calling code to be simultaneously enumerating a directory with
;                handle "1".  
;  
;  Syntax:       dirwalker(["directory"])
;
;  Parameters:   directory
;                   Specifies the current directory, begin searching a drive with "x:"
;
;  Version:      1.3
;
;  Post Date:    June 28, 2003
;
;  Revise Date:  July 29, 2003
;  
;  Returns:      Returns the next directory (after the one specified) according to disk
;                order.  Note:  the root directory will never be a result as it is the
;                starting point of a disk.
;  
;                @ERROR
;                   0  - successful, result returned
;                   3  - invalid directory specified
;                   18 - no more directories
;
;  KiXtart Ver:  Designed on 4.20 but should work on any version.
;
;  Example:      $dir="c:"
;                While @error=0
;                     $x=$dir+"\file.txt"
;                     If Exist($x)
;                          "Found $x" ?
;                     EndIf
;                     $dir=dirwalker($dir)
;                Loop
;
Function dirwalker($a)
	Dim $b,$c
	If Not (GetFileAttr($a) & 16) Exit 3 EndIf
	If Right($a,1)="\" $a=Left($a,Len($a)-1) EndIf
	$b=$a+"\"+Dir($a+"\*.*",2)
	While @Error=0
		If Right($b,1)<>"." And (GetFileAttr($b) & 16)
			$dirwalker=$b
			Exit 0
		EndIf
		$b=$a+"\"+Dir("",2)
	Loop
	While Right($a,1)<>":"
		$c=Left($a,InStrRev($a,"\")-1)
		$b=$c+"\"+Dir($c+"\*.*",2)
		While $b<>$a
			$b=$c+"\"+Dir("",2)
		Loop
		$b=$c+"\"+Dir("",2)
		While @Error=0
			If (GetFileAttr($b) & 16) And Right($b,1)<>"."
				$dirwalker=$b
				Exit 0
			EndIf
			$b=$c+"\"+Dir("",2)
		Loop
		$a=$c
	Loop
	$dirwalker=""
	Exit 18
EndFunction



[ 29. July 2003, 15:53: Message edited by: Gaven ]82884DisableAutoLogon17SealeopardDisableAutoLogon() 
- Disables autologon0

code:

;FUNCTION      DisableAutoLogon()
;
;ACTION        Disables autologon
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.3 (added remote computer as optional input)
;              1.2 (added return of error codes, added AutoLogonCount and
;                   IgnoreShiftOverride registry values)
;              1.1
;
;DATE CREATED  2002/01/18
;
;DATE MODIFIED 2003/06/01
;
;KIXTART       4.02+
;
;SYNTAX        DISABLEAUTOLOGON([COMP])
;
;PARAMETERS    COMP
;              optional name of a remote computer for which the autologon will be disabled
;
;RETURNS       0 if successful, otherwise error code
;
;REMARKS       none
;
;DEPENDENCIES  none
;
;EXAMPLE       $retcode=DISABLEAUTOLOGON()
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000151
;
function disableautologon(optional $comp)
  Dim $regsubkey, $rc

  if @INWIN=1
    $regsubkey='HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon'
  else
    $regsubkey='HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Winlogon'
  endif

  $comp=trim($comp)
  if $comp
    $regsubkey='\\'+$comp+'\'+$regsubkey
  endif

  $rc=writevalue($regsubkey,'AutoAdminLogon',0,'REG_SZ')
  $rc=writevalue($regsubkey,'AutoLogonCount',0,'REG_SZ')
  $rc=writevalue($regsubkey,'DefaultDomainName',@LDOMAIN,'REG_SZ')
  $rc=writevalue($regsubkey,'DefaultPassword','','REG_SZ')
  $rc=writevalue($regsubkey,'DefaultUsername','','REG_SZ')
  $rc=writevalue($regsubkey,'DontDisplayLastUserName',1,'REG_SZ')
  $rc=writevalue($regsubkey,'IgnoreShiftOverride ',0,'REG_SZ')
  exit @ERROR

endfunction



[ 02. June 2003, 03:54: Message edited by: sealeopard ]128323DiskDriveInfo119LonkeroDiskDriveInfo() 
-Lists HardDrive (fixed disk) info0 Code:

 ;Function:

;	DiskDriveInfo()

;

;Author:

;	Lonkero

;

;Credits:

;	NTDOC	- Based on your UDF

;	Chris S.	- you made it possible with Kixomatic

;

;Version:

;	1.0

;

;Version History:

;	1.0 - 22.10.2004 - initial release

;

;Action:

;	Lists info about fixed Disk Drives

;

;Syntax:

;	DiskDriveInfo([COMPUTER])

;

;Parameters:

;	COMPUTER

;	 optional. if given, queries the info from that given remote computer.

;

;Remarks:

;	Not all nice info in here. Restricted the data collection to only WMI.

;	Thus, even though I would have liked, can't identify the Logical Disk's

;	 Hardware location. On that, WMI sucks.

;

;Returns:

;	Array of DiskDrives.

;	Each Element Consisting of Array of values:

;	 0 - Disk Model

;	 1 - Disks Interface

;	 2 - Disks Size (in GB's)

;

;Dependencies:

; 	WMI

;

;Example:

;	"Listing Fixed Disks On this System." ?

;	"Model	Interface	Size" ?

;	for each $HD in DiskDriveInfo()

;	 $HD[0] "	" $HD[1] "	" $HD[2] ?

;	next

;	get $

;

;Source:

Function DiskDriveInfo(optional $Computer)

  Dim $Disk,$DL,$Size,$

  if not $Computer $Computer = "." endif

  For Each $Disk In GetObject('winmgmts:{impersonationLevel=impersonate}!//' + $Computer + '\root\cimv2' ).ExecQuery('select * from Win32_DiskDrive', , 48)

    $Size = ""+((0.0+$Disk.Size) / 1000000000)

    $Size = split($Size,iif(instr($Size,","),",","."))

    if 1 = ubound($Size)

     $Size = "" + $Size[0] + iif(0<>left($Size[1],1), "." + left($Size[1],1),"")

    else

     $Size=$Size[0]

    endif

    $DL = $DL + chr(10) + $Disk.Model + chr(13) + $Disk.interfacetype + chr(13) + $Size + 'GB'

  Next

  $DL = split(substr($DL,2),chr(10))

  for $=0 to Ubound($DL)

   $DL[$] = split($DL[$],chr(13))

  next

  $DiskDriveInfo=$DL

EndFunction

 

82589DiskSpace17SealeopardDiskSpace() - returns the available disk space on 
a drive0

code:

;FUNCTION      DiskSpace
;
;ACTION        returns the available disk space on a drive
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;CONTRIBUTORS  NTDOC, Radimus, kholm
;
;VERSION       1.4 (added PetaByte, Percentage as unit sizes)
;              1.3 (shortened code, included UNCs as valid input)
;              1.2 (added optional drive and optional units)
;              1.1
;
;DATE CREATED  2001/12/18
;
;DATE MODIFIED 2003/07/06
;
;KIXTART       4.21
;
;SYNTAX        DISKSPACE([DRIVE, FORMAT])
;
;PARAMETERS    DRIVE
;              optional driveletter, directory, or UNC (defaults to system drive)
;
;              FORMAT
;              optional parameter indicating the units to be used when returning the
;              available disk space
;              0 = KB (KiloByte, default)
;              1 = MB (MegaByte)
;              2 = GB (GigaByte)
;              3 = TB (TeraByte)
;              4 = PB (PetaByte)
;              5 = %  (percentage total diskspace, does not support UNCs)
;
;RETURNS       available diskspace
;
;REMARKS       none
;
;DEPENDENCIES  WMI (only for FORMAT = 5)
;
;EXAMPLE       $rc=DISKSPACE()
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000094
;
function diskspace(optional $drive, optional $format)
  dim $objWMIService, $sWQL, $colDrives, $objDrive
  if not $drive
    $drive='%WINDIR%'
  endif
  $format=val($format)
  if $format<5
    $format=iif($format=1,1024,iif($format=2,1024.0*1024,iif($format=3,1024.0*1024*1024,iif($format=4,1024.0*1024*1024*1024,1))))
    $diskspace=cdbl(GETDISKSPACE($drive))/$format
  else
    $objWMIService=getobject('winmgmts:{impersonationLevel=impersonate}!\\'+@WKSTA+'\root\cimv2')
    $sWQL = "SELECT Size, FreeSpace FROM Win32_LogicalDisk WHERE Name='"+left($drive,2)+"'"
    $colDrives=$objWMIService.ExecQuery($sWQL)
    for each $objDrive in $colDrives
      $diskspace=cdbl($objDrive.FreeSpace)/cdbl($objDrive.Size)*100
    next
  endif
  exit @ERROR
endfunction



[ 07. July 2003, 04:20: Message edited by: sealeopard ]127326DisplayGrid17SealeopardDisplayGrid() 
- Displays a 2-D array with optional1096763696Code:


;FUNCTION      DisplayGrid()

;

;ACTION        Displays a 2-D array with optional header

;

;AUTHOR        Jens Meyer (sealeopard@usa.net)

;

;VERSION       1.1  (added alignment options for header and data rows)

;              1.0

;

;DATE CREATED  2004/10/01

;

;DATE MODIFIED 2004/10/01

;

;KIXTART       4.22+

;

;SYNTAX        RETCODE = DISPLAYGRID(ARRAY [, HEADER, COUNTER, DELIMITER, HEADERDELIMITER, HEADALIGN, ROWALIGN])

;

;PARAMETERS    ARRAY

;              A 2-D array whose values are to be displayed in a grid

;

;              HEADER

;              An optional array with the column names

;

;              COUNTER

;              An optional boolean enabling the display of a rowcounter

;

;              DELIMITER

;              An optional string with the delimiter between columns

;

;              HEADERDELIMITER

;              An optional string with the delimiter between the header row and the data rows

;

;              HEADALIGN

;              Optional integer denoting header column alignment with 0=left, 1=center, and 2=right alignment

;

;              ROWALIGN

;              Optional integer denoting row column alignment with 0=left, 1=center, and 2=right alignment

;

;RETURN        0 if successful, otherwise error code

;

;REMARKS       Can be used to display tables from a database

;

;DEPENDENCIES  none

;

;EXAMPLE       $asColumns='column 1','column 2','column 3'

;              redim $asData[2,2]

;              for $iRow=0 to 2

;                for $iColumn=0 to 2

;                  $asData[$iRow,$iColumn]=''+$iRow+'-'+$iColumn

;                next

;              next

;              $iRC=DisplayGrid($asData,$asColumns,1,'|','=',1,0)

;

;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=126361

;

function DisplayGrid($asData,optional $asHeader, optional $bCnt, optional $sDelimiter, optional $sHeadDelim, optional $iHeadAlign, optional $iRowAlign)

  dim $iRow, $iColumn, $iRows, $iColumns, $iFieldLength, $asFiller, $asString, $sStringOut, $iStringLength, $sString



  if not (vartype($asData) & 8192)

    exit 3

  endif



  ; determine whether rowcounts need to be displayed

  $bCnt=iif($bCnt,1,0)



  ; set the default delimiter

  if $sDelimiter<>''

    $sDelimiter=iif($sDelimiter,$sDelimiter,' ')

  endif



  ; set the alignments

  if $iHeadAlign<>1 and $iHeadAlign<>2

    $iHeadAlign=0

  endif

  if $iRowAlign<>1 and $iRowAlign<>2

    $iRowAlign=0

  endif



  ; get maximum filed length in each column of the data grid

  $iRows = ubound($asData,1)

  $iColumns = ubound($asData,2)

  dim $aiColumnLength[$iColumns+$bCnt], $asColumnFiller[$iColumns+$bCnt]

  for $iRow=0 to $iRows

    for $iColumn=0 to $iColumns

      $iFieldLength = cdbl(len(cstr($asData[$iRow,$iColumn])))

      if $iFieldLength > $aicolumnLength[$iColumn+$bCnt]

        $aicolumnLength[$iColumn+$bCnt] = $iFieldLength

      endif

    next

  next



  ; get maximum field length in each header column

  if vartype($asHeader) & 8192

    $iColumns=ubound($asHeader)

    for $iColumn=0 to $iColumns

      $iFieldLength = cdbl(len(cstr($asHeader[$iColumn])))

      if $iFieldLength > $aicolumnLength[$iColumn+$bCnt]

        $aicolumnLength[$iColumn+$bCnt] = $iFieldLength

      endif

    next

  endif



  ; get maximum field length for rowcounter

  if $bCnt

    $aiColumnLength[0]=cdbl(len(cstr($iRows+1)))

 endif



  ; create the fillers for each column

  for $iColumn=0 to $iColumns+$bCnt

    redim $asFiller[$aicolumnLength[$iColumn]]

    $asColumnFiller[$iColumn]=join($asFiller,' ')

  next



  ; display the header

  if vartype($asHeader) & 8192

    redim $asString[$iColumns+$bCnt]

    for $iColumn=0 to $iColumns+$bCnt

      if $bCnt and $iColumn=0

        $sString=$asColumnFiller[$iColumn]

      else

        $sString=$asHeader[$iColumn-$bCnt]

      endif

      select

        case $iHeadAlign=0

            $asString[$iColumn]='' + $sString

                                + left($asColumnFiller[$iColumn],$aiColumnLength[$iColumn]-len($sString))

        case $iHeadAlign=1

            $asString[$iColumn]=left($asColumnFiller[$iColumn],cint(($aiColumnLength[$iColumn]-len($sString))/2))

                                + $sString

                                + substr($asColumnFiller[$iColumn],cint(($aiColumnLength[$iColumn]-len($sString))/2)+len($sString)+1)

        case $iHeadAlign=2

            $asString[$iColumn]=left($asColumnFiller[$iColumn],$aiColumnLength[$iColumn]-len($sString))

                                + $sString

      endselect

    next

    $sStringOut=join($asString,$sDelimiter)

    ? $sStringOut

  endif



 ; display the optional header line delimiter

  if $sHeadDelim

    $iStringLength=len($sStringOut)

    redim $sStringOut[$iStringLength/len($sHeadDelim)+1]

    $sStringOut=left(join($sStringOut,$sHeadDelim),$iStringLength)

    ? $sStringOut

  endif



  ; display the individual rows

  $iRows = ubound($asData,1)

  $iColumns = ubound($asData,2)

  for $iRow=0 to $iRows

    redim $asString[$iColumns+$bCnt]

    for $iColumn=0 to $iColumns+$bCnt

      if $bCnt and $iColumn=0

        $sString=cstr($iRow+1)

      else

        $sString=$asData[$iRow,$iColumn-$bCnt]

      endif

      select

        case $iRowAlign=0

            $asString[$iColumn]='' + $sString

                                + left($asColumnFiller[$iColumn],$aiColumnLength[$iColumn]-len($sString))

        case $iRowAlign=1

            $asString[$iColumn]=left($asColumnFiller[$iColumn],cint(($aiColumnLength[$iColumn]-len($sString))/2))

                                + $sString

                                + substr($asColumnFiller[$iColumn],cint(($aiColumnLength[$iColumn]-len($sString))/2)+len($sString)+1)

        case $iRowAlign=2

            $asString[$iColumn]=left($asColumnFiller[$iColumn],$aiColumnLength[$iColumn]-len($sString))

                                + $sString

      endselect

    next

    $sStringOut=join($asString,$sDelimiter)

    ? $sStringOut

  next

  exit @error

endfunction

82266DisplayText17SealeopardDisplayText() - Display text incl. logging 
option0

code:

;FUNCTION      DisplayText
;
;ACTION        Prints text to screen or file
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.6 (changed parameter order as textcolor parameter is less comon)
;              1.5
;
;DATE CREATED  2001/11/26
;
;DATE MODIFIED 2003/07/30
;
;KIXTART       4.20
;
;SYNTAX        DISPLAYTEXT(STRING [, TYPE, TEXTCOLOR])
;
;PARAMETERS    STRING
;              Required string containing the text to be displayed/logged
;
;              TYPE
;              Optional integer denoting a warning (1), error (2), or verbose (3) display
;
;              TEXTCOLOR
;              Optional text color
;
;RETURNS       1 if text has been displayed on screen, otherwise 0
;
;REMARKS       Requires the global variables:
;              $OUTPUTLINE (output line counter),
;              $LOGFILE (filename for additional logging),
;              $OUTPUT (output redirector, defaults to the screen),
;              $SCROLLING (enables scrolling display mode),
;              $LOGGING (bit-wise integer defining log levels)
;                1 = send output to screen (or other output device defined in $OUTPUT)
;                2 = send output to logfile (file defined in $LOGFILE)
;                4 = add time/date stamps to file log (screen output has no timestamps)
;                8 = print warnings to screen
;               16 = print warnings to logfiles
;               32 = print errors to screen
;               64 = print errors to logfile
;              128 = print verbose to screen
;              256 = print verbose to logfile
;
;DEPENDENCIES  none
;
;EXAMPLE       $rc=displaytext('This is an informal text!')
;              ; next line prints to screen if $LOGGING<>0
;              $rc=displaytext('This is an informal text!',1)
;              ; next line writes to $LOGFILE if $LOGGING<>0
;              $rc=displaytext('This is an informal text!',2)
;              ; next line prints to screen and writes to $LOGFILE if $LOGGING<>0
;              $rc=displaytext('This is an informal text!',3)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000036
;
function displaytext($text, optional $textcolor, optional $displaytype)
  Dim $rc, $length, $print2screen, $print2log, $screentext, $chars
  Dim $leftborder, $rightborder, $leftfill, $lines, $line, $a
  Dim $rows, $cols, $timestamps, $warnings2screen, $errors2screen
  dim $warnings2log, $errors2log
  dim $verbose2screen, $verbose2log

  ; assume windows size of 25 rows and 80 columns per row
  $rows=25
  $cols=80

  $print2screen=1
  $print2log=2
  $timestamps=4
  $warnings2screen=8
  $warnings2log=16
  $errors2screen=32
  $errors2log=64
  $verbose2screen=128
  $verbose2log=256
  $lines=0
  $leftborder=2
  $rightborder=1
  $screentext=''
  $chars=$cols-$leftborder-$rightborder

  if vartype($displaytype)
    $displaytype=val($displaytype)
  else
    $displaytype=0
  endif

  for $a=1 to $leftborder
    $leftfill=$leftfill+' '
  next

  if $text
    select
    case ($LOGGING & $print2log) and $displaytype=0
      $displaytext=1
    case ($LOGGING & $warnings2log) and $displaytype=1
      $displaytext=1
    case ($LOGGING & $errors2log) and $displaytype=2
      $displaytext=1
    case ($LOGGING & $verbose2log) and $displaytype=3
      $displaytext=1
    case 1
      $displaytext=0
    endselect

    if $displaytext and $LOGFILE
      $rc=redirectoutput($LOGFILE,0)
      if ($LOGGING & $timestamps)
        ? ''+@DATE+' '+@TIME+'.'+right('000'+@MSECS,3)+' - '+$text
      else
        ? $text
      endif
      $rc=redirectoutput($OUTPUT)
    endif

    select
    case (($LOGGING & $print2screen) and $displaytype=0)
      $displaytext=1
    case (($LOGGING & $warnings2screen) and $displaytype=1)
      $displaytext=1
    case (($LOGGING & $errors2screen) and $displaytype=2)
      $displaytext=1
    case (($LOGGING & $verbose2screen) and $displaytype=3)
      $displaytext=1
    case 1
      $displaytext=0
    endselect

    if $displaytext

      $lines=len($text)/$chars
      if (len($text) mod $chars)
        $lines=$lines+1
      endif
      if ($OUTPUTLINE+$lines)>($rows-1) and $SCROLLING=0
        cls
        $OUTPUTLINE=0
      endif

      if $OUTPUT='' and $textcolor
        color $textcolor
      endif

      for $line=1 to $lines
        at($OUTPUTLINE,0) $leftfill+left($text,$chars)
        $text=substr($text,$chars+1)
        $OUTPUTLINE=$OUTPUTLINE+1
        ? ''
      next

      if $OUTPUT='' and $textcolor
        color w/n
      endif

    endif
  endif
endfunction



[ 30. July 2003, 21:33: Message edited by: sealeopard ]167582Distance28BryceDistance() 
- Return the distance between 2 points.0Code:


/* Function	Distance()

Author		Bryce Lindsay

Action		Returns the distance between 2 points

Syntax		Distance(Point1, Point2)

Version		1.0

Date		1:04 PM 9/13/2006

Date Revised	1:04 PM 9/13/2006

Parameters	Point#
		This is a string of coordinates, X,Y You can also use 
		an optional Z.  
		use a , to set X Y "33,2"  or with the optional Z "33,2,10"

Remarks		This is just the Pythagorean theorem....

Returns		Distance between two points.

Dependencies	SQRT(), SQR()

KiXtart Ver	4.50
 
Example(s)	
	;sample using only x,y on a 2d grid
	$Point1 = "10,2"
	$Point2 = "22,11"
	? "the distance between Point1 and Point2 is " Distance($point1,$point2)

	;sample using x,y,z in a 3d space
	$Point1 = "10,2,33"
	$Point2 = "22,11,66"
	? "the distance between Point1 and Point2 is " Distance($point1,$point2)
*/ 
Function Distance($p1,$p2)
	dim $i
	$p1 = split($p1,',')
	$p2 = split($p2,',')
	if ubound($p1)<>ubound($p2) 
		exit 2
	endif
	for $i = 0 to ubound($p1)
		$p1[$i] = cdbl($p1[$i])
		$p2[$i] = cdbl($p2[$i])
	next
	Select
	   case ubound($p1) = 1
		$Distance = sqrt(sqr(cdbl($p2[0])-$p1[0]) + sqr($p2[1]-$p1[1]))
	   Case ubound($p1) = 2
		$Distance = sqrt(sqr(cdbl($p2[0])-$p1[0]) + sqr($p2[1]-$p1[1]) + sqr($p2[2]-$p1[2]))
	endselect
endfunction

83001Divide5474DrillSergeantDivide() - Divide large numbers & fractions (without 
kixtart limitations)0

Function Divide($g1,$g2, Optional $d)

;Function Divide()

;Author DrillSergeant (rogertheyoung@hotmail.com)

;Action Divide numbers without kix limitations.

;Syntax Divide($Number1, $Number2, [$precision])

;Parameters $Number1 (Required) - The number you want to divide.
; $Number2 (Required) - The number you want to divide by.
; $Precision - The number of decimals you want.

;Returns The result of the division (in a string)

;Remarks Yes, I'll add the other moderators (+, -, *) too . I've written them a while ago, but I need to join them with this one.

;Dependencies The little function Zfill at the end. This is used for filling out some of the strings with zeros.

;Example(s) Divide('233453223534523254234325235324532','324532644553453425623')
; Divide('22','7',30)
; Divide('-234523235423.2332523','34525.2353',2)

;Source

; Check & Set Minus Sign
$s=''
if left($g1,1)='-' $s='-' $g1=substr($g1,2) endif
if left($g2,1)='-' $s=$s+'-' $g2=substr($g2,2)endif
if $s='--' $s='' endif

; Check for Decimal Point(s)
$z=0
$p=instr($g1,'.')
if $p>0 $z=$z-len($g1)+$p $g1=left($g1,$p-1)+substr($g1,$p+1) endif
$p=instr($g2,'.')
if $p>0 $z=$z+len($g2)-$p $g2=left($g2,$p-1)+substr($g2,$p+1) endif
if $z>0 $g1=$g1+ZFill($z) endif
if $z<0 $g2=$g2+ZFill($z) endif

; Make numbers same length
while len($g1)<len($g2) $g1='0'+$g1 loop
while len($g2)<len($g1) $g2='0'+$g2 loop

; Make result string
$r='0.'+ZFill($d) $p=1

while $g2+'0'<='0'+$g1
$g2=$g2+'0' $g1='0'+$g1 $r='0'+$r $p=$p+1
loop

while $g2>$g1
$g2='0'+$g2 $g1=$g1+'0' $p=$p-1
loop

; Main Loop
while 1
; Remove leading Zeros
while left($g1,1)='0' and left($g2,1)='0'
$g1=substr($g1,2) $g2=substr($g2,2)
loop

; Remove trailing Zeros
while right($g1,1)='0' and right($g2,1)='0'
$g1=left($g1,len($g1)-1) $g2=left($g2,len($g2)-1)
loop

$t=0
while $g1>=$g2
$c=0
for $i=len($g1) to 1 step -1
$g1a=asc(substr($g1,$i,1))-48
$g2a=asc(substr($g2,$i,1))-48+$c $c=0
if $g1a<$g2a $g1a=$g1a+10 $c=1 endif
$g1=substr($g1,1,$i-1)+chr($g1a-$g2a+48)+substr($g1,$i+1)
next
$t=$t+1
loop

if $p<1 $k=instr($r,'.')-$p+1 else $k=instr($r,'.')-$p endif
if $k>len($r) goto done endif

$r=substr($r,1,$k-1)+chr($t+48)+substr($r,$k+1) $g1=$g1+'0' $g2='0'+$g2 $p=$p-1
loop

:done
$divide=$s+$r

EndFunction

Function ZFill($l)
$l=val('$l') $str=''
if $l<0 $l=$l*-1 endif
for $c=1 to $l $str=$str+'0' next
$ZFill=$str
EndFunction

[ 27 February 2002: Message edited by: DrillSergeant ]83745doc2txt119Lonkerodoc2txt() 
- convert word document to text0Code:


;Function:	Doc2txt()

;

;Author:	Jooel Nieminen

;

;Version:	1.0 (4th of December 2002)

;

;Action:	Converts word document to text file

;

;Syntax:	Doc2txt("SOURCE", "TARGET")

;

;Parameters:

;		SOURCE	- full path to source file

;		TARGET	- full path to destination file

;

;Returns:

;		Nothing. check errorcode for errors.

;

;		on error errorcodes set:

;			1 -source does not exist

;			2 -failed to initialize WORD-object

;			3 -conversion failed

;

;Dependencies:

;		Word ;)

;

;Remarks:

;		if target file exists, it will be overwritten.

;		tested with off2k sr-1. no other versions to test on.

;		some lines are stolen from shawns posts ;)

;

;Example:	

;		if not doc2txt("\\Docuserver\general\eula.doc","%temp%\eula.txt")

;			"NETWORK EULA:" ?

;			display "%temp%\eula.txt"

;		endif

;

;Source:

function doc2txt($_s,$_d)

 dim $_objW

 if not exist($_s) $doc2txt=1 exit 1 endif

 if exist($text) del $text endif

 $_objW = createobject("word.application")

 if @error $doc2txt=2 exit 2 endif

 $_objW.documents.open($_s).saveas($_d,5)

 if @error $doc2txt=3 exit 3 endif

 $_objW.quit

endfunction

83271DriveEnum31RadimusDriveEnum() - return a list of specific, connected 
drive types0

code:

;Function DriveEnum()
;
;Author Radimus
;
;Version 1 (06.20.2002)
;
;Action Returns a list of all connected drive letters (space seperated). 
;
;Syntax DriveEnum(optional $filter)
;
;Parameters
; $filter- (to return specific types of drives. any combination of the numbers below)
; 0/"" - return all drives
; 1 - return removable drives
; 2 - return fixed drives
; 3 - return network drives
; 4 - return CD rom drives
; 5 - return RAM drives
;
;
;Remarks
;
;
;Returns
; -space seperated list of drive letters use split() to seperate
;
;
;Dependencies
; WSH - kix 4.02+
;
;Examples
; $netdrives=DriveEnum(3)
; $localdrives=DriveEnum(124)
; $all=DriveEnum("")
;
;Source
;******************************************************************
function DriveEnum(optional $filter)
	dim $fso, $Drive

	$fso=CreateObject("Scripting.FileSystemObject")
	if $fso
		for each $Drive in $fso.Drives
			if instr($filter,$Drive.DriveType) or $filter=""
				$DriveEnum=$DriveEnum+$Drive.DriveLetter+" "
				endif
			next
		$DriveEnum=left($DriveEnum,len($DriveEnum)-1)
		$fso=""
		endif
	endfunction



[ 20 June 2002, 20:47: Message edited by: Radimus ]83909DriveIcon31RadimusDriveIcon() 
- Assign custom icon to mapped drive0

code:

 
;FUNCTION	DriveIcon()
;
;ACTION 	Set
;
;AUTHOR 	Radimus
;
;CONTRIBUTORS 	Lonkero, since he thought it was necessary
;
;VERSION 	1.01
;
;DATE CREATED 	Mar 14, 2003
;
;DATE MODIFIED 	Mar 14, 2003 9:21am EST
;
;KIXTART 	4.xx
;
;SYNTAX 	DriveIcon($DriveLetter, $Icon)
;
;PARAMETERS 	$DriveLetter
; 		Drive letter to assign Icon to, it only requires character 1 to be valid
;
; 		$Icon
; 		Complete path to Icon
;
;RETURNS 	@error if failed
;
;REMARKS 	Additional remarks about the UDF
;
;DEPENDENCIES 	Admin equivalent rights to registry at:
; 		HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons
;
;		Win2k or WinXP.  it MIGHT work on WinME, but who cares.
;
;EXAMPLE 	DriveIcon('h', '%SystemRoot%\system32\SHELL32.dll,13')
;
;KIXTART BBS 	http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000375
;
;
function DriveIcon($DriveLetter, $Icon)
	dim $di,$nul
	if @producttype="Windows XP Professional" or @producttype="Windows 2000 Professional"
		$di= "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons"
		$nul=writevalue($di+'\'+left($DriveLetter,1)+'\DefaultIcon','',$Icon,REG_SZ)
		if @error 	exit 1		endif
	else	
		exit 1
		endif
	endfunction
 



[ 14. March 2003, 15:15: Message edited by: Radimus ]83272DriveProp31RadimusDriveProp() 
- return an array of FSO drive properties0

code:

;Function DriveProp()
;
;Author Radimus
;
;Version 1 (06.20.2002)
;
;Action Returns an array of drive properties. 
;
;Syntax DriveProp("$drive")
;
;Parameters
; $driveletter- (the drive letter to get properties of)
;
;
;Remarks
;
;
;Returns
; -array of 6 drive properties, not all properties are filled for every drive type
;  "driveletter","drivetype","sharename","isready","filesystem","volumename","serialnumber"
;
;Dependencies
; WSH - kix 4.02+
;
;Examples
; $netdrives=DriveProp("c")
; proparray=split(DriveProp($c))
;
;Source
;******************************************************************
function DriveProp($Drive)
	dim $fso, $Drives, $list, $param, $property
	$DriveType="unknown","removable","fixed","network","cd-rom","ram"
	$DrivePara="driveletter","drivetype","sharename","isready","filesystem","volumename","serialnumber"
	dim $temparray[6]
	$fso = createobject("scripting.filesystemobject")
	if $fso
		$D=$fso.getdrive("$Drive")
		for $param = 0 to ubound($DrivePara)
			$property=$DrivePara[$param]
			$ret=execute('$$temparray[$param]=$$d.$property')
			if $param=1	$temparray[$param]=$DriveType[$temparray[$param]]	endif
			next
		$DriveProp=$temparray
		$fso=""
		endif
	exit @error
	endfunction



[ 20 June 2002, 20:45: Message edited by: Radimus ]122385Easter360kasulEaster() 
- Calculate the Date of the Eastersunday1089809712 Code:

  

;Function:

;                Easter()

;

;Author:

;                Klaus Ubben (kasul)

;

;Contributors:	Jochen Polster (DateCalc)

;               Carl Friedrich Gauss (algorithm)

;

;Action:

;               Calculate the Date of the Eastersunday for a given year

;

;Syntax:

;               Easter(year)

;

;Version:

;               1.0

;

;Date:

;               2004/07/08

;

;Parameters:

;              $year: (required)  

;                  a year (4-digits)

;

;      

;Returns:

;              the Date of the Eastersunday for a given Year

;

;Dependencies:

;              DateCalc()

;       

;Remarks:

;              Uses the Gauss-Algorithm. Should work for years btween 1583 and 8202

;

;

;Examples:

;              ? Easter(2004)			; gives "2004/04/11"

;

;Source:

Function Easter($J)

  Dim $d, $e

  $d = ((15 + (($J / 100) - ($J / 400) - 2) - (((8 * ($J / 100) + 13) / 25) - 2)) mod 30 + 19 * ($J mod 19)) mod 30

  If $d=29 OR ($d=28 AND ($J mod 19)>=11) $d=$d-1 EndIf

  $e = (2 * ($J mod 4) + 4 * ($J mod 7) + 6 * $d + ((6 + (($J / 100) - ($J / 400) - 2)) mod 7)) mod 7

  $Easter=DateCalc(""+$J+"/03/21",$d+$e+1)

EndFunction





83449EditShortCut31RadimusEditShortCut() - read and change the target of a 
shortcut or delete it0EditShortcut will read the target of a given shortcut 
and will:

delete the shortcut

change the target of the shortcut

return a 1 if the target matches
requires WSH, kix4.x
only tested on win2k
Author: Me idea based on Lonkero's unLink()
Example to edit the target of a shortcut:
EditShortcut($desktop,"Microsoft Word.lnk","C:\Program Files\Microsoft Office\Office\winword.exe","C:\Program 
Files\Microsoft Office\Office\excel.exe") 

Example to delete a shortcut
EditShortcut($desktop,"Microsoft Word.lnk","C:\Program Files\Microsoft Office\Office\winword.exe",,1) 

Example to find a match:
$x=EditShortcut($desktop,"Microsoft Word.lnk","C:\Program Files\Microsoft Office\Office\winword.exe") 
if $x
? "user has shortcut to winword"
endif

code:

function EditShortcut($lnkPath,$lnkFilename, optional $oldTarget, optional $newTarget, optional $delete)
	dim $WshShell, $oShellLink, $targetpath

	if not exist("$lnkPath\$lnkFilename")	exit 2		return		endif

	$WshShell 	= CreateObject("WScript.Shell")
	$oShellLink 	= $WshShell.CreateShortcut("$lnkPath\$lnkFilename")
	$targetpath	= $oShellLink.TargetPath
	select
		case $oldTarget=$targetpath and $delete
			del "$lnkPath\$lnkFilename"
		case $oldTarget=$targetpath and $newTarget
			$oShellLink.TargetPath = $newTarget
			$oShellLink.Save
		case $oldTarget=$targetpath
			$EditShortcut=1
		case 1
			$EditShortcut=0 exit 1
		endselect
	endfunction



[ 28. October 2002, 15:20: Message edited by: Radimus ]83865EICARTest17SealeopardEICARTest() 
- Checks Anti-Virus Software by writing an EICAR test string0

code:

;FUNCTION      EICARTest
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;              Based on an idea by CMarti posted at
;              http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=2;t=004232
;
;ACTION        Checks Anti-Virus Software by trying to write the EICAR test string
;
;VERSION       1.0
;
;KIXTART       4.12+
;
;SYNTAX        EICARTEST()
;
;PARAMETERS    none
;
;RETURNS       0 if successful, otherwise error code
;
;REMARKS       This might result in an 'Virus Detection' message on the user's desktop
;
;DEPENDENCIES  none
;
;EXAMPLE       IF eicartest()
;                ? 'Your AntiVirus software is malfunctioning'
;              ELSE
;                ? 'Your AntiVirus software is working properly.'
;              ENDIF
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000367
;
function EICARTest()
  dim $eicar, $handle, $rc, $file, $err
  $eicar='X5O!P%@@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*'
  $EICARTest=0
  $file='%TEMP%\eicar.com'

  if exist($file)
    del $file
    if @ERROR
      exit @ERROR
    endif
  endif

  $handle = FreeFileHandle()
  $err=@ERROR

  if $handle
    if open($handle,$file,5)=0
      $rc=writeline($handle,$eicar+@CRLF)
      $rc=close($handle)
      if exist($file)
        $EICARTest=1
        del $file
        if @ERROR
          exit @ERROR
        endif
      endif
    else
      exit @ERROR
    endif
  else
    exit $err
  endif

  if $EICARTest
    exit 5
  else
    exit 0
  endif
endfunction



[ 02. March 2003, 00:06: Message edited by: sealeopard ]136888EjectCDRom28BryceEjectCDRom()1123082189;Function		EjectCDRom()  
;  
;Author		Bryce Lindsay bryce@isorg.net  
;  
;Action		Opens or Closes all cdroms on a computer.  
;  
;Syntax		EjectCDRom([Device#],[Close])  
;  
;Version		1.1  
;  
;Date Revised	2005/08/01  
;  
;Parameters	[Device] the cdrom device number, Use -1 for all devices,  
;				Use 0 for the first device, and so on. 
; 
;		[Close] an optional true value to Close the cdrome drive.  
;  
;Remarks	Found this as some vbscript on the net, and converted it over to kix,   
;		Put it into a UDF, also added the optional Close value  
; 
;		Original idea based on code from Christoph Fricke posted in the  
;		microsoft.public.de.german.scripting.wsh news group 
; 
;		2005.08.01 Added optional Device number 
; 
;Returns	nothing  
;  
;Dependencies 	Windows Media player  
;  
;KiXtart Ver	4.22  
;  
;Example(s)	 
;		;this will open ALL cdroms 
;		EjectCDrom(-1) 
;		;this will close ALL cdroms 
;		EjectCDrom(-1,1) 
; 
;		;this will open the first cdrom  
;		EjectCDrom(0)  
;		;this will close the first cdrom  
;		EjectCDrom(0,1)  
; 
;		;this will open the 2nd cdrom  
;		ejectcdrom(1)			  
;		;this will close the 2nd cdrom  
;		ejectcdrom(1,1)			  

Function EjectCDROM(optional $device,  $close)
	DIM $owmp, $colCDROMs, $i

	$oWMP = CreateObject("WMPlayer.OCX.7")
	$colCDROMs = $oWMP.cdromCollection
	If $colCDROMs.Count >= 1
		If $Device+1
			$colCDROMs.Item($device).Eject
			If $close $colCDROMs.Item($Device).Eject EndIf
		Else
			;all CD ROMS
			For $i = 0 To $colCDROMs.Count - 1
				$colCDROMs.Item($i).Eject
				If $close $colCDROMs.Item($i).Eject EndIf
			Next
		EndIf
	EndIf
	$oWMP.Close
EndFunction
165881EmbedGoogleVideo52NTDOCEmbedGoogleVideo() - Create HTML code to embed 
Google video0

;FUNCTION       EmbedGoogleVideo() - Create HTML code to embed Google video  
;  
;ACTION         Creates the HTML code to allow posting embedded Google videos 
;		on the KiXtart board.  
;  
;AUTHOR         NTDOC 
;  
;SYNTAX         EmbedGoogleVideo($docid,$Title) 
;  
;Version	1.0    
;    
;Date		2006-08-11   
;    
;Date Revised    
;    
;Reason Revised    
;  
;PARAMETERS     $docid: 
;		The DOCID is the number you see in the URL when watching a Google video  
;		It must include the minus sign with the number after the = sign 
;		Example: http://video.google.com/videoplay?docid=-5861348317112531889&hl=en 
;		You would copy this:  -5861348317112531889 
; 
;		$Title: 
;		Title of the video to write into the googlevideo.ini file  
;  
;REMARKS        When posting you need to use the drop down box and choose 
;		using HTML and UBBCode 
;		Once posted using HTML only a Moderator or Admin can edit the post 
;		and retain the HTML coding.  If you edit it yourself it will lose the 
;		HTML and post as regular text. 
;		The example script runs Notepad to open the file to allow you to  
;		copy and paste the code into your KiXrart BBS post. 
;  
;RETURNS        Nothing, it writes a file called GOOGLEVIDEO.INI in the same 
;		directory the script was run from. 
;  
;DEPENDENCIES   KiXtart 4.x 
;  
;  
;EXAMPLES         
;		Break On 
;		Dim $SO 
;		$SO=SetOption('Explicit','On') 
;		$SO=SetOption('NoVarsInStrings','On') 
;		$SO=SetOption('NoMacrosInStrings','On') 
 
;		Dim $Video 
;		$Video = EmbedGoogleVideo('-5861348317112531889','GoDaddy Girl') 
;		RUN 'Notepad.exe ' + '.\googlevideo.ini' 
 
;SOURCE 
 
Function EmbedGoogleVideo($docid,$Title)
  Dim $Source,$Nul
  $Source = '<embed style='+'"'+'width:400px; height:326px;'+'"'+' id='+'"'+'VideoPlayback'+'"' + ' align='+'"'+'middle'+'" ' +
  'type='+'"'+'application/x-shockwave-flash'+'"'+' src='+'"'+'http://video.google.com/googleplayer.swf?docId=' +
  $docid + '"' + ' allowScriptAccess='+'"'+'sameDomain'+'"'+' quality='+'"'+'best'+'"'+' bgcolor='+'"'+'#ffffff '+'"' +
  'scale='+'"'+'noScale'+'"'+' salign='+'"'+'TL'+'" ' +
  'FlashVars='+'"'+'playerMode=embedded'+'"'+'> </embed>'
  $Nul = WriteProfileString('.\googlevideo.ini','MOVIES',$Title,$Source)
  Exit @ERROR
EndFunction
 

Odd this is post 8666 and it relates to Google 
83848EmptyFolder119LonkeroEmptyFolder() - checks if folder is empty0Code:


;FUNCTION	EmptyFolder()

;

;AUTHOR		Jooel Nieminen

;

;ACTION		checks if folder is empty

;

;VERSION	1.1 (13.8.2003)

;

;SYNTAX		EmptyFolder(FOLDER)

;

;PARAMETERS	FOLDER - Folder to check

;

;RETURNS	1 - if folder is empty

;

;DEPENDENCIES	none.

;

;EXAMPLE

;		if EmptyFolder("C:\windows")

;		 "spooky!"

;		endif

;

;CODE



function EmptyFolder($_)

 dim $

 $=dir($_)

 do $=dir() until $<>"." and $<>".." or @error

 if $="." or $=".." or not len($) $emptyfolder=1 endif

endfunction

82883EnableAutoLogon17SealeopardEnableAutoLogon() - Enables autologin0

code:

;FUNCTION      EnableAutoLogon()
;
;ACTION        Enables autologon
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.3 (added remote computer as optional input)
;              1.2 (added return of error codes, added AutoLogonCount and
;                   IgnoreShiftOverride registry values)
;              1.1
;
;DATE CREATED  2002/01/18
;
;DATE MODIFIED 2003/06/01
;
;KIXTART       4.12+
;
;SYNTAX        ENABLEAUTOLOGON(DOMAIN,USERNAME,PASSWORD [, COUNT, COMP])
;
;PARAMETERS    DOMAIN
;              Windows NT doamin to log into
;
;              USERNAME
;              Username for the Windows NT domain
;
;              PASSWORD
;              Corresponding password for the username
;
;              COUNT
;              Optional number of permitted autologons, defaults to 1
;
;              COMP
;              Optional remote computername for which to enable autologon
;
;RETURNS       0 if successful, otherwise error code
;
;REMARKS       none
;
;DEPENDENCIES  none
;
;EXAMPLE       $retcode=ENABLEAUTOLOGON()
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000150
;
function enableautologon($domain,$username,$password, optional $count, optional $comp)
  Dim $regsubkey, $rc

  if $domain='' or $username=''
    exit 87
  endif

  if @INWIN=1
    $regsubkey='HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon'
  else
    $regsubkey='HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Winlogon'
  endif

  $comp=trim($comp)
  if $comp
    $regsubkey='\\'+$comp+'\'+$regsubkey
  endif

  $count=val($count)
  if $count<1
    $count=1
  endif

  $rc=writevalue($regsubkey,'AutoAdminLogon',1,'REG_SZ')
  $rc=writevalue($regsubkey,'AutoLogonCount',0,'REG_SZ')
  $rc=writevalue($regsubkey,'DefaultDomainName',$domain,'REG_SZ')
  $rc=writevalue($regsubkey,'DefaultPassword',$password,'REG_SZ')
  $rc=writevalue($regsubkey,'DefaultUsername',$username,'REG_SZ')
  $rc=writevalue($regsubkey,'DontDisplayLastUserName',0,'REG_SZ')
  $rc=writevalue($regsubkey,'IgnoreShiftOverride',0,'REG_SZ')
  exit @ERROR
endfunction



[ 02. June 2003, 03:54: Message edited by: sealeopard ]142627EnableDHCP3439AllenEnableDHCP() 
- Configures a NIC to use DHCP settings1129938301Code:

;Function: 
;    EnableDHCP() 
; 
;Author: 
;    Allen Powell (Al_Po) 
; 
;Version: 
;    1.0 
; 
;Action: 
;    Configures a NIC to use DHCP settings   
; 
;Dependencies;   
;   WMI with Windows XP, Windows 2000 Professional, or Windows NT Workstation 4.0 SP4 and later 
;   Tested with Kixtart 4.22, 4.50 
; 
; 
;Syntax: 
;    EnableDHCP(optional $remotepc, optional $force)  
; 
;Parameters: 
;      $remotepc: (optional)   
;             Name of PC (if omitted, defaults to local machine) 
;      $force: (optional) 
;             Defaults to 0.  The script checks to see if DHCP is already enabled.  Set $force=1 to force it to run again 
;                       
;Returns: 
;     0 - Successful 
;     1 - Failed 
;     If Failed sets @error to 
;      -1 - DHCP Already Enabled 
; 
;Example: 
; 
;if EnableDHCP()=0 
;  ? "DHCP Enabled" 
;else 
;  if @error=-1 
;    ? "DHCP already enabled on this device" 
;  else 
;    ? "Error:  " + @error 
;  endif 
;endif 
; 
function EnableDHCP(optional $remotepc, optional $force)
  dim $objWMIService, $colitems, $objnetadapter, $
  $enableDHCP=1
  if $remotepc=""
    $remotepc="."
  endif
  $objWMIService = GetObject("winmgmts:\\" + $remotepc + "\root\cimv2")
  if @error
    exit @error
  endif
  $colItems = $objWMIService.ExecQuery("Select * from Win32_NetworkAdapterConfiguration where IPEnabled=-1")
  For Each $objNetAdapter In $colItems
    if $objNetAdapter.DHCPEnabled<>-1 or $force
      $=$objNetAdapter.SetDNSServerSearchOrder
      $=$objNetAdapter.SetWINSServer("","") 
      $=$objNetAdapter.SetDNSDomain
      $=$objNetAdapter.EnableDHCP
      if @error=0
        $enabledhcp=0
      endif
    else
      exit -1
    endif
  Next
endfunction

157320EnableDisableJava52NTDOCEnableDisableJava() - Disable OR Re-enable 
JAVA browser plugin0

;Function	EnableDisableJava() - Disable OR Re-enable JAVA browser plugin 
;   
;Author		NTDOC   
;   
;Contributors	   
;   
;Action		Allows easy on the fly method of disabling and re-enabling SUN JAVA 
;   
;Syntax		EnableDisableJava(optional $Flag) If no value set for the flag it will enable JAVA  
;		If a flag is used it will disable JAVA 
;   
;Version	1.0   
;   
;Date		2006-Feb-15   
;   
;Date Revised	xxxx-xxx-xx   
;   
;Revision Reason   
;		   
;   
;Parameters	Takes a value of 1 to disable JAVA  
;   
;Remarks	Tested on XP Pro / Server 2003  
;   
;Returns	Errorlevel of the last file moved  
;   
;Dependencies	KiXtart v4.5   
;		Written and tested with KiXtart v4.52 beta 2   
;   
;Notes	  
;		Java can not be currently running in order to disable 
;		In my testing moving HPI.DLL was enough for some browsers but caused 
;		errors and crashes in others. Moving all the files appeared to work okay 
;		for the systems I tested it on. 
;  
;Example  
;		EnableDisableJava(1)  
;		  ;Will disable Java  
;  
;		EnableDisableJava()  
;		  ;Will re-enable JAVA  
;  
;Source   
 
Function EnableDisableJava(optional $Flag)
  Dim $JPath
  $JPath=ReadValue('HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\javaws.exe','Path')+'\'
  If GetFileAttr($JPath+'BACKUP') & 16 
  Else 
    MD $JPath+'BACKUP' 
    If @ERROR Exit @ERROR EndIf
  EndIf
  If $Flag 
    MOVE $JPath+'*.*' $JPath+'BACKUP\'
  Else
    MOVE $JPath+'BACKUP\*.*' $JPath
  EndIf
  Exit @ERROR
EndFunction
 
82699EndProc79KdyerEndProc() - Terminate a process using WMI0Code:


;NAME:          ENDPROC

;AUTHOR:        Kent Dyer (leptonator@hotmail.com)

;CONTRIBUTORS:  Conrad Wheeler "Radimus", kholm

;ACTION:        Terminates a local or remote process using WMI

;SYNTAX:        ENDPROC($PROC,optional $COMPUTER)

;VERSION:       1.2

;PARAMETERS:   $PROC

;              Required string for the name of process you want to kill

;              $COMPUTER

;              Optional string containing the name of the system you are interested in,

;              you could use @WKSTA

;RETURNS:       Returncode (0) and PID

;REMARKS:       Reference - Terminate all copies of the& nbsp;Notepad process on host TEST01 

;                     Simplified (hopefully) version of kholm's script

;                     No warning about program being killed.

;DEPENDENCIES:  Kixtart 4.0, WMI

;EXAMPLE(s):    $COMPUTER = @WKSTA

;                     $PROC = "NOTEPAD.EXE"

;

;                     ENDPROC($PROC,$COMPUTER)

;

;                     Returns:

;                     0

;                     notepad.exe is 1508

FUNCTION ENDPROC($PROC, optional $COMPUTER)

DIM $Process

IF $COMPUTER=''

     $COMPUTER='.'

ENDIF

For each $Process in GetObject('winmgmts:{impersonationLevel=impersonate}!\\'+$COMPUTER+'\root\cimv2')

.ExecQuery('Select * from Win32_Process where Name=' +'"'+$Proc+'"')

    $Process.Terminate

    ?$Process.Name+' is '+$Process.ProcessId

Next

ENDFUNCTION


Another way to do this and suppress the results: 

Code:


FUNCTION ENDPROC($PROC, optional $COMPUTER)

Dim $Process,$RC

IF $COMPUTER=''

     $COMPUTER='.'

ENDIF

For each $Process in GetObject('winmgmts:{impersonationLevel=impersonate}!\\'+$COMPUTER+'\root\cimv2')

.ExecQuery('select * from Win32_Process where Name='+'"'+$PROC+'"')

    $RC=$Process.Terminate

Next

ENDFUNCTION


83774EnumDHCP31RadimusEnumDHCP() - uses DHCPCMD.exe to return assigned 
addresses0ver 2.0

returns an array

Parameters: 
$DHCPServerIP - IP of DHCP server
$IPSubnet - Valid IP subnet (or array of subnets)hosted on the server
Optional $ReturnIP - any value to return IP, otherwise returns name

Example: 

code:

break on
$serverip="192.168.1.1"
$subnets =split("192.168.1.0 192.168.2.0")

?"--------------"
for each $ip in enumdhcp($serverip,$subnets,1)
	? $ip
	next
?"--------------"
for each $pc in enumdhcp($serverip,$subnets)
	? $pc
	next
?"--------------"

requires WshPipe(),JoinArray(), DHCPCMD.exe from MS ResKit

code:

Function EnumDHCP($DHCPServerIP, $IPSubnet, Optional $ReturnIP)
	dim $DHCPCMD, $command, $return, $line, $count
	Dim $arrIPSubnet[0]
	$DHCPCMD ='"S:\MIS Tools\NTRESKIT\DHCPCMD.exe"'
	if VarType($IPSubnet) > 0 and VarType($IPSubnet) < 8192
		ReDim $arrIPSubnet[0]
		$arrIPSubnet[0] = $IPSubnet
	else 
		$arrIPSubnet = $ipsubnet
		endif
	$clip = 19
	if $returnip
		$clip = 4
		endif
	for each $subnet in $arrIPSubnet
		$command ='$DHCPCMD $DHCPServerIP enumclients $Subnet'
		$return	= WshPipe($command,1)
		if not @error
			$count = ubound($return)-3
			dim $temp[$count]
			for $line = 0 to $count
				$temp[$line] = trim(substr($return[$line+1],$clip,17))
				next
			$enumDHCP=joinarray($enumdhcp,$temp)
			endif
		next
	endfunction



[ 31. December 2002, 21:00: Message edited by: Radimus ]83639EnumDir31RadimusEnumDir() 
- Yet Another Dir Routine0

code:

;FUNCTION Enumdir
;
;AUTHOR Radimus
;
;VERSION 1.1
;
;ACTION Performs a Dir command to return filename into an array
;
;SYNTAX Enumdir($directory, optional $mask, Optional $Subdir)
;
;PARAMETERS
;	$directory
;	    Required string containing the directory path
;
;	$mask
;	    Optional string containing the file mask e.g. "*.bmp" or "00*.bmp"
;
;	$Subdir
;	    Optional value to include scanning subdirectories
;
;RETURNS errorcode 1 if directory does not exist
;
;REMARKS including the $subdir parameter will cause the array of filenames to be 
;	 returned with the compete path. Otherwise only the filename is returned
;	 in the array
;
;DEPENDENCIES WSHPipe(),
;
;KIXTART VER 4+
;
;EXAMPLE 
;	$dir=Enumdir("\\server\wallpaper","*.bmp")
;	for each $file in $dir
;		? $file
;		next
;

Function Enumdir($directory, optional $mask, Optional $Subdir)
	if $subdir	$subdir='/s'	endif
	if exist("$directory")
		$E=WshPipe('%comspec% /c dir "$directory\$mask" /b $subdir',1)
		for $element = 0 to ubound($e)
		    $e[$element]=left($e[$element],len($e[$element])-1)
		    next
                 $Enumdir=$e
	else
		exit 1
		endif
	endfunction

modified to remove chr(13) appended to each element of array

[ 08. November 2002, 18:20: Message edited by: Radimus ]178623EnumFreeLetters5694WittoEnumFreeLetters() 
- Enumerate all free drive letters0;ACTION Enumerate all free drive letters 
; 
;AUTHOR Wim Rotty 
; 
;CONTRIBUTORS NTDOC for the idea 
; 
;VERSION 1 Initial release
; 
;DATE CREATED 2007-08-02 
; 
;DATE MODIFIED 
; 
;KIXTART 4.00 and higher 
; 
;SYNTAX EnumFreeLetters([$FirstLetter],[$LastLetter]) 
; 
;PARAMETERS $FirstLetter 
; Optional parameter, 
; First letter to start enumerate the free letters 
; If blank, set to A 
; 
; $LastLetter 
; Optional parameter, 
; Last letter to stop enumerate the free letters 
; If blank, set to Z 
; 
;RETURNS Array, containing all free drive letters 
; 
; Error code in case of error 
; Error 87 if wrong parameters are provided 
; Error -2147221005 if FileSystemObject cannot be created (I presume) 
; 
;REMARKS 
; 
;DEPENDENCIES ".NET Framework 3.0" 
; or 
; ".NET Framework 2.0" 
; For the "Scripting.FileSystemObject" 
; 
;EXAMPLE Break On
; $RC = EnumFreeLetters("C","Z")
; If @ERROR
; "Error " + @ERROR + ": " + @SERROR ?
; Else
; For Each $RC in $RC
; $RC ?
; Next
; EndIf
; 
;KIXTART BBS http://www.kixtart.org/forums/ubbthreads.php?ubb=showflat&Number=178623 
; 
Function EnumFreeLetters(Optional $FirstLetter, Optional $LastLetter)
;Declare variables
Dim $objFSO, $objDrives, $objDrive
Dim $arrLetters, $chrLetter
Dim $arrUsedLetters
Dim $intI
;Initialize variables & check for errors
$objFSO = CreateObject("Scripting.FileSystemObject")
If @ERROR
Exit @ERROR
EndIf
If $FirstLetter = ""
$FirstLetter = "A"
Else
$FirstLetter = UCase($FirstLetter)
EndIf
If $LastLetter = ""
$LastLetter = "Z"
Else
$LastLetter = UCase($LastLetter)
EndIf
If Asc($FirstLetter) < 65 Or Asc($FirstLetter) > 90 Or Asc($LastLetter) < 65 Or 
Asc($LastLetter) > 90
Exit 87
EndIf
If $LastLetter < $FirstLetter
Exit 87
EndIf
For $intI = Asc($FirstLetter) to Asc($LastLetter)
If Not $arrLetters = ""
$arrLetters = $arrLetters + ","
EndIf
$arrLetters = $arrLetters + Chr($intI)
Next
$arrLetters = Split($arrLetters,",")
;Code
$objDrives = $objFSO.Drives
For Each $objDrive in $objDrives
If Not $arrUsedLetters = ""
$arrUsedLetters = $arrUsedLetters + ","
EndIf
$arrUsedLetters = $arrUsedLetters + $objDrive.DriveLetter
Next
$arrUsedLetters = Split($arrUsedLetters,",")
For Each $chrLetter in $arrLetters
If AScan($arrUsedLetters,$chrLetter) = -1
If Not $EnumFreeLetters = ""
$EnumFreeLetters = $EnumFreeLetters + ","
EndIf
$EnumFreeLetters = $EnumFreeLetters + $chrLetter
EndIf
Next
$EnumFreeLetters = Split($EnumFreeLetters,",")
EndFunction 
84431ENUMINI79KdyerENUMINI() - Enumerate an INI file0Original topic is 
discussed at - ENUMINI() - Trying to create a new UDF


;Function ENUMINI()
;
;Author Kent Dyer (leptonator@hotmail.com)
;
;Contributors Jens Meyer
; Howard Bullock
;
;Action Enumerates an INI file to map drives based on groups
;
;Syntax ENUMINI($fl)
;
;Version 1.1 - Updated NOVARSINSTRINGS
; 1.0
;
;Date 2003/07/18
;
;Date Revised 2003/07/18
;
;Parameters $fl 
; File to be read in and used
;
;Remarks Note: The structure for the User Hidden drive mappings.
;SAMPLE INI file
;[DOMAIN1\GROUPA]
;H=\\SERVER1\+@userid+'$$'
;R=\\SERVER3\APPS
;S=\\SERVER1\SHARED
;
;[DOMAIN2\GROUPB]
;H=\\SERVER1\+@userid+'$$'
;R=\\SERVER3\APPS
;S=\\SERVER1\SHARED
;
;[DOMAIN1\GROUPC]
;G=\\SERVER2\IS
;
;Returns Nothing
; 
;Dependencies None
;
;KiXtart Ver 4.02
; 
;Example(s) ENUMINI("C:\FLMAP.INI")
; $rc=SETOPTION("NoVarsInStrings","ON")
; ENUMINI($fl)

FUNCTION ENUMINI($fl)
DIM $sections,$keys,$sectionkey,$sectionentry,$rc,$resource
$sections=split(readprofilestring($fl,'',''),chr(10))
FOR EACH $sectionentry IN $sections
IF $sectionentry <>''
;?'Section '+$sectionentry
$keys=split(readprofilestring($fl,$sectionentry,''),chr(10))
FOR EACH $sectionkey IN $keys
IF $sectionkey <>''
;? 'Key "'+$sectionkey+'" = "'+readprofilestring($fl,$sectionentry,$sectionkey)+'"'
$resource=readprofilestring($fl,$sectionentry,$sectionkey)
$rc=execute('$$resource='+$resource)
IF INGROUP($sectionentry)
USE $sectionkey+':' $resource
ENDIF
ENDIF
NEXT
ENDIF
NEXT
ENDFUNCTION



[ 28. October 2003, 16:52: Message edited by: kdyer ]135385EnumIni2980Glenn 
BarnasEnumIni() - Enumerate sections or keys from an INI file1205519409



;; 
;;====================================================================== 
;; 
;;FUNCTION       EnumIni() 
;; 
;;ACTION         Enumerates sections or keys of an INI file 
;; 
;;AUTHOR         Glenn Barnas  
;; 
;;VERSION        2.0 
;; 
;;DATE CREATED   2003/11/17 
;; 
;;DATE MODIFIED  2004/10/16 
;; 
;;SYNTAX         EnumIni(File [, Section]) 
;; 
;;PARAMETERS     File - 	REQUIRED, path/name of INI file to examine 
;; 
;;               Section -	OPTIONAL, Section name to parse 
;; 
;;REMARKS        Returns an array containing the sections in an INI file, or 
;;               an array of key names in a specified section. Errors are returned 
;;               for non-existant files or INI file reads. If the specified file 
;;               contains no sections, or the specified section contains no keys, 
;;               the UDF exits with error 13 and returns a null array. Thus, a For-Each loop 
;;               will properly perform no iterations if no data is returned. 
;; 
;;               CAUTION - Error 13 is returned for empty files, or nonexistant sections. 
;;                         This is not necessarily a "failure". 
;; 
;;RETURNS        Array of sections or keys in a section 
;; 
;;DEPENDENCIES   none 
;; 
;;TESTED WITH    Kix 4.2+, NT4, W2K, WXP, W2K3 
;; 
;;EXAMPLES       $Sections = EnumIni('.\config.ini') 
;;               $Keys = EnumIni('.\config.ini', 'Common') 
; 
Function EnumIni($_fSrcFile, OPTIONAL $_fSectName)
 
  Dim $_fSectList
 
  ; die if the file doesn't exist 
  If Exist($_fSrcFile) = 0
    Exit 2
  EndIf
 
  ; Get the list of sections or keys 
  $_fSectList = ReadProfileString($_fSrcFile, $_fSectName, '')
  ; Return if error occurred 
  If @ERROR
    Exit @ERROR
  EndIf
 
  ; If len is >0, return an array of sections 
  ; If len is 0, either no sections or keys exist, or an invalid section name was specified. Return nothing. 
  If Len($_fSectList) > 0
    $EnumIni = Split(Left($_fSectList,len($_fSectList)-1), Chr(10))
    Exit 0
  EndIF
 
  ; return an error here for value not found (no sections or no keys in section) 
  Exit 13
 
EndFunction
 
 
 

84481enumINI119LonkeroenumINI() - Load ini-file into array0

;Function:

;	enumINI()

;

;Author:

;	Lonkero

;

;Version:

;	1.1.1 (25th of august 2003)

;

;Version history:

;	1.1.1 (25th of august 2003) - found and fixed one more buggie   

;	1.1 (25th of august 2003) - some bug fixes   

;	1.0 (24th of august 2003) - initial version

;

;Action:

;	reads ini-file into memory

;

;Syntax:

;	enumINI(FILE)

;

;Parameters:

;	FILE - INI-file to read

;

;Returns:

;	ARRAY of ARRAYS of ARRAYS:

;	array of sections which holds array of values which holds array of valuename and data

;	[section][value][info]

;

;	[section][0] - sectionname

;	[section][1+] - values in section

;	[section][1+][0] - value's name

;	[section][1+][1] - value data

;

;Errors Returned:

;	0 - successfull execution

;	2 - file does not exist

;	13 - file does not contain any sections, not readable or not ini-file

;

;Dependencies:

;	none

;

;Remarks:

;	inspired by the other enumini.

;	you can judge which is better 

;	one thing I'm sure of, this is not for noobies 

;

;Example:

;	"treeview of ini-file"

;	$data=enumINI("C:\!kix\test.ini")

;	if @error

;		? "something went wrong: @serror"

;		Sleep 2

;	else

;		for each $section in $data

;			? $section[0]

;			for $value=1 to ubound($section)

;				? " " $section[$value][0]

;			next

;		next

;	endif

;	get $

;

;Source:

function enumini($ini)

 dim $,$s,$lf,$!

 $lf=chr(10)

 if not exist($ini) exit 2 endif

 $s=readprofilestring($ini,'','')

 $enumini=split(left($s,len($s)-1),$lf)

 if not len($enumini[0]) exit 13 endif

 for $=0 to ubound($enumini)

 $s=readprofilestring($ini,$enumini[$],'')

  $enumini[$]=split($enumini[$]+$lf+left($s,len($s)-1),$lf)

  for $!=1 to ubound($enumini[$])

   $enumini[$][$!]=$enumini[$][$!],readprofilestring($ini,$enumini[$][0],$enumini[$][$!])

  next

 next

endfunction



[ 25. August 2003, 22:45: Message edited by: Lonkero ]82866EnumIPInfoAll17SealeopardEnumIPInfoAll() 
- Enables enumeration of TCP/IP information of all network adapters0

code:

;FUNCTION      EnumIPInfoAll
;
;ACTION        Enables enumeration of TCP/IP information of all network adapters of the local system
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2 (added error codes)
;              1.1
;
;DATE CREATED  2002/01/18
;
;DATE MODIFIED 2003/05/31
;
;KIXTART       4.12+
;
;SYNTAX        ENUMIPINFOALL(INDEX [, TYPE])
;
;PARAMETERS    INDEX
;              A numeric value representing the IP information you want to discover (where 0 is the first group)
;
;              TYPE
;              Optional parameter identifying the type of information you want to enumerate.
;              0    IP address
;              1    Subnet mask
;              2    Adapter description
;              3    Default gateway
;
;RETURNS       A string representing the requested information
;
;REMARKS       Similar to ENUMIPINFO but works for Windows 9x/NT too and does not rely on the IP Helper API
;
;DEPENDENCIES  none
;
;EXAMPLE       $Result=EnumIPInfoAll()
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000146
;
function enumipinfoall(optional $index, optional $type)
  Dim $ipinfo, $servicename, $regsubkey, $regvalue, $counter0, $counter1, $counter2
  Dim $devicedesc, $binding, $adapterfound, $desiredbinding, $enumsubkey, $enumregvalue
  Dim $virtualadapter

  $index=val('0'+$index)
  $type=val('0'+$type)

  select
  case @inwin=2
    ; check whether it does work in Windows 9x
    if exist('%WINDIR%\system\iphlpapi.dll')
      $ipinfo=enumipinfo($index,$type)
    else
      $ipinfo=''
    endif

    if $ipinfo<>''
      $enumipinfoall=$ipinfo
      exit 0
    else
      ; special routine for Windows 9x
      $regsubkey=enumkey('HKEY_LOCAL_MACHINE\Enum\Network\MSTCP',$index)
      if $regsubkey=259 or $regsubkey=''
        $enumipinfoall=''
        exit 2
      endif
      $regvalue=readvalue('HKEY_LOCAL_MACHINE\Enum\Network\MSTCP\'+$regsubkey,'Driver')
      $regsubkey='HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\'+$regvalue
      select
      case $type=0
        $ipinfo=readvalue($regsubkey,'IPAddress')
      case $type=1
        $ipinfo=readvalue($regsubkey,'IPMask')
      case $type=2
        $adapterfound=0
        $counter0=0
        $desiredbinding='MSTCP\'+enumkey('HKEY_LOCAL_MACHINE\Enum\Network\MSTCP',$index)
        do
          $regsubkey=enumkey('HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\Net',$counter0)
          if $regsubkey<>''
            $regvalue=readvalue('HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\Net\'+$regsubkey+'\Ndi','DeviceID')
            if left($regvalue,3)='PCI'
              $enumsubkey='HKEY_LOCAL_MACHINE\Enum\'+$regvalue
              if keyexist($enumsubkey)
                $regvalue=enumkey($enumsubkey,0)
                $devicedesc=readvalue($enumsubkey+'\'+$regvalue,'DeviceDesc')
                $binding=$enumsubkey+'\'+$regvalue+'\Bindings'
                $counter1=0
                do
                  $enumregvalue=enumvalue($binding,$counter1)
                  if $enumregvalue=$desiredbinding
                    $adapterfound=1
                  endif
                  $counter1=$counter1+1
                until $enumregvalue='' or $enumregvalue=259 or $adapterfound=1
              endif
            else
              $enumsubkey='HKEY_LOCAL_MACHINE\Enum\Root\Net'
              $counter1=0
              do
                $virtualadapter=enumkey($enumsubkey,$counter1)
                $binding=readvalue($enumsubkey+'\'+$virtualadapter,'CompatibleIDs')
                if $binding=$regvalue
                  $binding=$enumsubkey+'\'+$virtualadapter+'\Bindings'
                  $devicedesc=readvalue($enumsubkey+'\'+$virtualadapter,'DeviceDesc')
                  $counter2=0
                  do
                    $enumregvalue=enumvalue($binding,$counter2)
                    if $enumregvalue=$desiredbinding
                      $adapterfound=1
                    endif
                    $counter2=$counter2+1
                  until $enumregvalue='' or $enumregvalue=259 or $adapterfound=1
                endif
                $counter1=$counter1+1
              until $virtualadapter='' or $virtualadapter=259 or $adapterfound
            endif
          endif
          $counter0=$counter0+1
        until $regsubkey='' or $regsubkey=259 or $adapterfound=1
        if $adapterfound=0
          $ipinfo=''
        else
          $ipinfo=$devicedesc
        endif
      case $type=3
        $ipinfo=readvalue($regsubkey,'DefaultGateway')
      endselect
    endif
  case @dos='4.0'
    ; special routine for Windows NT
    $regsubkey='HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards\'+($index+1)
    $servicename=readvalue($regsubkey,'ServiceName')
    select
    case $type=0
      $regsubkey='HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\'+$servicename+'\Parameters\Tcpip'
      $ipinfo=readvalue($regsubkey,'IPAddress')
    case $type=1
      $regsubkey='HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\'+$servicename+'\Parameters\Tcpip'
      $ipinfo=readvalue($regsubkey,'SubnetMask')
    case $type=2
      $ipinfo=readvalue($regsubkey,'Description')
    case $type=3
      $regsubkey='HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\'+$servicename+'\Parameters\Tcpip'
      $ipinfo=readvalue($regsubkey,'DefaultGateway')
    endselect

    if right($ipinfo,1)='|'
      $ipinfo=left($ipinfo,len($ipinfo)-1)
    endif
  case 1
    ; Windows 2000/XP/2003
    $ipinfo=enumipinfo($index,$type)
  endselect

  $enumipinfoall=$ipinfo
  exit 0
endfunction



[ 31. May 2003, 23:06: Message edited by: sealeopard ]83977EnumIPRange31RadimusEnumIPRange() 
- Enum an IP range of addresses0


;FUNCTION EnumIPRange
;
;ACTION 1 dimensional Array of all possible IPs in the provided IP range
;
;AUTHOR Radimus
;
;CONTRIBUTORS Richard H.
;
;VERSION 2.1
;
;DATE CREATED 04/09/2003
;
;DATE MODIFIED 04/09/2003
;
;KIXTART 4.x
;
;SYNTAX EnumIPRange($sIPaddress,$sNetMask)
;
;PARAMETERS $sIPaddress
; IP Address (starting IP address of the network??) or Network ID in CIDR format
;
; optional $sNetMask
; Subnet of the IP network if CIDR is not specified in $sIPaddress
;
;RETURNS Array of strings
;
;REMARKS 
;
;DEPENDENCIES 
;
;EXAMPLE $arrayIPs = EnumIPRange("192.168.0.1","255.255.255.0")
; $arrayIPs = EnumIPRange("192.168.0.1/24")
;
;KIXTART BBS http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000385 color=#4682B4>
; http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=2;t=003828#000006 color=#4682B4>
;

Function EnumIPRange($sIPaddress,optional $sNetMask)
Dim $aiStartRange,$aiMaskBits,$aiEndRange[4],$iHostCount,$i
Dim $cidr,$fac,$mask,$temp,$temp2,$a,$b
Dim $iOctet1,$iOctet2,$iOctet3,$iOctet4
Dim $tempArray[1],$arrOctect[4]

if instr($sIPaddress,'/')
$cidr=val(split($sIPaddress,'/')[1])
$sIPaddress=split($sIPaddress,'/')[0]
$sNetMask=''
for $a = 1 to $cidr
$mask=$mask+'1'
next
for $a = $cidr + 1 to 32
$mask=$mask+'0'
next
for $a = 0 to 3
$temp=substr($mask,$a*8+1,8)
$temp2=0
$fac=256
for $b=1 to 8
$fac = $fac / 2
$temp2 = $temp2 + val(substr($temp,$b,1)) * $fac
next
if not $a=3
$sNetMask=$sNetMask+$temp2+ '.'
else
$sNetMask=$sNetMask+$temp2
endif
next
endif

$iHostCount=1

$aiStartRange=Split($sIPaddress,".")
$aiMaskBits=Split($sNetMask,".")
Redim Preserve $aiStartRange[4]
Redim Preserve $aiMaskBits[4]

For $i = 0 To 3
$aiMaskBits[$i] =Val($aiMaskBits[$i]) & 255
$aiStartRange[$i] =Val($aiStartRange[$i]) & $aiMaskBits[$i]
$aiEndRange[$i] =$aiStartRange[$i]+(255-$aiMaskBits[$i])
$iHostCount =$iHostCount*($aiEndRange[$i]-$aiStartRange[$i]+1)
Next

redim $temparray[$iHostCount]
$i=0
For $iOctet1 = $aiStartRange[0] To $aiEndRange[0]
For $iOctet2 = $aiStartRange[1] To $aiEndRange[1]
For $iOctet3 = $aiStartRange[2] To $aiEndRange[2]
For $iOctet4 = $aiStartRange[3] To $aiEndRange[3]
$temparray[$i]=''+$iOctet1+'.'+$iOctet2+'.'+$iOctet3+'.'+$iOctet4
$i=$i+1
Next
Next
Next
Next
$EnumIPRange=$temparray
EndFunction



[ 10. April 2003, 14:28: Message edited by: Radimus ]139601EnumNetworkConnections3439AllenEnumNetworkConnections() 
- Creates an Array/List of Network Connections1142483271Code:

;Function:  
; EnumNetworkConnections()  
;  
;Author:  
; Allen Powell  
;  
;Version:  
; 2.0 2006/03/15 Complete Re-write (backward compatible) 
; 1.0 2005/05/11 Original Version - Returned just the "Connection Name" 
;  
;Action:  
; Enumerates/Lists the Network Connections names  
; 
;Syntax:  
; EnumNetworkConnections(optional $mode, optional $remotepc)  
;  
;Parameters:  
; $mode - (Optional) Numeric expression that is the sum of values below 
;       - 0 Connection Name (default) 
;       - 1 MACAddress 
;       - 2 Network Adapter Name 
; 
; $remotepc - (Optional) Remote Computer Name 
; 
;Returns: 
; Array of Network Connection Names, optionally with MACAddress and/or Name of the Network Card 
; 
;Dependencies 
;  WMI with Windows XP, Windows 2000 Professional, or Windows NT Workstation 4.0 SP4 and later 
;  Tested with Kixtart 4.52 Beta 
;Example:  
; 
;for each $nc in Enumnetworkconnections() 
;  ? $NC 
;next 
; 
function EnumNetworkConnections(optional $mode,optional $remotepc)
  dim $NCs[0],$objWMIService,$colItems,$objItem,$counter
  if $remotepc=""
    $remotepc="."
  endif
  $objWMIService = GetObject("winmgmts:\\" + $remotepc + "\root\cimv2")
  if @error
    exit @error
  endif
  $colItems = $objWMIService.ExecQuery("Select * from Win32_NetworkAdapter where (MACAddress is not null) and (NetConnectionID is not null)")
  For each $objItem in $colItems
    redim preserve $NCs[$counter]
    $NCs[$counter]=$objItem.NetConnectionID
    if $mode & 1
      $NCs[$counter]=$NCs[$counter] + "," + $objItem.MACAddress
    endif
    if $mode & 2
      $NCs[$counter]=$NCs[$counter] + "," + $objItem.Name
    endif    
    $counter=$counter + 1
  Next
  $EnumNetworkConnections=$NCs
endfunction

138356EnumNetworkDrives52NTDOCEnumNetworkDrives() - Returns the current 
network drive mapping information0

;Function		EnumNetworkDrives() - Returns the current network drive mapping information 
;  
;Author			NTDOC  
;  
;Contributors  
;  
;Action			Enumerates all of the mapped drives and returns their drive letter and path 
;  
;Syntax			EnumNetworkDrives()  
;  
;Version		1.0  
;  
;Date			2005-Apr-20  
;  
;Date Revised		xxxx-xxx-xx  
;  
;Revision Reason  
;  
;Parameters		None  
;  
;Remarks		Idea based on the EnumPrinterConnections() UDF and EnumPrinterConnections2() 
;			http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=83545 
;			http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=137527  
;			Using methods derived from here at Microsoft  
;			http://msdn.microsoft.com/library/default.asp?url=/library/en-us/script56/html/wsmthenumnetworkdrives.asp 
;  
;			Tested on 2000/XP/2003  
;  
;Returns		The EnumNetworkDrives method returns a collection.  
;			This collection is an array that associates pairs of items 
;			network drive local names and their associated UNC names 
;  
;Dependencies		KiXtart v4.x, WSH 5.6  
;			Written and tested with KiXtart v4.23  
;  
;Example		NOTE! This example uses the QS UDF to sort the list  
;			http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=82876  
;  
;			Dim $DriveData, $DriveMap, $Di 
;			$DriveData = QS(EnumNetworkDrives()) 
;			If Ubound($DriveData) <> -1 
;			  For $Di = 0 To Ubound($DriveData) 
;			    $DriveMap = Split($DriveData[$Di],",",-1) 
;			    $DriveMap[0]+CHR(9)+$DriveMap[1] ? 
;			  Next 
;			Else 
;			  ? 'No drive mappings found.' 
;			EndIf 
;  
;Source  
 

 

Function EnumNetworkDrives()
  Dim $WshNetwork, $oDrives, $i, $DriveArray[0]
  $EnumNetworkDrives=""
  $WshNetwork = CreateObject("WScript.Network")
  If Not @ERROR
    $oDrives = $WshNetwork.EnumNetworkDrives
    For $i = 0 To $oDrives.Count - 1 Step 2
      $DriveArray[Ubound($DriveArray)]=$oDrives.Item($i)+','+$oDrives.Item($i+1)
      ReDIM Preserve $DriveArray[UBound($DriveArray)+1]
    Next
    If UBound($DriveArray) > 0
      ReDIM Preserve $DriveArray[UBound($DriveArray)-1]
    Else
      $DriveArray = 0
    EndIf
  Else
    $EnumNetworkDrives=@ERROR
    Exit $EnumNetworkDrives
  EndIf
  $EnumNetworkDrives=$DriveArray
EndFunction
 
83786EnumOUs31RadimusEnumOUs() - Enumerates OUs containing Users or 
Computers0Ver 1.0 jan 5, 2003

Purpose: To return a | delimited string of the ldap string for all OUs 
containing objects of the specified type

Example: 

code:

$ldap="LDAP://wheelerfam/DC=wheelerfam, DC=net"

$count = EnumOUs($ldap, 'computer')
for each $item in split($count,"|")
	? $item
	next

output:
LDAP://wheelerfam/OU=Domain Controllers, DC=wheelerfam, DC=net
LDAP://wheelerfam/OU=Wheelerfam Computers, DC=wheelerfam, DC=net
LDAP://wheelerfam/OU=Wheelerfam Servers, DC=wheelerfam, DC=net
 

Thanks to Howard for writing most of this for me 

There is some filter issue in filtering user types, it returned all OUs, so I 
put in the if $item.class = $Filter as a work-around... but it could just be the 
XP machine I'm working on, being obstinant... The 'computer' filter works as 
expected

code:

 
Function EnumOUs($LDAP, $Filter)
	dim $aFilter[0], $pos,  $objOU, $i, $j
	if $Filter <> 'user'
		$Filter = 'computer'
		endif
	$objOU = GetObject($LDAP)
	if VarTypeName($objOU)='Object'
		$aFilter[0] = $Filter
		$objOU.Filter = $aFilter
		for each $item in $objOU
			if $item.class = $Filter
				$i = $LDAP
				endif
			next
		$aFilter[0] = "organizationalUnit"
		$objOU.Filter = $aFilter
		for each $item in $objOU
			$Name = $item.Name
			$pos = instrrev($LDAP,"/")
			$DN = Left($LDAP,$pos) + $Name + ", " + substr($LDAP, $pos+1)
			$j = EnumOUs($DN, $Filter)
			if $j
				if $i
					$i = $i +"|"+ $j
				else
					$i = $j
					endif
				endif
			next
	else
	;      ? "GetObject COM error: " + @error + " " + @serror
		exit 1
		endif
 	$EnumOUs = $i
	Endfunction
 



[ 06. January 2003, 04:14: Message edited by: Radimus ]84485EnumPrinterConnections1651Armin 
LinderEnumPrinterConnections() - Another approach0Hi,

evaluating several approaches to enumerate ALL network printer connections (Windows 
style as well as DOS LPT style connections) and trying to find a solution that 
does work on Windows NT4, Windows 2000 and Windows XP I found that all existing 
scripts had some shortcomings, especially when running on the NT4 platform. 
Directly reading the LPT devices from HKCU\Network lists only persistent 
connections. Redirecting net use to a file and parsing it is not very elegant. 
Using WMI requires that I do first roll out the WMI client on NT4 (Windows 2000 
and XP already do have it built in).

Finally I found a Windows Script Host object that does the job for me. Since wsh 
comes with any modern Internet Explorer (tested V5 and V6 on Nt4 and XP) this 
script should run almost anywhere.

Here is the script:

code:

; EnumPrinterConnections V1.2 (C)2003 Armin Linder (ali@arminlinder.de)
; -------------------------------------------------------------------
; Call: EnumPrinterConnections()
; Returns: Array of Printers, format is "printer name","printer port name"
; or empty array
; Requires: Windows Script Host 1.0+

? "EnumPrinterConnections sample script (C)2003 Armin Linder"
? "----------------------------------------------------------"
? "Printers on machine @wksta:"
$Printers=EnumPrinterConnections()
If Ubound($Printers) <> -1
	For $i = 0 To Ubound($printers)
	$Printer=Split($Printers[$i],",",-1)
	? "Port: "+$Printer[1]+" --> "+$Printer[0]
	Next
Else
	? "No printers found." 
EndIf
Quit

Function EnumPrinterConnections
; return a list of all printer connections
; format: UNC name, port

	Dim $ReturnArray[]
	Dim $WshNetwork, $oPrinters
	Dim $i
	
	$EnumPrinterConnections=""
	$WshNetwork = CreateObject("WScript.Network")
	If @Error=0
		$oPrinters = $WshNetwork.EnumPrinterConnections
		For $i = 0 to $oPrinters.Count-1 Step 2
			; init/enlarge the return array
			If Ubound($ReturnArray)=-1
				ReDim $ReturnArray[0]
			Else
				ReDim Preserve $ReturnArray[Ubound($ReturnArray)+1]
			EndIf
			$ReturnArray[Ubound($ReturnArray)]=$oPrinters.Item($i+1)+","+$oPrinters.Item($i)
		Next
	Else 
		? "Failed to get WScript.Network object."
	EndIf 
	$EnumPrinterConnections=$ReturnArray
EndFunction

  

This is what the result looks like:

EnumPrinterConnections sample script (C)2003 Armin Linder
----------------------------------------------------------
Printers on machine C2811TOSGOTT:
Port: NPI428ED8:RAW --> \\S2811KIV099\DR099150
Port: LPT1 --> \\S2811KIV099\DR099120

[Moderator Jochen edited topic title to reflect standards]

[ 08. September 2003, 08:20: Message edited by: Jochen ]138355EnumPrinterConnections252NTDOCEnumPrinterConnections2() 
- Enumerates all connected printers0

;Function		EnumPrinterConnections2() - Enumerates all connected printers 
;   
;Author			NTDOC 
;   
;Contributors		Bryce 
;   
;Action			Enumerates all of the installed / connected printers into an array  
;   
;Syntax			EnumPrinterConnections2()  
;   
;Version		1.0  
;   
;Date			2005-Apr-20   
;   
;Date Revised		xxxx-xxx-xx   
;   
;Revision Reason	  
;   
;Parameters		None 
;   
;Remarks		Based on the EnumPrinterConnections() UDF 
;			http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=83545 
;			Which I believe was probably derived from here at Microsoft 
                        EnumPrinterConnections Method 
;			Minor modifications due to invalid array dim and array starts 
;			with a blank which can cause issues when trying to display or 
;			write to a log file.  This method should work a little better. 
;			 
;			Tested on 2000/XP/2003  
;   
;Returns		An array of all the installed / connected printers 
;   
;Dependencies		KiXtart v4.x, WSH 5.6  
;			Written and tested with KiXtart v4.23 
; 
;Example		NOTE! This example uses the QS UDF to sort the list 
;			http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=82876 
; 
;			Dim $PrinterData, $PrinterMap, $Pi 
;			$PrinterData = QS(EnumPrinterConnections2()) 
;			If Ubound($PrinterData) <> -1 
;			  For $Pi = 0 To Ubound($PrinterData) 
;			    $PrinterMap = Split($PrinterData[$Pi],",",-1) 
;			    $PrinterMap[0]+CHR(9)+$PrinterMap[1] ? 
;			  Next 
;			Else 
;			  ? 'No printer mappings found.' 
;			EndIf 
; 
;Source  
 

Function EnumPrinterConnections2()
  Dim $WshNetwork, $oPrinters, $i, $PrintArray[0]
  $EnumPrinterConnections2=""
  $WshNetwork = CreateObject("WScript.Network")
  If Not @ERROR
    $oPrinters = $WshNetwork.EnumPrinterConnections
    For $i = 0 To $oPrinters.Count - 1 Step 2
      $PrintArray[Ubound($PrintArray)]=$oPrinters.Item($i+1)+','+$oPrinters.Item($i)
      ReDim Preserve $PrintArray[Ubound($PrintArray)+1]
    Next
      If Ubound($PrintArray) > 0
        ReDIM Preserve $PrintArray[UBound($PrintArray)-1]
      Else
        $PrintArray = 0
      EndIf
  Else
    $EnumPrinterConnections2=@ERROR
    Exit $EnumPrinterConnections2
  EndIf
  $EnumPrinterConnections2=$PrintArray
EndFunction
 
83681EnumProcess31RadimusEnumProcess() - enum specific process PIDs and/or 
terminate them1124220243FUNCTION EnumProcess($exe, optional $terminate, 
optional $Computer)

To enumerate or kill specific processes

$exe: the process name or numeric PID
$terminate: null/notnull value to terminate the specified process(es)
$Computer: the PC to execute against. Null = local PC

returns an array of PIDs (pipe seperated), if $exe is a process name

To return the pid of setup.exe
$pid= EnumProcess("setup.exe")

to terminate all running Internet Explorer windows
$kill= EnumProcess("iexplore.exe",1)

To terminate a specific exe by it's PID
$pid=694
$kill=EnumProcess($pid,1)

Code:

FUNCTION EnumProcess($exe, optional $terminate, optional $Computer)
	Dim $winmgmts, $ExecQuery, $Process, $id, $getobject, $
	if not $computer	$computer=@wksta	endif
	$winmgmts="winmgmts:{impersonationLevel=impersonate}!//$COMPUTER"
	select
		case val($exe)>0
			$ExecQuery="select * from Win32_Process where ProcessId='$exe'"
			$GetObject=GetObject($winmgmts).ExecQuery($ExecQuery)
			For each $Process in $GetObject
				if $terminate		$=$Process.Terminate	endif
				$EnumProcess = $Process.name
				next
			$GetObject=''
		case vartype($exe)=8
			$ExecQuery="select * from Win32_Process where Name='$exe'"
			$GetObject=GetObject($winmgmts).ExecQuery($ExecQuery)
			For each $Process in $GetObject
				if $terminate		$=$Process.Terminate	endif
				$id=$Process.ProcessId
				$EnumProcess = "$Id" + "|" + "$EnumProcess"
				Next
			$EnumProcess=left($EnumProcess,len($EnumProcess)-1)
			$GetObject=''
		case 1
			exit 1
		endselect
	ENDFUNCTION

84448EnumSCSIDevices107mvdwEnumSCSIDevices() - Enumerates SCSI devices and 
firmware levels0Please consider the following UDF :

code:

;Function	EnumSCSIDevices()
;
;Author		MvdW (mvdw @ mvdw.net)
;
;Contributors	www.kixtart.org (where I learned to appreciate kix ;)
;
;Action		Enumerates SCSI devices according to the info in the hardware devicemap in
;		the registry on a local or a remote machine.
;
;Syntax		EnumSCSIDevices("server", "peripheraltype", firstonly)
;
;Version	1.0
;
;Date           06-aug-2003
;
;Date Revised   N/A
;
;Parameters 	server
;		must be a string containing either the servername or the ip address
;
;		peripheraltype
;		optional parameter, can be used to filter specific devicetypes.
;
;		firstonly
;		optional, can be anything that returns TRUE. If set only the first device
;		will be returned. This speeds up script runtime when you know there is only
;		one device
;
;Remarks	The information retrieved this way can be obtained in more "sophisticated" ways
;		This specific function was written to work on those good old NT4 systems to 
;		retrieve firmware information for tapedrives throughout the enterprise.
;		Note that you should check if you have administrative rights on the remote machine.
;		
;Returns	Returns an array containing the requested information, each device will be a (string)
;		element of the array in the following format :
;		peripheraltype;description;firmware level
; 
;Dependencies 	fEnumKey 
;		http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000221#000000
;
;KiXtart Ver	4.20
; 
;Example(s)	using the following script:
;		break on cls
;		$test = EnumSCSIDevices("MyServer")
;		if @error = 1
;		  "no drives found"?
;		  exit (0)
;		endif
;		for $i = 0 to ubound($test)
;		  $driveinfo = split($test[$i], ";")
;		  $thetype = $driveinfo[0]
;		  $thedrive = $driveinfo[1]
;		  $theware = $driveinfo[2]
;		  "Peripheral type  : $thetype"?
;		  "Peripheral name  : $thedrive"?
;		  "Firmware level   : $theware"??
;		next
;		exit (0)
;		
;		would give you this output:
;
;		Peripheral type  : CdRomPeripheral
;		Peripheral name  : LG   CD-ROM CRD-8322B
;		Firmware level   : 1.06
;
;		Peripheral type  : TapePeripheral
;		Peripheral name  : SEAGATE DAT    06240-XXX
;		Firmware level   : 8110
;		
;		Peripheral type  : DiskPeripheral
;		Peripheral name  : IBM     ServeRAID
;		Firmware level   : 4.50
;		
;		Peripheral type  : OtherPeripheral
;		Peripheral name  : IBM     CaVv3 S2
;		Firmware level   : 0
;		
;		Peripheral type  : OtherPeripheral
;		Peripheral name  : IBM     DUMMY DEVICE
;		Firmware level   : 4.50
;
;		Using the following function call in the same script
;		$test = EnumSCSIDevices("MyServer", "Tape") ; would give :
;		
;		Peripheral type  : TapePeripheral
;		Peripheral name  : SEAGATE DAT    06240-XXX
;		Firmware level   : 8110
;		
;		and using $test = EnumSCSIDevices("MyServer", "Other", 1)
;		would give:
;		
;		Peripheral type  : OtherPeripheral
;		Peripheral name  : IBM     CaVv3 S2
;		Firmware level   : 0
;		

Function EnumSCSIDevices($server, optional $peripheraltype, optional $firstonly)
Dim $DevsFound[0]
Dim $scsikey, $scsiports, $scsiport, $scsibuses, $scsibus, $scsiids, $scsiid, $specificsearch 
Dim $scsiluids, $scsiluid, $devicetype, $deviceidentifier, $model, $firmware, $drivefound
$devsFound[0] = "No tapedrives found"

if vartype($peripheraltype) = 8
  $specificsearch = 1
  $peripheraltype = $peripheraltype + "Peripheral"
endif

$scsikey = "HKEY_LOCAL_MACHINE\HARDWARE\DEVICEMAP\scsi"
$scsiports = fEnumKey($server, $scsikey)
for each $scsiport in $scsiports
  $scsiport = $scsikey + "\" + $scsiport
  $scsibuses = fEnumKey($server, $scsiport)
  for each $scsibus in $scsibuses
    $scsibus = $scsiport + "\" + $scsibus
    $scsiids = fEnumKey($server, $scsibus)
    for each $scsiid in $scsiids
      if instr ($scsiid, "Target")
        $scsiid = $scsibus + "\" + $scsiid
        $scsiluids = fEnumkey($server, $scsiid)
        for each $scsiluid in $scsiluids
          $scsiluid = "\\" + $server + "\" + $scsiid + "\" + $scsiluid
          $devicetype = readvalue($scsiluid, "type")
          if ($specificsearch) and (Not($devicetype = $peripheraltype))
          else
            $deviceidentifier = readvalue($scsiluid, "Identifier")
            $model = ltrim(rtrim(substr($deviceidentifier, 1, (len($deviceidentifier)-4))))
            $firmware = ltrim(rtrim(substr($deviceidentifier, (len($deviceidentifier)-3), len($deviceidentifier))))
            $drivefound = $devicetype + ";" + $model + ";" + $firmware
            $DevsFound[ubound($DevsFound)] = $drivefound
            redim preserve $DevsFound[(ubound($DevsFound) + 1)]
            if $firstonly
              redim preserve $DevsFound[(ubound($DevsFound) - 1)]
              $EnumSCSIDevices = $DevsFound
              exit (0)
            endif
          endif
        next
      endif
    next
  next
next
if ubound($DevsFound) = 0
  exit (1)
endif
redim preserve $DevsFound[(ubound($DevsFound) - 1)]
$EnumSCSIDevices = $DevsFound
exit(0)
EndFunction

Most of you might think of this as oldschool sh*t but hey, I just couldn't help 
myself writing and posting it... hehe

Hopefully I have followed all the guidelines for posting a UDF, if not just give 
us a PM and I'll fix it.83712Environment119LonkeroEnvironment() - enum 
environment variables0

code:

;Function:
; Environment()
;
;Author:
; Lonkero
;
;Version:
; 1.0.0 (29.11.2002)
;
;Action:
; enumerates the environment values
;
;Syntax:
; Environment($mode)
;
;Parameters:
; optional mode
; 	2 - system environment
;	1 - current users environment
; 	0 - both (same as without parameter)
;
;Remarks:
; probably you will wonder why there is not all the same listed as in your %comspec% window.
; they just simply do not belong to windows environment but to dos. don't worry, if you set a value
; in your script, it will be there.
;
;Returns:
; array of the valuenames and values (in "valuename=value" format)
; 
;Dependencies:
; none
; 
;Examples:
;1:
;	"Your and systems environment has these values:" ?
;	for each $value in environment
;		$value ?
;	next
;
;2:
;	"This system has these environment values:" ?
; 	for each $value in environment(2)
;		$value ?
;	next
;
;Source:
function environment(optional $mode)
dim $,$help,$name
if 2>0+$mode
 do
  $name=enumvalue("HKEY_CURRENT_USER\Environment",0+$help)
  $help=$help+1
  $=$+$name+"="+readvalue("HKEY_CURRENT_USER\Environment",""+$name)+chr(10)
 until @error
endif
if 2=$mode or 0=0+$mode
 $help=0
 do
  $name=enumvalue("HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment",$help)
  $help=$help+1
  $=$+$name+"="+readvalue("HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment",""+$name)+chr(10)
 until @error
endif
for each $ in split($,chr(10))
 if 2<len($) $environment=$environment+$+chr(10) endif
next
$environment=split(left($environment,len($environment)-1),chr(10))
endfunction

82659Err17SealeopardErr() - Prints an error message on screen and writes 
the error into the error log0

code:

;FUNCTION      Err
;
;ACTION        Prints an error message on screen and writes the error into the error log
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.21 (changed DisplayText() parameter order)
;              1.2
;
;DATE CREATED  2001/12/20
;
;DATE MODIFIED 2003/07/30
;
;KIXTART       4.20
;
;SYNTAX        ERR(STRING [, LOG , NOTIFY])
;
;PARAMETERS    STRING
;              Required string containing details about the error message
;
;              LOG
;              Optional string denoting the location of the error database (.INI file)
;
;              NOTIFY
;              Optional string containing user/computer that will receive a SENDMESSAGE
;              with the error
;
;RETURNS       0 if successful, otherwise error code
;
;REMARKS       Translates COM erroro codes into Win32 API error codes
;
;DEPENDENCIES  DISPLAYTEXT() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000036
;
;EXAMPLE       $rc=err('There was an error!')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000107
;
function err($errorinfo, optional $errorlog, optional $notify)
  Dim $alert_message, $section, $sectionkey, $sectionstring, $rc
  Dim $errorcode, $errortext, $errorsub

  $errorcode=@ERROR
  $errortext=@SERROR

  If $errorcode<0
    $errorsub=$errorsub+'Function TranslateCOMError($lErr)'+@CRLF
    $errorsub=$errorsub+'If $lErr<0 $lErr=VAL("&"+Right(DecToHex($lErr),4)) EndIf'+@CRLF
    $errorsub=$errorsub+'exit $lErr'+@CRLF
    $errorsub=$errorsub+'Endfunction'
    $errortext=execute($errorsub)
    $errorcode=TranslateCOMError($errorcode)
    $errorcode=@ERROR
    $errortext=@SERROR
  EndIf

  if $errorcode>-1
    $errorinfo=''+$errorinfo
    if right($errortext,1)=chr(10)
      $errortext=left($errortext,len($errortext)-1)
    endif
    if right($errortext,1)=chr(13)
      $errortext=left($errortext,len($errortext)-1)
    endif

    ; send verbose error message to alertserver
    $notify=trim($notify)
    if $notify
      $alert_message='Script Processing Error!'+@CRLF+@CRLF
      $alert_message=$alert_message+'Error code '+$errorcode+' ('+$errortext+') '
      $alert_message=$alert_message+'occurred at '+@TIME+' while '+@USERID+' ('+@FULLNAME+') '
      $alert_message=$alert_message+'was running a script on '+@WKSTA+'.'
      $rc=sendmessage($notify,$alert_message)
    endif

    ; write verbose error message into error log
    $errorlog=trim($errorlog)
    if $errorlog
      $section=@DATE+'-'+@TIME+' for '+@USERID+' on '+@WKSTA
      $sectionkey='Errormessage'
      $sectionstring='Error code '+$errorcode+' ('+$errortext+') with description: '+$errorinfo
      $rc=writeprofilestring($ERRORLOG,$section,$sectionkey,$sectionstring)
    endif

    ; display short error message on screen
    $rc=displaytext('Error code ' + $errorcode + ' (' + $errortext+') occurred',2,'r/n')
  endif

  $err=@error
endfunction



[ 30. July 2003, 21:37: Message edited by: sealeopard ]117209EscapeCharAdd288jtokachEscapeCharAdd() 
- Adds escape chars in strings1200338171 

Code:

;FUNCTION       EscapeCharAdd()
;
;ACTION         Adds an escape character where necessary
;
;AUTHOR         James Tokach (jtokach@users.sourceforge.net)
;
;CONTRIBUTERS	N/A
;
;VERSION        1.0
;
;DATE CREATED   2004/04/01
;
;DATE MODIFIED  N/A
;
;KIXTART        Tested only with 4.22
;
;SYNTAX         $Return = EscapeCharAdd($String)
;
;PARAMETERS     $String
;               The stirng to parse and modify
;
;RETURNS        The modified string
;
;REMARKS        Only searches for and adds additional \'s
;               For example, this is very handy for writing values to MySQL tables
;
;DEPENDENCIES   None
;
;EXAMPLE        $MyStr="C:\Program Files\Internet Explorer"
;               $MyStr=EscapeCharAdd($MyStr)
;               ? $MyStr ; Returns C:\\Program Files\\Internet Explorer
;
;               $MyStr="\\Server\Share"
;               $MyStr=EscapeCharAdd($MyStr)
;               ? $MyStr ; Returns \\\\Server\\Share
;
;KIXTART BBS	http://www.kixtart.org/ubbthreads/showflat.php?Cat=&amp;Number=115996&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=&amp;fpart=&amp;vc=
;
Function EscapeCharAdd($String)
    Dim $k,$NewString
    $k=1
    While $k&lt;=Len($String)
        If Substr($String,$k,1)="\"
            $Newstring=$newString+Substr($String,$k,1)+"\"
        Else
            $Newstring=$newString+Substr($String,$k,1)
        EndIf
        $k=$k+1
    Loop
    $EscapeCharAdd=$NewString
EndFunction  
117210EscapeCharRemove288jtokachEscapeCharRemove() - Removes escape chars 
from str1080935499 Code:

;FUNCTION       EscapeCharRemove()

;

;ACTION         Removes escape characters where necessary

;

;AUTHOR         James Tokach (james.tokach@lmco.com)

;

;CONTRIBUTERS	N/A

;

;VERSION        1.1 - Had to move the counter above the concatentation line so 

;                     the proper character is written.

;               1.0 - Released

;

;DATE CREATED   2004/04/01

;

;DATE MODIFIED  N/A

;

;KIXTART        Tested only with 4.22

;

;SYNTAX         $Return = EscapeCharRemove($String)

;

;PARAMETERS     $String

;               The stirng to parse and modify

;

;RETURNS        The modified string

;

;REMARKS        Only searches for and removes additional \'s

;

;DEPENDENCIES   None

;

;EXAMPLE        $MyStr="C:\\Program Files\\Internet Explorer"

;               $MyStr=EscapeCharRemove($MyStr)

;               ? $MyStr ; Returns C:\Program Files\Internet Explorer

;

;               $MyStr="\\\\Server\\Share"

;               $MyStr=EscapeCharRemove($MyStr)

;               ? $MyStr ; Returns \\Server\Share

;

;KIXTART BBS	http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=115999&page=0&view=collapsed&sb=5&o=&fpart=&vc=

;

Function EscapeCharRemove($String)

    Dim $k,$NewString

    $k=1

    While $k<=Len($String)

        If Substr($String,$k,1)="\"

            $k=$k+1

            $Newstring=$newString+Substr($String,$k,1)

        Else

            $Newstring=$newString+Substr($String,$k,1)

        EndIf

        $k=$k+1

    Loop

    $EscapeCharRemove=$NewString

EndFunction    

83760ExistOnPath119LonkeroExistOnPath() - checks if file exists anywhere in 
the %path%0

code:

;Function:	ExistOnPath()
;
;Author:	Lonkero
;
;Version:	1.0 (11th of December 2002)
;
;Action:	Checks if specified file exists on %path%
;
;Syntax:	ExistOnPath("FILE")
;
;Parameters:
;	FILE	- file to check for
;
;Remarks:
;	Uses current path instead of the one you see in your script which
;	was in effect when you started kix.
;	Also @curdir is checked.
;
;
;Returns:	true if found.
; 
;Dependencies:
;	none
; 
;Examples:
;	1:
;	if existonpath("word.exe")
;		runEx("word.exe",@scriptdir+"\index.htm")
;	endif
;
;	2:
;	if @inwin=1 and not existonpath("cmd.exe")
;		"Broken environment. contact your administrator!"
;		gets $enter
;	endif
;
;Source:
function existonpath($_file)
 dim $
  $=readvalue("HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment","path")
  $=split($+";"+readvalue("HKEY_CURRENT_USER\Environment","path"),";")
 for each $ in $ if exist($+"\"+$_file) $existonpath=not 0 endif next
endfunction

168461Fac5694WittoFac() - Calculate Factorial of a natural number1159259310

;FUNCTION       Fac 
; 
;ACTION         Calculate Factorial of a natural number 
; 
;AUTHOR         Wim Rotty 
; 
;CONTRIBUTORS 
; 
;VERSION        1 
; 
;DATE CREATED   2006-09-25 
; 
;DATE MODIFIED 
; 
;KIXTART        4.xx 
; 
;SYNTAX         Fac($n) 
; 
;PARAMETERS     $n 
;               Natural number, an Integer number equal to or greater then 0 
; 
;RETURNS        If 0 =< n =< 12 then Return Value = Integer 
;               If 13 =< n =< 170 then Return Value = Double 
;               If other input 
;                        - Return Value is Empty ("") 
;                        - ERROR is set to 87 to indicate that the parameter is incorrect 
; 
;REMARKS        Due to the limits of Integer and Double, the UDF is limited to an input number of 170 
;               For more information about Factorial: 
;               Factorial (English): http://en.wikipedia.org/wiki/N%21 
;               Faculteit (Dutch):   http://nl.wikipedia.org/wiki/Faculteit_%28wiskunde%29 
; 
;DEPENDENCIES   none 
; 
;EXAMPLE        Break On 
;               Dim $Factorial 
;               For $Factorial = -1 to 171 
;                 ? "Factorial of " + $Factorial + " = " + Fac($Factorial) 
;                 If @ERROR 
;                   "Error " + @ERROR + ": " + @SERROR 
;                 EndIf 
;               Next 
; 
;KIXTART BBS 
; 
Function Fac($n)
  If $n = CInt($n) AND 0 <= $n AND 170 >= $n
    If $n = 0 OR $n = 1
      $Fac = 1
    Else
      If $n > 12
        $n = CDbl($n)
      EndIf
      $Fac = $n
      Dim $i
      For $i = $n - 1 to 1 step -1
        $Fac = $Fac * $i
      Next
    EndIf
  Else
    Exit 87
  EndIf
EndFunction
 
83147fADSIServiceRun172Howard BullockfADSIServiceRun() - ADSI routine that 
starts, stops ,pause, and continues a service0ADSI routine that starts, stops 
,pause, and continues a service.


;FUNCTION fADSIServiceRun()
;AUTHOR Howard A. Bullock (hbullock@tycoelectronics.com)
;ACTION Starts or stops a service.
;SYNTAX fADSIServiceRun(Computer, Service, $Run)
;PARAMETERS $Computer (Required) - String value
; $Service (Required) - String value
; $Run (Required) (0=stop or 1=start|continue or 2=Pause)
;REMARKS This function starts,stops, pauses, or continues a service on
; the local or a remote computer. This function sets @ERROR on exit.
; when "pausing" a service this function will start a stopped service then
; pause it.
;RETURNS Nothing
;DEPENDENCIES ADSI
;EXAMPLES ServiceRun ("", "Alerter", 0)
; ServiceRun ("SomeComputer", "Alerter", 1)

Function fADSIServiceRun ($Computer, $Service, $Run)
Dim $objService, $status, $StartUp
; Validate input parameters
if VarType($Computer) <> 8
exit(87)
endif
if VarType($Service) <> 8
exit(87)
endif
if VarType($Run) <> 2 and
VarType($Run) <> 3 and
$Run >= 0 and $Run <= 3
exit(87)
endif

if $Computer = ""
$Computer = @wksta
endif

$objService = Getobject("WinNT://$Computer/$Service,Service")
if @error = 0
$status = $objService.status

select
case $Run = 0
select
case $status = 4 ;Running
$objService.stop
case $status = 1 ;Stopped
exit (2182)
case $status = 7 ;Paused
$objService.stop
case 1
? "Unhandled service status(0):$status"
exit (1)
endselect
case $Run = 1
select
case $status = 1 ;Not Running
$StartUp = $objService.get("StartType")
if $StartUp <> 4
$objService.start
else
exit (1058)
endif
case $status = 7 ;Paused
$objService.continue
case $status = 4 ;Running
exit (3521)
case 1
? "Unhandled service status(1):$status"
exit (1)
endselect
case $Run = 2
select
case $status = 4 ;Running
$objService.pause
case $status = 1 ;Stopped
$StartUp = $objService.get("StartType")
if $StartUp <> 4
$objService.start
$objService.pause
else
exit (1058)
endif
case 1
? "Unhandled service status(2):$status"
exit (1)
endselect
endselect
$objService = ""
else
exit @error
endif
EndFunction



[ 04. April 2003, 16:09: Message edited by: Howard Bullock ]83146fADSIServiceStartup172Howard 
BullockfADSIServiceStartup() - ADSI routine to change a service startup type0ADSI 
routine to change a service startup type.


;FUNCTION fADSIServiceStartup()
;
;AUTHOR Howard A. Bullock (hbullock@tycoelectronics.com)
;
;ACTION Set the startup property of a service.
;
;SYNTAX fADSIServiceRun(Computer, Service, $Run)
;
;PARAMETERS $Computer (Required) - String value
; $Service (Required) - String value
; $Startup (Required) - String (Boot, System, Automatic, Manual, Disabled)
;
;REMARKS This function sets the a service's startup parameter on the local
; or a remote computer. This function sets @ERROR on exit.
;
;RETURNS Nothing
;
;DEPENDENCIES ADSI
;
;EXAMPLES fADSIServiceStartup("", "mssqlserver", "Disabled")
; fADSIServiceStartup("", "mssqlserver", "Manual")
; fADSIServiceStartup("RemoteComputer1", "mssqlserver", "Automatic")
;
Function fADSIServiceStartup ($Computer, $Service, $StartUp)
Dim $objService
; Validate input parameters
if VarType($Computer) <> 8
exit(87)
endif
if VarType($Service) <> 8
exit(87)
endif
if VarType($StartUp) <> 8 and
$StartUp <> "Boot" and
$StartUp <> "System" and
$StartUp <> "Automatic" and
$StartUp <> "Manual" and
$StartUp <> "Disabled"
exit(87)
endif
if VarType($ServiceAccountName ) <> 8 and VarType($ServiceAccountName) <> 0
exit(87)
endif
if VarType($Password) <> 8 and VarType($Password) <> 0
exit(87)
endif


if $Computer = ""
$Computer = @wksta
endif

$objService = Getobject("WinNT://$Computer/$Service,Service")
if @error = 0

Select
case $StartUp = "Automatic" $StartUp = 2
case $StartUp = "Manual" $StartUp = 3
case $StartUp = "Disabled" $StartUp = 4
case $StartUp = "Boot" $StartUp = 0 ;valid only for driver services
case $StartUp = "System" $StartUp = 1 ;valid only for driver services
EndSelect
if VarType($StartUp) <> 8
$objService.put("StartType",$StartUp)
endif
$objService.SetInfo
$objService = ""
endif
exit (@error)
EndFunction 



[ 05. April 2003, 17:47: Message edited by: Howard Bullock ]82623Fatal17SealeopardFatal() 
- Prints an error message on screen and a verbose message into an error log0

code:

;FUNCTION      Fatal
;
;ACTION        Prints an error message on screen and writes the error into the error
;              log incl. complete computer information in case of unautorized login attempts
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.11 (changed DisplayText parameter order)
;              1.1
;
;DATE CREATED  2001/12/19
;
;DATE MODIFIED 2003/07/30
;
;KIXTART       4.20
;
;SYNTAX        FATAL([STRING])
;
;PARAMETERS    STRING
;              Optional string containing details about the error message
;
;RETURNS       0 if successful, otherwise 1
;
;REMARKS       Requires the global variable $ERRORLOG (filename for the error log) and
;              $ALERTSERVER (name of the alert server)
;
;DEPENDENCIES  DISPLAYTEXT() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000036
;
;EXAMPLE       $rc=fatal('Attempted break-in!')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000101
;
function fatal(optional $errorinfo)
  Dim $alert_message, $section, $sectionkey, $sectionstring, $rc, $crlf

  $crlf=@CRLF+@CRLF

  ; send verbose error message to alert server
  if $ALERTSERVER
    $alert_message='Unauthorized Acess!'+$crlf
    $alert_message=$alert_message+'User '+@USERID+' on computer '+@WKSTA+' with IP address '+@IPADDRESS0
    $alert_message=$alert_message+' tried to access the '+@LDOMAIN+' LAN at '+@TIME+'.'+$crlf
    $alert_message=$alert_message+'User has been kicked off.'
    $rc=sendmessage($ALERTSERVER,$alert_message)
  endif

  ; write verbose error message into error log
  if $ERRORLOG
    $section=@DATE+'-'+@TIME+' for '+@USERID+' on '+@WKSTA
    $sectionkey='Unauthorized Access'
    $sectionstring='User '+@USERID+' on computer '+@WKSTA+' with IP address '+@IPADDRESS0
    $sectionstring=$sectionstring+' tried to access the '+@LDOMAIN+' LAN at '+@TIME+'.'
    $sectionstring=$sectionstring+' User has been kicked off.'
    $rc=writeprofilestring($ERRORLOG,$section,$sectionkey,$sectionstring)
    $rc=writeprofilestring($ERRORLOG,$section,'Network Adapter Address',@ADDRESS)
    $rc=writeprofilestring($ERRORLOG,$section,'Domain',@DOMAIN)
    $rc=writeprofilestring($ERRORLOG,$section,'Operating System',$OS_LONG)
    $rc=writeprofilestring($ERRORLOG,$section,'Full Username',@FULLNAME)
    $rc=writeprofilestring($ERRORLOG,$section,'Hostname',@HOSTNAME)
    $rc=writeprofilestring($ERRORLOG,$section,'Computername',@WKSTA)
    $rc=writeprofilestring($ERRORLOG,$section,'UserID',@USERID)
  endif

  $alert_message=$errorinfo+$crlf+'You are attempting to log into the '+@DOMAIN
  $alert_message=$alert_message+' from an unauthorized IP address. The Systems Administrator'
  $alert_message=$alert_message+' has been notified of this attempted security breach!'
  $rc=messagebox($alert_message,'Unauthorized Access to '+@LDOMAIN,0+16+4096)

  ; display short error message on screen
  $rc=displaytext('Unauthorized Access!',,'r+/n')

  $fatal=@error
endfunction



[ 30. July 2003, 21:41: Message edited by: sealeopard ]157352FatFile1024MartFatFile() 
- Create a file with a specified name and size.1140468755Code:


;Function	FatFile()
;
;Author:		Mart
;
;Contributors:
;		Shawn - For supplying the fsutil command.
;			I just stuffed it into a UDF.
;		Bryce - UDF name inspiration.
;			 hope you don't mind me using the name you used in the original post.
;		http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=153006&an=&page=0&vc=1
;
;Action:
;		Create a file with a specified name and size.
;
;Syntax:
;		FatFile($path, $file, $size)
;
;Version:
;		1.0 February 16th 2006
;			Initial post.
;		1.1 February 17th 2006
;			Commenst by NTDOC fixed.
;		1.2 February 20th 2006
;			Typo in silencing the shell line.
;
;
;Date:
;		February 16th 2006
;
;Date Revised:
;		February 17th 2006
;			Comments by NTDOC, thanx.
;			Folders get created if they do not exist.
;
;Parameters:
;		$path (required, string)
;			Path to the file to be created
;			Path get's created if it does not exist.
;		
;		$file (required, string)
;			The filename to be created.
;			The created file is NOT empty. Notepad just does not show anything.
;			Use something like editplus to view the contents of the file.
;
;		$size (required, string)
;			The size of the file to be created in bytes.
;			Use 1048576 for a 1MB file.
;			Just multiply it by the number of MB's you want.				
;
;Remarks:
;		None.
;
;Returns:
;		Error codes, see @error.
; 
;Dependencies
;		Windows XP or up, Windows 2003 or up.
;
;KiXtart:
;		Developed and tested KiXtart 4.51 and Windows XP SP2.
;
;Example(s):
;		$path = "c:\"
;		$file = "1mbfile.txt"
;		$size = "1048576"
;		$rc = FatFile($path, $file, $size)
;		?$rc
;		Sleep 3
;
;
Function FatFile($path, $file, $size)

Dim $path, $file, $size

If NOT Exist ($path)
	MD $path
	If @ERROR
		Exit @ERROR
	EndIf
EndIf
;
If Exist ($file)
	Exit 80
EndIf
;
Select
	Case $file = ""
		Exit 2
	Case $size = ""
		Exit 13
EndSelect

$file = $path + $file
Shell "%comspec% /c fsutil file createnew " + $file + " " + $size + " >nul"

If @ERROR
	$FatFile = @ERROR
Else
	$FatFile = 0
EndIf
Exit
EndFunction

83247fEnumKey172Howard BullockfEnumKey() - Enumerates registry keys on a 
local or remote computer0Jens, I didn't know your UDF was out there until 
after I wrote this. If this is too close to ArrayEnumKeys() let me know.


;AUTHOR           Howard A. Bullock (habullock@comcast.net)

;

;ACTION           Enumerates registries keys on the specified computer.

;

;SYNTAX           fEnumKey($Computer, $Key)

;

;PARAMETERS       $Computer (Required) -  String value

;                 $Key (Required) -  String value

;

;REMARKS          Do not prefix the computer name with "\\"'s. Can serve as a

;                 direct replacement for EnumKey().

;

;RETURNS          Array of keys names.

;

;DEPENDENCIES     KiXtart 4.02,

;

;EXAMPLES         fEnumKey("", "HKEY_USERS")

;                 fEnumKey("Remote1", "HKEY_USERS")

;

Function fEnumKey($Server, $Key)

   Dim $Index, $Error, $x

   $Index = 0

   Dim $KeyName[$Index]

   If $Server <> ""

      $Key = "\\" + $Server + "\" + $Key

   Endif



   If KeyExist($Key)

      Do

         $x = ENUMKEY($Key, $Index)

         $Error = @Error

         If NOT $Error and $Index > Ubound($KeyName)

            ReDim PRESERVE $KeyName[$Index]

         Endif

         If NOT $Error

            $KeyName[$Index] = $x

            $Index = $Index + 1

         Endif

      Until $Error

   Else

      $KeyName[0] = ""

      Exit 2

   Endif

   $fEnumKey = $KeyName

   Exit 0

Endfunction

[ 07. August 2003, 05:41: Message edited by: Howard Bullock ]83736FileAction119LonkeroFileAction() 
- execute action on file0Code:


;Function:	FileAction()

;

;Author:	Jooel Nieminen

;

;Version:	1.1 (30th of November 2002)

;

;Action:	executes file action

;

;Syntax:	FileAction("FILE", "ACTION")

;

;Parameters:

;		FILE	- full path to file which to execute on

;		ACTION	- name of action

;

;Returns:

;		Nothing or errorcode on error.

;

;		on error errorcodes returned and set:

;			1 -no Such Action

;			2 -Failed to bind to file

;

;Dependencies:

;		w2k/xp/ME or win98 with IE 4 or others with IE4 and integrated shell

;		see: http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/programmersguide/versions.asp

;

;Remarks:

;		File exsistence not checked.

;		If you don't know what is file's action right click on it and the actions are listed

;

;Example:	

;		$worksheet="c:\test.xls"

;		"Printing file "+$worksheet

;		if FileAction($worksheet,"Print")

;			? "error occured:" @error

;		else

;			? "File Printed."

;		endif

;

;Source:

function FileAction($file,$action)

 dim $shell,$

 $fileaction=1

 $shell=createobject("shell.application")

 $file=$Shell.namespace($file).self

 if @error  $fileaction=2 exit 2 endif

 for each $ in $file.verbs

  if join(split($,"&"),"")=$action

   $file.invokeverb(""+$)

   $fileaction=0

  endif

 next

 if $fileaction exit 1 endif

endfunction

84680FileList31RadimusFileList() - another Dir replacement0

;Function	FileList($folderName,optional $mask)  

;  

;Author		Radimus  

;  

;Contributors	  

;  

;Action		returns an array of filenames (a dir replacement)  

;  

;Syntax		$array=FileList($folderName,optional $mask)  

;  

;Version	1.0.1  

;  

;Date           10/21/2003 

;  

;Date Revised   10/22/2003 		Dimmed Variables 

;  

;Parameters 	Foldername  

;		Folder to get a dir of  

;		Mask  

;		optional file mask to return  

;  

;Remarks	I can't remember if I wrote this or a captured this from a post  

;  

;Returns	Normal output is an array of filenames  

;		@error if failed  

;   

;Dependencies 	FSO  

;  

;KiXtart Ver	4.02  

;   

;Example(s)	$array=FileList('%windir%','.bmp')  



Function FileList($folderName,optional $mask)

	Dim $t, $name, $objdir, $objFile

	$objDir = CreateObject("Scripting.FileSystemObject").GetFolder($folderName).Files

	if @error	exit 1		endif		; usually folder not found

	For Each $objFile In $objDir

		$name=$objFile.name

		if ($mask and instr($name,$mask)) or not $mask

			$t=$t+'|'+$name

			endif

		Next

	$FileList=split(substr($t,2),'|')

	EndFunction

[ 22. October 2003, 22:36: Message edited by: Radimus ]83447FileLock288jtokachFileLock() 
- Checks if a file's locked for exclusive use0

code:

;FUNCTION         FileLock($file)
;
;AUTHOR           Jim Tokach (JTokach@Hotmail.com)
;
;ACTION           Determines if a file is locked... Yeah, I think. =)
;
;SYNTAX           FileLock($file)
;
;PARAMETERS       $file (Required) [String]
;                    The file to check
;
;REMARKS          The examples require Windows NT/2000/XP
;
;RETURNS          "Locked" if the file is in use
;                 "Unlocked" if the file is NOT in use
;                 "File not found" if ...
;
;                 @Error Returns
;                 32 If the file is in use.
;                 2 If the file is not found.
;                 0 If the file is NOT in use.
;
;DEPENDENCIES     None
;
;EXAMPLES         ; This example should return in use.
;                 ; Status is checked through @error
;                 $i=FileLock("C:\Pagefile.sys")
;                 If @error=0 ? "The file is not locked" Else ? "@Serror" EndIf
;
;                 ; This example should return NOT in use.
;                 ; Print the status to the screen
;                 FileLock("C:\boot.ini")
;
;                 ; This example should return error code 2 (File not found).
;                 ; Print the error code to the screen
;                 $nul=FileLock("C:\xyz.foo")
;                 @error

Function FileLock($file)
    If Exist ("$File")=1
        $fileOpen=CompareFileTimes("$file","c:\foo")
        If $fileOpen=-2
            $FileLock="Locked"
            Exit 32
        Else
            $FileLock="Unlocked"
            Exit 0
        EndIf
    Else
        $FileLock="File not found"
        Exit 2
    EndIf
EndFunction  

Besides this being a completly arbitrary waste-o'time function, are you ready 
for this? *I think* this checks if a file is locked. I use it for backing up .PST's 
manually. (Actually, I think you can copy a .PST while it's open, as long as no 
changes are made, but you just can't be too safe...) Anyway, I check if it's 
locked, if so prompt the user to close Outlook and retry. If nothing else, I 
sleep that much better at night. 

If there's a better way to do this through kix suggestions welcome.

[ 21. February 2003, 16:12: Message edited by: jtokach ]84101FileOwner119LonkeroFileOwner() 
- Retrieve file's owner info0


;Function:

;	FileOwner()

;

;Author:

;	Lonkero

;

;Version:

;	1.1

;

;Version History:

;	1.1	(29.4.2003)	- now supports also XP, NT and WIN9x

;	1.0.1	(29.4.2003)	- syntax error fix

;	1.0	(28.4.2003)	- initial release

;

;Action:

;	Retrieves File's Owner Info

;

;Syntax:

;	FileOwner(FILE)

;

;Parameters:

;	FILE	Required. Full path to file.

;

;Remarks:

;	Don't try to use on FAT-filesystem       

;

;Returns:

;	File's Owners

;	if no return value, check @error for possible errors (listed below)

;

;Errorcodes:

;	2	file does not exist

;	120	shell.dll version not sufficient

;

;Dependencies:

;	shell32.dll version 4.71

;

;Examples:

;	"file c:\winnt\logon.log owner is:"

;	fileowner("c:\winnt\niemjo.log")

;

;Source:

function FileOwner($file)

 dim $,$f

 if not exist($file) exit 2 endif

 $f=split($file,"\")

 $file=$f[ubound($f)]

 $f[ubound($f)]=""

 $f=join($f,"\")

 $=createobject("shell.application")

 if 9<>vartype($) exit 120 endif

 $FileOwner=$.namespace($f).getdetailsof($.namespace($f).parsename($file),8)

endfunction



[ 29. April 2003, 13:54: Message edited by: Lonkero ]83279fileprops79Kdyerfileprops() 
- Grab the properties of files0

; Function fileprops($folder)
;
; Author Kent Dyer (leptonator@hotmail.com)
;
; Version 1.2 (30.06.2002)
;
; Action Gets file properties.
;
; Syntax fileprops($folder)
;
; Parameters
; $folder - Required folder to get files properties from
;
; Remarks
; -- Ref. - http://kixtart.org/board/ultimatebb.php?ubb=get_topic;f=1;t=005123
; -- Thanks Rad for help w/file attributes
;
; Returns
; Name
; File Type
; Last Modfied
; Last Accessed
;
; -- Output example
; -- Name is: c:\!kix\wzremove.bat
; -- File Type: c:\!kix\MS-DOS Batch File
; -- Last Modfied: c:\!kix\7/24/2001 9:07:41 AM
; -- Last Accessed: c:\!kix\6/17/2002 12:20:17 PM
;
; Dependencies
; kixtart 4.x
;
; Examples
; BREAK ON
; CLS
; fileprops("c:\!kix")
;
; Source

FUNCTION fileprops($folder)
$folderspec = $folder
$fs = CreateObject("Scripting.FileSystemObject")
;;$f = $fs.GetFolder(server.mappath($folderspec))
$f = $fs.getfolder($folderspec)
$fc = $f.files
?"File List"
FOR EACH $list IN $fc
?"Name is: " + $list.name
?"File Type: " + $list.type
?"Last Modfied: " + $list.datelastmodified
?"Last Accessed: " + $list.datelastaccessed
$result = GetFileAttr( $list.name ) $attr=""
IF $result & 4096 $attr=$attr+"Offline " 
ENDIF
IF $result & 2048 $attr=$attr+"compressed " 
ENDIF
IF $result & 1024 $attr=$attr+"Reparse point " 
ENDIF
IF $result & 512 $attr=$attr+"Sparse file " 
ENDIF
IF $result & 256 $attr=$attr+"Temporary " 
ENDIF
IF $result & 128 $attr=$attr+"Normal " 
ENDIF
IF $result & 64 $attr=$attr+"Encrypted " 
ENDIF
IF $result & 32 $attr=$attr+"Archive " 
ENDIF
IF $result & 16 $attr=$attr+"Directory " 
ENDIF
IF $result & 4 $attr=$attr+"System " 
ENDIF
IF $result & 2 $attr=$attr+"Hidden " 
ENDIF
IF $result & 1 $attr=$attr+"Read only" 
ENDIF
?"Attributes: $result " + $attr
?
NEXT

$fs = ""
$f = ""
$ = ""
ENDFUNCTION



[ 28. October 2003, 16:51: Message edited by: kdyer ]84112FileVersion119LonkeroFileVersion() 
- Retrieve file's version0

;Function:

;	FileVersion()

;

;Author:

;	Lonkero

;

;Version:

;	1.0.1

;

;Version History:

;	1.0.1	(29.4.2003)	- correct error codes

;	1.0	(28.4.2003)	- initial release

;

;Action:

;	Retrieves the binary FileVersion

;

;Syntax:

;	FileVersion(FILE)

;

;Parameters:

;	FILE	Required. Full path to file.

;

;Remarks:

;	As kixtart returning currently only the string fileversion info,

;	I wrote this UDF which then returns the binary version.

;

;Returns:

;	File's Version

;

;Errorcodes:

;	2	- file does not exist

;	120	- FSO could not be created

;

;Dependencies:

;	FSO

;

;Examples:

;	"wkix32 clames to be:		"

;		getfileversion(@ldrive+"wkix32.exe") ?

;	"but it's binary version string is:	"

;		 fileVersion(@ldrive+"wkix32.exe") ?

;

;Source:

function FileVersion($file)

 dim $

 if not exist($file) exit 2 endif

 $ = CreateObject("Scripting.FileSystemObject")

 if 9<>vartype($) exit 120 endif

 $FileVersion=$.GetFileVersion($file)

endfunction



[ 16. July 2003, 05:05: Message edited by: Lonkero ]82267Fill5474DrillSergeantFill() 
- Create a string or fill out another string0FILL()

Action:

Fills a string.

Syntax:

FILL(Length, 'filler', 'string', 'position')

Parameters:

Length: The required length of the new string.

Filler (optional): A character (or multiple characters) to fill the string with.

String (optional): The base string you want to fill out.

position (optional): This can be 'LEFT', 'RIGHT' or 'CENTER'. LEFT will put the 
filler in front of the default string, RIGHT will put the filler at the end of 
the default string, CENTER will position the default string in the midle of the 
new string.

Returns:

The string formatted to the new size.
If an invalid default string is entered, the function will return with the 
string 'INVALID_DEFAULT_VALUE'.

Remarks:

The function can not handle a length over 2,147,483,647 (Kix gets confused)

Dependecies:

KiXtart 4.0 (Final)

Examples: 

$test = "Hello" + fill(10)+"world"
? $test '->' len($test)

$test = fill(10,'*')
? $test '->' len($test)

$test = fill(5,'0','323','left')
? $test '->' len($test)

$test = fill(20,,@DATE,'center')
? $test '->' len($test)

Source:

code:


Function FILL($_length, Optional $_filler, Optional $_BaseString, Optional $_mode)

	Dim $_FillString

	if VarType($_BaseString)>8 $FILL='INVALID_DEFAULT_VALUE' exit endif

	if $_filler = '' $_filler = ' ' endif

	while Len($_FillString) + len($_BaseString) < $_length $_FillString = $_FillString + $_Filler loop
	$_FillString = Left($_FillString, $_length-len($_BaseString))

	select
		case $_mode='LEFT'
			$FILL = $_FillString + $_BaseString
		case $_mode='CENTER'
			$FILL = Left($_FillString, Len($_FillString)/2) + $_BaseString + Right($_FillString, Len($_FillString)-Len($_FillString)/2)
		case 1
			$FILL = $_BaseString + $_FillString
	endselect

Endfunction

Author(s):

DrillSergeant84679FilterArray31RadimusFilterArray() - filter an array for a 
provided string0

;Function	FilterArray($array,$find, optional $inclusive) 

; 

;Author		Radimus 

; 

;Contributors	 

; 

;Action		returns an array of filtered items from a source array 

; 

;Syntax		$Filtered=FilterArray($array,$find, optional $inclusive) 

; 

;Version	1.0 

; 

;Date           10/21/2003 

; 

;Date Revised    

; 

;Parameters 	Array  

;		source array 

;		Find 

;		string to filter for 

;		inclusive 

;		0 or non 0 value to return either the elements of the array that 

;		match or the elements that do not match the file string 

; 

;Remarks	 

; 

;Returns	Normal output is an array of items 

;		@error if failed 

;  

;Dependencies 	None 

; 

;KiXtart Ver	4.02 

;  

;Example(s)	$array=FilterArray($array,$find, optional $inclusive) 



Function FilterArray($array,$find, optional $inclusive)

	Dim $lf, $t, $l, $sp

	$lf=chr(10)	$sp=chr(32)

	If Not VarType($Array) & 8192    Exit(1)        EndIf

	for each $l in $array

		if     (instr($l,$find) and     $inclusive and trim($l)> $sp)

		or (not instr($l,$find) and not $inclusive and trim($l)> $sp)

			$t=$t+$lf+$l

			endif

		next

	$FilterArray=split(substr($t,2),$lf)

	EndFunction
84484FilterArray31RadimusFilterArray() - Filter an array of elements 
containing a specific string0


;Function FilterArray()
;
;Author Radimus
;
;Contributors Lonkero provided the array building string concept
;
;Action returns a filtered array containing eiter all the elements (or none
; of the elements) of an array matching a specified string.
;
;Syntax FilterArray($array,'find me', 1)
;
;Version 1.0
;
;Date 8/25/03
;
;Date Revised 
;
;Parameters Array - Must be an array 
; Filter - a string to search for
; Inclusive - any value, null or zero will return elements not containing the 
; filter, any other value will return elements containing the filter value
;
;Remarks think of the "find" command in DOS cmd language
;
;Returns Returns an array of filtered items
; 
;Dependencies None
;
;KiXtart Ver 4.02
; 
;Example(s) shell "cmd /c ping $server >$file"
; $pingreturn = ReadFile($file)
; $replies = FilterArray($pingreturn,'Reply from', 1)
;
Function FilterArray($array,$find, optional $inclusive)
Dim $lf, $t, $l, $sp
$lf=chr(10) $sp=chr(32)
If Not VarType($Array) & 8192 Exit(1) EndIf
for each $l in $array
if (instr($l,$find) and $inclusive and trim($l)> $sp)
or (not instr($l,$find) and not $inclusive and trim($l)> $sp)
$t=$t+$lf+$l
endif
next
$FilterArray=split(substr($t,2),$lf)
EndFunction

160238FindFile3755GavenFindFile() - Find one or multiple files1144091497; 
Function: FindFile
;
; Author: Gaven Henderson, Gaven@GavDogg.net
; 
; Action: Findfile can be used to find one or many files. In single file mode, 
it returns a string
; containing the full path of the found file, including the file name. If 
searching for
; multiple files, FindFile returns an array of strings as previously described. 
The function
; can be instructed to return results plain, in single (') or double (") quotes. 
Wild cards
; are supported for both single and multi file searches.
;
; Version: 3.0a
;
; Post Date: June 19, 2003
;
; Revise Date: April 03, 2006
;
; Dependancies: DirWalker()
;
; Syntax: findfile(["search"], [options], [path], [first drive], [last drive], [max 
results])
; 
; Parameter: search
; String specifying what you are looking for. Wildcards "?" and "*" are 
supported.
; 
; options (optional)
; Options are set bit-wise in a single number, add options to produce the 
options number.
;
; 1 - Find all matches, return results in a one dimension array
; 2 - Apply "double-quotes" to results (overrides option 4)
; 4 - Apply 'single-quotes' to results
;
; path (optional)
; Confines search to specific directory and its sub-directories. Disables drive 
search.
;
; first drive (optional)
; Number representing drive letter to begin search with, default is 3. (1 = A, 2 
= B,..., 26 = Z)
;
; last drive (optional)
; Number representing drive letter to end search with, default is 26. (1 = A, 2 
= B,..., 26 = Z)
;
; max results (optional)
; For multi file searches, stops search once max results is reached, default is 
0. (0 = No limit)
;
; Returns: Returns a string representing the found file and directory. An empty 
string is returned if
; the file was not found or the function is finished enumerating the search.
;
; @ERROR
; 0 - search successful, result returned
; 1 - invalid search or options
;
; KiXtart Ver: Designed on 4.51 but should work on any version.
;
Code:


Function findfile($a,optional $b,$c,$d,$e,$f)
	Dim $,$w,$x,$y,$z[0]
	$b=Val($b)
	$d=Val($d)
	$e=Val($e)
	$f=Val($f)
	If ($b & 2) And ($b & 4) $b=$b-4 EndIf
	If $d<1 Or $d>26 $d=3 EndIf
	If $e<1 Or $e>26 $e=26 EndIf
	If $d>$e Exit 1 EndIf
	If $e<1 $e=0 EndIf
	$d=$d+64
	$e=$e+64
	If InStr($a,":") Or InStr($a,"\") Or InStr($a,"/") Or InStr($a,'"') Or InStr($a,"<") Or InStr($a,">") Or InStr($a,"|") Or Len($a)<1
		Exit 1
	EndIf
	If $c
		While Right($c,1)="*" Or Right($c,1)="." Or Right($c,1)="\" $c=Left($c,Len($c)-1) Loop
		If Not Exist($c) Exit 1 EndIf
		$x=$c
	Else
		$x=Chr($d)+":"
		While Not Exist($x+"\*.*")
			$d=$d+1
			If $d>$e Exit 1 EndIf
			$x=Chr($d)+":"
		Loop
	EndIf
	If InStr($a,"?") Or InStr($a,"*") $w=1 Else $w=0 EndIf
	$y=0
	While $y=0
		If Exist($x+"\"+$a)
			If ($b & 1)
				If $w=0
					$z[UBound($z)]=Iif($b & 2,'"','')+Iif($b & 4,"'","")+$x+"\"+$a+Iif($b & 2,'"','')+Iif($b & 4,"'","")
					ReDim Preserve $z[UBound($z)+1]
				Else
					$=Dir($x+"\"+$a,2)
					Do
						If Right($,1)<>"."
							$z[UBound($z)]=Iif($b & 2,'"','')+Iif($b & 4,"'","")+$x+"\"+$+Iif($b & 2,'"','')+Iif($b & 4,"'","")
							ReDim Preserve $z[UBound($z)+1]
						EndIf
						$=Dir(,2)
					Until @Error Or (UBound($z)>=$f And $f<>0)
				EndIf
				If UBound($z)>=$f And $f<>0 $y=1 EndIf
			Else
				If $w=0
					$findfile=Iif($b & 2,'"','')+Iif($b & 4,"'","")+$x+"\"+$a+Iif($b & 2,'"','')+Iif($b & 4,"'","")
					Exit 0
				Else
					$=Dir($x+"\"+$a,2)
					Do
						If Right($,1)<>"."
							$findfile=Iif($b & 2,'"','')+Iif($b & 4,"'","")+$x+"\"+$+Iif($b & 2,'"','')+Iif($b & 4,"'","")
							Exit 0
						EndIf
						$=Dir(,2)
					Until @Error
				EndIf
			EndIf
		EndIf
		$x=DirWalker($x)
		If $c And Left($x,Len($c))<>$c $y=1 EndIf
		If $x=""
			If $d=$e
				$y=1
			Else
				$d=$d+1
				$x=Chr($d)+":"
				While Not Exist($x+"\*.*") And $d<=$e
					$d=$d+1
					$x=Chr($d)+":"
				Loop
				If Not Exist($x+"\*.*") $y=1 EndIf
			EndIf
		EndIf
	Loop
	If ($b & 1)
		If UBound($z)>0 ReDim Preserve $z[UBound($z)-1] EndIf
		$findfile=$z
	EndIf
	Exit 0
EndFunction

82288FindLargeFolders107mvdwFindLargeFolders() - Finds folders larger than...0Hi 
there,

This is for all the admins who don't have some form of Quota Managament on their 
servers, or anyone who is wondering which directory contains too much data.

I made this because some of our users are smart enough to keep tons of mp3/mpeg/divx 
on their homedrive, renaming the extensions and other ways of trying to hide 
their data-load on teh server.

My old trusty AmigaOS used to show how large a folder is, but in Windows you're 
supposed to get the properties of each folder individually (try that with 1000+ 
homedirs..)

Just run this UDF, you'll see exactly Who is hiding What and Where !

FindLargeFolders()
Action:
Scans a given directory for folders bigger than a certain amount of megabytes.

Author:
Maarten van der Woord

Syntax:
FindLargeFolders(RootFolder,MinimumSize)

Parameters:
Rootfolder : The complete path to the folder you want to scan (e.g. "D:\Data")
MinimumSize : The minimum size of a folder (in Mb) to be listed.

Returns:
For now it dumps output to screen (or you could redirect), a small modification 
would make it possible to catch it in an array. (I prefer the output...)

Remarks:
1. Since it is a recursive function, i could not figure out how to keep the used 
vars locally... it still puzzles me a bit but someday i'll figure it out (or 
someone tells me...)
i "worked around" that by using varnames beginning with $__

2. The maximum minimumsize (?!) to filter on is somewhere around 2047 MB. Also 
all dirs with a larger size than that are reported as 2047+ MB. This is due to 
the limitation of integers in kix, the max value is 2,147,483,647 which would 
represent approximately 2047.999 MB


Dependencies:
KiXtart 4.0 (Final)

Example(s):

FindLargeFolders("D:\Data\homedirs",40)

will output all subfolders in D:\Data\homedirs occupying more than 40 MB of your 
precious storage unit.

code:


Function FindLargeFolders($path, optional $minimum)

$fso = createobject (Scripting.FileSystemObject)
if vartype($minimum) = 3
	$__minsize = $minimum
endif

	$__folder = $fso.getfolder($path)
	$__subs = $__folder.subfolders
	$__indent = $__indent + "  "

	for each $__sub in $__subs
		if $__sub.size
			$__subsize = (val($__sub.size)) /  1048576
			if (val($__subsize)) > (val($__MinSize))
				? $__indent + "\" + $__sub.name + " = $__subsize Mb"
			endif
		else
			if $__sub.size <> 0
				? $__indent + "\" + $__sub.name + " = 2047+ Mb"
			endif
		endif

		FindLargeFolders($__sub)
		$__indent = substr($__indent,1,(len($__indent)-2))
	next

Endfunction

let me know what you think... 82885Flags28BryceFlags() - Returns the data 
flags used in a given number0

code:


;Function	Flags()
;
;Author		Bryce Lindsay (Bryce@isorg.net)
;
;Action		Returns the data flags used in a given number.
;
;Syntax		Flags("flag data",[HEX/DEC output flag])
;
;Parameters 	Flag Number
;			this can be either a hex or dec number representing
;			the desired flags used.
;		
;		HEX/DEC output flag (optional)
;			to return HEX output set this flag to 1
;
;
;Returns 	This UDF will return a array of flag options gathered 
;		from the flag data information.
;
;Remarks 	A number of Microsoft ADSI Com objects will return a flag 
;		variable that can represent 1 or more flag options.
;
;		Example:  the flag number 169 represents the flag variables 
;		128,32,8 and 1.
;		
;		Do to the limit of kix not being able to handle values greater
;		than 2,147,483,647, this limits the number of flag variables 
;		that can be returned to 19.
;
; 
;Dependencies 	None
; 
;Example(s)	$flags = flags(169)
;		for each $flag in $flags
;			? $flag
;		next
;
;		;You can also work with HEX values
;		$flags = flags(&1C0,1)
;		for each $flag in $flags
;			? $flag
;		next
; 
;Source
Function Flags($data,optional $dechex)
	DIM $flagarray, $value, $temp

	$temp = ""
	$data = val($data)
	$flagArray ="&80000000 &40000000 &20000000 &10000000 &1000000 &100000 &80000 &40000 &20000 &10000 &100 &80 &40 &20 &10 &8 &4 &2 &1"
	$flagarray = split($flagarray," ")
	
	for each $value in $flagarray
		if $data & val($value)
			if $decHex = 1
				$temp = $temp + "$value,"
			else
				$temp = $temp + val($value) + ","
			endif
				
		endif
	
	next

	$flags = split($temp,",")
	if ubound($flags) >= 1
		redim preserve $flags[ubound($flags)-1]
	endif
endfunction

[ 22 January 2002: Message edited by: Bryce ]

[ 22 January 2002: Message edited by: DrillSergeant ]122521FlipcTime28BryceFlipcTime() 
Converts Kix Date/Time into a cTime #1124295490Code:


;Function      FlipcTime()
;
;ACTION        Converts a Kixtart format date/time into a cTime time
;
;AUTHOR        Bryce Lindsay
;
;VERSION       1.0 first publish
;              1.1 removed dependencies
;              1.2 added Time Zone support
;              1.3 added optional epoc date, fixed the 32bit bug!
;
;KIXTART       4.22+
;
;SYNTAX        RETCODE = FLIPCTIME(DATE,TIME,[TIME ZONE],[Epoc Date])
;
;PARAMETERS    DATE
;              Date In YYYY/MM/DD
;
;              TIME
;              Time In HH:MM[:SS]
;
;              Optional ZIME ZONE
;              the timezone that you want To adjust For.
;
;              Optional Epoc date
;              if no epoc date is given, then 1970/1/1 is used
;
;Return        the given date/time In number of seconds that have passed since the Epoc date (default is 1970/1/1)
;
;REMARKS       See this thread For original idea
;              http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=80863
;              Also know as UNIX time.
;
;DEPENDENCIES  None
;
;              ;give the Epoc time For the central time zone In the US(-6)
;EXAMPLE       $Return = FlipcTime("2004/07/08","14:45:23",-6)
;
;              ;number of seconds that have passed since 1900/1/1
;              $return = flipctime(@DATE,@TIME,'','1900/1/1')
;              
Function FlipcTime($date,$time,optional $tz,$epoc)
	DIM $y,$m,$d
	$tz = Val($tz)
	$date = Split($date,"/")
	If UBound($date) <> 2 Exit(1) EndIf
	$y=Val($date[0]) $m=Val($date[1]) $d=Val($date[2])
	If $m<3
		$m=$m+12
		$y=$y-1
	EndIf
	$Date=CDbl($d)+(153*$m-457)/5+365*$y+$y/4-$y/100+$y/400-306
	If $epoc
		$epoc = Split($epoc,'/') If UBound($epoc) <> 2 Quit 1 EndIf
		If 0+$epoc[1]<3
			$epoc[1]=0+$epoc[1]+12
			$epoc[0]=0+$epoc[0]-1
		EndIf
		$epoc= 0+$epoc[2]+(153*$epoc[1]-457)/5+365*$epoc[0]+$epoc[0]/4-$epoc[0]/100+$epoc[0]/400-306
	Else
		$epoc = 719163
	EndIf
	$time = Split($time,":")
	Select 
		Case UBound($time)=1
			ReDIM preserve $time[2]
			$time[2]=0
		Case UBound($time)=2
		Case 1
			Exit(1)
	EndSelect
	$time = (Val(CDbl($time[0]))*3600)+(Val($time[1])*60)+Val($time[2])
	$flipctime = IIf(Val($tz),(($date-$epoc)*86400 + $time)-($tz*3600),($date-$epoc)*86400 + $time)
EndFunction



82836FlipStrBin487New Mexico MarkFlipStrBin() - Convert string to binary 
and back0I know this function has been beat to death. But so far I haven't 
seen the inverse function as someone had mentioned. Here is my version with the 
inverse built in. Enjoy.

code:

  
;Function	FlipStrBin()
;
;Author		New Mexico Mark (But built on the success of others.)
;
;Action		If supplied a string of mixed characters, converts that string
;		to a string of 8-bit representations of that number. If
;		supplied a string of only 1's and 0's, converts each octet back
;		to the Chr() value of the binary number. bStr overrides to
;		force conversion to a binary represenation.
;
;Syntax		FlipStrBin(String,Boolean)
;
;Parameters
;		String
;		Any expression that evaluates to a string. Maximum length is
;		3,750 characters when converting to binary and 30,000
;		characters when converting back to text.
;
;		Boolean
;		Any expression that evaluates to boolean true or false. If
;		set to true, the function will always convert to binary.
;
;Remarks 	This function has been beat to death. However, here is the
;		synopsis. The fastest way to do the conversion would be to
;		initialize an array of 256 elements and fill it with '0001',
;		'0010'... However, this would make the function too large
;		to be practical. The most elegant way is simply to convert
;		each character on the fly. However, this is somewhat slow.
;		This function is a compromise, using a four-element array
;		that can be initialized on just one line.
;
;Returns	A string.
;
;Dependencies	None.
;
;Example(s)		
$TestVal = "Test 1"
$TestVal = FlipStrBin($TestVal)
$TestVal ?
FlipStrBin($TestVal) ?
FlipStrBin("0100",1) ?
;
;Console output from examples
;010101000110010101110011011101000010000000110001
;Test 1
;00110000001100010011000000110000
;
;Source
FUNCTION FlipStrBin($sString, OPTIONAL $bStr)
	; bStr = True -- Regular string supplied - go to binary
	; bStr = False or not supplied -- Evaluate supplied string
	$sString    = "" + $sString
	DIM $iStrLen, $iCtr, $Chr
	$iStrLen = Len($sString)
	IF NOT $bStr
		FOR $iCtr = 1 TO $iStrLen
			$Chr = SubStr($sString,$iCtr,1)
			IF $Chr <> "1" AND $Chr <> "0" ; sString contains non-binary character(s)
				$bStr = 1 ; Go to string
			ENDIF
		NEXT
	ENDIF
	IF $bStr ; Go go binary
		DIM $i3, $i2, $i1, $i0
		DIM $aValues, $iChar
		$aValues    = '00','01','10','11'
		$FlipStrBin = ""
		$iCtr = 0
		WHILE $iCtr < $iStrLen
			$iCtr  = $iCtr + 1
			$iChar = Asc(SubStr($sString,$iCtr,1))
			$i3 = ($iChar & 192) / 64
			$i2 = ($iChar & 48)  / 16
			$i1 = ($iChar & 12)  / 4
			$i0 = ($iChar & 3)
			$FlipStrBin = "" + $FlipStrBin + $aValues[$i3] + $aValues[$i2] + 
			           $aValues[$i1] + $aValues[$i0]
		LOOP
	ELSE ; Go to string
		DIM $iPwr, $iExp, $sBinStr, $Chr
		FOR $iCtr = 1 TO $iStrLen STEP 8
			$sBinStr = "" + SubStr($sString,$iCtr,8)
			$iExp    = 1
			$iChrVal = 0
			$sBinStr = SubStr("00000000",1,8-Len($sBinStr)) + $sBinStr
			FOR $iPwr = 0 TO 7
				$iChrVal = 0 + $iChrVal + (Val(SubStr($sBinStr,8 - $iPwr,1)) * $iExp)
				$iExp = $iExp * 2
			NEXT
			$FlipStrBin = "" + $FlipStrBin + Chr($iChrVal)
		NEXT
	ENDIF
ENDFUNCTION

82811Flip_Currency487New Mexico MarkFlip_Currency() - Add/Remove currency 
symbol0

code:

  
;Function	Flip_Currency()
;
;Author		New Mexico Mark
;
;Action		Adds (or removes if present) the system currency symbol to the
;		system-specified location in a string (or expression that can
;		be converted to a string), then returns the modified string.
;
;Syntax		Flip_Currency(String)
;
;Parameters
;
;		String
;		Any expression that evaluates to a string or can be directly
;		converted to a string.
;
;Remarks 	This is a pretty basic function. It may be used directly, but
;		I designed it for advanced string handling from the FMT UDF.
;
;Returns	A string.
;
;Dependencies	The settings in the registry must be correct.
;
;Example(s)		
;"Flip_Currency($123.00) = " + Flip_Currency("$123.00") ?
;"Flip_Currency(123.00) = " + Flip_Currency("123.00") ?
;
;Console Output (Example)
;Flip_Currency($123.00) = 123.00
;Flip_Currency(123.00) = $123.00
;
;Source
FUNCTION Flip_Currency($sVar)
; This function takes an expression that evaluates to a string or that can be
; directly converted to a string. It adds (or removes if present) the system
; currency symbol in the place specified by the system and returns the 
; modified string.
	IF VarType($sVar) < 2 OR VarType($sVar) > 8 RETURN ENDIF
	DIM $cCur, $iLoc, $iLen, $sReg
	$sVar = "" + $sVar
	$sReg = 'HKCU\Control Panel\International'
	$cCur = ReadValue($sReg,'sCurrency')
	$iLoc = Val(ReadValue($sReg,'iCurrency'))
	$iLen = Len($sVar)
	SELECT
	CASE $iLoc = 0 ; "$2"
		IF SubStr($sVar,1,1) = $cCur 
			$Flip_Currency = SubStr($sVar,2)
		ELSE
			$Flip_Currency = $cCur + $sVar
		ENDIF
	CASE $iLoc = 1 ; "2$"
		IF $iLen > 1
			IF SubStr($sVar,$iLen - 1,1) = $cCur
				$Flip_Currency = SubStr($sVar,1,$iLen - 1)
			ELSE
				$Flip_Currency = $sVar + $cCur
			ENDIF
		ENDIF
	CASE $iLoc = 2 ; "$ 2"
		IF SubStr($sVar,1,2) = $cCur + " "
			$Flip_Currency = SubStr($sVar,3)
		ELSE
			$Flip_Currency = $cCur + " " + $sVar
		ENDIF
	CASE $iLoc = 3 ; "2 $"
		IF $iLen > 2
			IF SubStr($sVar,$iLen - 2,2) = " " + $cCur
				$Flip_Currency = SubStr($sVar,1,$iLen - 2)
			ELSE
				$Flip_Currency = $sVar + " " + $cCur
			ENDIF
		ELSE
			$Flip_Currency = $sVar + " " + $cCur
		ENDIF
	ENDSELECT
ENDFUNCTION ; Flip_Currency()

[ 18 January 2002: Message edited by: New Mexico Mark ]82812Flip_Dec487New 
Mexico MarkFlip_Dec() - Add/Remove decimal0

code:

  
;Function	Flip_Dec()
;
;Author		New Mexico Mark
;
;Action		Takes a string expression (or any variable that can be directly
;		converted to a string) and adds (or removes if present) the
;		system decimal point in the string (hundreds place is default).
;		It returns the modified string. It can also relocate a decimal
;		in a string.
;
;Syntax		Flip_Dec(String, PositiveInteger)
;
;Parameters
;		String
;		Any expression that evaluates to a string or can be directly
;		converted to a string by the function.
;
;		PositiveInteger
;		Integer of the position between 1 and 30,000. I.e. 2 = nnn.nn
;
;Returns	String.
;
;Dependencies	The decimal symbol must be correct in the system regional
;		settings. There is are conditional dependencies on 
;		Flip_NumSep() and/or Flip_Currency. If strings without
;		currency and/or separation characters are supplied, this is
;		a non-issue.
;
;Example(s)		
;$str = "98765.43210" ?
;FOR $i = 11 TO 0 STEP -1
;	$t = SubStr($str,1,$i)
;	"Flip_Dec(" + Chr(34) + $t + Chr(34) + ") = "  +
;	Chr(34) + Flip_Dec($t) + Chr(34) ?
;NEXT
;$t = "987654321" ?
;FOR $i = -1 TO 12
;	"Flip_Dec(" + Chr(34) + $t + Chr(34) + "," + $i + ") = "  +
;	Chr(34) + Flip_Dec($t,$i) + Chr(34) ?
;NEXT
;$t = "6543.21" ?
;"Flip_Dec(" + Chr(34) + $t + Chr(34) + ",4) = "  +
;Chr(34) + Flip_Dec($t,4) + Chr(34) ?
;
;Console Output (Example)
;
;Flip_Dec("98765.43210") = "9876543210"
;Flip_Dec("98765.4321") = "987654321"
;Flip_Dec("98765.432") = "98765432"
;Flip_Dec("98765.43") = "9876543"
;Flip_Dec("98765.4") = "987654"
;Flip_Dec("98765.") = "98765"
;Flip_Dec("98765") = "987.65"
;Flip_Dec("9876") = "98.76"
;Flip_Dec("987") = "9.87"
;Flip_Dec("98") = ".98"
;Flip_Dec("9") = ".09"
;Flip_Dec("") = ".00"
;
;Flip_Dec("987654321",-1) = "9876543.21"
;Flip_Dec("987654321",0) = "9876543.21"
;Flip_Dec("987654321",1) = "98765432.1"
;Flip_Dec("987654321",2) = "9876543.21"
;Flip_Dec("987654321",3) = "987654.321"
;Flip_Dec("987654321",4) = "98765.4321"
;Flip_Dec("987654321",5) = "9876.54321"
;Flip_Dec("987654321",6) = "987.654321"
;Flip_Dec("987654321",7) = "98.7654321"
;Flip_Dec("987654321",8) = "9.87654321"
;Flip_Dec("987654321",9) = ".987654321"
;Flip_Dec("987654321",10) = ".0987654321"
;Flip_Dec("987654321",11) = ".00987654321"
;Flip_Dec("987654321",12) = ".000987654321"
;
;Flip_Dec("6543.21",4) = "65.4321"
;
;Source
FUNCTION Flip_Dec($sVar, OPTIONAL $iPos)
; Takes an expression that can be directly converted to a string and returns
; a string with a system decimal added (or removed if already present) to the
; hundreds place. This can provide a work-around for currency by using 
; integers * 100 and displaying the results with this function.
	IF VarType($sVar) < 2 OR VarType($sVar) > 8 RETURN ENDIF
	DIM $cDec, $cSep, $cCur, $iLen, $sReg, $iBeg, $iEnd, $i, $j, $k, $c
	DIM $bCur, $bSep, $bPos
	$sVar  = "" + $sVar
	$iPos = 0 + $iPos
	$iLen  = Len($sVar)
	$iBeg  = 1
	$iEnd  = $iLen
	IF $iPos < 1 $iPos = 2 ELSE $bPos=1 ENDIF
	$sReg  = 'HKCU\Control Panel\International'
	$cDec = ReadValue($sReg,'sDecimal')
	$cSep = ReadValue($sReg,'sThousand')
	$cCur = ReadValue($sReg,'sCurrency')
	IF InStr($sVar,$cDec) ; One or more decimals present... remove.
		FOR $i = $iBeg TO $iEnd
			$c = SubStr($sVar,$i,1)
			IF $c <> $cDec
				$k = "" + $k + $c
			ENDIF
		NEXT
		IF $bPos $k = Flip_Dec($k,$iPos) ENDIF
		$Flip_Dec = $k
	ELSE ; Add decimal
		IF InStr($sVar, $cCur) $sVar=Flip_Currency($sVar) $bCur=1 ENDIF
		IF InStr($sVar, $cSep) $sVar=Flip_NumSep($sVar) $bSep=1 ENDIF
		$iLen = Len($sVar)
		$iEnd = $iLen
		IF ($iEnd < $IPos) $iEnd=$IPos ENDIF
		FOR $i = $iBeg TO $iEnd
			IF $i <= $iLen
				$k = "" + $k + SubStr($sVar,$i,1)
			ELSE
				$k = "0" + $k
			ENDIF
			; "Beg=$iBeg End=$iEnd Len=$iLen iPos=$Ipos i=$i k=$k" ?
			IF $iLen=$iPos+$i $k = "" + $k + $cDec ENDIF
			IF ($iPos >= $iLen) AND ($iPos = $i) $k = "" + $cDec + $k ENDIF
		NEXT
		$Flip_Dec = $k
		IF $bSep $Flip_Dec=Flip_NumSep($Flip_Dec) ENDIF
		IF $bCur $Flip_Dec=Flip_Currency($Flip_Dec) ENDIF
	ENDIF
ENDFUNCTION ; Flip_Dec()

[ 18 January 2002: Message edited by: New Mexico Mark ]

[ 19 January 2002: Message edited by: New Mexico Mark ]82810Flip_NumSep487New 
Mexico MarkFlip_NumSep() - Add/Remove separation characters from a string0

code:

  
;Function Flip_NumSep()
;
;Author New Mexico Mark (wmarkh@aol.com)
;
;Action	Takes a string expression (or any value that can be directly
;	converted to a string) and adds (or removes if present) the
;	system separation character from the string. It then
;	returns the string.
;
;Syntax Flip_NumSep(String)
;
;Parameters
;
;String
;
;		Any expression that evaluates to a string or can be directly
;		converted to a string by the function.
;
;Remarks
;		Nice for easy-to-read numbers. It also correctly handles a 
;		string with a system decimal character present.
;
;Returns
;		String.
;
;Dependencies 
;		The system decimal character and number separation character
;		must be correct in the system regional settings. Also, Flip_Currency() must
;		be available if strings with currency symbols in them are supplied.
;
;Example(s) 
;$str = "1,234,567.89" ?
;FOR $i = 12 TO 1 STEP -1
;	$s = SubStr($str,$i)
;	"Flip_NumSep(" + Chr(34) + $s + Chr(34) + ") = " +
;	Chr(34) + Flip_NumSep($s) + Chr(34) ? 
;NEXT
;$str = "1234567.890" ?
;FOR $i = 0 TO 11
;	$s = SubStr($str,1,Len($str) - $i)
;	"Flip_NumSep(" + Chr(34) + $s + Chr(34) + ") = " +
;	Chr(34) + Flip_NumSep($s) + Chr(34) ? 
;NEXT
;
;Console Output (Example)
;Flip_NumSep("9") = "9"
;Flip_NumSep("89") = "89"
;Flip_NumSep(".89") = ".89"
;Flip_NumSep("7.89") = "7.89"
;Flip_NumSep("67.89") = "67.89"
;Flip_NumSep("567.89") = "567.89"
;Flip_NumSep(",567.89") = "567.89"
;Flip_NumSep("4,567.89") = "4567.89"
;Flip_NumSep("34,567.89") = "34567.89"
;Flip_NumSep("234,567.89") = "234567.89"
;Flip_NumSep(",234,567.89") = "234567.89"
;Flip_NumSep("1,234,567.89") = "1234567.89"
;
;Flip_NumSep("1234567.890") = "1,234,567.890"
;Flip_NumSep("1234567.89") = "1,234,567.89"
;Flip_NumSep("1234567.8") = "1,234,567.8"
;Flip_NumSep("1234567.") = "1,234,567."
;Flip_NumSep("1234567") = "1,234,567"
;Flip_NumSep("123456") = "123,456"
;Flip_NumSep("12345") = "12,345"
;Flip_NumSep("1234") = "1,234"
;Flip_NumSep("123") = "123"
;Flip_NumSep("12") = "12"
;Flip_NumSep("1") = "1"
;Flip_NumSep("") = ""
;
;Source
FUNCTION Flip_NumSep($sVar)
; This function takes an expression that evaluates to a string or that can be
; directly converted to a string. It adds (or removes if present) the system
; number separator from every third place in the string and returns the 
; modified string. It can handle strings with a system decimal character in
; them (i.e. "1234.56" will return "1,234.56")
; Conditional dependencies are: UDF_Flip_Currency
	IF VarType($sVar) < 2 OR VarType($sVar) > 8 RETURN ENDIF
	DIM $cDec, $cSep, $cCur, $iBeg, $iEnd, $sVar, $iLen, $i, $j
	DIM $Chr, $sReg, $bCur, $bDec
	$bCur=0 $bDec=0 $iBeg=Len($sVar) $iEnd=1
	$sVar = "" + $sVar
	$iLen = Len($sVar)
	$sReg = 'HKCU\Control Panel\International'
	$cSep = ReadValue($sReg,'sThousand')
	$cDec = ReadValue($sReg,'sDecimal')
	$cCur = ReadValue($sReg,'sCurrency')
	; Remove a currency symbol, if it exists. This is a conditional 
	;dependency on Flip_Currency()
	IF InStr($sVar,$cCur)
		$sVar = Flip_Currency($sVar)
		$bCur = 1
	ENDIF
	; If a decimal character is present, start to the left of it
	IF InStr($sVar,$cDec)
        	$iBeg = InStr($sVar,$cDec) - 1
        	$bDec = 1
	ELSE
		$iBeg = Len($sVar)
	ENDIF
	IF InStr($sVar,$cSep) > 0  ; Separator(s) present - remove all
		FOR $i = 1 TO $iLen
			$Chr = SubStr($sVar,$i,1)
			IF $Chr <> $cSep
				$Flip_NumSep = $Flip_NumSep + $Chr
			ENDIF
		NEXT
	ELSE ; Separator not present, add
		; Counter $j is needed because $i might not start at 1
		$j = 1
		FOR $i = $iBeg TO $iEnd STEP -1
			$Flip_NumSep = "" +
				SubStr($sVar,$i,1) + 
				$Flip_NumSep 
			IF $j - (($j / 3) * 3) = 0 AND $i <> $iEnd
				$Flip_NumSep = "" + $cSep + $Flip_NumSep
			ENDIF
			$j = $j + 1
		NEXT
		; If decimal present, re-add and parse remainder
		IF $bDec
			FOR $i = $iBeg + 1 TO Len($sVar)
				$Flip_NumSep = "" + $Flip_NumSep +  
					SubStr($sVar,$i,1)
			NEXT
		ENDIF
	ENDIF
	; Restore separation characters if stripped earlier
	IF $bCur $Flip_NumSep=Flip_Cur($Flip_NumSep) ENDIF
ENDFUNCTION ; Flip_NumSep()

[ 18 January 2002: Message edited by: New Mexico Mark ]82813Fmt487New Mexico 
MarkFmt() - Format a string - update 1/19/020;Function Fmt()
;
;Author New Mexico Mark
;
;Action Given a string and formatting codes, returns a formatted string.
;
;Syntax Fmt(String, MinMax, Control)
;
;Parameters
;
; String
; Any expression that evaluates to a string or a type that can be
; directly converted to a string.
;
; MinMax
; A *string* in the format "MIN[.MAX" where MIN is a number
; giving the minimum length of the returned string, and .MAX
; is the maximum length of the returned string. Ex. "20.20" or
; "80" or ".30".
;
; Control
; An integer sum of the following options (1-128 are internal):
; 1 - Left justify (right is default)
; 2 - Center justify (right is default - overrides 1)
; 4 - Pad with combination Tabs/spaces (spaces only is default)
; 8 - Reserved
; 16 - Reserved
; 32 - Reserved
; 64 - Reserved
; 128 - Reserved
; 256 - Add/remove separation characters (i.e. commas) *
; 512 - Add system decimal in the 100's place or remove any decimal *
; 1024 - Add/remove system currency symbol (i.e. "$") *
; 2048 - All through bit 31 reserved.
; * Requires another UDF.
;
;Remarks This is a huge help when formatted output is desired... i.e.
; columns of numbers or text like this. I kept the function
; name as short as possible, as it is my experience that it
; may be used repeatedly. This helps keep program lines 
; managable.
; I once posted a similar function in the ScriptLogic forum.
; However, this has been rewritten with more flexibility and
; with better control of UDF dependencies. If you are using 
; the old function, check your syntax before substituting 
; functions.
; * Essentially, what I did was to keep the core formatting
; internal to the function and use calls to other UDF's for
; the fancier stuff that may or may not be needed. This keeps
; the function reasonably small.
;
;Returns A formatted string.
;
;Dependencies None, UNLESS currency, number separator, or currency manip-
; ulation is required.
;
;Example(s)
; The following is a call to a file containing the following UDF's:
; Flip_Dec()
; Flip_Currency()
; Flip_NumSep()
CALL 'd:\util\kss\UDF_Flip_Fun.kix'
; ?
; The following code is pretty complex because I'm not only formatting the
; string, but I'm supplying quotes for clarity, then formatting THAT output
; for clarity. However, it demonstrates the flexibility of Fmt. I encourage
; anyone trying out this UDF to play with the "formatting fun" example code
; to see how easy it is to build beautifully formatted output with Fmt.
$Q=Chr(34)
$Str = "Hello World"
"String supplied to examples 1-5 is: " + $Str ?
"Example 01: " + Fmt($Q+Fmt($str,"")+$Q,30,1,".") + " No formatting specified." 
?
"Example 02: " + Fmt($Q+Fmt($str,"20",0)+$Q,30,1,".") + " Min=20, No Max, No 
Options." ?
"Example 03: " + Fmt($Q+Fmt($str,"20",1)+$Q,30,1,".") + " Min=20, No Max, Left 
Justify." ?
"Example 04: " + Fmt($Q+Fmt($str,"22",2)+$Q,30,1,".") + " Min=22, No Max, Center." 
?
"Example 05: " + Fmt($Q+Fmt($str,"20.5",1)+$Q,30,1,".") + " Min=20, Max=5, Left 
Justify." ?
"Number supplied to examples 6-14 is 1024. Min=8, No Max." ?
"Example 06: " + Fmt($Q+Fmt(1024,"8",256)+$Q,30,1,".") + " Separation characters." 
? ;*
"Example 07: " + Fmt($Q+Fmt(1024,"8",512)+$Q,30,1,".") + " Decimal." ? ;*
"Example 08: " + Fmt($Q+Fmt(1024,"8",1024)+$Q,30,1,".") + " Currency."? ;*
"Example 09: " + Fmt($Q+Fmt(1024,"8",768)+$Q,30,1,".") + " Separation and 
decimal." ? ;*
"Example 10: " + Fmt($Q+Fmt(1024,"8",1536)+$Q,30,1,".") + " Decimal and currency." 
? ;*
"Example 11: " + Fmt($Q+Fmt(1024,"8",1892)+$Q,30,1,".") + " Separation, decimal 
and currency." ? ;*
"Example 12: " + Fmt($Q+Fmt(1024,"8",1280)+$Q,30,1,".") + " Separation and 
currency." ? ;*
"Example 13: " + Fmt($Q+Fmt(1024,8,257)+$Q,30,1,".") + " Separation and Left-Justify." 
? ;*
"Example 14: " + Fmt($Q+Fmt(1024,8,1)+$Q,30,1,".") + " Left-Justify." ?
;
$strTest = "1234567890" ?
FOR $x = 1 TO 10
"The time is @TIME: Your Enron stock value is:" + 
Fmt(SubStr($strTest,1,11 - $x),16,1892) ? ; *
SLEEP 1
NEXT
; * These require external UDF's. See documentation above.
;
; If you really want to have some fun, uncomment the following code.
;
;$str = " Formatting Fun! "
;FOR $x = 1 TO 80
; Fmt($str,"" + $x + "." + $x) ?
;NEXT
;FOR $x = 80 TO 1 STEP -1
; Fmt($str,"" + $x + "." + $x) ?
;NEXT
;FOR $x = 1 TO 80
; Fmt($str,"" + $x + "." + $x,2,"*") ?
;NEXT
;FOR $x = 80 TO 1 STEP -1
; Fmt($str,"" + $x + "." + $x,2,"*") ?
;NEXT
;FOR $x = 1 TO 80
; Fmt(Fmt($str,"" + $x + "." + $x,2,"*"),80,2) ?
;NEXT
;FOR $x = 80 TO 1 STEP -1
; Fmt(Fmt($str,"" + $x + "." + $x,2,"*"),80,2) ?
;NEXT
;FOR $x = 1 TO 80
; Fmt(Fmt($str,"" + $x + "." + $x,2,"<*>"),"" + (80 - $x) + ".80",2,"<*>") ?
;NEXT
;FOR $x = 80 TO 1 STEP -1
; Fmt(Fmt($str,"" + $x + "." + $x,2,"<*>"),"" + (80 - $x) + ".80",2,"<*>") ?
;NEXT
; ; End fun code.
;
; Console output from main code (fun code too long to list here):
;
;String supplied to examples 1-5 is: Hello World
;Example 01: "Hello World"................. No formatting specified.
;Example 02: " Hello World"........ Min=20, No Max, No Options.
;Example 03: "Hello World "........ Min=20, No Max, Left Justify.
;Example 04: " Hello World "...... Min=22, No Max, Center.
;Example 05: "Hello"....................... Min=20, Max=5, Left Justify.
;Number supplied to examples 6-14 is 1024. Min=8, No Max.
;Example 06: " 1,024".................... Separation characters.
;Example 07: " 10.24".................... Decimal.
;Example 08: " $1024".................... Currency.
;Example 09: " 10.24".................... Separation and decimal.
;Example 10: " $10.24".................... Decimal and currency.
;Example 11: " $10.24".................... Separation, decimal and currency.
;Example 12: " $1,024".................... Separation and currency.
;Example 13: "1,024 ".................... Separation and Left-Justify.
;Example 14: "1024 ".................... Left-Justify.
;
;The time is 09:30:25: Your Enron stock value is: $12,345,678.90
;The time is 09:30:26: Your Enron stock value is: $1,234,567.89
;The time is 09:30:28: Your Enron stock value is: $123,456.78
;The time is 09:30:29: Your Enron stock value is: $12,345.67
;The time is 09:30:30: Your Enron stock value is: $1,234.56
;The time is 09:30:31: Your Enron stock value is: $123.45
;The time is 09:30:32: Your Enron stock value is: $12.34
;The time is 09:30:33: Your Enron stock value is: $1.23
;The time is 09:30:34: Your Enron stock value is: $.12
;The time is 09:30:35: Your Enron stock value is: $.01
;

code:

  
; Source
FUNCTION Fmt($sText, $sMinMax, OPTIONAL $iCtrl, OPTIONAL $sPad)
; $sText is an integer or string.
; $sMinMax must a string formatted as follows: "[MinLen][.MaxLen]"
; $sPad is a string of one or more characters to use as padding.
; $iCtrl is one or more of the following options (additive).
; 1=Left-justify, 2=Center, 4=TABs and spaces
; 256=Add or remove separation characters
; 512=Add decimal in 100's place or remove any decimal chararacter
; 1024=Add or remove currency symbol
; NOTE: The first 8 bits (1 - 128) are built in to FMT(). Bits 9+ (256+ decimal)
; require external UDF's
; If the length of the integer or string is less than MinLen, it will be 
; right-justified and padded with spaces, unless specified otherwise by intControl.
; If .MaxLen is supplied, the string (plus any padding added) will be 
; truncated at that length.
; Returns: Formatted string
; Dependencies: Contitional dependencies on Flip_NumSep(), Flip_Currency() and
; Flip_Dec()
	IF VarType($sText) < 2 OR VarType($sText) > 8 RETURN ENDIF
	DIM $sPadding, $bTabs, $sLPad, $sRPad
	DIM $iMin, $iMax, $iPadLen, $iFmtLen, $iTabWid, $iCharWid, $i, $j, $k
	$iTabSpc=0 $iFmtLen=0 $iPadLen =0 $iTabWid=8 $iCharWid=1
	$sText    = '' + $sText
	$sMinMax  = '' + $sMinMax
	$iCtrl    = 0 + $iCtrl
	$sPad     = '' + $sPad
	IF $sPad = '' $sPad = Chr(32) ENDIF
	IF $iCtrl & 4 $sPad = Chr(9) ENDIF ; Horizontal Tab
	;Calculate the width of the pad string
	FOR $i = 1 TO Len($sPad)
		IF Asc(SubStr($sPad,$i,1)) = 9
			$iPadLen = $iPadLen + ($iTabWid * (1 + ($iCtrl & 2)/2))
		ELSE
			$iPadLen = $iPadLen + ($iCharWid * (1 + ($iCtrl & 2)/2))
		ENDIF
	NEXT
	; Parse MinMax
	IF InStr($sMinMax,".") > 0
		$iMin = Val(SubStr($sMinMax,1,InStr($sMinMax,".") - 1))
		$iMax = Val(SubStr($sMinMax,InStr($sMinMax,".") + 1))
	ELSE
		$iMin = Val($sMinMax)
		IF $iMin = 0 $iMin = Len($sText) ENDIF
		$iMax = 32000
	ENDIF
	; UDF dependencies.
	IF $iCtrl & 0256 $sText = Flip_NumSep($sText) ENDIF
	IF $iCtrl & 0512 $sText = Flip_Dec($sText) ENDIF
	IF $iCtrl & 1024 $sText = Flip_Currency($sText) ENDIF
	; After pre-processing, truncate string to $iMax length
	IF $iMax < Len($sText) $sText = SubStr($sText,1,$iMax) ENDIF
	; Calculate the width of the supplied string including TABS
	FOR $i = 1 TO Len($sText)
		IF Asc(SubStr($sText,$i,1)) = 9
			$iFmtLen = $iFmtLen + $iTabWid
		ELSE
			$iFmtLen = $iFmtLen + 1
		ENDIF
	NEXT
	IF $iFmtLen < $iMin
		$j = $iMin - ($iFmtLen + $iPadLen)
		$k = 0
		FOR $i = 0 TO $j STEP $iPadLen ; Number of sPad strings needed
			$sPadding = $sPadding + $sPad
			$k = $k + $iPadLen
		NEXT
		$iFmtLen = $iFmtLen + $k
		$sLPad=$sPadding $sRPad=$sPadding
		FOR $i = 1 TO ($iMin - $iFmtLen) ; Fill remainder with even number of spaces
			IF $iCtrl & 2
				IF $i & 1 
					$sRPad = $sRPad + ' '
				ELSE 
					$sLPad = ' ' + $sLPad 
				ENDIF
			ELSE
				$sPadding = $sPadding + ' '
			ENDIF
		NEXT
	ENDIF
	IF $iCtrl & 1 ; LJust
		$Fmt = $sText + $sPadding
	ELSE  ; RJust
		$Fmt = $sPadding + $sText
	ENDIF
	IF $iCtrl & 2 ; Center
		$Fmt = $sLPad + $sText + $sRPad
	ENDIF
	;Recalculate the total length of the string.
	$iFmtLen = 0
	FOR $i = 1 TO Len($Fmt)
		IF Asc(SubStr($Fmt,$i,1)) = 9
			$iFmtLen = $iFmtLen + $iTabWid
		ELSE
			$iFmtLen = $iFmtLen + 1
		ENDIF
	NEXT
	FOR $i = 1 TO ($iMin - $iFmtLen) ; Fill remainder with spaces
		$Fmt = $Fmt + ' '
	NEXT
	$Fmt = SubStr($Fmt,1,$iMax)
ENDFUNCTION ; Fmt()

[ 19 January 2002: Message edited by: New Mexico Mark ]145655fnActiveTimeZone953Chris 
S.fnActiveTimeZone() - Retrieves the Active Timezone or Active Timezone Bias0; 
;Function: 
; fnActiveTimeZone() 
; 
;Author: 
; Christopher Shilt (christopher.shilt@relizon.com) 
; 
;Version: 
; 1.0 (Aug 15, 2005) 
; 
;Version History: 
; 
;Action: 
; Retrieves the Active Timezone or Active Timezone Bias 
; 
;Syntax: 
; fnActiveTimeZone(Optional BIAS) 
; 
;Parameters: 
; BIAS         : Optional. Specifies whether to return the active timezone bias. 
;                BIAS = 0 (Active Timezone) 
;                BIAS = 1 (Active Timezone Bias) 
; 
;Remarks:  
; 
; This function returns the time difference from Greenwich Mean Time (GMT) adjusted For 
; Daylight Savings Time. For example, if you are in the Eastern Time Zone (GMT-05:00) and 
; Daylight Savings is in effect the function will return "-4". 
; 
; When returning the Active Timezone Bias, the value is the current time difference from  
; Greenwich Mean Time (GMT) in minutes and is the difference for GMT. For example, if  
; you are in the Eastern Time Zone with Daylight Savings in effect, the difference in  
; minutes is 240. 
; 
;Returns: 
; 
; The current active timezone, or the current active timezone bias. 
; 
;Dependencies: 
;  
;  
;Example: 
; 
; ; == Return the Active Timezone =================================  
; $Timezone = fnActiveTimeZone() 
;  
; ; == Return the Active Timezone Bias ============================  
; $TimzoneBias = fnActiveTimeZone(1) 
;  
;  
Function fnActiveTimeZone(Optional $Bias)
   $fnActiveTimeZone = Val(ReadValue("HKLM\System\CurrentControlSet\Control\TimeZoneInformation\","ActiveTimeBias"))
   If @ERROR Exit @ERROR EndIf
   $fnActiveTimeZone = Iif($Bias,$fnActiveTimeZone,$fnActiveTimeZone / 60 * -1)
EndFunction 
83661fnAllSpecialFolders953Chris S.fnAllSpecialFolders() - Dynamically set 
variables to the path of all Special Folders0

code:

;
;Function:
;		fnAllSpecialFolders()
;
;Author:
;		Christopher Shilt (christopher.shilt@relizon.com)
;
;Contributors:
;		Radimus
;
;Version:
;		1.1
;
;Version History:
;		13 November 2002 Version 1.0	: Original Version
;		13 November 2002 Version 1.1	: Declares all variables
;
;Action:
;		Dynamically sets variables with the path of all available Windows
;		special folders.
;
;Syntax:
;		fnAllSpecialFolders()
;
;Parameters:
;
;Remarks:
;		This function retrieves paths to special folders using the 
;		special folder name as the index. A special folder's path 
;		depends on the user environment. The information stored in 
;		a special folder is unique to the user logged onto the computer 
;		system. If several different users have accounts on the same 
;		computer system, several different sets of special folders 
;		are stored on the hard disk. If the special folder does not exist
;		(e.g. AllUsersPrograms on a Windows 95 computer), then the 
;		resulting string will be empty.
;
;		The following strings will be created: 
;
;		$AllUsersDesktop 
;		$AllUsersStartMenu 
;		$AllUsersPrograms 
;		$AllUsersStartup
;		$AppData 
;		$Desktop 
;		$Favorites 
;		$Fonts 
;		$MyDocuments 
;		$NetHood 
;		$PrintHood 
;		$Programs 
;		$Recent 
;		$SendTo 
;		$StartMenu 
;		$Startup 
;		$Templates 
;
;Returns:
;		Path to special folder item
;		@ERROR = 0	: Operation Completed Successfully
;		@ERROR = 1	: Unable to instantiate WScript.Shell object
; 
;Dependencies:
;		KiX 4.02 (or higher)
;		Windows Scripting Host (WSH) 1.0 (or higher)
; 
;Example:
;		fnAllSpecialFolders()
;
;		$AllUsersDesktop ?
;		$AllUsersStartMenu ?
;		$AllUsersPrograms ?
;		$AllUsersStartup ?
;		$AppData ?
;		$Desktop ?
;		$Favorites ?
;		$Fonts ?
;		$MyDocuments ?
;		$NetHood ?
;		$PrintHood ?
;		$Programs ?
;		$Recent ?
;		$SendTo ?
;		$StartMenu ?
;		$Startup ?
;		$Templates ?
;
;Example Returns:
;		C:\Documents and Settings\All Users\Desktop
;		C:\Documents and Settings\All Users\Start Menu
;		C:\Documents and Settings\All Users\Start Menu\Programs
;		C:\Documents and Settings\All Users\Start Menu\Programs\Startup
;		C:\Documents and Settings\Chris\Application Data
;		C:\Documents and Settings\Chris\Desktop
;		C:\Documents and Settings\Chris\Favorites
;		C:\WINDOWS\Fonts
;		C:\Documents and Settings\Chris\My Documents
;		C:\Documents and Settings\Chris\NetHood
;		C:\Documents and Settings\Chris\PrintHood
;		C:\Documents and Settings\Chris\Start Menu\Programs
;		C:\Documents and Settings\Chris\Recent
;		C:\Documents and Settings\Chris\SendTo
;		C:\Documents and Settings\Chris\Start Menu
;		C:\Documents and Settings\Chris\Start Menu\Programs\Startup
;		C:\Documents and Settings\Chris\Templates
;
;Source:
;
 
Function fnAllSpecialFolders()
	Dim $sAllFolders, $objWshShell, $Folder, $nul
	Global $AllUsersDesktop, $AllUsersStartMenu, $AllUsersPrograms, $AllUsersStartup, 
		$AppData, $Desktop, $Favorites, $Fonts, $MyDocuments, $NetHood, $PrintHood,
		$Programs, $Recent, $SendTo, $StartMenu, $Startup, $Templates
	$sAllFolders="AllUsersDesktop AllUsersStartMenu AllUsersPrograms AllUsersStartup "+
		"AppData Desktop Favorites Fonts MyDocuments NetHood PrintHood Programs Recent "+
		"SendTo StartMenu Startup Templates"
	$objWshShell = CreateObject("WScript.Shell")
	If @ERROR Exit(1) EndIf
	For Each $Folder in Split($sAllFolders)
		$nul=Execute("$"+$Folder+" = $$objWshShell.SpecialFolders($$Folder)")
	Next
	$objWshShell='' Exit(0)
EndFunction



[ 14. November 2002, 03:11: Message edited by: Chris S. ]161084fnArrcopy9247BjörnfnArrcopy() 
- Copies file/files to destination/destinations.1146729258Due to a bit to 
early posting (and not really following the rules for a udf), use at your on 
risk, and be aware of flaws that exists (you can read more about those further 
down in this thread). This is work in progress.
Code:


;
;Function	fnArrcopy()
;
;Author		Björn Nilsson (nilsson.bjorn@home.se)
;
;Contributors	Only based on the COPY-command (that I know of), Thanks goes out to all of the Korg-collective ;)
;
;Action		Copies file/files to destination/destinations.
;
;Syntax		fnArrcopy($sourcepath,optional $array,$destination,$mode,optional $errorcheck))
;
;Version	1.01
;
;Date           2006-04-24 (YYYY-MM-DD)
;
;Date Revised   2006-04-27
;
;Parameters 	
;				$sourcepath = "d:\temp" ; full path to where the source-files are located. Leave out the last "\" !
;				$array = "adbrowser.kix,ad_browser.kix" ; files to be copied. if mode all / all-destarray is used, this is not used.)
;				$destination = "c:,d:"  ;if multiple destinations, all-destarray / array-destarray mode must be used. Leave out the last "\" !
;				$mode = "array-destarray" ;(all,array, all-destarray, array-destarray) 
;				all > *.* from sourcepath to destination. 
;				array > array of files fom sourcepath to destination
;				all-destarray > *.* from sourcepath to multiple destinations
;				array-destarray > array of files from sourcepath to multiple destinations
;				$errorcheck = "yes" ;yes or no/blank. 
;				Checks sourcepath for specified file/files, checks filesize before and after copy.
;				Mode all does not (right now) support errorcheck. 
;
;Remarks	Need to add errorchecking for "all-mode". No other issues detected.
;			Plan to support an array of sourcepaths. Tested with NoVarsInStrings On and Off, 
;			no problems detected. Also Explicit is set to on. All improvements and suggestions are welcome!		
;
;Returns	none.
; 
;Dependencies 	None
;
;KiXtart Ver	4.51
; 
;Example(s):
;SetOption('Explicit','on')
;SetOption('NoVarsInStrings','on')
;Break on

;fnArrcopy("d:\temp","adbrowser.kix,ad_browser.kix","c:,d;","array-destarray")
	
Function fnArrcopy($sourcepath,optional $array,$destination,$mode,optional $errorcheck)
dim $ray,$dest,$destarr,$file,$filesize1,$filesize2

select

	case $mode = "all"
		COPY "$sourcepath\*.*" "$destination\*.*"
			
	case $mode = "array"
		
		$ray = split($array,",")
		
		if $errorcheck = "yes"
			
			for each $file in $ray
			$filesize1 = "0"
			$filesize2 = "0"
			if exist("$sourcepath\$file")
			 	$filesize1=GETFILESIZE("$sourcepath\$file") 
					
				COPY "$sourcepath\$file" "$destination\$file"
				if NOT exist("$destination\$file") exit 1 endif
				$filesize2=GETFILESIZE("$destination\$file") 
				if NOT $filesize1 = $filesize2 exit 1 endif
			else 
			exit 1
			endif
			next
		else	
			for each $file in $ray
							
			COPY "$sourcepath\$file" "$destination\$file"
			
			next
		endif
		
	case $mode = "all-array"
		$destarr = split($destination,",")
		for each $dest in $destarr
		COPY "$sourcepath\*.*" "$destination\*.*"
		next
	
	case $mode = "array-destarray"
	
		$ray = split($array,",")
		$destarr = split($destination,",")
		
		if $errorcheck = "yes"
		for each $dest in $destarr	
			for each $file in $ray
			$filesize1 = "0"
			$filesize2 = "0"
			if exist("$sourcepath\$file")
			 	$filesize1=GETFILESIZE("$sourcepath\$file") 
				exit 1
	
				COPY "$sourcepath\$file" "$dest\$file"
				if NOT exist("$dest\$file") exit 1 endif
				$filesize2=GETFILESIZE("$dest\$file") 
				if NOT $filesize1 = $filesize2 exit 1 endif
			else 
exit 1
			endif
			next
		next
		
		else
		for each $dest in $destarr	
			for each $file in $ray
				
				COPY "$sourcepath\$file" "$dest\$file"
			next	
		next
		
		endif
		
	case 1
	exit 1

endselect

endfunction

return

83912fnCOMErr953Chris S.fnCOMErr() - Converts COM error codes into Win32 
API error codes0


;
;Function:
; fnCOMErr()
;
;Authors:
; Howard A. Bullock (hbullock@tycoelectronics.com) 
; Christopher Shilt (christopher.shilt@relizon.com)
;
;Version:
; 1.0
;
;Version History:
;
;
;Action:
; Converts COM error codes into Win32 API error codes.
;
;Syntax:
; fnCOMErr(ERROR CODE)
;
;Parameters:
; ERROR CODE : Required Parameter. Error code of the COM error to translate.
;
;Remarks:
; Related FAQ: Error Code Look up.. 
;
;Returns:
; Sets @ERROR to the translated Win32 API error code.
; 
;Dependencies:
; KiX 4.02 (or higher)
; 
;Example:
;
; $objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2")
; $colProcessList = $objWMIService.ExecQuery
; ("Select * from Win32_Process Where Name = 'Explorer.exe'")
; For Each $objProcess in $colProcessList
; $objProcess.Not_A_Method()
; fnCOMErr(@ERROR)
; @ERROR " : " @SERROR ?
; Next
;
; $objSigner=CreateObject("Scripting.Signer")
; $objSigner.SignFile("C:\Scripts\Non_Existant_Script.kix","Yogi Bear")
; fnCOMErr(@ERROR)
; @ERROR " : " @SERROR ?
;
;Source:
;
Function fnCOMErr($lErr)
If $lErr<0 $lErr=VAL("&"+Right(DecToHex($lErr),4)) EndIf
Exit $lErr
Endfunction



[ 21. March 2003, 17:42: Message edited by: Chris S. ]119581fnCompress953Chris 
S.fnCompress() - Sets the NTFS Compression Flag0Code:


;
;Function:
; fnCompress()
;
;Author:
; Christopher Shilt (christopher.shilt@relizon.com)
;
;Version:
; 1.0 (May 10, 2004)
;
;Version History:
;
;Action:
; Uses WMI to set the NTFS Compression flag (Compress/Uncompress).
;
;Syntax:
; fnCompress(TARGET, Optional UNCOMPRESS, Optional COMPUTER)
;
;Parameters:
; TARGET       : Required. Target file or directory.
;
; UNCOMPRESS   : Optional. Switch used to uncompress a compressed NTFS file/directory.
;
; COMPUTER     : Optional. Local or Remote WMI enabled target computer.
;
;Remarks: 
;

;Returns:
;
;    Compress/Uncompress Method Return Value Table:
;
;         Return Code             Description 
;         -----------             ------------------------------
;         0                       Success 
;         2                       Access denied
;         8                       Unspecified failure
;         9                       Invalid object
;        10                       Object already exists
;        11                       File system not NTFS
;        12                       Invalid Operating System
;        13                       Drive not the same
;        14                       Directory not empty
;        15                       Sharing violation
;        16                       Invalid start file
;        17                       Privilege not held
;        21                       Invalid parameter
;
; Sets the value of @ERROR based on success/failure.
;        
;         Return Code             Description 
;         -----------             ------------------------------
;         0                       Success 
;         1                       See the Return Value Table above
;         2                       System cannot file the file/directory
;         ?                       Unspecified error creating WMI object
;
;Dependencies:
; WMI Enabled target computer.
; 
;Example:
;
; ; == Compress a local file =============
; $rc = fnCompress("C:\temp\status.log")
; @ERROR " | " @SERROR ?
;
; ; == Compress a local directory ========
; $rc = fnCompress("C:\temp")
; @ERROR " | " @SERROR ?
;
; ; == Uncompress a local file ===========
; $rc = fnCompress("C:\temp\status.log",1)
; @ERROR " | " @SERROR ?
;
; ; == Uncompress a remote directory =====
; $rc = fnCompress("C:\temp",1,"MyTestPC")
; @ERROR " | " @SERROR ?
;
;
Function fnCompress($sTarget,Optional $bUncompress,Optional $sComputer)
   Dim $objWMI,$colTarget
   $sTarget = Join(Split($sTarget,"\"),"\\")
   If Not $sComputer $sComputer=@WKSTA EndIf
   $objWMI = GetObject("winmgmts:{impersonationLevel=impersonate}!\\" + $sComputer + "\root\cimv2")
   If @ERROR<0 Exit VAL("&"+Right(DecToHex(@ERROR),4)) EndIf
   $colTarget = $objWMI.ExecQuery("Select * from CIM_Logicalfile where name = '" + $sTarget + "'")
   If $colTarget.Count = 0 Exit(2) EndIf
   For Each $sTarget in $colTarget
      If $bUncompress
         $fnCompress = $sTarget.Uncompress
      Else
         $fnCompress = $sTarget.Compress
      EndIf
   Next
   If $fnCompress > 0 Exit(1) EndIf
EndFunction

145850fnDateTime953Chris S.fnDateTime() - Formats/Converts Date/Time Values0; 
;Function: 
; fnDateTime() 
; 
;Author: 
; Christopher Shilt (christopher.shilt@relizon.com) 
; 
;Version: 
; 1.0 (Aug 17, 2005) 
; 
;Version History: 
; 
;Action: 
; Given a valid date and/or time, returns KiXtart formated date and/or time. 
; Optionally, it will return date and/or time in localized, WMI, or FILETIME format. 
; 
;Syntax: 
; fnInteger8Date(DATE, Optional RETURNTYPE) 
; 
;Parameters: 
; DATE         : Required. Any valid date and/or time. 
; 
; RETURNTYPE   : Optional. If specified, the function will return date and/or 
;                time in KiXtart (default), localized, WMI DATETIME, or FILETIME  
;                (seconds since 1601/01/01) format. 
; 
;                RETURNTYPE = 0 (KiXtart format) 
;                RETURNTYPE = 1 (Local Date/Time format) 
;                RETURNTYPE = 2 (WMI DATETIME format) 
;                RETURNTYPE = 3 (FILETIME format - e.g. seconds since 1601/01/01) 
; 
;Remarks:  
; 
; This function will not return a date AND time if the date specified is 1899/12/30. 
; Instead, the function will return only the time. This seems to be a limitation of 
; the object. 
; 
; Another limitation is that if a date AND time is specified and the time is 00:00:00 
; (e.g. 12:00:00 AM), only the date will be returned. 
; 
;Returns: 
; 
; A date and/or time in the specified format. 
; 
; Sets the value of @ERROR based on success/failure. 
;         
;Dependencies: 
; WMI, Microsoft Windows XP 
;  
;Example: 
; 
; ; == Display various date/time examples ==========================  
; For $ = 0 to 3 
;    fnDateTime("4/20/66",$) ? 
;    fnDateTime("April 20, 1966",$) ? 
;    fnDateTime("20-Apr-05 12:00 am",$) ? 
;    fnDateTime("April 2005 6:00 pm",$) ? 
;    fnDateTime("00:00:00",$) ? 
;    fnDateTime("1899/12/30 08:31:00",$) ? 
;    fnDateTime("January 1, 1601",$) ? 
;    fnDateTime("January 1, 1970",$) ?? 
; Next 
; 
;  
Function fnDateTime($sDate,Optional $lReturnType)
   Dim $objDateTime
   $objDateTime = CreateObject("WbemScripting.SWbemDateTime")
   If @ERROR Exit @ERROR EndIf
   $objDateTime.SetVarDate($sDate)
   If @ERROR Exit @ERROR EndIf
   Select
   Case $lReturnType = 0
      $fnDateTime = $objDateTime.Value
      Select
      Case Left($fnDateTime,8)="18991230"
         $fnDateTime = Substr($fnDateTime,9,2)+':'+Substr($fnDateTime,11,2)+':'+Substr($fnDateTime,13,2)
      Case InStr($objDateTime.GetVarDate,':')
         $fnDateTime = Left($fnDateTime,4)+'/'+Substr($fnDateTime,5,2)+'/'+Substr($fnDateTime,7,2)+' '+
            Substr($fnDateTime,9,2)+':'+Substr($fnDateTime,11,2)+':'+Substr($fnDateTime,13,2)
      Case 1
         $fnDateTime = Substr($fnDateTime,1,4)+'/'+Substr($fnDateTime,5,2)+'/'+Substr($fnDateTime,7,2)
      EndSelect
   Case $lReturnType = 1
      $fnDateTime = $objDateTime.GetVarDate
   Case $lReturnType = 2
      $fnDateTime = $objDateTime.Value
   Case $lReturnType = 3
      $fnDateTime = $objDateTime.GetFileTime
   Case 1
      Exit 87
   EndSelect
EndFunction 
84604fnFileCreationMon953Chris S.fnFileCreationMon() - Uses WMI to return 
the filename of new file in target folder0


;
;Function:
; fnFileCreationMon()
;
;Author:
; Christopher Shilt (christopher.shilt@relizon.com)
;
;Version:
; 1.0
;
;Version History:
;
;
;Action:
; Uses the InstanceCreationEvent provider in WMI to pause script execution until
; a new file is detected in the target directory. Returns the new file's path and name .
;
;Syntax:
; fnFileCreationMon(FOLDER, Optional COMPUTER, Optional WITHIN)
;
;Parameters:
; FOLDER : Required Parameter. Path to Folder or Drive.
; COMPUTER : Optional Parameter. Target computer.
; WITHIN : Optional Parameter. Must be a positive integer. Frequency (in seconds) for
; the provider to check for a new file event.
;
;Remarks:
; Folder cannot use an UNC path. A drive letter should be used instead.
;
;Returns:
; Path and filename of new file.
; 
;Dependencies:
; WMI
; 
;Example:
;
; $sFile = fnFileCreationMon("E:\",,10)
; @ERROR " | " @SERROR ?
; $sFile ?
;
;Source:
;
Function fnFileCreationMon($sFolder, Optional $sComputer, Optional $lWithin)
If Not Exist($sFolder) Exit(3) EndIf
If Not $sComputer $sComputer = "." EndIf
If Not $lWithin $lWithin = 10 EndIf
If $lWithin < 0 Exit(1) EndIf

Dim $objWMI,$colMonEvents,$objEvent

$sFolder = Join(Split($sFolder,"\"),"\\\\")

$objWMI = GetObject("winmgmts:{impersonationLevel=impersonate}!\\" + $sComputer + "\root\cimv2")
If @ERROR<0 Exit VAL("&"+Right(DecToHex(@ERROR),4)) EndIf

$colMonEvents = $objWMI.ExecNotificationQuery ("SELECT * FROM __InstanceCreationEvent " +
"WITHIN " + $lWithin + " WHERE Targetinstance ISA 'CIM_DirectoryContainsFile' and " + 
"TargetInstance.GroupComponent='Win32_Directory.Name=" + '"' + $sFolder + '"' + "'")
If @ERROR<0 Exit VAL("&"+Right(DecToHex(@ERROR),4)) EndIf

$objEvent = $colMonEvents.NextEvent
$fnFileCreationMon = Join(Split(Split($objEvent.TargetInstance.PartComponent,'"')[1],"\\"),"\")
EndFunction



[ 08. October 2003, 16:32: Message edited by: Chris S. ]84255fnGetFileProp953Chris 
S.fnGetFileProp() - Uses FSO to retrieve file properties.0


;
;Function:
; fnGetFileProp()
;
;Authors:
; Christopher Shilt (christopher.shilt@relizon.com)
;
;Version:
; 1.0
;
;Version History:
;
;
;Action:
; Uses the File System Object to retrieve file properties.
;
;Syntax:
; fnGetFileProp(FILE, PROPERTY)
;
;Parameters:
; FILE : Required Parameter. Path to File.
; PROPERTY : Required Parameter. See Remarks for available properties.
;
;Remarks:
; Attributes : Returns the attributes of the file.
; DateCreated : Returns the date and time that the specified file was created. 
; DateLastAccessed : Returns the date and time that the specified file was last accessed. < /font>
; DateLastModified : Returns the date and time that the specified file was last modified. 
; Drive : Returns the drive letter of the drive on which the specified file resides.
; Name : Returns the name of a specified file.
; ParentFolder : Returns the folder object for the parent of the specified folder.
; Path : Returns the path for a specified file
; ShortName : Returns the short name used by programs that require the earlier 8.3 naming
; convention.
; ShortPath : Returns the short path used by programs that require the earlier 8.3 naming
; convention.
; Size : Returns the size, in bytes, of the specified file.
; Type : Returns information about the type of a folder.
;
;Returns:
; Property specified.
; 
;Dependencies:
; KiX 4.02 (or higher), File System Object (FSO)
; 
;Example:
;
; $sFile = "E:\KIX32.exe"
; 
; fnGetFileProp($sFile,Attributes) ?
; fnGetFileProp($sFile,DateCreated) ?
; fnGetFileProp($sFile,DateLastAccessed) ?
; fnGetFileProp($sFile,DateLastModified) ?
; fnGetFileProp($sFile,Drive) ?
; fnGetFileProp($sFile,Name) ?
; fnGetFileProp($sFile,ParentFolder) ?
; fnGetFileProp($sFile,Path) ?
; fnGetFileProp($sFile,ShortName) ?
; fnGetFileProp($sFile,ShortPath) ?
; FormatNumber(fnGetFileProp($sFile,Size),0) ?
; fnGetFileProp($sFile,Type) ?
; 
;Source:
;
Function fnGetFileProp($sFile,$sProp)
Dim $objFSO, $objFile, $nul
$objFSO = CreateObject("Scripting.FileSystemObject")
If Not VarType($objFSO)=9 Exit 1 EndIf
$objFile = $objFSO.GetFile($sFile)
If Not VarType($objFile)=9 Exit 2 EndIf
$nul=Execute("$$fnGetFileProp = $$objFile."+$sProp)
If VarType($fnGetFileProp)=0 Exit 87 EndIf
EndFunction



[ 14. May 2003, 19:19: Message edited by: Chris S. ]84249fnGetFolderProp953Chris 
S.fnGetFolderProp() - Uses FSO to retrieve folder properties.0


;
;Function:
; fnGetFolderProp()
;
;Authors:
; Christopher Shilt (christopher.shilt@relizon.com)
;
;Version:
; 1.0
;
;Version History:
;
;
;Action:
; Uses the File System Object to retrieve folder properties.
;
;Syntax:
; fnGetFolderProp(FOLDER, PROPERTY)
;
;Parameters:
; FOLDER : Required Parameter. Path to Folder or Drive.
; PROPERTY : Required Parameter. See Remarks for available properties.
;
;Remarks:
; Attributes : Returns the attributes of folders.
; DateCreated : Returns the date and time that the specified folder was created. 
; DateLastAccessed : Returns the date and time that the specified folder was last accessed. ;
; DateLastModified : Returns the date and time that the specified folder was last modified.
; Drive : Returns the drive letter of the drive on which the specified folder resides.
; Files : Returns a Files collection consisting of all File objects contained in the
; specified folder, including those with hidden and system file attributes set.
; IsRootFolder : Returns True if the specified folder is the root folder; False if it is not.
; Name : Returns the name of a specified folder.
; ParentFolder : Returns the folder object for the parent of the specified folder.
; Path : Returns the path for a specified folder, or drive.
; ShortName : Returns the short name used by programs that require the earlier 8.3 naming
; convention.
; ShortPath : Returns the short path used by programs that require the earlier 8.3 naming
; convention.
; Size : Returns the size, in bytes, of all files and subfolders contained in the folder.
; SubFolders : Returns a Folders collection consisting of all folders contained in a specified
; folder, including those with hidden and system file attributes set.
; Type : Returns information about the type of a folder.
;
;Returns:
; Property specified.
; 
;Dependencies:
; KiX 4.02 (or higher), File System Object (FSO)
; 
;Example:
;
; $sFolder = "%USERPROFILE%"
;
; fnGetFolderProp($sFolder,Attributes) ?
; fnGetFolderProp($sFolder,DateCreated) ?
; fnGetFolderProp($sFolder,DateLastAccessed) ?
; fnGetFolderProp($sFolder,DateLastModified) ?
; fnGetFolderProp($sFolder,Drive) ?
; fnGetFolderProp($sFolder,IsRootFolder) ?
; fnGetFolderProp($sFolder,Name) ?
; fnGetFolderProp($sFolder,ParentFolder) ?
; fnGetFolderProp($sFolder,Path) ?
; fnGetFolderProp($sFolder,ShortName) ?
; fnGetFolderProp($sFolder,ShortPath) ?
; FormatNumber(fnGetFolderProp($sFolder,Size),0) ?
; fnGetFolderProp($sFolder,Type) ?
; 
; $aFiles = fnGetFolderProp($sFolder,Files)
; "Files:" ?
; For Each $sFile in $aFiles
; " " $sFile ?
; Next
;
;Source:
;
Function fnGetFolderProp($sFldr,$sProp)
Dim $objFSO, $objFldr, $nul
$objFSO = CreateObject("Scripting.FileSystemObject")
If Not VarType($objFSO)=9 Exit 1 EndIf
$objFldr = $objFSO.GetFolder($sFldr)
If Not VarType($objFldr)=9 Exit 3 EndIf
$nul=Execute("$$fnGetFolderProp = $$objFldr."+$sProp)
If VarType($fnGetFolderProp)=0 Exit 87 EndIf
EndFunction



[ 14. May 2003, 18:23: Message edited by: Chris S. ]83803fnGetM953Chris S.fnGetM() 
- Get Keystrokes with Optional Mask and Timeout0


;
;Function:
; fnGetM()
;
;Author:
; Christopher Shilt (christopher.shilt@relizon.com)
;
;Version:
; 1.2
;
;Version History:
; 10 February 2003 Version 1.0 : Original Version
; 11 February 2003 Version 1.1 : Added Sleep. Omits Backspace keystrokes.
; 05 March 2003 Version 1.2 : Added Timeout. Handles Backspace keystrokes.
;
;Action:
; Simulates the GetS Command, with optional mask and timeout.
;
;Syntax:
; fnGetM(optional MASK, optional TIMEOUT)
;
;Parameters:
;
;Remarks:
;
;Returns:
; Typed string.
; 
;Dependencies:
; KiX 4.02 (or higher)
; 
;Example:
; "Enter Password: " GetS $pass
; ? $pass
; ?
;
; "Enter Password: " $pass = fnGetM("*",10)
; @ERROR " : " @SERROR
; ? $pass
;
;Example Returns:
; Results of typed string.
;
;Source:
;

Function fnGetM(OPTIONAL $sM,OPTIONAL $lTO)
Dim $X,$lT,$lTC
Do
$lT=@Ticks
Sleep 0.05
If KbHit()
Get $X
If Asc($X)>32
$fnGetM=$fnGetM+$X
If $sM $sM Else $X EndIf
EndIf
If Instr($X,Chr(8)) AND LEN($fnGetM)>0
Chr(8) Chr(32) Chr(8)
$fnGetM=Left($fnGetM,LEN($fnGetM)-1)
EndIf
$lTC=0
Endif
If $lTO
If $lTC < $lTO*1000
$lTC=$lTC+@Ticks-$lT
Else
$fnGetM=""
? Exit 121
EndIf
EndIf
Until Instr($X,Chr(13))
? Exit 0
EndFunction



[ 05. March 2003, 17:50: Message edited by: Chris S. ]83648fnGetSpecialFolder953Chris 
S.fnGetSpecialFolder() - Returns the path of a Windows Special Folder0

code:

;
;Function:
;		fnGetSpecialFolder()
;
;Author:
;		Christopher Shilt (christopher.shilt@relizon.com)
;
;Version:
;		1.1
;
;Version History:
;		12 November 2002 Version 1.0	: Original Version
;		13 November 2002 Version 1.1	: Added check for $sFolder VarType
;
;Action:
;		Returns the path of a Windows special folder.
;
;Syntax:
;		fnGetSpecialFolder($sFolder)
;
;Parameters:
;		$sFolder	: REQUIRED. Special folder to retrieve.
;
;Remarks:
;		This function retrieves paths to special folders using the 
;		special folder name as the index. A special folder's path 
;		depends on the user environment. The information stored in 
;		a special folder is unique to the user logged onto the computer 
;		system. If several different users have accounts on the same 
;		computer system, several different sets of special folders 
;		are stored on the hard disk.
;
;		The following special folders are available: 
;
;		AllUsersDesktop 
;		AllUsersStartMenu 
;		AllUsersPrograms 
;		AllUsersStartup
;		AppData 
;		Desktop 
;		Favorites 
;		Fonts 
;		MyDocuments 
;		NetHood 
;		PrintHood 
;		Programs 
;		Recent 
;		SendTo 
;		StartMenu 
;		Startup 
;		Templates 
;
;Returns:
;		Path to special folder item
;		@ERROR = 0	: Operation Completed Successfully
;		@ERROR = 1	: Unable to instantiate WScript.Shell object
;		@ERROR = 2	: Requested folder not available
;		@ERROR = 3	: Requested folder not a string
; 
;Dependencies:
;		KiX 4.02 (or higher)
;		Windows Scripting Host (WSH) 1.0 (or higher)
; 
;Example:
;		$sDesktop = fnGetSpecialFolder("Desktop")
;		$sDesktop ?
;
;Example Returns:
;		C:\Documents and Settings\Chris\Desktop
;
;Source:
;
 
Function fnGetSpecialFolder($sFolder)
	Dim $objWshShell, $sFolder
	If Not VarType($sFolder)=8 Exit(3) EndIf
	$objWshShell = CreateObject("WScript.Shell")
	If @ERROR Exit(1) EndIf
	$fnGetSpecialFolder = $objWshShell.SpecialFolders($sFolder)
	If $fnGetSpecialFolder='' $objWshShell='' Exit(2) EndIf
	$objWshShell='' Exit(0)
EndFunction



[ 14. November 2002, 14:23: Message edited by: Chris S. ]145945fnHMMSStoSeconds28BrycefnHMMSStoSeconds() 
- Converts H:MM:SS to Seconds Format1124403553Code:


;Function	fnHMMSStoSeconds()
;
;Author		Bryce http://kix.isorg.com
;
;Action		Turns hh:mm:ss into the number of seconds
;
;Syntax		fnHMMSStoSeconds('hh:mm[:ss]')
;
;Version	1.0
;
;Date           2005.08.18
;
;Parameters 	Time
;		HH = Hours
;		MM = minutes
;		ss = optional seconds.
;
;Remarks	This will turn the time into number of seconds that have
;		passed since midnight.
;
;Returns	Returns a number of seconds of a given time.
; 
;Dependencies 	None
;
;KiXtart Ver	4.22
; 
;Example(s)	$Seconds=fnHMMSStoSeconds(@time)
; 
Function fnHMMSStoSeconds($time)
	$time = Split($time,":")
	Select 
		Case UBound($time)=1
			ReDIM preserve $time[2]
			$time[2]=0
		Case UBound($time)=2
		Case 1
			Exit 1
	EndSelect
	$fnHMMSStoSeconds = (Val($time[0])*3600)+(Val($time[1])*60)+Val($time[2])
EndFunction

144167fnInGroupAD953Chris S.fnInGroupAD() - Determines if a user or 
computer is a member of an AD Group0; 
;Function: 
; fnInGroupAD() 
; 
;Author: 
; Christopher Shilt (christopher.shilt@relizon.com) 
; 
;Version: 
; 1.0 (June 22, 2005) 
; 
;Version History: 
; 
;Action: 
; Determines if a user or computer is a member of an Active Directory Group 
; 
;Syntax: 
; fnInGroupAD(GROUP, Optional MODE) 
; 
;Parameters: 
; WHAT         : Required. Group to test for membership of. 
; 
; MODE         : Optional. Specifies whether to search the group membership For 
;                the current user account or the current computer account. 
;                MODE = 0 (user) 
;                MODE = 1 (computer) 
; 
;Remarks:  
; 
; This function is meant to compliment KiXtart's built-in InGroup function, not 
; replace or mimic it's functionality. The built-in InGroup function cannot test 
; for membership of computer accounts or Universal groups. 
; 
;Returns: 
; 
; 0  The user or computer IS NOT a member of a group with this name  
; 1  The user or computer IS a member of a group with this name 
;         
;Dependencies: 
;  
;  
;Example: 
; 
; ; == Test the functionality of the built-in InGroup =============  
; If InGroup("TestUniversalGroup") 
;     "This will always be false" ? 
; EndIf 
;  
; ; == Test if the current user is a member of a group ============  
; If fnInGroupAD("TestUniversalGroup") 
;     "The user is a member of the TestUniversalGroup" ? 
; EndIf 
;  
; ; == Test if the current computer is a  member of a group ======= 
; If fnInGroupAD("TestUniversalGroup",1) 
;     "The computer is a member of the TestUniversalGroup" ? 
; EndIf 
; 
;  
Function fnInGroupAD($sGroup,Optional $bComputer)
    Dim $objSys,$objTarget,$aMemberOf,$sMemberOf
    $objSys = CreateObject("ADSystemInfo")
    $objTarget = GetObject("LDAP://"+Iif($bComputer,$objSys.ComputerName,$objSys.UserName))
    $aMemberOf = $objTarget.GetEx("memberOf")
    For Each $sMemberOf in $aMemberOf
        If InStr($sMemberOf,"CN="+$sGroup+",")
            $fnInGroupAD = Not 0 
            Exit
        EndIf
    Next
    $fnInGroupAD = NOT 1
EndFunction 
145863fnInteger8Date953Chris S.fnInteger8Date() - Returns the DATETIME of 
an Integer8 date object0; 
;Function: 
; fnInteger8Date() 
; 
;Author: 
; Christopher Shilt (christopher.shilt@relizon.com) 
; 
;Contributors: 
; Richard Mueller (HilltopLab@RLMueller.Net) 
; Jochen Polster (jochen.polster@gmx.net)  
; Bryce Lindsay (http://kix.isorg.com/) 
; 
;Version: 
; 1.0 (Aug 17, 2005) 
; 
;Version History: 
; 
;Action: 
; Returns the Date/Time of an Integer8 date object in YYYY/MM/DD HH:MM:SS format. 
; 
;Syntax: 
; fnInteger8Date(OBJDATE, Optional BIAS) 
; 
;Parameters: 
; OBJDATE      : Required. Integer8 date object. 
; 
; BIAS         : Optional. Timezone bias to adjust the time returned for the 
;                date object. If not specified, it will use your default active 
;                timezone bias. If BIAS = 0, then it will return the UTC date/ 
;                time. 
; 
;Remarks:  
; 
; Many attributes in Active Directory have a syntax called Integer8. These 64-bit 
; numbers (8 bytes) usually represent time in 100-nanosecond intervals. If the 
; Integer8 attribute is a date, the value represents the number of 100-nanosecond 
; intervals since 12:00 AM January 1, 1601. 
; 
; ADSI automatically employs the IADsLargeInteger interface to deal with these 
; 64-bit numbers. This interface has two property methods, HighPart and LowPart, 
; which break the number up into two 32-bit numbers. The LowPart property method 
; returns values between -2^31 and 2^31 - 1. 
; 
;Returns: 
; 
; A Interger8 Date Object in YYYY/MM/DD HH:MM:SS format. 
; 
; Sets the value of @ERROR based on success/failure. 
;         
;Dependencies: 
; NONE! (Thanks, Bryce!) 
;  
;Example: 
; 
; ; == Display the date/time the user last changed their password ==  
; $objSys = CreateObject("ADSystemInfo") 
; $objUser = GetObject("LDAP://"+$objSys.UserName) 
;   
; "You last set your password on " + fnInteger8Date($objUser.pwdLastSet) + "." ? 
; 
;  
Function fnInteger8Date($objDate,Optional $lngBias) 
   Dim $lngHigh,$lngLow,$lngDate,$Pow,$l,$jdate,$lngYear,$lngMonth,$lngDay,$s,$m,$h
   If Not (VarType($objDate) & 9) Exit 87 EndIf
   If VarType($lngBias)=0
      $lngBias = Val(ReadValue("HKLM\System\CurrentControlSet\Control\TimeZoneInformation\","ActiveTimeBias"))
      If @ERROR Exit @ERROR EndIf
   EndIf
   
   $lngHigh = $objDate.HighPart 
   $lngLow = $objDate.LowPart 
   If $lngLow < 0 $lngHigh=$lngHigh+1 EndIf
   If $lngHigh = 0 And $lngLow = 0 $lngBias=0 EndIf
   $Pow=2.0
   For $l = 1 to 31 $Pow=2.0*$Pow Next
   $lngDate = ((CDBL($lngHigh)*$Pow+$lngLow)/600000000-$lngBias)/1440 
   If $lngDate > 0
      $jdate = 584389 + Fix($lngDate)
      $lngYear = (100*(((100*($jdate+306)-25)/3652425)-(((100*($jdate+306)-25)/3652425)/4))+
         (100*($jdate+306)-25))/36525 
      $lngMonth = (5*(((100*($jdate+306)-25)/3652425)-(((100*($jdate+306)-25)/3652425)/4)+
         ($jdate+306)-365*$lngYear-$lngYear/4)+456)/153 
      $lngDay = (((100*($jdate+306)-25)/3652425)-(((100*($jdate+306)-25)/3652425)/4)+
         ($jdate+306)-365*$lngYear-$lngYear/4)-(153*$lngMonth-457)/5 
      If $lngMonth>12 $lngYear=$lngYear+1 $lngMonth=$lngMonth-12 EndIf 
      $lngMonth = Right("0"+$lngMonth,2) 
      $lngDay = Right("0"+$lngDay,2) 
      
      $s = Fix(86400.0 * ($lngDate-Fix($lngDate)))
      $m = $s / 60
      $s = $s mod 60
      $h = $m / 60
      $m = $m mod 60
      $fnInteger8Date=''+$lngYear+'/'+$lngMonth+'/'+$lngDay+' '+$h+':'+Right("0"+$m,2)+':'+Right("0"+$s,2)
   EndIf
EndFunction  
148713fnIsDate953Chris S.fnIsDate() - Validates date/time expressions0; 
;Function: 
; fnIsDate() 
; 
;Author: 
; Christopher Shilt (christopher.shilt@relizon.com) 
; 
;Version: 
; 1.0 (Sep 28, 2005) 
; 
;Version History: 
; 
;Action: 
; Returns a Boolean value indicating whether an expression is a valid KiXtart 
; formatted date and/or time. 
; 
;Syntax: 
; fnIsDate(DATE) 
; 
;Parameters: 
; DATE         : Required. Date and/or time string in YYYY/M/D H:MM[:SS] format. 
; 
;Remarks:  
; 
; fnIsDate returns True (1) if the expression is a date; otherwise, it returns 
; False (0). fnIsDate also verifies that the date/time is valid (e.g. 2005/2/29 
; is not a valid date as 2005 is not a leap year). 
; 
;Returns: 
; 
; 0   :  The date/time is invalid 
; 1   :  The date/time is valid 
; 
; Sets the value of @ERROR based on success/failure. 
;         
;Dependencies: 
; NONE 
;  
;Example: 
; 
; ; Various date/time samples 
; fnIsDate("2005/02/28 23:59:59") ? 
; fnIsDate("2005/02/28 24:00:00") ? 
; fnIsDate("2005/02/29 00:00:00") ? 
; fnIsDate(@DATE) ? 
; fnIsDate(@DATE+' '+@TIME) ? 
; fnIsDate("00:00:00") ? 
; fnIsDate("00:00") ? 
; fnIsDate("24:00:00") ? 
; fnIsDate("12") ? 
;   
; ; Only centuries evenly divisible by 400 are leap year. 
; For $y = 1500 to 2999 Step 4 
;    For $m = 1 to 12 
;       For $d = 28 to 29 
;          If fnIsDate(''+$y+'/'+$m+'/'+$d)=0 
;             ''+$y+'/'+$m+'/'+$d+' is not a valid date!' ? 
;          EndIf 
;       Next 
;    Next 
; Next 
; 
;  
Function fnIsDate($sDate)
   Dim $Date,$Time,$y,$m,$d,$l,$o,$h,$n,$s
   $o=0,3,0,1,0,1,0,0,1,0,1,0
   $sDate=Iif(InStr($sDate,' '),Split($sDate,' '),$sDate)
   If UBound($sDate)>1 Exit 1901 EndIf
   If UBound($sDate)=>0
      Select
      Case InStr($sDate[0],'/') and InStr($sDate[1],':') $Date=$sDate[0] $Time=$sDate[1]
      Case InStr($sDate[0].'/') $Date=$sDate[0]
      Case InStr($sDate[0].':') $Date=$sDate[0]
      Case 1 $fnIsDate=0 Exit 1901
      EndSelect
   Else
      Select
      Case InStr($sDate,'/') $Date=$sDate
      Case InStr($sDate,':') $Time=$sDate
      Case 1 $fnIsDate=0 Exit 1901
      EndSelect
   EndIf
   
   If $Date
      $Date=Split($Date,"/") If UBound($Date)<>2 $fnIsDate=0 Exit 1901 EndIf
      $y=Val($Date[0]) $m=Val($Date[1]) $d=Val($Date[2])
      $l=(Right($y*25,2)='00') and ((Right($y,2)<>'00') or (Right($y*25,4)='0000'))
      If $m<1 or $m>12 $fnIsDate=0 Exit 1901 EndIf
      $Date=Iif(($y=0)+($d<1 or $d+$o[$m-1]+Iif($m=2,-$l,0)>31),1,0)
   EndIf
   If $Time
      $Time=Split($Time,':') If UBound($Time)>2 $fnIsDate=0 Exit 1901 EndIf
      $h=$Time[0] $n=$Time[1] If UBound($Time)=2 $s=$Time[2] EndIf
      $Time=Iif(($h<0 or $h>23)+($n<0 or $n>59)+($s<0 or $s>59),1,0)
   EndIf
   $fnIsDate=Iif($Date+$Time,0,1)
   If $fnIsDate=0 Exit 1901 EndIF
EndFunction 
142043fnLDAPQuery953Chris S.fnLDAPQuery() - Uses ADO to query Active 
Directory using LDAP dialect0; 
;Function: 
; fnLDAPQuery() 
; 
;Author: 
; Christopher Shilt (christopher.shilt@relizon.com) 
; 
;Contributors: 
; Christophe Melin (christophe.melin@cus-strasbourg.net)  
; Jens Meyer (sealeopard@usa.net) 
; 
;Version: 
; 1.0 (June 20, 2005) 
; 
;Version History: 
; 
;Action: 
; Uses ADODB to retrieve information from Active Directory. 
; 
;Syntax: 
; fnLDAPQuery(WHAT, Optional FROM, Optional FILTER, Optional ORDER BY, 
;              Optional SCOPE, Optional USER, Optional PASSWORD) 
; 
;Parameters: 
; WHAT         : Required. Attribute (or array of attributes) to retrieve. 
; 
; FROM         : Optional. Specifies the ADsPath of the base of the search. 
;                For example, the ADsPath of the Users container in an Active 
;                Directory domain might be 'LDAP://CN=Users,DC=Fabrikam,DC=COM'. 
; 
; FILTER       : Optional. Specifies the query filter. You can also add wildcards 
;                and conditions to an LDAP search filter. The following examples 
;                show substrings that can be used to search the directory. 
; 
;                Get all users: 
;                    "(objectClass=Users)" 
;                Get all users with a common name equal to "bob": 
;                    "(&(objectClass=Users)(cn=bob))" 
;                Get all users with a common name beginning with "bob": 
;                    "(&(objectClass=Users)(cn=bob*))" 
;                Get all users containing "bob" somewhere in the common name: 
;                    "(&(objectClass=Users)(cn=*bob*))" 
;                Get all users with "bob" as the common name and "dull" as the surname: 
;                    "(&(objectClass=Users)(cn=bob)(sn=dull))" 
; 
; ORDER BY     : Optional. An optional statement that generates a server-side 
;                sort. Active Directory supports the sort control, but it can 
;                impact server performance if the results set is large. Active 
;                Directory supports only a single sort key. You can use the 
;                optional ASC and DESC keywords to specify ascending or descending 
;                sort order; the default is ascending. 
; 
;                Order by surname with a ascending sort order: 
;                    "sn" 
;                Order by surname with a descending sort order: 
;                    "sn DESC" 
; 
; SCOPE        : Optional. Specifies the scope of a directory search. 
; 
;                BASE 
;                    Limits the search to the base object. The result contains, 
;                    at most, one object.  
;                ONELEVEL 
;                    Searches one level of the immediate children, excluding 
;                    the base object.  
;                SUBTREE (DEFAULT) 
;                    Searches the whole subtree, including all the children and 
;                    the base object itself. 
; 
; USER         : Optional. Specifies the user to connect to the directory. 
; 
; PASSWORD     : Optional. Specifies the password to connect to the directory. 
; 
;Remarks:  
; 
; See http://msdn.microsoft.com/library/en-us/adschema/adschema/attributes_all.asp 
; for a list of LDAP attributes that may be queried. 
; 
;Returns: 
; 
; A multi-diminsional array of attributes entered in the order specified in the 
; WHAT parameter. 
; 
; Sets the value of @ERROR based on success/failure (Note: A query that returns no 
; data is still considered a successful query). 
;         
;Dependencies: 
;  
;  
;Example: 
; 
; ; == Return the Name and AdsPath of all users ===================  
; $aAttributes = "Name", "AdsPath"  
; $sADsPath = "LDAP://"+GetObject("LDAP://rootDSE").Get("defaultNamingContext")  
; $strFilter = "(&(objectClass=User)(Name=*))"  
;  
; $aResults = fnLDAPQuery($aAttributes,$sADsPath,$strFilter,"Name")  
; @ERROR " | " @SERROR ?  
;  
; For $c = 0 to Ubound($aResults) 
;     For $r = 0 to UBound($aResults,2) 
;         $aResults[$c,$r] ? 
;     Next 
;     ? 
; Next 
;  
; ; == Return the Name, AdsPath and members of all groups =========  
; $aAttributes = "Name", "AdsPath", "member"  
; $sADsPath = "LDAP://"+GetObject("LDAP://rootDSE").Get("defaultNamingContext")  
; $strFilter = "(&(objectClass=group)(Name=*))"  
;  
; $aResults = fnLDAPQuery($aAttributes,$sADsPath,$strFilter)  
; @ERROR " | " @SERROR ?  
;  
; For $c = 0 to Ubound($aResults) 
;     For $r = 0 to UBound($aResults,2) 
;         "=============================" ?  
;         If VarType($aResults[$c,$r])>8192 
;            "  Members:" ? 
;            For Each $rr in $aResults[$c,$r] 
;                "   " $rr ? 
;            Next 
;         Else 
;            $aResults[$c,$r] ? 
;         EndIf            
;     Next 
;     ? 
; Next 
; 
;  
Function fnLDAPQuery($What,Optional $From,Optional $Filter,Optional $OrderBy,Optional $Scope,
    Optional $User,Optional $Pswd)
    
    Dim $oCon,$oCMD,$oRS,$sQ,$aR,$C,$R
    
    $sQ="<"+Iif($From="","LDAP://"+GetObject("LDAP://rootDSE").Get("defaultNamingContext"),
        $From)+">;"+$Filter+";"+Iif(VarType($What)>8192,Join($What,','),$What)+";"+
        Iif($Scope<>"base" AND $Scope<>"onelevel","subtree",$Scope)
    
    $oCon=CreateObject("ADODB.Connection")
    $oCon.Provider="ADsDSOObject"
    $oCon.Properties("Encrypt Password").Value=1
    $oCon.Properties("ADSI Flag").Value=1
    If $User AND $Pswd
        $oCon.Properties("User ID").Value=$User
        $oCon.Properties("Password").Value=$Pswd
    EndIf
    $oCon.Open("Active Directory Provider")
     
    $oCMD=CreateObject("ADODB.Command")
    $oCMD.ActiveConnection=$oCon
    $oCMD.CommandText=$sQ
    $oCMD.Properties("Page Size").Value=1000
    $oCMD.Properties("Timeout").Value=30
    $oCMD.Properties("Cache Results").Value=0
    
    If InStr($OrderBy,"distinguishedName")
        $oRS=CreateObject("ADODB.Recordset")
        $oRS.CursorLocation=3
        $oRS.Sort=$OrderBy
        $oRS.Open($sQ,$oCon,0,1,1)
    Else
        If $OrderBy
            $oCMD.Properties("Sort On").Value=$OrderBy
        EndIf
        $oRS=$oCMD.Execute
    EndIf
    If @ERROR Exit @ERROR EndIf
    If $oRS.BOF AND $oRS.EOF Exit @ERROR EndIf
    
    $aR = $oRS.GetRows()
    Dim $aFR[Ubound($aR,2),Ubound($aR,1)]
    For $R=0 to Ubound($aR,2)
        For $C=0 to Ubound($aR,1)
            $aFR[$R,$C]=$aR[$C,$R]
        Next
    Next
    
    $fnLDAPQuery=$aFR
EndFunction 
84374fnMapped953Chris S.fnMapped() - Uses FSO to determine if a UNC is 
mapped0


;
;Function:
; fnMapped()
;
;Author:
; Christopher Shilt (christopher.shilt@relizon.com)
;
;Version:
; 1.0
;
;Version History:
;
;
;Action:
; Uses the File System Object to determine is a share is mapped to a drive letter.
;
;Syntax:
; fnMapped(UNC)
;
;Parameters:
; UNC : Required Parameter. UNC path to test.
;
;Remarks:
;
;Returns:
; Drive letter of drive mapped to the specified UNC.
; Nothing if the UNC is not mapped.
;
; @ERROR = 1 if FSO is not installed.
; 
;Dependencies:
; KiX 4.02 (or higher), File System Object (FSO)
; 
;Example:
;
; $sShare = "\\server\share"
;
; fnMapped($sShare) ?
; 
; If Not fnMapped($sShare)
; "Do something here..." ?
; EndIf
;
;Source:
;
Function fnMapped($sUNC)
Dim $oDrives,$oDrive
$oDrives = CreateObject("Scripting.FileSystemObject").Drives
If Not VarType($oDrives) & 9 Exit 1 EndIf
For Each $oDrive in $oDrives
If $oDrive.DriveType = 3 AND $sUNC = $oDrive.ShareName
$fnMapped = $oDrive.DriveLetter + ":"
EndIf
Next
EndFunction

120570fnProper953Chris S.fnProper() - Converts a text string to proper case1087908875Code:


;

;Function:

; fnProper()

;

;Author:

; Christopher Shilt (christopher.shilt@relizon.com)

; Jochen Polster (jochen.polster@gmx.net)

;

;Version:

; 1.1 (June 22, 2004) - Updated delimiters

; 1.0 (June 3, 2004)

;

;Version History:

;

;Action:

; Converts a text string to proper case; the first letter in each

; word in uppercase, and all other letters to lowercase.

;

;Syntax:

; fnProper(STRING)

;

;Parameters:

; STRING       : Required. String to convert to proper case.

;

;Remarks: 

;

;Returns:

;

;    String in proper case.

;

;Dependencies:

; None

; 

;Example:

;

; ; == Convert a string to proper case ===

; $Names = "chris shilt", "baba o'reilly", "ronald mcdonald", "barbara novak-block"

;

; For Each $Name in $Names

;    fnProper($Name) ?

; Next

;

Function fnProper($String)

   Dim $i, $Delim

   $Delim = "'", '"', "-", Chr(9), Chr(10), Chr(13)

   For Each $D in $Delim $String = Join(Split($String,$D)," "+$D+" ") Next

   $String = Split($String)

   For $i = 0 to Ubound($String)

      $String[$i] = UCase(Left($String[$i],1)) + LCase(SubStr($String[$i],2))

   Next

   $String = Join($String)

   For Each $D in $Delim $String = Join(Split($String," "+$D+" "),$D) Next

   $fnProper = $String

EndFunction

83794fnRemapDrives953Chris S.fnRemapDrives()0

code:

;
;Function:
;		fnRemapDrives()
;
;Author:
;		Christopher Shilt (christopher.shilt@relizon.com)
;
;Version:
;		1.1
;
;Version History:
;		22 January 2003 Version 1.0	: Original Version
;		23 January 2003 Version 1.1	: Reworked error levels.
;
;Action:
;		Dynamically remaps a user's persistent drive mappings server
;		name with the new server name.
;
;Syntax:
;		fnRemapDrives($sOldServer,$sNewServer)
;
;Parameters:
;		$sOldServer	: REQUIRED. Name of old server to remap.
;		$sNewServer	: REQUIRED. Name of new server to remap.
;
;Remarks:
;
;Returns:
;		@ERROR = 0	: Operation Completed Successfully.
;		@ERROR = ?	: Function failed to remap one or more drives.
; 
;Dependencies:
;		KiX 4.02 (or higher)
; 
;Example:
;		fnRemapDrives("oldserver","newserver")
;
;Example Returns:
;
;Source:
;
Function fnRemapDrives($sOldServer,$sNewServer)
	Dim $lIndex,$sPersist,$sDrive,$sRemotePath,$sSplit,$lS,$sShare,$NUL,$Err
	$lIndex=0
	$sPersist="HKCU\Network\"
	If @INWIN=2 $sPersist=$sPersist+"Persistent\" EndIf
	Do
		$sDrive=EnumKey($sPersist,$lIndex)
		If $sDrive
			$sRemotePath=ReadValue($sPersist+$sDrive,"RemotePath")
			$sSplit=Split($sRemotePath,"\")
			If $sSplit[2]=$sOldServer
				$lS=Len($sRemotePath)-Len($sOldServer)-2
				$sShare=Right($sRemotePath,$lS)
				$NUL=WriteValue($sPersist+$sDrive,"RemotePath","\\"+$sNewserver+$sShare,"REG_SZ")
				If @ERROR $Err=@ERROR EndIf
			EndIf
		EndIf
		$lIndex=$lIndex+1
	Until $sDrive=""
	If Not $Err $Err=0 EndIf
	Exit $Err
EndFunction



[ 23. January 2003, 16:59: Message edited by: Chris S. ]84343fnRemapShare953Chris 
S.fnRemapShare() - Remaps a user's persistent drives to a new path0


;
;Function:
; fnRemapShare()
;
;Author:
; Christopher Shilt (christopher.shilt@relizon.com)
;
;Version:
; 1.0
;
;Version History:
; 30 April 2003 Version 1.0 : Original Version
;
;Action:
; Dynamically remaps a user's persistent drive mappings to a new path.
; 
;
;Syntax:
; fnRemapShare($sOldPath,$sNewPath)
;
;Parameters:
; $sOldPath : REQUIRED. Name of old path to remap.
; $sNewPath : REQUIRED. Name of new path to remap.
;
;Remarks:
; Supports deep mapping if the operating system supports deep mapping.
; (i.e. fnRemapShare("\\oldserver\oldshare\OLDsubfldr","\\oldserver\oldshare\NEWsubfldr")
;Returns:
; @ERROR = 0 : Operation Completed Successfully.
; @ERROR = ? : Function failed to remap one or more drives.
; 
;Dependencies:
; KiX 4.02 (or higher)
; 
;Example:
; fnRemapShare("\\oldserver","\\newserver")
; fnRemapShare("\\oldserver\oldshare","\\oldserver\newshare")
; fnRemapShare("\\oldserver\oldshare","\\newserver\newshare")
;
;
;Source:
;
Function fnRemapShare($sOldPath,$sNewPath)
Dim $lIndex,$sOldSplit,$sPersist,$lMatch,$sDrive,$sRemotePath,$sShrSplit,$x,$Err
$lIndex=0
$sOldSplit=Split($sOldPath,"\")
$sPersist="HKCU\Network\"
If @INWIN=2 $sPersist=$sPersist+"Persistent\" EndIf
Do
$lMatch=1
$sDrive=EnumKey($sPersist,$lIndex)
If $sDrive
$sRemotePath=ReadValue($sPersist+$sDrive,"RemotePath")
$sShrSplit=Split($sRemotePath,"\")
For $x = 0 to Ubound($sOldSplit)
If $x > Ubound($sShrSplit)
$lMatch=0
Else
If $sShrSplit[$x]<>$sOldSplit[$x] $lMatch=0 EndIf
EndIf
Next

If $lMatch
Use $sDrive+":" /DELETE /PERSISTENT
If @ERROR
$Err=@ERROR
Else
"Remapping $sDrive: to $sNewPath"+Split($sRemotePath,$sOldPath)[1] ?
Use $sDrive+":" $sNewPath+Split($sRemotePath,$sOldPath)[1] /PERSISTENT
If @ERROR $Err=@ERROR EndIf
EndIf
EndIf
EndIf
$lIndex=$lIndex+1
Until $sDrive=""
Exit $Err
EndFunction



[ 05. June 2003, 15:59: Message edited by: Chris S. ]167578fnRemoteExec119LonkerofnRemoteExec() 
- execute process remotely with credentials0Code:


;Function 
; fnRemoteExec() 
; 
;ACTION 
; Uses WMI to create a process on a remote PC 
; 
;AUTHOR 
; Radimus 
; Christopher Shilt (christopher.shilt@relizon.com) 
; 
;CONTRIBUTORS 
; A whole bunch of us 
; 
;VERSION 
; 2.0 
; 
;DATE CREATED 
; 7/20/2005 
; 
;SYNTAX 
; RemoteExec(COMMAND, Optional COMPUTER, Optional USERNAME, Optional PASSWORD) 
; 
;PARAMETERS 
; COMMAND      : Required. The command to execute on remote PC (check the paths, best bet is  
;                to pust a batch file and exec that) 
; 
; COMPUTER     : Optional. Target PC, if blank defaults to local 
; 
; USER         : Optional. Specifies the user to connect to the remote computer. 
; 
; PASSWORD     : Optional. Specifies the password to connect to the remote computer. 
; 
;RETURNS 
; Returns a value of 0 (zero) if the process was successfully created, and any other number  
; to indicate an error. Some of the possible return values are listed in the following table. 
; 
;     Return Code      Description  
;     -----------      ---------------------- 
;     0                Successful completion  
;     2                Access denied  
;     3                Insufficient privilege  
;     8                Unknown failure  
;     9                Path not found  
;     21               Invalid parameter  
; 
; Sets the value of @ERROR based on success/failure. 
; 
;REMARKS 
; This execs under the remote PC's system context, the user has no interaction with the  
; process and the process has no permission to network resources. local & silent commands only 
; 
;DEPENDENCIES 
; Kix 4.x, WMI, see remarks 
; 
;EXAMPLE 
; $rc = fnRemoteExec('regsvr32 c:\winnt\system32\kixforms.dll /s', $computer) 
; 
; $rc = fnRemoteExec("net send " + @WKSTA + " Test message","SomePC","USER","p@ssw0rd") 
; 
Function fnRemoteExec($sCommand,Optional $sComputer,Optional $sUser,Optional $sPwd)
    Dim $objLocator,$objSvc,$objSet
    $objLocator = CreateObject("WbemScripting.SwbemLocator")
    $objSvc = Iif($sComputer='',$objLocator.ConnectServer(),$objLocator.ConnectServer($sComputer,,$sUser,$sPwd))
    If @ERROR Exit @ERROR EndIf
    $objSet = $objSvc.Get("Win32_Process")
    If @ERROR Exit @ERROR EndIf
    $fnRemoteExec = $objSet.Create($sCommand)
    Exit @ERROR
EndFunction

83642fnSecondsToHMMSS953Chris S.fnSecondsToHMMSS() - Converts Seconds to H:MM:SS 
Format1124398798Code:

;
;Function
; fnSecondsToHMMSS()
;
;Author
; Christopher Shilt (christopher.shilt@relizon.com)
;
;Version
; 1.1 (Aug 18, 2005) - Revised algorithm
; 1.0 (Nov 8, 2002)
; 
;Action
; Converts seconds to H:MM:SS string format.
;
;Syntax
; fnSecondsToHMMSS(SECONDS)
;
;Parameters 
; SECONDS      : REQUIRED. Seconds to convert to H:MM:SS string format.
;
;Remarks
;
;Returns	Seconds converted to H:MM:SS string format and sets error level.
; @ERROR = 0   : Operation Completed Successfully
; @ERROR = 87  : Invalid parameter
; 
;Dependencies
; 
;Example:
; fnSecondsToHMMSS(281329) ?
;
;Returns:
; 78:08:49
;
;Source
Function fnSecondsToHMMSS($s)
   If Not (VarType($s) & 3) Exit 87 EndIf
   Dim $m,$h
   $m = $s / 60
   $s = $s mod 60
   $h = $m / 60
   $m = $m mod 60
   $fnSecondsToHMMSS=''+$h+':'+Right("0"+$m,2)+':'+Right("0"+$s,2)
EndFunction

84407fnSTRIP953Chris S.fnSTRIP() - Concatenate a string, removing the 
specified delimiter0


;
;Function:
; fnSTRIP()
;
;Author:
; Christopher Shilt (christopher.shilt@relizon.com)
;
;Version:
; 1.0
;
;Version History:
;
; 30 June 2003 Version 1.0 - Original Version.
;
;Action:
; Strips the specified delimeter character from a string and returns the concatenated
; string.
;
;Syntax:
; fnSTRIP(STRING, optional DELIMETER)
;
;Parameters:
; STRING : REQUIRED. String value to concatenate.
;
; DELIMETER : OPTIONAL. Delimeter to strip from STRING. CHR(32), (e.g. the space 
; character), is used if not specified.
;
;Remarks:
;
;Returns:
; Concatentated string.
; 
;Dependencies:
; KiX 4.02
; 
;Example:
;
; ; *** Strip all spaces from @IPADDRESS0 ***
; fnSTRIP(@IPADDRESS0) ?
;
; ; *** Remove all double-quotes from a string ***
;
; ; Faked ReadLine() string from a tab-delimited text file exported from an Excel spreadsheet.
; $sReadline = 'Username'+CHR(9)+'"Last, First MI"'
;
; $sReadline ?
;
; fnSTRIP($sReadline,'"') ?
;
;Source
Function fnSTRIP($sString,OPTIONAL $sDelimeter)
If VarType($sString)<>8 Exit(1) EndIf
If Not $sDelimeter $sDelimeter = CHR(32) EndIf
$sString = Split($sString,$sDelimeter)
For Each $sString in $sString
$fnSTRIP=$fnSTRIP+$sString
Next
EndFunction



[ 30. June 2003, 18:12: Message edited by: Chris S. ]83765FnTCPIPPort170Will 
HetrickFnTCPIPPort() - Creates an IP Printer Port0

code:

 

;FUNCTION      FnTCPIPPort()
;
;ACTION        Creates an IP Printer Port on a Windows 2000 Computer
;
;VERSION       1.0
;
;KIXTART VER   4.12
;
;AUTHOR        Wilbur Hetrick
;
;SYNTAX        RETCODE = FnTCPIPPort($IPAddress,Optional $SNMPCommunity)
;
;PARAMETERS    IPAddress
;              The IP Address of the Printer
;
;              SNMPCommunity
;			The SNMP Community name, if no name it defualts to 'PUBLIC'
;
;RETURN        Returns an Event Code as Follows
;               0 = Successful
;               1 = Failed to Write to Registry
;               2 = IP Port Already Exists
;               3 = Missing or Bad IP Address
;
;REMARKS      
;  Must have at least Poweruser Rights to create Port
;  Tested on Windows 2000 machines
;  Currently requires a reboot to show up
;
;DEPENDENCIES  NONE
;
;EXAMPLE       $IP = "10.0.0.1"
;			$Comm = "Public"
;			$X = FnTCPIPPort($IP,$Comm)
;			Select
;				Case $X = 0
;					? "Successful"
;				Case $X = 1
;					? "Error Accessing Registry"
;				Case $X = 2
;					? "Key Already Exists"		
;				Case $x = 3
;					? "Missing or Bad Ipaddress"
;			EndSelect
;			Exit


Function FnTCPIPPort($IPAddress,OPTIONAL $SNMPCommunity)
	
	If $IPAddress = "" $FnTCPIPPort = 3 Exit(1) EndIf
	If $SNMPCommunity = ""	$Snmpcommunity = "Public" EndIf
	$Key = "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Print\Monitors\Standard TCP/IP Port\Ports\"
	$FNTCPIPPort = 1
	$Check = KeyExist($Key + "IP_$IPAddress")
	If $check <> 1
		$RC = AddKey($Key)
		If $RC <> 0
  			$FNTCPIPPort = 1
  			Exit()
		EndIf

		$FnTCPIPPort = 0
		$X = WriteValue($Key + "IP_$IPAddress", "Protocol", "00000001", "REG_DWORD")
		If @error <> 0
			$FnTCPIPPort = 1
		EndIf
		$X = WriteValue($Key + "IP_$IPAddress", "Version", "00000001", "REG_DWORD")
		If @error <> 0
			$FnTCPIPPort = 1
		EndIf
		$X = WriteValue($Key + "IP_$IPAddress", "HostName", "", "REG_SZ")
		If @error <> 0
			$FnTCPIPPort = 1
		EndIf
		$X = WriteValue($Key + "IP_$IPAddress", "IPAddress", "$IPAddress", "REG_SZ")
		If @error <> 0
			$FnTCPIPPort = 1
		EndIf
		$X = WriteValue($Key + "IP_$IPAddress", "HWAddress", "", "REG_SZ")
		If @error <> 0
			$FnTCPIPPort = 1
		EndIf
		$X = WriteValue($Key + "IP_$IPAddress", "PortNumber", "00009100", "REG_DWORD")
		If @error <> 0
			$FnTCPIPPort = 1
		EndIf
		$X = WriteValue($Key + "IP_$IPAddress", "SNMP Community", "public", "REG_SZ")
		If @error <> 0
			$FnTCPIPPort = 1
		EndIf
		$X = WriteValue($Key + "IP_$IPAddress", "SNMP Enabled", "00000001", "REG_DWORD")
		If @error <> 0
			$FnTCPIPPort = 1
		EndIf
		$X = WriteValue($Key + "IP_$IPAddress", "SNMP Index", "00000001", "REG_DWORD")
		If @error <> 0
			$FnTCPIPPort = 1
		EndIf
	Else
		$FNTCPIPPort = 2
	
	EndIf

	Exit	
EndFunction

 

See Also Connecting a Printer to an IP Port with no User intervention

[ 20. December 2002, 20:30: Message edited by: Will Hetrick ]83747fnWMIAuthentication17SealeopardfnWMIAuthentication() 
- Authenticates against a local or remote WMI provider0

code:

;FUNCTION      fnWMIAuthentication()
;
;ACTION        Authenticates against a local or remote WMI provider
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2 (removed console output)
;              1.1
;
;DATE CREATED  2002/12/05
;
;DATE MODIFIED 2003/05/26
;
;KIXTART VER   4.12
;
;SYNTAX        fnWMIAuthentication([$sComputerName, $sUserName, $sPassword, $sNameSpace])
;
;PARAMETERS    $SCOMPUTERNAME
;              Optional string containing the target computers name, defaults to local computer
;
;              $SUSERNAME
;              optional username when connection to a remote system, defaults to current username
;
;              $SPASSWORD
;              optional password when connecting to a remote system, defaults to current password
;
;              $SNAMESPACE
;              optional string containing the namespace to connect to, defaults to root\CIMV2
;
;RETURNS       WBEM object if successful, otherwise error code
;
;REMARKS       none
;
;DEPENDENCIES  WMI
;
;EXAMPLE:      $objWBEM=fnWMIAuthentication('WORKSTATION','username','password','root\CIMV2')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000319
;
function fnWMIAuthentication(optional $sComputerName, optional $sUserName, optional $sPassword, optional $sNameSpace)
  dim $objLocator, $objWBEM

  $sNameSpace=trim($sNameSpace)
  if $sNameSpace=''
    $sNameSpace = 'root\CIMV2'
  endif

  ; check to see whether we're connecting to a local or remote computer
  $sComputerName=trim($sComputerName)
  select
  case $sComputerName=@WKSTA
    $sComputerName='.'
  case $sComputerName
  case 1
    $sComputerName='.'
  endselect

  select
  case $sUserName and $sComputerName<>'.'
    ; create locator object for connection to a remote computer
    $objLocator = CreateObject('WbemScripting.SWbemLocator')
    if @ERROR
      exit @ERROR
    endif

    ; create an credentialed (username/password provided) connection to a remote computer
    $objWBEM=$objLocator.ConnectServer($sComputerName,$sNameSpace,$sUserName,$sPassword)
    if @ERROR
      exit @ERROR
    endif

    ; set the impersonation level
    $objWBEM.Security_.ImpersonationLevel = 3
    if @ERROR
      exit @ERROR
    endif

  case 1
    ;set the impersonation level
    $objWBEM=GetObject('winmgmts:{impersonationLevel=impersonate}!\\'+$sComputerName+'\'+$sNameSpace)
    if @ERROR
      exit @ERROR
    endif
  endselect

  $fnWMIAuthentication=$objWBEM
  exit @ERROR
endfunction



[ 27. May 2003, 01:31: Message edited by: sealeopard ]83811fnWMILoggedIn17SealeopardfnWMILoggedIn() 
- Retrieves users/computers connected to a computer0

code:

;FUNCTION      fnWMILoggedIn()
;
;ACTION        Retrieves users/computers connected to a computer
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2 (changed array redim method)
;              1.1
;
;DATE CREATED  2002/12/05
;
;DATE MODIFIED 2003/05/26
;
;KIXTART       4.20+
;
;SYNTAX        fnWMILoggedIn([$iMode, $sComputerName , $sUsername, $sPassword])
;
;PARAMETERS    $IMODE
;              Optional bit-wise integer denoting which users to retrieve
;              1 - Interactive users
;              2 - All local non-interactive users (service accounts)
;              4 - All remote users connected to local resources
;              8 - All remote computers connected to local resources
;
;              $SCOMPUTERNAME
;              Optional string containing the target computers name, defaults to local computer
;
;              $SUSERNAME
;              optional username when connection to a remote system
;
;              $SPASSWORD
;              optional password when connecting to a remote system
;
;RETURNS       string or array of usernames
;
;REMARKS       If $iMode is omitted only the interactive user is being returned
;
;DEPENDENCIES  WMI, ADSI
;
;EXAMPLE:      $rc=fnWMILoggedIn()
;              $rc=fnWMILoggedIn(3,'workstation')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000337
;
Function fnWMILoggedin(optional $iMode, optional $sComputerName, optional $sUserName, optional $sPassword)
  dim $objLocator, $objWBEM, $sUserNames, $sNameSpace, $sName
  dim $objAdsFso, $objSystem, $sCompName, $objAdsSession

  $fnWMILoggedin=''

  $iMode=val($iMode)

  $sNameSpace = 'root\CIMV2'

  ; check to see whether we're connecting to a local or remote computer
  $sComputerName=trim($sComputerName)
  select
  case $sComputerName=@WKSTA
    $sCompName=$sComputerName
    $sComputerName='.'
  case $sComputerName
    $sCompName=$sComputerName
  case 1
    $sCompName=@WKSTA
    $sComputerName='.'
  endselect

  select
  case $sUserName and $sComputerName<>'.'
    ; create locator object for connection to a remote computer
    $objLocator = CreateObject('WbemScripting.SWbemLocator')
    if @ERROR
      exit @ERROR
    endif
    ; create an credentialed (username/password provided) connection to a remote computer
    $objWBEM=$objLocator.ConnectServer($sComputerName,$sNameSpace,$sUserName,$sPassword)
    if @ERROR
      exit @ERROR
    endif
    ; set the impersonation level
    $objWBEM.Security_.ImpersonationLevel = 3
    if @ERROR
      exit @ERROR
    endif
  case 1
    ;set the impersonation level
    $objWBEM=GetObject('winmgmts:{impersonationLevel=impersonate}!\\'+$sComputerName+'\'+$sNameSpace)
    if @ERROR
      exit @ERROR
    endif
  endselect

  if $iMode=0 or ($iMode & 1)
    $objSystem = $objWBEM.ExecQuery('Select UserName from Win32_ComputerSystem')
    for each $sName in $objSystem
      if $sName.UserName
        redim preserve $sUserNames[ubound($sUserNames)+1]
        $sUserNames[ubound($sUserNames)] = $sName.UserName
      endif
    next
  endif

  if ($iMode & 2)
    $objSystem = $objWBEM.ExecQuery("Select StartName from Win32_Service WHERE State='Running' AND StartName<>'LocalSystem'")
    for each $sName in $objSystem
      redim preserve $sUserNames[ubound($sUserNames)+1]
      if left($sName.StartName,2)='.\'
        if $sCompName
          $sUserNames[ubound($sUserNames)] = ucase($sCompName)+substr($sName.StartName,2)
        else
          $sUserNames[ubound($sUserNames)] = ucase(@WKSTA)+substr($sName.StartName,2)
        endif
      else
        $sUserNames[ubound($sUserNames)] = $sName.StartName
      endif
    next
  endif

  if ($iMode & 4) or ($iMode & 8)
	  $objAdsFSO = GetObject('WinNT://'+$sCompName+'/LanmanServer')
    for each $objAdsSession In $objAdsFSO.Sessions
      $sName=$objAdsSession.User
      select
        case $sName=''
          ; inter-server connection
        case right($sName,1)='$' and ($iMode & 8) and ascan($sUserNames,$sName)=-1
          redim preserve $sUserNames[ubound($sUserNames)+1]
          $sUserNames[ubound($sUserNames)]=ucase(left($sName,len($sName)-1))
        case right($sName,1)<>'$' and ($iMode & 4) and ascan($sUserNames,$sName)=-1
          redim preserve $sUserNames[ubound($sUserNames)+1]
          if not instr($sName,'\')
            $sUserNames[ubound($sUserNames)]=$sCompName+'\'+$sName
          else
            $sUserNames[ubound($sUserNames)]=$sName
          endif
      endselect
    Next
    $objAdsFSO = 0
  endif

  $objWBEM=0
  $objLocator=0

  if ubound($sUserNames)=0
    $sUserNames=$sUserNames[0]
  endif

  $fnWMILoggedin=$sUserNames
  exit @ERROR
EndFunction



[ 27. May 2003, 01:31: Message edited by: sealeopard ]84423fnWMIPagefile17SealeopardfnWMIPagefile() 
- Reads pagefile (usage) info and creates/resizes/deletes pagesfiles0

code:

;FUNCTION      fnWMIPagefile
;
;ACTION        Reads pagefile (usage) info and creates/resizes/deletes pagesfiles
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.0
;
;DATE CREATED  2003/07/02
;
;DATE MODIFIED 2003/07/02
;
;KIXTART       4.21+
;
;SYNTAX        FNWMIPAGEFILE([DRIVE, MINSIZE, MAXSIZE, COMP])
;
;PARAMETERS    DRIVE
;              Optional string containing the driveletter
;
;              MINSIZE
;              Optional integer with the minimum size of the pagefile in MB. If the MINSIZE is set
;              to 0 then the pagefile on DRIVE will be deleted
;
;              MAXSIZE
;              Optional integer with the maximum size of the pagefile in MB. If the parameters is
;              not provided then MAXSIZE will equal MINSIZE. If MAXSIZE is greater than the available
;              space on the drive after creating the pagefile the function will error out safely.
;
;              COMP
;              Optional string denoting a remote computer. Pagefile manipulation on remote computers
;              require the CreatePagefile right.
;
;RETURNS       An 2-dimensional array of pagefile information if no parameter or only the drive letter
;              are provided.
;              0 if successful or an error code if a pagefile is being created/deleted/resized
;
;REMARKS       Not supported under Windows 9x
;
;DEPENDENCIES  WMI
;
;EXAMPLE       ? 'Checking pagefiles before any action'
;              $asPagefiles=fnWMIPageFile()
;              ? 'Error '+@ERROR+' - '+@SERROR
;              for $iRC=0 to ubound($asPagefiles,1)
;                ? 'Name          = ' +$asPagefiles[$iRC,0]
;                ? 'Initial Size  = ' +$asPagefiles[$iRC,1]
;                ? 'Maximum Size  = ' +$asPagefiles[$iRC,2]
;                ? 'Current Usage = ' +$asPagefiles[$iRC,3]
;                ? 'Peak Usage    = ' +$asPagefiles[$iRC,4]
;              next
;              ? 'create a 4095MB pagefile on D:'
;              $asPagefiles=fnWMIPagefile('D:',4095)
;              ? 'Error '+@ERROR+' - '+@SERROR
;              ? 'delete a pagefile on D:'
;              $asPagefiles=fnWMIPagefile('D:',0)
;              ? 'Error '+@ERROR+' - '+@SERROR
;              $asPagefiles=fnWMIPageFile()
;              ? 'Error '+@ERROR+' - '+@SERROR
;              ? 'Checking pagefile on C:'
;              $asPagefiles=fnWMIPagefile('C:')
;              for $iRC=0 to ubound($asPagefiles,1)
;                ? 'Name          = ' +$asPagefiles[$iRC,0]
;                ? 'Initial Size  = ' +$asPagefiles[$iRC,1]
;                ? 'Maximum Size  = ' +$asPagefiles[$iRC,2]
;                ? 'Current Usage = ' +$asPagefiles[$iRC,3]
;                ? 'Peak Usage    = ' +$asPagefiles[$iRC,4]
;              next
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000437
;
function fnWMIPagefile(optional $sDrive, optional $iMinSize, optional $iMaxSize, optional $comp)
  dim $objWMIService, $colPagefileSetting, $colPagefileUsage, $asPagefiles, $objWMIService1
  dim $sWQL, $objPagefileSetting, $iNumPagefiles, $iPagefile, $objPagefileUsage, $asLokupTable

  if $sDrive
    $sDrive=left(trim($sDrive),1)+':'
  else
    $sDrive=''
  endif

  if vartype($iMinSize)
    $iMinSize=val(trim($iMinSize))
    select
    case $iMinSize=0
      $iMaxSize=0
    case $iMinSize>0 and $iMinSize<2
      $iMinSize=2
    endselect
    $iMaxSize=val(trim($iMaxSize))
    if $iMaxSize<$iMinSize
      $iMaxSize=$iMinSize
    endif
  else
    $iMinSize=-1
    $iMaxsize=-1
  endif

  $comp=trim($comp)
  if not $comp
    $comp=@WKSTA
  endif

  ; get the Pagefiles info
  if $iMinSize+1
    ; changing Pagefile settings
    $objWMIService=getobject('winmgmts:{impersonationLevel=impersonate,(CreatePagefile)}!\\'+$comp+'\root\cimv2')
  else
    ; retrieving Pagefile settings
    $objWMIService=getobject('winmgmts:{impersonationLevel=impersonate}!\\'+$comp+'\root\cimv2')
  endif
  if @error exit @error endif

  select
  case $iMinSize = -1
    ; retrieve Pagefile settings
    $sWQL = 'SELECT Name, InitialSize, MaximumSize FROM Win32_PagefileSetting'
    $colPagefileSetting=$objWMIService.ExecQuery($sWQL)
    if $sDrive
      $iNumPagefiles=1
    else
      $iNumPagefiles=$colPagefileSetting.Count
    endif
    if $iNumPagefiles
      redim $asPagefiles[$iNumPagefiles-1,4], $asLookupTable[$iNumPagefiles-1]
      $iPagefile=0
      for each $objPagefileSetting in $colPagefileSetting
        if left($objPagefileSetting.Name,len($sDrive))=$sDrive
          $asLookupTable[$iPagefile]=$objPagefileSetting.Name
          $asPagefiles[$iPagefile,0]=$objPagefileSetting.Name
          $asPagefiles[$iPagefile,1]=$objPagefileSetting.InitialSize
          $asPagefiles[$iPagefile,2]=$objPagefileSetting.MaximumSize
          $iPagefile=$iPagefile+1
        endif
      next

      ;retrieve Pagefile usage
      $sWQL = 'SELECT Name, CurrentUsage, PeakUsage FROM Win32_PagefileUsage'
      $colPagefileUsage=$objWMIService.ExecQuery($sWQL)
      for each $objPagefileUsage in $colPagefileUsage
        $iPagefile=ascan($asLookupTable,$objPagefileUsage.Name)
        if $iPagefile+1
          $asPagefiles[$iPagefile,3]=$objPagefileUsage.CurrentUsage
          $asPagefiles[$iPagefile,4]=$objPagefileUsage.PeakUsage
        endif
      next

      $fnWMIPagefile=$asPagefiles
      exit @ERROR
    else
      $fnWMIPagefile=''
      exit 2
    endif
  case $iMinSize = 0
    if $sDrive=''
      exit 87
    endif
    $colPagefileSetting=$objWMIService.InstancesOf('Win32_PagefileSetting')
    for each $objPagefileSetting in $colPagefileSetting
      if left($objPagefileSetting.Name,len($sDrive))=$sDrive
        if $objPagefileSetting.InitialSize<>$iMinSize or $objPagefileSetting.MaximumSize<>$iMaxSize
          $objPagefileSetting.Delete_
          if @ERROR exit @ERROR endif
        endif
        $fnWMIPagefile=0
        exit 0
      endif
    next
  case $iMinsize
    if $sDrive=''
      exit 87
    endif
    $colPagefileSetting=$objWMIService.InstancesOf('Win32_PagefileSetting')
    for each $objPagefileSetting in $colPagefileSetting
      if left($objPagefileSetting.Name,len($sDrive))=$sDrive
        if $objPagefileSetting.InitialSize<>$iMinSize or $objPagefileSetting.MaximumSize<>$iMaxSize
          $objPagefileSetting.InitialSize=$iMinSize
          if @ERROR exit @ERROR endif
          $objPagefileSetting.MaximumSize=$iMaxSize
          if @ERROR exit @ERROR endif
          $objPagefileSetting.Put_(1)
          ; the following line creates an COM error 'Member not found' even though the actions
          ; seems to be successful. At least the Pagefile will get resized correctly.
          ;if @ERROR exit @ERROR endif
        endif
        $fnWMIPagefile=0
        exit 0
      endif
    next
    $colPagefileSetting = 0
    $objPagefileSetting = 0
    $colPagefileSetting=$objWMIService.Get('Win32_PagefileSetting')
    if @ERROR exit @ERROR endif
    $objPagefileSetting=$colPagefileSetting.SpawnInstance_(0)
    if @ERROR exit @ERROR endif
    $objPagefileSetting.Name=$sDrive+'\Pagefile.sys'
    if @ERROR exit @ERROR endif
    $objPagefileSetting.InitialSize=$iMinSize
    if @ERROR exit @ERROR endif
    $objPagefileSetting.MaximumSize=$iMaxSize
    if @ERROR exit @ERROR endif
    $objPagefileSetting.Put_(0)
    ; the following line creates an COM error 'Member not found' even though the actions
    ; seems to be successful. At least the Pagefile will get resized correctly.
    ;if @ERROR exit @ERROR endif
    $fnWMIPagefile=0
    exit 0
  case 1
    exit 13
  endselect

  $fnWMIPagefile=@ERROR
  exit @ERROR
endfunction



[ 03. July 2003, 02:19: Message edited by: sealeopard ]84031fnWMIService953Chris 
S.fnWMIService() - Use the Win32_Service class of WMI to control services0

Code:

;
;Function:
; fnWMIService()
;
;Author:
; Christopher Shilt (christopher.shilt@relizon.com)
;
;Version:
; 1.1
;
;Version History:
; 2005-07-12   : NoVarsInStrings compliant
;
;Action:
; Uses WMI to execute methods on services.
;
;Syntax:
; fnWMIService(SERVICE NAME, METHOD, Optional COMPUTER)
;
;Parameters:
; SERVICE NAME : Required. Target service name to execute methods against.
;
; METHOD       : Required. See remarks for details.
;
; COMPUTER     : Optional. Local or Remote WMI enabled target computer.
;
;Remarks:
; See WMI SDK on Win32_Service class for complete documentation: 
;     http://msdn.microsoft.com/library/en-us/wmisdk/wmi/win32_service.asp
;
; The following properties may be queried:
;
;    PROPERTIES              DATA TYPE  DESCRIPTION
;    ----------------------  ---------  -----------------------------------------------------------------
;    AcceptPause             [boolean]  Service can be paused.
;    AcceptStop              [boolean]  Service can be stopped.
;    Caption                 [string]   Short description of the objecta one-line string.
;    CheckPoint              [uint32]   Value that the service increments periodically to report its
;                                       progress during a long start, stop, pause, or continue operation.
;                                       This value should be zero when the service does not have a start,
;                                       stop, pause, or continue operation pending. 
;    CreationClassName       [string]   WMI Creation Class Name
;    Description             [string]   Description of the object.
;    DesktopInteract         [boolean]  Service can create or communicate with windows on the desktop.
;    DisplayName             [string]   Display name of the service.
;    ErrorControl            [string]   Severity of the error if this service fails to start during startup.
;    ExitCode                [uint32]   Windows error code defining any problems encountered in starting or
;                                       stopping the service.
;    InstallDate             [datetime] Date object is installed.
;    Name                    [string]   Unique identifier of the service.
;    PathName                [string]   Fully-qualified path to the service binary file that implements the
;                                       service.
;    ProcessId               [uint32]   Process identifier of the service.
;    ServiceSpecificExitCode [uint32]   Service-specific error code for errors that occur while the service 
;                                       is either starting or stopping.
;    ServiceType             [string]   Type of service provided to calling processes.
;    Started                 [boolean]  Service has been started.
;    StartMode               [string]   Start mode of the Windows base service.
;    StartName               [string]   Account name under which a service runs.
;    State                   [string]   Current state of the base service.
;    Status                  [string]   Current status of the object.
;    SystemCreationClassName [string]   Type name of the system that hosts this service.
;    SystemName              [string]   Name of the system that hosts this service.
;    TagId                   [uint32]   Unique tag value for this service in the group.
;    WaitHint                [uint32]   Estimated time required (in milliseconds) for a pending start, stop, 
;                                       pause, or continue operation.
;
; Win32_Service supports the following methods (see table below for return values):
;
;    PROPERTIES              DATA TYPE  DESCRIPTION
;    ----------------------  ---------  -----------------------------------------------------------------
;    StartService            [int]      Starts a service.
;    StopService             [int]      Stops a service.
;    PauseService            [int]      Pauses a service.
;    ResumeService           [int]      Resumes a service.
;    InterrogateService      [int]      Requests that the service update its state to the service manager.
;    DeleteService           [int]      Deletes a service.
;
;    UserControlService()    [int]      Attempts to send a user-defined control code to a service. Accepts 
;                                       the following parameters:
;
;                                       ControlCode  (as integer) Specifies defined values(from 128 to 255)
;                                                                 that provide control commands specific to 
;                                                                 a user.
;
;    ChangeStartMode()       [int]      Modifies the service start mode. Accepts the following parameters:
;
;                                       StartMode (as string) StartMode may be one of the following:
;
;                                          Value      Meaning 
;                                          ---------- ---------------------------------------------------
;                                          Boot       Device driver started by the operating system loader.
;                                                     This value is valid only for driver services. 
;                                          System     Device driver started by the IoInitSystem method. This
;                                                     value is valid only for driver services. 
;                                          Automatic  Service to be started automatically by the service 
;                                                     control manager during system startup. 
;                                          Manual     Service to be started by the service control manager 
;                                                     when a process calls the StartService method. 
;                                          Disabled   Service that can no longer be started. 
;
;    Change()                [int]      Modifies a service. Please see the WMI SDK for documentation:
;                                       http://msdn.microsoft.com/library/en-us/wmisdk/wmi/change_method_in_class_win32_service.asp
;
;    Create()                [int]      Modifies a service. Please see the WMI SDK for documentation:
;                                       http://msdn.microsoft.com/library/en-us/wmisdk/wmi/create_method_in_class_win32_service.asp
;
;    Win32_Service Method Return Value Table:
;
;         Return Code             Description 
;         -----------             ------------------------------
;         0                       Success 
;         1                       Not Supported 
;         2                       Access Denied 
;         3                       Dependent Services Running 
;         4                       Invalid Service Control 
;         5                       Service Cannot Accept Control 
;         6                       Service Not Active 
;         7                       Service Request Timeout 
;         8                       Unknown Failure 
;         9                       Path Not Found 
;         10                      Service Already Running 
;         11                      Service Database Locked 
;         12                      Service Dependency Deleted 
;         13                      Service Dependency Failure 
;         14                      Service Disabled 
;         15                      Service Logon Failure 
;         16                      Service Marked For Deletion 
;         17                      Service No Thread 
;         18                      Status Circular Dependency 
;         19                      Status Duplicate Name 
;         20                      Status Invalid Name 
;         21                      Status Invalid Parameter 
;         22                      Status Invalid Service Account 
;         23                      Status Service Exists 
;         24                      Service Already Paused 
;
;Returns:
; Queries on properties will return a value as indicated above. Method functions will return a return code 
; from the Win32_Service Method Return Value Table.
;
; Note: An error code will only be set if the WMI object is unable to be created.  Use the Return Code on 
;       methods to determine method success/failure.
; 
;Dependencies:
; KiX 4.02 (or higher)
; WMI Enabled target computer.
; 
;Example:
;
; Break On CLS
; 
; $nul=SetOption("WrapAtEOL","On")
; $nul=SetOption("Explicit","On")
; 
; Dim $sSrvc,$sTrgt
; 
; $sSrvc = "Messenger"
; $sTrgt = @WKSTA
; 
; "Service Name: " fnWMIService($sSrvc,"DisplayName",$sTrgt) ?
; If @ERROR
;     @ERROR " | " @SERROR ?
; Else
;     "Service State: " fnWMIService($sSrvc,"State",$sTrgt) ?
;     "Service Status: " fnWMIService($sSrvc,"Status",$sTrgt) ?
;     
;     If fnWMIService($sSrvc,"AcceptStop",$sTrgt)
;         "Stopping $sSrvc Service"
;         If fnWMIService($sSrvc,"StopService",$sTrgt)
;             ? "Error stopping service" ?
;         Else
;             While fnWMIService($sSrvc,"CheckPoint",$sTrgt) "." Loop
;             ? "Service Stopped" ?
;         EndIf
;     EndIf
; 
;     If Not fnWMIService($sSrvc,"Started",$sTrgt)
;         "Starting $sSrvc Service"
;         If fnWMIService($sSrvc,"StartService",$sTrgt)
;             ? "Error starting service" ?
;         Else
;             While fnWMIService($sSrvc,"CheckPoint",$sTrgt) "." Loop
;             ? "Service Started" ?
;         EndIf
;     EndIf
;     Sleep 3
; EndIf
;
;Source:
;
Function fnWMIService($sService,$sMethod,Optional $sComputer)
	Dim $objWMI,$objSrvc,$nul
	If Not $sComputer $sComputer=@WKSTA EndIf
	$objWMI = GetObject("winmgmts:{impersonationLevel=impersonate}!\\"+$sComputer+"\root\cimv2")
	If @ERROR&lt;0 Exit VAL("&amp;"+Right(DecToHex(@ERROR),4)) EndIf
	$objSrvc = $objWMI.ExecQuery('Select * from Win32_Service WHERE Name = "'+$sService+'"')
	For Each $objSrvc in $objSrvc 
		$nul=Execute("$"+"fnWMIService = $"+"objSrvc."+$sMethod)
	Next
EndFunction
83746fnWMIShutdown17SealeopardfnWMIShutdown() - LogOff/reboot/shutdown a 
user/computer locally or remotely0

code:

;FUNCTION      fnWMIShutdown()
;
;ACTION        LogOff/reboot/shutdown a user/computer locally or remotely
;
;AUTHOR        Jens Meyer (sealeopard@usa.net) for the WMI authentication sequence
;              Vig for the base WMI shutdown sequence (see RemoteLRS UDF)
;
;VERSION       1.3 (added powerdown option)
;              1.2 (removed console output)
;              1.1
;
;DATE CREATED  2002/12/05
;
;DATE MODIFIED 2003/07/01
;
;KIXTART VER   4.12
;
;SYNTAX        fnWMIShutdown([$sComputerName ,$iMode, $sUserName, $sPassword)
;
;PARAMETERS    $SCOMPUTERNAME
;              Optional string containing the target computers name, defaults to local computer
;
;              $IMODE
;              Optional integer denoting the logoff/shutdown mode, defaults to logoff
;               0 - Logoff
;               1 - Shutdown
;               2 - Reboot
;               4 - Force Logoff
;               5 - Force Shutdown
;               6 - Force Reboot
;               8 - Powerdown
;              12 - Force Powerdown
;
;              $SUSERNAME
;              optional username when connection to a remote system
;
;              $SPASSWORD
;              optional password when connecting to a remote system
;
;RETURNS       0 if successful, otherwise error code
;
;REMARKS       Using "Force" causes all open programs to close without the option to save
;
;DEPENDENCIES WMI
;
;EXAMPLE:     $rc=fnWMIShutdown()
;
;KIXTART BBS  http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000318
;
Function fnWMIShutdown(optional $sComputerName, optional $iMode, optional $sUserName, optional $sPassword)
  dim $objLocator, $objWBEM, $objShutdown, $objOpSys
  dim $iSuccess, $sNameSpace

  $iMode=val($iMode)

  $sNameSpace = 'root\CIMV2'

  ; check to see whether we're connecting to a local or remote computer
  $sComputerName=trim($sComputerName)
  select
  case $sComputerName=@WKSTA
    $sComputerName='.'
  case $sComputerName
  case 1
    $sComputerName='.'
  endselect

  select
  case $sUserName and $sComputerName<>'.'
    ; create locator object for connection to a remote computer
    $objLocator = CreateObject('WbemScripting.SWbemLocator')
    if @ERROR
      exit @ERROR
    endif
    ; create an credentialed (username/password provided) connection to a remote computer
    $objWBEM=$objLocator.ConnectServer($sComputerName,$sNameSpace,$sUserName,$sPassword)
    if @ERROR
      exit @ERROR
    endif
    ; set the impersonation level
    $objWBEM.Security_.ImpersonationLevel = 3
    if @ERROR
      exit @ERROR
    endif
  case 1
    ;set the impersonation level and make sure we have shutdown permissions
    $objWBEM=GetObject('winmgmts:{impersonationLevel=impersonate, (Shutdown)}!\\'+$sComputerName+'\'+$sNameSpace)
    if @ERROR
      exit @ERROR
    endif
  endselect

  $objShutdown = $objWBEM.ExecQuery('Select * from Win32_OperatingSystem where Primary=true')
  if $objShutdown.count
    For Each $objOpSys in $objShutdown
      $iSuccess=$objOpSys.Win32Shutdown($iMode)
    Next
  endif

  $objShutdown=0
  $objWBEM=0
  $objLocator=0

  $fnWMIShutdown=$iSuccess

EndFunction



[ 01. July 2003, 18:06: Message edited by: sealeopard ]83748fnWMIWriteValue17SealeopardfnWMIWriteValue() 
- Write to a local or remote registry using WMI with authentication0

code:

;FUNCTION      fnWMIWriteValue()
;
;ACTION        Write to a local or remote registry using WMI with authentication support
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2 (removed console output)
;              1.1
;
;DATE CREATED  2002/12/05
;
;DATE MODIFIED 2003/05/26
;
;KIXTART VER   4.12
;
;SYNTAX        fnWMIWriteValue($sSubkey, $sEntry, $sExpression, $sDataType [, $sUserName, $sPassword])
;
;PARAMETERS    $SSUBKEY
;              Required string containing the subkey where you want to write a value entry
;
;              $SENTRY
;              Required string containing the name of the entry. To write to the (default) entry
;              of a key, specify an empty string as the entry name ('').
;
;              $SEXPRESSION
;              Required string containing the data to store as the value of the entry
;
;              $SDATATYPE
;              Identifies the data type of the entry. The following data types are supported:
;              REG_SZ
;              REG_EXPAND_SZ
;              REG_BINARY
;              REG_DWORD
;              REG_MULTI_SZ
;
;              $SUSERNAME
;              Optional string/object. A string would contain the username to be used when authenticating
;              against a remote system. Alternatively, it can contain an WBEM object if already
;              authenticated against the remote computer, e.g. by calling fnWMIAuthentication() and
;              authenticating the 'root\default' namespace of the local or remote computer. This function
;              returns an object that can then be passed into fnWMIWriteValue().
;
;              $SPASSWORD
;              optional password when connecting to a remote system, defaults to current password
;
;RETURNS       0 if successful, otherwise error code
;
;REMARKS       This is just a demonstration. The preferred way is to use fnWMIAuthentication() followed by pure KiXtart
;              registry manupulation functions like WRITEVALUE()
;
;DEPENDENCIES  WMI
;
;EXAMPLE:      ; write to local computer
;              $iRC=fnWMIWriteValue('HKEY_CURRENT_USER\SOFTWARE\KiXtart','Name',@USERID,'REG_SZ')
;              ; authenticate and write to registry
;              $iRC=fnWMIWriteValue('\\WORKSTATION\HKEY_CURRENT_USER\SOFTWARE\KiXtart','Name',@USERID,'REG_SZ','username','password')
;              ; authenticate once and write multiple times to registry
;              $objWBEM=fnWMIAuthentication('WORKSTATION','username','password','root\default')
;              $iRC=fnWMIWriteValue('\\WORKSTATION\HKEY_CURRENT_USER\SOFTWARE\KiXtart','Name',@USERID,'REG_SZ',$objWBEM)
;              $iRC=fnWMIWriteValue('\\WORKSTATION\HKEY_CURRENT_USER\SOFTWARE\KiXtart','Domain',@DOMAIN,'REG_SZ',$objWBEM)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000320
;
function fnWMIWriteValue($sSubkey, $sEntry, $sExpression, $sDataType, optional $sUserName, optional $sPassword)
  dim $iRC, $iRegistryTree, $sComputerName, $sNameSpace
  dim $objLocator, $objWBEM, $objRegistry

  if instr($sSubkey,'\\')=1
    $sSubkey=substr($sSubkey,3)
    $sComputerName=left($sSubkey,instr($sSubkey,'\')-1)
    $sSubkey=substr($sSubkey,instr($sSubkey,'\')+1)
  endif
  select
  case $sComputerName=@WKSTA
    $sComputerName='.'
  case $sComputerName
  case 1
    $sComputerName='.'
  endselect

  select
  case instr($sSubkey,'HKEY_CLASSES_ROOT')=1
    $iRegistryTree='&80000000'
    $iRegistryTree=cint(2147483648.0)
    $sSubkey=substr($sSubkey,len('HKEY_CLASSES_ROOT')+2)
  case instr($sSubkey,'HKEY_CURRENT_USER')=1
    $iRegistryTree='&80000001'
    $iRegistryTree=cint(2147483649.0)
    $sSubkey=substr($sSubkey,len('HKEY_CURRENT_USER')+2)
  case instr($sSubkey,'HKEY_LOCAL_MACHINE')=1
    $iRegistryTree='&80000002'
    $iRegistryTree=cint(2147483650.0)
    $sSubkey=substr($sSubkey,len('HKEY_LOCAL_MACHINE')+2)
  case instr($sSubkey,'HKEY_USERS')=1
    $iRegistryTree='&80000003'
    $iRegistryTree=cint(2147483651.0)
    $sSubkey=substr($sSubkey,len('HKEY_USERS')+2)
  case instr($sSubkey,'HKEY_CURRENT_CONFIG')=1
    $iRegistryTree='&80000005'
    $iRegistryTree=cint(2147483653.0)
    $sSubkey=substr($sSubkey,len('HKEY_CURRENT_CONFIG')+2)
  case instr($sSubkey,'HKEY_DYN_DATA')=1
    $iRegistryTree='&80000006'
    $iRegistryTree=cint(2147483654.0)
    $sSubkey=substr($sSubkey,len('HKEY_DYN_DATA')+2)
  case 1
    exit 1
  endselect

  if vartype($sUserName)=9
    $objWBEM=$sUserName
    $sUserName=''
    $sPassword=''
  else
    $sNameSpace='root\default'
    select
    case $sUserName and $sComputerName<>'.'
      ; create locator object for connection to a remote computer
      $objLocator = CreateObject('WbemScripting.SWbemLocator')
      if @ERROR
        exit @ERROR
      endif
      ; create an credentialed (username/password provided) connection to a remote computer
      $objWBEM=$objLocator.ConnectServer($sComputerName,$sNameSpace,$sUserName,$sPassword)
      if @ERROR
        exit @ERROR
      endif
      ; set the impersonation level
      $objWBEM.Security_.ImpersonationLevel = 3
      if @ERROR
        exit @ERROR
      endif
    case 1
      ;set the impersonation level and make sure we have shutdown permissions
      $objWBEM=GetObject('winmgmts:{impersonationLevel=impersonate}!\\'+$sComputerName+'\'+$sNameSpace)
      if @ERROR
        exit @ERROR
      endif
    endselect
  endif

  $objRegistry=$objWBEM.Get('StdRegProv')
  select
  case $sDataType='REG_SZ'
    $iRC = $objRegistry.SetStringValue($iRegistryTree, $sSubkey, $sEntry, $sExpression)
  case $sDataType='REG_EXPAND_SZ'
    $iRC = objRegistry.SetExpandedStringValue($iRegistryTree, $sSubkey, $sEntry, $sExpression)
  case $sDataType='REG_BINARY'
    $iRC = objRegistry.SetBinaryValue($iRegistryTree, $sSubkey, $sEntry, $sExpression)
  case $sDataType='REG_DWORD'
    $iRC = objRegistry.SetDWORDStringValue($iRegistryTree, $sSubkey, $sEntry, $sExpression)
  case $sDataType='REG_MULTI_SZ'
    $iRC = objRegistry.SetMultiStringValue($iRegistryTree, $sSubkey, $sEntry, $sExpression)
  case 1
    exit 1
  endselect

  if @ERROR
    exit @ERROR
  endif

  $objRegistry=0
  $objWBEM=0
  $objLocator=0

  $fnWMIWriteValue=$iRC
  exit @ERROR
endfunction



[ 27. May 2003, 01:33: Message edited by: sealeopard ]133152FormatDate52NTDOCFormatDate() 
- Converts date string YYYYMMDD for DateCalc0500th posted UDF 

;Function:			FormatDate() - Converts date string YYYYMMDD for DateCalc 
; 
;Author:			NTDOC ntdoc@_@kixhelp.com 
; 
;Action:			Converts a text string in the format YYYYMMDD to format for use with DateCalc UDF 
;				Can be used for other purposes as well.  Adds / to the string YYYY/MM/DD 
; 
;Syntax:			FormatDate($String) takes a string in the format YYYYMMDD 
; 
;Date:				2005-Jan-30 
; 
;Date Revised:		 
; 
;Version:			1.0 
; 
;Update Changes:		None 
; 
;Remarks:			None 
; 
;Dependencies:			None 
;  
;Example: 
;				Break On 
;				$Date = '20050123' 
;				$Date = FormatDate($Date) 
;				$Age = DateCalc(@DATE,$Date) ; This example requires DateCalc UDF 
;				? 'Age: ' + $Age 
;				Get $Pause 
 
 

Function FormatDate($String)
	Dim $Year, $Month, $Day, $Date
	If Not $String Exit 1 EndIf
	$Year = SubStr($String,1,4)
	$Month = SubStr($String,5,2)
	$Day = SubStr($String,7,2)
	$Date = $Year+'/'+$Month+'/'+$Day
	$FormatDate=$Date
EndFunction


DateCalc UDF 161426FormatDrive5931apronkFormatDrive() - Formats a drive 
with optional parameters0Code:


;FUNCTION 	FormatDrive()
;
;AUTHOR		Arend Pronk
;
;VERSION  	1.1
;
;CHANGED  	Added more options
;
;ACTION		Formats a drive with optional parameters
;
;SYNTAX		FormatDrive($DriveName, $DriveType, Optional $VolumeName, Optional $FileSystem, Optional $QuickFormat)
;
;PARAMETERS	$DriveName (Required) - String value ie: C or D or F.
;		$DriveType (Required) - Integer value, 1 for Removable drives
;		2 for NON-Removable drives.
;		$VolumeName (Optional) - String value, Label for the drive.
;		$FileSystem (Optional) - String value, ie: FAT, FAT32 or NTFS.
;		$QuickFormat (Optional) = Integer value, 1 for yes.
;
;REMARKS  	This is a simple function that formats a drive with the parameters specified.
;
;RETURNS  	Error Code, 0 for success, error code for failure.
;
;DEPENDENCIES	KiXtart 4.02
;
;EXAMPLE  	$error = FormatDrive("G",2,"Test-Data","NTFS",1)
;		; Will Quick Format a Non-Removable drive and set the label to "Test-Data"
;		$error = FormatDrive("F",1,"FLASH_STICK","FAT32",0)
;		; Will Normal Format a Removable drive in FAT32 and set the label to "FLASH_STICK"
;		$error = FormatDrive("F",1,"FLASH_STICK")
;		; Will do the same as above.
;
;NOTES		Remember you cannot Quickformat an NTFS drive to FAT32 and vice versa.
;

Function FormatDrive($DriveName, $DriveType, Optional $VolumeName, Optional $FileSystem, Optional $QuickFormat)
  Dim $WshShell, $fso, $DriveCol, $Switches
  $WshShell = CreateObject("WScript.Shell")
  $fso = CreateObject("Scripting.FileSystemObject")
  $DriveCol = $fso.Drives
  For Each $Drive in $DriveCol
    If $VolumeName = ""
      $VolumeName = "New"
    EndIf
    SELECT
    Case $FileSystem = "FAT"
      $Switches = "/FS:FAT"
    Case $FileSystem = "FAT32"
      $Switches = "/FS:FAT32"
    Case $FileSystem = "NTFS"
      $Switches = "/FS:NTFS"
    Case 1
      $Switches = ""
    ENDSELECT
    If $QuickFormat = 1
      $Switches = $switches + " /Q"
    EndIf
    If $Drive.DriveType = $DriveType
      If Left($drive,1) = $DriveName
        $FormatDrive = $WshShell.Run("format " + $Drive + " /V:" + $VolumeName + " " + $Switches + " /Y", 1, 1)
      EndIf
    EndIf
  Next
EndFunction

83276FormatS1057BrianTXFormatS() - Formats a string to fit the screen width0

code:

;FUNCTION	FormatS($input, Optional $widthsc)
;
;AUTHOR		BrianTX
;
;ACTION		Formats a string with carriage returns and line feeds
;		to fit the specified screen width.
;
;SYNTAX		FormatS($input, Optional $widthsc)
;
;PARAMETERS	$Input (Required) -  String value
;		$widthsc (Optional) -  Integer equal to view or screen width.
;
;REMARKS	This is a simplistic function that only makes sure data in a
;		string is viewable instead of scrolling off the right side of         
;		the viewing area. This function will not do word wrap at this
;		time.
;
;RETURNS	String
;
;DEPENDENCIES	KiXtart 4.02
;
;EXAMPLE	FormatS("abcdefghijklmnopqrstuvwxyz",12)
;		RETURNS:
;		"abcdefghijkl
;		mnopqrstuvwx
;		yz"
;                 

function FormatS($input, Optional $widthsc)
If $widthsc Else $widthsc = 80 Endif
$Lst = LEN($input)
$co = 0
For $nl = 1 to $Lst
 $co = $co + 1
 $ps = INSTR(SUBSTR($input,$nl,1),CHR(10))
 If $ps $co = 0 Endif
 If $co = $widthsc
  $input = SUBSTR($input,1,$nl) + CHR(13) + CHR(10) + SUBSTR($input,$nl+1)
  $co = 0
 Endif
Next
$formats=$input
EndFunction

This is the first UDF I've posted. I'm open to making it more powerful in the 
future if need be.

Brian83322FormLink119LonkeroFormLink() - link in KixForms-object0

code:

;Function FormLink()
;
;Author	Lonkero
;
;Version 1.0.1 - 25th of feb 2003 (1.0 - 11th of july 2002)
;
;Action Makes Hyperlink to KiXForms object.
;
;Syntax FormLink($Target,$Object,$Parent)
;
;Parameters
;	$Target
;		String representing target URL
;
;	$Object
;		Object-handle for kixforms-object
;		to bind the link to.
;		notice that the object needs to support:
;		 -onclick event
;		 -onmousemove event
;
;	$Parent
;		Object-handle to the parent object where the $Object resides
;
;Remarks
;	Still lacking the color and other style arguments.
;	 Will do them on demand.
;	Now just opens IE in new window with the target address.
;
;Returns
;	nothing
;
;Dependencies
;	kix2001,kixforms,windows NT/2000/XP
;
;Examples
;	FormLink("http://MakeMyDayOnHolidayEveningS.enu/shiPping_food.xml","$$link_label","$$form3")
;	FormLink("%windir%",$form.CommandButton("explore systemfiles",2,230,100,20),$form)
;
;
;Source
Function FormLink($_Target, $_Object, $_Parent)
if 1=@inwin and len($_Object) and len($_Parent) and len($_Target)>7
$=execute('$_Parent.onmousemove="$'+'$_Object.fontbold=0 $'+'$_Object.fontunderline=0"')
$=execute('$_Object.onmousemove="$'+'$_Object.fontbold=1 $'+'$_Object.fontunderline=1"')
$=execute('$_Object.onmouseup="run '+chr(39)+'explorer "+chr(34)+"'+$_Target+'"+chr(34)+chr(39)')
endif
endfunction



[ 25. February 2003, 09:50: Message edited by: Lonkero ]82528Freshfile31RadimusFreshfile() 
- Keep client files up to date0freshfile("server folder","client folder","filename", 
[optional force])

code:

;example	FreshFile("$setup\apps\OASIS Plugin","C:\Program Files\Internet Explorer\PLUGINS","npdwe70.dll")
;		used to compare files for updating to newer versions
;		version 1.2 optional force any non-zero value will force the copy
		
FUNCTION FreshFile($source,$destination,$file, optional $force,)
	dim $compare
	if exist("$destination\$file") or $force
		$compare=comparefiletimes("$source\$file","$destination\$file")
		if $compare=1 or $force
			setfileattr("$destination\$file",128)
			copy "$source\$file" "$destination"
			? "	Updating $file"
			endif
		endif
	ENDFUNCTION



[ 28. October 2002, 15:21: Message edited by: Radimus ]83713FTPget119LonkeroFTPget() 
- download a file1186074213

Code:

;Function:	FTPget()
;
;Authors:	Lonkero
;		kdyer
;
;Version:	1.2 (2th of August 2007)
;
;Version History:
;		1.2 - current, added Force-parameter
;		1.1 (6th of December 2002)
;
;Action:	gets file from ftp or http server and saves it in specified file
;
;Syntax:	FTPget("URL", "TARGET", "USERNAME", "PASSWORD", FORCE)
;
;Parameters:
;		URL	- full url to the file to get
;		TARGET	- full path to file where to save
;		USERNAME- optional, specifies username to use in connection
;		PASSWORD- optional, specifies password to use in connection
;		FORCE	- optional, force udf to bypass cache
;
;Returns:
;		Nothing or errorcode on error.
;
;		on error errorcodes returned and set:
;			1 -failed to initialize http-object
;			2 -failed to initialize ADODB-object
;			3 -failed to open connection
;			4 -ADO write failed
;			5 -save to file failed
;
;Dependencies:
;		IE5 or higher
;
;Remarks:
;		if file exists, it will be overwritten.
;		not sure about the ado, dependency?
;
;Example:	
;		"Downloading TypelibViewer, Please standby..."
;		if FTPget("http://www.rwksystems.com/files/TypeLibViewer.exe","%temp%\typelibViewer.exe")
;			"error occured:" @error
;		else
;			"Download complete. file is saved in %temp% as typelibViewer.exe"
;		endif
;
;Source:
Function FTPget($sURL, $sTargetFile, optional $sUser, $sPass, $iForce)
  Dim $oFTP, $oStream,$dwSM,$,$sLoc
  $sLoc="HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
  $sUser=""+$sUser
  if $iForce
    $dwSM = Readvalue($sLoc,"Syncmode5")
    $=writevalue($sLoc,"Syncmode5",3,"REG_DWORD")
  endif
  $oFTP = CreateObject("Microsoft.XMLHTTP")
  if @error
    $ftpget=1
    if $iForce
      $=writevalue($sLoc,"Syncmode5",$dwSM,"REG_DWORD")
    endif
    exit 1
  endif
  $oStream = CreateObject("ADODB.Stream")
  if @error
    $ftpget=2
    if $iForce
      $=writevalue($sLoc,"Syncmode5",$dwSM,"REG_DWORD")
    endif
    exit 2
  endif
  if $sUser
    $oFTP.Open("GET", $sURL, not 1, $sUser, $sPass)
  else
    $oFTP.Open("GET", $sURL, not 1)
  endif
  if @error
    $ftpget=3
    if $iForce
      $=writevalue($sLoc,"Syncmode5",$dwSM,"REG_DWORD")
    endif
    exit 3
  endif
  $oFTP.Send
  $oStream.Type = 1
  $oStream.Mode = 3
  $oStream.open
  $oStream.Write($oFTP.responseBody)
  if @error
    $ftpget=4
    if $iForce
      $=writevalue($sLoc,"Syncmode5",$dwSM,"REG_DWORD")
    endif
    exit 4
  endif
  $oStream.SaveToFile($sTargetFile, 2)
  if @error
    $ftpget=5
    if $iForce
      $=writevalue($sLoc,"Syncmode5",$dwSM,"REG_DWORD")
    endif
    exit 5
  endif
  $oFTP=0
  if $iForce
    $=writevalue($sLoc,"Syncmode5",$dwSM,"REG_DWORD")
  endif
  $oStream.Close
EndFunction
84375FTPput3677AndyMackFTPput( ) - FTP function to PUT files0

code:

;FUNCTION 		: FTPput()
;
;ACTION			: Puts a file, or multiple files, onto a specified host or url
;
;AUTHOR			: Andrew Mack
;
;CONTRIBUTORS		: Richard H.
;
;VERSION		: 2.5
;
;DATE CREATED		: 18 June 2003
;
;DATE MODIFIED		: 26 June 2003
;
;KIXTART		: All versions
;
;SYNTAX			: FTPput(Host, Path, File, UserID, PassWD, optional 	
;			  FTPcommand)
;
;PARAMETERS		: Host - The target IP Address, host or URL
;			: Path - The path to the source file
;			: File - The source file
;			: UserID - The login ID
;			: PassWD - The login ID's password
;			: optional FTPcommand - an additional FTP command that you
;			  want to add (e.g. rename)
;
;RETURNS		: 0 on success
;			: @ERROR on Incomplete file transfer
;
;REMARKS		: Will overwrite existing files. Checks for fail by getting sent file
;			: back to a separate area and then comparing with original file.
;			: $File can be a multi value array with the values seperated
;			: by spaces.
;
;DEPENDENCIES		: FTP existing on source host. Ability to access destination 
;			: host
;
;EXAMPLE		: If FTPput($Host, $Path, $File, $UID, $PWD) = 0
;			:	?"transfer OK"
;			: Else
;			:	?"transfer failed. Comence panic now"
;			: EndIf	
;
; Source Begins:

Function FTPput($Host, $Path, $File, $UID, $PWD, optional $FTPcmds) 

; Declare local variables here

dim $FTPchk

$FTPchk = %TEMP%


; Create an FTP command file

If Open(1,$FTPchk+"\FTPcmds",5) = 0

	WriteLine(1,$UID+@CRLF)			
	WriteLine(1,$PWD+@CRLF)
	WriteLine(1,"binary"+@CRLF)
	WriteLine(1,"lcd "+$Path+@CRLF)
	WriteLine(1,"mput "+$File+@CRLF)

; Now get the transferred file back to a check area so we can confirm it worked
	WriteLine(1,"lcd "+$FTPchk+@CRLF)
	WriteLine(1,"mget "+$File+@CRLF)

; Additional FTP commands passed to the function are actioned here
	WriteLine(1,""+$FTPcmds+@CRLF)

	WriteLine(1,"close"+@CRLF)		
	WriteLine(1,"quit"+@CRLF)

	Close(1)

EndIf

; Shell FTP command to transfer the file(s) concerned

Shell"ftp -v -i -s:"+$FTPchk+"\FTPcmds "+$Host+@CRLF


; Now do a check that the file was transferred and set the error on exit.
; If file exists, delete it to tidy up.

Shell "%COMSPEC% /C echo N | comp "+$FTPChk+"\"+$File+" "+$Path+"\"+$File+" >NUL: 2>NUL:"

        If @ERROR   
            $FTPput=@ERROR
        Else   
             $FTPput=0
        EndIf
     
        Del $FTPchk+"\"+$File
        Del $FTPchk+"\FTPcmds"
        Exit $FTPput
	
EndFunction



[ 30. June 2003, 01:09: Message edited by: AndyMack ]82207FULLFILE17SealeopardFULLFILE() 
- Creates a fully qualified pathname1110566994Code:


;FUNCTION      FullFile

;

;ACTION        Creates a fully qualified path

;

;AUTHOR        Jens Meyer (sealeopard@usa.net)

;

;VERSION       2.01 (added UNC support)

;              2.0  (complete code rewrite)

;              1.1

;

;DATE CREATED  2002/11/26

;

;DATE MODIFIED 2005/03/11

;

;KIXTART       4.20+

;

;SYNTAX        FULLFILE(PATH1 [, PATH2])

;

;PARAMETERS    PATH1

;              Required string/array containing pathname(s)

;

;              PATH2

;              Optional string/array containing the rightmost pathname(s) or filename

;

;RETURNS       The fully qualified path or filename

;

;REMARKS       none

;

;DEPENDENCIES  none

;

;EXAMPLE       $file = fullfile('c:\windows','system32\kixtart.exe')

;              $file = 'c:\windows\system32\kixtart.exe'

;              $path[0]='c:\'

;              $path[1]='temp'

;              $file='test.txt'

;              $file=fullfile($path,$file)

;

;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=81757

;

function fullfile($p1, optional $p2)

  dim $p,$l



  if vartype($p1) & 8192

    $p1=join($p1,'\')

  endif

  if vartype($p2) & 8192

    $p2=join($p2,'\')

  endif

  $p=$p1+'\'+$p2

  $l=iif(right($p,2)='\\','\','')

  $p=iif(right($p,1)='\',left($p,-1),$p)



  if instr($p,'\\')

    $p=fullfile(join(split($p,'\\'),'\'))

  endif

  if left($p,1)='\' and left($p,2)<>'\\'

    $p='\'+$p

  endif



  $fullfile=$l+$p

endfunction

Code:

84410Function3805rvdmastFunction GetOption() - Returns value of cmd-line option for scripts compiled...0

code:

 
;FUNCTION GetOption
;ACTION Returns the value of a command-line option (if given) for
;       scripts compiled with KiXscripts Editor EXE Package Creator
;       since the normal procedure for passing parameters to KiXtart
;       scripts wont work with compiled packages.
;AUTHOR rvdmast
;
;VERSION 1.0.0
;
;KIXTART 4.20
;
;DEPENDENCY KiXscripts Editor
;
;SYNTAX command-line options are to be given in the form:
;       name_of_compiled_script.exe /option1=value /option2=value ...
;
;RETURNS returns a string containing the value of the requested
;        command-line option 
;
;REMARKS Uses the $EXECmdLine and $EXEPath variables built into
;        the KiXscripts Editor EXE Package Creator to extract
;        the options given on the command-line. This script
;        will therefor only work when compiled
;
;EXAMPLE To retrieve the value of userid and pass when using:
;        c:\myscripts\myscript.exe /userid=JohnDoe /pass=1234
;        you would call in your compiled script:
;        $userid = GetOption ("userid")
;        $pass = GetOption ("pass")

Function GetOption ($WantedOption)

$PathInCmd = InStr ("$EXECmdLine", "$EXEPath")
If $PathInCmd
	$Command=SubStr($EXECmdLine,Len("$EXEPath")+2)
	$ExePos = InStr ($Command, ".exe")
	If $ExePos = 0
		$Param = LTrim(SubStr ($Command, "/"))
	Else
		$Param = LTrim(SubStr ($Command, $ExePos + 4))
	EndIf
Else
	$ExePos = InStr ($EXECmdLine, ".exe")
	If $ExePos = 0
		$ExePos = InStr ($EXECmdLine, "/")
		$Param = LTrim(SubStr ($EXECmdLine, $ExePos))
	Else
		$Param = LTrim(SubStr ($EXECmdLine, $ExePos + 4))
	EndIf
EndIf

$Options = Split("$Param", "/")
For Each $Element In $Options
  $ReturnValue = InStr (Ucase($Element), $WantedOption+"=")
  If $ReturnValue <> 0
  	$GetOption = LTrim(SubStr ($Element, Len($WantedOption)+2))
  	$GetOption = RTrim($GetOption)
  EndIf
Next

EndFunction
 


 
 [ 01. July 2003, 07:40: Message edited by: rvdmast ]165704Function52NTDOCFunction HTMLInputBox() - Displays an Input-box via IE0

; Function	HTMLInputBox() - Displays an Input-box via IE 
; 
; Author:	Steve O ; posted as UDF by NTDOC
;		Posted in Beta forum - http://www.kixtart.org/ubbthreads/showthreaded.php?Cat=0&Number=77407 
; 
; ACTION:	Displays an Input-box that allows a user to input a string. This box is HTML based and 
;		uses the Internet Explorer Application object. 
; 
; SYNTAX:	HTMLInputBox("HTML Message", OPTIONAL "Window Title","Default Value","Button Text","Text Color",  
;		"Background Color", "Alt Button Text","Alt Button Return Value") 
; 
; Version:	1.0 
; 
; Date:		Sep 27 2001 
; 
; Date Revised:	 
; 
; Revision Reason:	 
; 
; PARAMETERS: 
; HTML Message: The message for the Input Box. ex: What is your favorite color?  
; Note: This can accept any HTML code, so go to town! Also Note: the <b> tag is enabled, so if you want to do  
; custom HTML, put </b> as the first tag. 
; Window Title: ( OPTIONAL ) The title of the HTML Input Box Window. If blank, defaults to "Question...". 
; Default Value: ( OPTIONAL ) The default value for the box which will show when the box appears.  
; If blank, defaults to blank. 
; Button Text: ( OPTIONAL ) The text on the main button. If blank, default is "SUBMIT". 
; Text Color: ( OPTIONAL ) The color of text on the input box. If blank, this defaults to black.  
; Note: This can be overridden by including additional HTML tags in the HTML Message. 
; Background Color: ( OPTIONAL ) The color of the background of the HTML form. Defaults to silver. 
; Alt Button Text: ( OPTIONAL ) If this is specified, an alternate button will appear on the form and  
; if clicked, the function will (by default) return "-1". This is useful as a "HELP" button, or  
; for many other purposes. 
; Alt Button Return Value: ( OPTIONAL ) If the Alt button is needed, and -1 is a potential legitimate  
; return value for the main submit button, you can specify an alternate return value for the alternate button. 
; 
; REMARKS: 
; This has been tested by the author on Win 98 and Win 2k machines. It should require at least IE 4.0  
; to function, however it does not check the IE version before executing. 
; 
; RETURNS: 
; The string in the text box, or another value if the "Alternate button" is pressed. The alternate value  
; defaults to -1, but can be changed by specifying the "Alt Button Return Value". 
; 
; Dependencies:	IE, KiXtart 4.x 
; 
; EXAMPLE: 
; HTMLInputBox("What is your favorite color?","Color Quiz","Red","Submit Me!","Black","Yellow","I don't know!!!") 
; 
; Source: 

 

Function HTMLInputBox($L_Prompt, OPTIONAL $L_Title,$L_DefaultValue,$L_ButtonText,$L_TextColor,$L_BGColor,$L_AltButtonText,$L_AltButtonReturnValue)
Dim $HTML, $AppIE, $SF
If $L_Title = ""
  $L_Title = "Question..."
EndIf
 
If $L_ButtonText = ""
  $L_ButtonText = "Submit"
EndIf
 
If $L_AltButtonReturnValue = ""
  $L_AltButtonReturnValue = -1
EndIf
 
Select
  Case $L_TextColor = "Black"
    $L_TextColor = "000000"
  Case $L_TextColor = "Silver"
    $L_TextColor = "C0C0C0"
  Case $L_TextColor = "Gray"
    $L_TextColor = "808080"
  Case $L_TextColor = "White"
    $L_TextColor = "FFFFFF"
  Case $L_TextColor = "Maroon"
    $L_TextColor = "800000"
  Case $L_TextColor = "Red"
    $L_TextColor = "FF0000"
  Case $L_TextColor = "Purple"
    $L_TextColor = "800080"
  Case $L_TextColor = "Fuchsia"
    $L_TextColor = "FF00FF"
  Case $L_TextColor = "Green"
    $L_TextColor = "008000"
  Case $L_TextColor = "Lime"
    $L_TextColor = "00FF00"
  Case $L_TextColor = "Olive"
    $L_TextColor = "808000"
  Case $L_TextColor = "Yellow"
    $L_TextColor = "FFFF00"
  Case $L_TextColor = "Navy"
    $L_TextColor = "000080"
  Case $L_TextColor = "Blue"
    $L_TextColor = "0000FF"
  Case $L_TextColor = "Teal"
    $L_TextColor = "008080"
  Case $L_TextColor = "Aqua"
    $L_TextColor = "00FFFF"
  Case $L_TextColor = ""
    $L_TextColor = "000000"
EndSelect
 
Select
  Case $L_BGColor = "Black"
    $L_BGColor = "000000"
  Case $L_BGColor = "Silver"
    $L_BGColor = "C0C0C0"
  Case $L_BGColor = "Gray"
    $L_BGColor = "808080"
  Case $L_BGColor = "White"
    $L_BGColor = "FFFFFF"
  Case $L_BGColor = "Maroon"
    $L_BGColor = "800000"
  Case $L_BGColor = "Red"
    $L_BGColor = "FF0000"
  Case $L_BGColor = "Purple"
    $L_BGColor = "800080"
  Case $L_BGColor = "Fuchsia"
    $L_BGColor = "FF00FF"
  Case $L_BGColor = "Green"
    $L_BGColor = "008000"
  Case $L_BGColor = "Lime"
    $L_BGColor = "00FF00"
  Case $L_BGColor = "Olive"
    $L_BGColor = "808000"
  Case $L_BGColor = "Yellow"
    $L_BGColor = "FFFF00"
  Case $L_BGColor = "Navy"
    $L_BGColor = "000080"
  Case $L_BGColor = "Blue"
    $L_BGColor = "0000FF"
  Case $L_BGColor = "Teal"
    $L_BGColor = "008080"
  Case $L_BGColor = "Aqua"
    $L_BGColor = "00FFFF"
  Case $L_BGColor = ""
    $L_BGColor = "C0C0C0"
EndSelect
 
$HTML = '<HTML>' +
'<BODY TEXT=' + $L_TextColor + ' BGCOLOR=' +
$L_BGColor + '>' +
'<TITLE>' + $L_Title + '</TITLE><B>' +
$L_Prompt + '</B>' +
'<form name=CompTrends>' +
'<BR>' +
'<input id=Answer name=Answer class=tbox' +
' value="' + $L_DefaultValue + '" Tabindex="1"> ' +
'<input id=Submitted name=Submitted type=hidden value=0>' +
'<input id=Submit name=Submit type=button value=" ' +
$L_ButtonText + ' "' +
' onclick="CompTrends.Submitted.value=1" Tabindex="2">'
 
If $L_AltButtonText <> ""
$HTML = $HTML + '<input id=AltButton name=AltButton type=button value=" ' +
$L_AltButtonText + ' "' +
' onclick="CompTrends.Submitted.value=2" Tabindex="3">'
EndIf
 
$HTML = $HTML + '</FORM>' +
'</BODY></HTML>'
 
$AppIE = CreateObject("InternetExplorer.Application")
 
;Set IE Object Properties 
$appIE.top = 30
$appIE.left = 30
$appIE.height = 350
$appIE.width = 500
$appIE.addressbar = 0
$appIE.menubar = 0
$appIE.toolbar = 0
$appIE.statusbar = 0
$appIE.resizeable = 0
$appIE.navigate("about:blank")
While $AppIE.busy <> 0 And @ERROR = 0 Loop
 
;Write the HTML code to the document 
$AppIE.document.write($HTML)
 
While $AppIE.busy <> 0 And @ERROR = 0 LOOP
 
;Make IE visible and set focus 
$AppIE.visible = 1
$SF = SetFocus("about:blank - Microsoft Internet Explorer")
$AppIE.document.GetElementById("Answer").focus
 
Dim $L_LastBoxValue,$L_LastBoxValueCache
While $appIE.document.GetElementById("Submitted").value = 0
  If $appIE.document.GetElementById("Submit").value = " " + $L_ButtonText + " "
    If $appIE.document.GetElementById("Answer").value <> ""
      $L_LastBoxValue = $appIE.document.GetElementById("Answer").value
      If $L_LastBoxValue <> ""
        $L_LastBoxValueCache = $L_LastBoxValue
      EndIf
    EndIf
  EndIf
Loop
 
If $AppIE.document.GetElementById("Submitted").value = 2
  $HTMLInputBox = $L_AltButtonReturnValue
Else
  $HTMLInputBox = $L_LastBoxValueCache
EndIf
 
$AppIE.QUIT
$AppIE = ""
EndFunction
 
144337GetAdminAccount119LonkeroGetAdminAccount() - Retrieves Admin Account Info (name or sid)0 Code:


;Function:
;	GetAdminAccount()
;
;Author:
;	Lonkero
;
;Version:
;	1.0
;
;Version History:
;	1.0 - 27th of july 2005 - initial release
;
;Action:
;	Retrieves Admin Account Info
;
;Syntax:
;	GetAdminAccount(COMPUTER, TYPE)
;
;Parameters:
;	COMPUTER, optional
;	 against what machine to run. defaults to local.
;	TYPE, optional
;	 0 - Return Account Name (default)
;	 1 - Return Account Sid
;
;Remarks:
;	had to write this as didn't seen anything like it in the lib.
;
;Returns:
;	The Requested Admin Account Info
;
;Dependencies:
; 	WMI
;
;Example:
;	"Local Admin Account name is: " GetAdminAccount()	   ?
;	"Local Admin Account SID is: " GetAdminAccount(,1)	   ?
;	"Admin Account Name on SOME is: " GetAdminAccount("SOME")  ?
;	"Admin Account SID on SOME is: " GetAdminAccount("SOME",1) ?
;
;Source:
function GetAdminAccount(optional $m,$t)
dim $,$wmi
if not len($m) $m = "." endif
if not vartype($t) $t = 0 endif
$wmi = GetObject("winmgmts:\\" + $m + "\root\cimv2")
For each $ in $wmi.ExecQuery("Select * from Win32_UserAccount",,48)
 if right($.SID,4) = "-500"
  if $t=0 $GetAdminAccount = $.Name endif
  if $t=1 $GetAdminAccount = $.SID endif
 endif
Next
endfunction

83246GetADsPathFromHexSid172Howard BullockGetADsPathFromHexSid() - Returns AdsPath of object represented by HexSid0


;FUNCTION GetAdsPathFromHexSid($HexSid)
;
;AUTHOR Howard A. Bullock (hbullock@comcast.net)
;
;ACTION Uses ADsSecurity.DLL to translate a Hex Sid into the
; objects AdsPath.
;
;SYNTAX GetADsPathFromHexSid($HexSid)
;
;PARAMETERS $HexSid (Required) - String value
;
;REMARKS ADsSecurity.Dll required
;
;RETURNS String - ADsPath path of object represented by a Hex Sid.
;
;DEPENDENCIES KiXtart 4.02, AdsSecurity.DLL
;
;EXAMPLES
; GetAdsPathFromHexSid("010500000000000515000000BC2E7001633DBD3D0E6D055C79050000")
;
Function GetADsPathFromHexSid($HexSid)
Dim $oADsSid
$GetADsPathFromHexSid = ""
$oADsSid = CreateObject("ADsSid")
If VarTypeName($oADsSid) = 'Object'
$oADsSid.SetAS(1,$HexSid)
If @Error <> 0
? "Failed: SetAS(1,$HexSid) @Error @Serror"
Exit 1
Endif
$GetADsPathFromHexSid=$oADsSid.GetAS(5)
If @Error <> 0
? "Failed: GetAS(5) @Error @Serror"
Exit 1
Endif
Else
? "CreateObject('ADsSid') Failed. @Error @Serror"
? "AdsSecurity.DLL required."
Exit 1
Endif
Exit 0
Endfunction


 
 [ 05. April 2003, 17:51: Message edited by: Howard Bullock ]83792GetAllADUserInfoToFile52NTDOCGetAllADUserInfoToFile() Queries the AD for all user information and writes to file0; *** FUNCTION:		GetAllADUserInfoToFile()
; *** AUTHOR:		Ron Lewis/NTDOC
; *** DATE CREATED:	2003-01-10 21:10 PST
; *** ACKNOWLEDGEMENTS:	Special thanks to Lonkero for help with array parsing of names
; *** SYNTAX:		GetAllADUserInfoToFile
; *** PARAMETERS:	(you must supply the LDAP lookup path and file name to save)
; *** ACTION:		This file queries the Active Directory for all user information
; *** 			and copies it to a supplied file name and location.  It is designed for multiple OU query
; ***			Does not include group membership and security information.  The file uses a * for a
; ***			delimiter to make import into Excel easier for report viewing.
; *** DEPENDENCIES:	(KiXtart 4.02 or later)  (Windows 2000 AD)  (ADSI (2000 and XP workstations have ADSI))

; *************** REVISION HISTORY  ***************
; 001.02 *** 2003-01-16 15:10 PST by Ron Lewis
;	Enabled multiple OU usage
; 001.01 *** 2003-01-15 13:50 PST by Ron Lewis
;	Cleared up variables
; 001.00 *** 2003-01-10 21:10 PST by Ron Lewis
;	original file release

; *** USAGE EXAMPLE: 
BREAK On
$FileName="C:\TEMP\ADUserInfo.txt"
$LDAP="LDAP://ou=Users,ou=business1, your company rootDSE info", "LDAP://ou=Users,ou=business2, your company rootDSE info"
GetAllADUserInfoToFile

code:

Function GetAllADUserInfoToFile()
For each $domain in $LDAP
$ou = GetObject($domain)
  For each $user in $ou
    $all=""
    $StreetValue=""
    $direct=""
    $mymanager=""
    $mymail=""
    $MyDescription=""
    $MyTelephoneNotes=""
    $MyCompany=""
; This block gathers the users Name and strips off the extra path data
; ***********************************************************************
  IF $user.name
   $name=split(substr($user.name,4),",")
   $name[0]=join(split($name[0],"\"),"")
   $name=join($name,",")
  ENDIF
; ***********************************************************************

; This block gathers the users smtp email address and strips off the word
; "email." after the @ sign
; ***********************************************************************
  IF $user.mail
   $mymail=split(substr($user.mail,1),",")
   $mymail[0]=join(split($mymail[0],"email."),"")
   $mymail=join($mymail,",")
  ENDIF
; ***********************************************************************

; This block gathers the Manager and strips off the extra path data
; ***********************************************************************
  IF $user.manager
   $mymanager=split(substr($user.manager,4),",")
   $mymanager=join(split($mymanager[0],"\"),"")+","+$mymanager[1]
  ENDIF
; ***********************************************************************

; This block gathers the directReports and strips off the extra path data
; ***********************************************************************
  For each $item in $user.directReports
   $direct=$direct+chr(10)+$item
  Next
  IF Not $direct $direct=$user.directReports+chr(10)
  ENDIF
  For each $value in split($direct,chr(10))
  IF $value $value=split(substr($value,4),",")
    $all=$all+"  "+join(split($value[0],"\"),"")+","+$value[1]
    $all=SUBSTR($all,2)
  ENDIF
  Next
; ***********************************************************************

  $StreetValue=join(split($user.streetAddress,@CRLF)," ")
  $MyDescription=join(split($user.description,@CRLF,),"")
  $MyTelephoneNotes=join(split($user.info,@CRLF,),"")
  $MyCompany=join(split($user.company,@CRLF,),"")

  IF OPEN(1,"$FileName", 5)= 0
	$out = WriteLine(1, $user.givenName+"*"+$user.initials+"*"+$user.sn+"*"+$user.displayname+"*"+
	$MyDescription+"*"+$user.physicalDeliveryOfficeName+"*"+$user.telephoneNumber+"*"+$mymail+"*"+
	$user.wWWHomePage+"*"+$user.url+"*"+$StreetValue+"*"+$user.postOfficeBox+"*"+$user.l+"*"+
	$user.st+"*"+$user.postalCode+"*"+$user.c+"*"+$user.sAMAccountName+"*"+$user.userPrincipalName+
	"*"+$user.userWorkstations+"*"+$user.profilePath+"*"+$user.scriptPath+"*"+$user.homeDrive+"*"+
	$user.homeDirectory+"*"+$user.homePhone+"*"+$user.pager+"*"+$user.mobile+"*"+
	$user.facsimileTelephoneNumber+"*"+$user.ipPhone+"*"+$user.otherTelephone+"*"+$MyTelephoneNotes+
	"*"+$user.title+"*"+$user.department+"*"+$user.company+"*"+$mymanager+"*"+$all+"*"+@crlf)
	$x = CLOSE(1)
  ENDIF

  Next
Next
EndFunction


 
 [ 22. January 2003, 21:28: Message edited by: NTDOC ]84340GetAutologonStatus17SealeopardGetAutologonStatus() - Get the autologon status0

code:

;FUNCTION      GetAutoLogonStatus()
;
;ACTION        Get the autologon status
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.1 (added remote computer as optional input)
;              1.0
;
;DATE CREATED  2003/05/31
;
;DATE MODIFIED 2003/06/01
;
;KIXTART       4.12+
;
;SYNTAX        GETAUTOLOGONSTATUS([COMP, VERBOSE])
;
;PARAMETERS    COMP
;              Optional computername from which to return the autologon setting
;
;              VERBOSE
;              Optional boolean that retrieves all autologon parameters
;
;RETURNS       1 if autologon is enabled, otherwise 0
;              Alternatively, an array of all autologon parameters
;
;REMARKS       none
;
;DEPENDENCIES  none
;
;EXAMPLE       $status=GETAUTOLOGONSTATUS('server1',1)
;              ? 'AutoAdminLogon          = '+$status[0]
;              ? 'AutoLogonCount          = '+$status[1]
;              ? 'DefaultDomainName       = '+$status[2]
;              ? 'DefaultPassword         = '+$status[3]
;              ? 'DefaultUsername         = '+$status[4]
;              ? 'DontDisplayLastUserName = '+$status[5]
;              ? 'IgnoreShiftOverride     = '+$status[6]
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000421
;
function GetAutologonStatus(optional $comp, optional $verbose)
  dim $status[6], $regsubkey

  if @INWIN=1
    $regsubkey='HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon'
  else
    $regsubkey='HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Winlogon'
  endif

  $comp=trim($comp)
  if $comp
    $regsubkey='\\'+$comp+'\'+$regsubkey
  endif


  if val($verbose)=1
    $status[0]=val(readvalue($regsubkey,'AutoAdminLogon'))
    $status[1]=val(readvalue($regsubkey,'AutoLogonCount'))
    $status[2]=readvalue($regsubkey,'DefaultDomainName')
    $status[3]=readvalue($regsubkey,'DefaultPassword')
    $status[4]=readvalue($regsubkey,'DefaultUsername')
    $status[5]=val(readvalue($regsubkey,'DontDisplayLastUserName'))
    $status[6]=val(readvalue($regsubkey,'IgnoreShiftOverride'))
    $getautologonstatus=$status
  else
    $getautologonstatus=val(readvalue($regsubkey,'AutoAdminLogon'))
  endif

  exit @ERROR
endfunction


 
 [ 02. June 2003, 03:55: Message edited by: sealeopard ]175596GetAVinfo119LonkeroGetAVinfo() - retrieve antivirus product and status information1177440400

;FUNCTION
;		GetAVinfo()
;
;AUTHOR
;		Jooel
;
;ACTION
;		Returns Antivirus information on local or remote machine
;
;VERSION	1.0.1
;
;CHANGES
;		1.0.1 (24.4.2007) - changed returncode for true from -1 to 1
;		1.0   (20.4.2007) - initial release
;
;SYNTAX
;		GetAVinfo([MACHINE])
;
;PARAMETERS
;
;		MACHINE		- optional. remote machine to query against
;
;RETURNS
;		Array containing the AV info as known by windows security center.
;		Elements are as follows:
;		 0 - Displayname
;		 1 - Version
;		 2 - Company
;		 3 - uptodate
;		 4 - RealtimeScanning Enabled
;
;REMARKS
;		talk about simple retrieval of AV info...
;
;DEPENDENCIES
;		xp sp2
;
;EXAMPLES
;		"AV on this computer: "
;		getAVInfo()[0] ?
;
;		"AV status on serverMachine: " ?
;		$av = getAVinfo
;		"installed AV:	" $av[0]
;		"version:	" $av[1]
;		"uptodate:	" if $av[3] "yes" else "no" endif
;		"realtime scanning: " if $av[4] "yes" else "no" endif
;
;SOURCE
Function GetAVinfo(optional $machine)
dim $oSWbem,$colAV,$av[4],$oAntiVirusProduct
 if not $machine $machine = "." endif

 $oSWbem = GetObject("winmgmts:{impersonationLevel=impersonate}!\\" + $machine + "\root\SecurityCenter")
 If @Error exit @error EndIf
 $colAV = $oSWbem.ExecQuery("Select * From AntiVirusProduct")
 If @Error exit @error EndIf

 For Each $oAntiVirusProduct In $colAV
  $av[0] = $oAntiVirusProduct.displayName
  $av[1] = $oAntiVirusProduct.versionNumber
  $av[2] = $oAntiVirusProduct.companyName
  $av[3] = iif(-1 = $oAntiVirusProduct.productUptoDate,1,0)
  $av[4] = iif(-1 = $oAntiVirusProduct.onAccessScanningEnabled,1,0)
 Next
 $GetAVinfo=$av
EndFunction
113239GetComputerOU4832RemkoGetComputerOU() - Retrieve OU of computer account0Comments and/or suggestions are welcome



;Function	    GetComputerOU()

;

;Author		    Remko Weijnen

;

;Action		    Returns the DN of the OU/Container which the computer is placed in

;

;Syntax		    GetComputerOU()

;

;Version	    1.0

;

;Date               2004-0203

;

;Date Revised   

;

;Parameters 	    None 

;

;Remarks	    None

;

;Returns	    If the DN eq CN=SomeComputer,OU=SomeOU,DC=ad,DC=local

;                   it returns OU=SomeOU,dc=ad,dc=local

; 

;Dependencies 	    None

;

;KiXtart Ver	    4.22

; 

;Example(s)	    $ComputerOU = $GetComputerOU

; 



Function GetComputerOU()

  Redim $TempArray[0]

  Redim $GetComputerOU

  $adSys = CreateObject("ADSystemInfo")

  $TempArray = Split($adSys.ComputerName,",")

  ; Check if there's a comma in the CN, eg if the user name = "Surname, Name" AD returns "Surname\, Name"

  If Right($TempArray[0],1) = "\" 

    $Start = 2

  Else

    $Start = 1

  EndIf

  

  For $Counter = $Start To UBound($TempArray)

    If Len($GetComputerOU) = 0

      $GetComputerOu = $TempArray[$Counter]

	Else

      $GetComputerOu = $GetComputerOu + "," + $TempArray[$Counter]

	EndIf

  Next



  $adSys = 0 

EndFunction GetComputerOU()      

   122263GetDataBase5441Gold_KoyGetDataBase() - Gets an db entry0
;FUNCTION      GetDataBase()
;
;ACTION        Gets an Databaseentry
;
;AUTHOR        Markus Gerbig (Markus.Gerbig@aventis.com)
;
;VERSION			 1.0
;
;DATE CREATED  2004/06/30
;
;DATE MODIFIED
;
;KIXTART       4.22+
;
;SYNTAX        GetDataBase(Table,Key,KeyValue,Colum)
;
;PARAMETERS    Table
;              Specifies the table.
;
;							 Key
;							 Specifies the Key or Keys of an table, "Machine" or "Machine;Virus".
;
;							 KeyValues
;							 The Values of the Key or Keys, "Machine1" or ""Machine1;LoveSan".
;
;							 Colum
;							 The colums which to get.
;
;RETURNS       the Value
;
;REMARKS       This function looks if an dabaseentry exits and gets the value.
;
;DEPENDENCIES  Function needed : "DBCOMMAND" by Jens Meyer (sealeopard@usa.net)
;
;EXAMPLE       GetDataBase("Virus","Machine;Virus","Machine1;LoveSan","Counter")
;
Function GetDataBase($Table,$Key,$KeyValue,$Colum)

$Key = Split($KEY,";")
$KeyValue = Split($KeyValue,";")
For $i = 0 To UBound($Key)
	If $i = 0
		$Select = $Key[$i] + " LIKE '" + $KeyValue[$i] + "'"
		$Keys = $Key[$i]
		$KeyValues =	 $KeyValue[$i]
	Else
		$Select = $Select + " AND " + $Key[$i] + " LIKE '" + $KeyValue[$i] + "' "
		$Keys = $Keys + ", " + $Key[$i]
		$KeyValues =	$KeyValues + "," + $KeyValue[$i]
	EndIf
Next

$sql="SELECT $Colum FROM $Table Where $Select"
$recordset = GetDBCommand($dsn,$sql)
IF @ERROR
	? "Error " + @Error
	$GetDataBase = 0
Else
	if UBound($recordset) => 0
		If $recordset[0,0] <> ""
		$GetDataBase = $recordset[0,0]
		else
			$GetDataBase = ""
		endif
	else
		$GetDataBase = ""
	endif
ENDIF
$recordset= ""
$Select = ""
$Keys = ""
$KeyValues = ""
$Colums = ""
$Value = ""
$sql = ""
EndFunction
   118766GetDefaultPrinter29JochenGetDefaultPrinter() - Returns default printer0 Code:

;FUNCTION         GetDefaultPrinter()
;
;AUTHOR           Jochen Polster (jochenDOTpolsterATgmxDOTnet)
;
;VERSION          1.0
;
;VERSION HISTORY  1.0 2004/04/28 Initial release
;
;ACTION           Retrieves the current default Printer
;
;SYNTAX           GetDefaultPrinter()
;
;PARAMETERS       none
;
;REMARKS          won't work with 9x OS
;
;RETURNS          The current Users default Printer
;
;DEPENDENCIES     None !
;
;EXAMPLES         $default = GetDefaultPrinter

function GetDefaultPrinter()
    $GetDefaultPrinter = join(split(readvalue("HKEY_USERS\"+@sid+"\Software\Microsoft\Windows NT\CurrentVersion\Windows","Device"),',',1),'')
endfunction

  84424GetDiskSize3755GavenGetDiskSize() - get the size of a disk in bytes0

code:

;  Function:     GetDiskSize()
;
;  Author:       Gaven Henderson, Gaven@GavDogg.net
;  
;  Action:       GetDiskSize will return the size of the specified disk in bytes.
;  
;  Syntax:       getdisksize([drive])
;
;  Parameter:    drive
;                   Specifies the drive letter of the disk you want the size of.
;
;  Version:      2.1
;
;  Post Date:    July 05, 2003
;
;  Revise Date:  September 09, 2003
;  
;  Returns:      Returns a double representing the size of the specified disk in
;                bytes.  If the disk can not be located, an empty spring is returned
;                along with an error code.
;  
;                @ERROR
;                   0 - successful, result returned
;                   x - error creating object or getting drive
;
;  KiXtart Ver:  Designed on 4.20 but should work on any version.
;
;  Dependencies: Windows Management Instrumentation or Windows Script Host
;
;  Example:      $size=getdisksize('c:')/1024
;                $percentfree=(CDBL(GetDiskSpace('c:'))/$size)*100
;                'Drive C: is ' FormatNumber(($size/1024),2) ' MB and has ' FormatNumber($percentfree,2) '%% free.'
;
Function getdisksize($a)
	Dim $b,$c
	If Exist(%windir%+'\system\wbem\winmgmt.exe') Or Exist(%windir%+'\system32\wbem\winmgmt.exe')
		$b=GetObject('WinMgmts:\root\cimv2').ExecQuery('Select Size From Win32_LogicalDisk Where Name="'+$a+'"')
		If @Error Exit @Error EndIf
		For Each $c In $b
			$getdisksize=CDbl($c.Size)
		Next
	Else
		$b=CreateObject('Scripting.FileSystemObject')
		If @Error Exit @Error EndIf
		$c=$b.GetDrive($b.GetDriveName($a))
		If @Error Exit @Error EndIf
		$getdisksize=CDbl($c.TotalSize)
		$c=0
	EndIf
	$b=0
EndFunction


 
 [ 09. September 2003, 08:38: Message edited by: Gaven ]186694GetDN5694WittoGetDN() - Get Distinguished Name starting from NetBios name0



;FUNCTION       GetDN  
;  
;ACTION         Get the Distinguished Name starting  
;               from the NetBios name of an object ($strNetBiosName) 	 
;               and the NteBios name of the domain ($strDomain) using  
;               name translate  
;                 
;AUTHOR         Wim Rotty  
;  
;CONTRIBUTORS  
;  
;VERSION        1.0.1  
;  
;DATE CREATED   2008-04-03  
;  
;DATE MODIFIED  2008-04-04  
;               1.0.1 Removed Goto's for error handling  
;  
;KIXTART        4.xx  
;  
;SYNTAX         GetDN($strNetBiosName, $strDomain, Optional $Computer)  
;  
;PARAMETERS     $strNetBiosName  
;               NetBios name that has to be converted to the Distinguished Name  
;               The name can be a: 
;               - Computer 
;               - User 
;               - Group 
;  
;               $strDomain  
;               NetBios Name of the domain the object is part of  
;  
;               $Computer  
;               Optional  
;               Set this parameter to 1 or "True" if the object is a Computer  
;               Set this parameter to 0, "False" or don't set a value  
;                                  If the object is a User Or a Group  
;  
;RETURNS        Distinguished Name for the NetBios Name  
;               Error  Value is set if function fails  
;  
;REMARKS          
;  
;DEPENDENCIES   none  
;  
;EXAMPLE          
;  
;               Break On 
;                
;               ; Get the NETBIOS name of the domain 
;               $objSystemInfo = CreateObject("ADSystemInfo")  
;               $strDomain = $objSystemInfo.DomainShortName 
;                
;               ; Get the name of the computer 
;               $objNetwork = CreateObject("Wscript.Network") 
;               $strNetBiosName = $objNetwork.ComputerName 
;                
;               ; Call function to return the distinguished name (DN) of the NetBios name 
;               $strDN = getDN($strNetBiosName,$strDomain,1) 
;                
;               ? $strDN 
;               If @ERROR 
;               	? "Error " @ERROR ": " @SERROR 
;               EndIf 
;  
;KIXTART BBS    http://www.kixtart.org/forums/ubbthreads.php?ubb=showflat&Number=186694#Post186694  
;  
Function getDN($strNetBiosName, $strDomain, Optional $Computer)
	
	;;;;;;;;;;;;;;;;;;;;; 
	; Declare variables ; 
	;;;;;;;;;;;;;;;;;;;;; 
	
	; Constants required for name translate 
	Dim $ADS_NAME_INITTYPE_GC
	Dim $ADS_NAME_TYPE_NT4
	Dim $ADS_NAME_TYPE_1779
	
	; Variable to set an error for the function 
	Dim $Error
	
	; Variable to create object to translate the name 
	Dim $objTrans
	
	;;;;;;;;;;;;;;;;;;;;;;;; 
	; Initialize variables ; 
	;;;;;;;;;;;;;;;;;;;;;;;; 
 
	; Constants required for name translate 
	$ADS_NAME_INITTYPE_GC = 3
	$ADS_NAME_TYPE_NT4 = 3
	$ADS_NAME_TYPE_1779 = 1
	
	; Variable to set an error for the function 
	$Error = 0
	
	;;;;;;;; 
	; Code ; 
	;;;;;;;; 
	
	; Create NameTranslate object 
	$objTrans = CreateObject("NameTranslate")
	;If error occurred during creation, set error 
	If @ERROR <> 0
		$Error = @ERROR
	EndIf
	
	If $Error = 0	
		; Initialize name translate using global catalog 
		$objTrans.Init($ADS_NAME_INITTYPE_GC, "")
		;If error occurred during creation, set error 
		If @ERROR
			$Error = @ERROR
		EndIf
	EndIf
	
	If $Error = 0
		Select
			Case LCase($Computer) = "true" Or $Computer = 1
				; Input computer name (NT Format), add trailing $-sign 
				$objTrans.Set($ADS_NAME_TYPE_NT4, $strDomain + "\" + $strNetBiosName + Chr(36))
			Case LCase($Computer) = "false" Or $Computer = 0 Or $Computer = ""
				; Input group or user name (NT Format) 
				$objTrans.Set($ADS_NAME_TYPE_NT4, $strDomain + "\" + $strNetBiosName)
			Case 1
				; Value for Parameter $Computer is not correct 
				$Error = 87
		EndSelect
		;If error occurred, set error 
		If @ERROR
			$Error = @ERROR
		EndIf
	EndIf
	
	If $Error = 0
		; Get Distinguished Name. 
		$getDN = $objTrans.Get($ADS_NAME_TYPE_1779)
		; If error occurred during getting name, set error 
		If @ERROR
			$Error = @ERROR
		EndIf
	EndIf
	
	$objTrans = ""
	Exit $Error
	
EndFunction
 
160880GetExtFileProperties3439AllenGetExtFileProperties() - Get Extended File Properties / Attributes of Files1172951112

;Function:  
; GetExtFileProperties() 
;  
;Author:  
; Allen Powell  
;  
;Version: 
; 1.2.0 
; 
;Version History  
; 1.2.0 2007/03/02 Updated to work with Vista, can now use the name or number of the Attribute/Property 
; 1.0.1 2006/11/18 Updated with a more efficient method of determining the same information 
; 1.0.0 2006/04/18 Original  
;  
;Action:  
; Get Extended File Properties / Attributes of Files  
; 
;Syntax:  
; GetExtFileProperties($FQFN, $attribute) 
;  
;Parameters:  
; $FQFN - (Required) Full Path Name and File name 
; $attribute - (Required) Number or Name from Attribute Table below.   
; 
;Returns: 
; String of Attribute(s) or nothing if there is an error.  Check @error for problems. 
; 
;Dependencies 
;  Tested with Kixtart 4.53 
; 
;Examples: 
;Using Windows XP and Attribute Number 
;$MP3="C:\MP3s\Ac--Dc - Back In Black.mp3" 
;$duration=GetExtFileProperties($mp3,21)  
;? $duration 
; 
;Using Windows XP and Attribute Name 
;$MP3="C:\MP3s\Ac--Dc - Back In Black.mp3" 
;$duration=GetExtFileProperties($mp3,"Duration")  
;? $duration 
; 
;Using Windows Vista and Attribute Name 
;$MP3="C:\MP3s\Ac--Dc - Back In Black.mp3" 
;$duration=GetExtFileProperties($mp3,"Length")  
;? $duration 
; 
;Comments: 
;  Please notice that attributes are specific to the OS.  This means that not only can the  
;  Attribute number be different from one OS to the next, but the Attribute Name can be 
;  different as well.  As in the examples above, in Windows XP, the duration of the song was  
;  called "Duration, but in Vista it's called "Length".  Thanks MS.   
; 
function GetExtFileProperties($FQFN, $attribute)
  dim $objShell, $objFolder,$i,$found
  if exist($FQFN)
    $objShell=CreateObject("Shell.Application")
    $objFolder=$objShell.Namespace(left($FQFN,instrrev($FQFN,"\")))
    if $objFolder
      if vartypename($attribute)="string"
        While $i<267 and $found=0
          if $attribute=$objFolder.GetDetailsOf($objFolder.Items, $i)
            $attribute=$i
            $found=1
          endif
          $i=$i+1
        loop
      endif 
      if vartypename($attribute)="long" ; Number 
        $GetExtFileProperties=$objFolder.GetDetailsOf($objFolder.ParseName(right($FQFN,len($FQFN)-instrrev($FQFN,"\"))),$attribute)
      else
        exit -1 
      endif
    else
      exit @error
    endif
  else
    exit 2
  endif
endfunction
; 
;Attribute tables 
; 
;Windows XP 
;Windows Server 2003 	Windows 2000  
;------------------------------------------- 
;0 Name			Name  
;1 Size			Size  
;2 Type			Type  
;3 Date Modified	Date Modified  
;4 Date Created		Attributes  
;5 Date Accessed	Comment  
;6 Attributes 		Date Created  
;7 Status 		Date Accessed  
;8 Owner 		Owner  
;9 Author 		???  
;10 Title 		Author  
;11 Subject 		Title  
;12 Category 		Subject  
;13 Pages 		Category  
;14 Comments 		Pages  
;15 Copyright 		Copyright  
;16 Artist 		Company Name  
;17 Album Title		Module Desription  
;18 Year 		Module Version  
;19 Track Number 	Product Name  
;20 Genre 		Product Version  
;21 Duration 		Sender Name  
;22 Bit Rate 		Recipient Name  
;23 Protected 		Recipient Number  
;24 Camera Model 	Csid  
;25 Date Picture Taken	Tsid  
;26 Dimensions 		Transmission Time  
;27 ??? 		Caller Id  
;28 ??? 		Routing  
;29 Episode Name	Audio Format  
;30 Program Description	Sample Rate  
;31 Description		Audio Sample Size  
;32 Audio sample size 	Channels  
;33 Audio sample rate 	Play Length  
;34 Channels	 	Frame Count  
;35 Company		Frame Rate  
;36 Description		Video Sample Size  
;37 File Version	Video Compression  
;38 Product Name	??? 
;39 Product Version	??? 
;40 Keywords (XP only)	??? 
; 
; 
;Windows Vista 
;------------------------------------------------ 
;  0 Name 
;  1 Size 
;  2 Type 
;  3 Date modified 
;  4 Date created 
;  5 Date accessed 
;  6 Attributes 
;  7 Offline status 
;  8 Offline availability 
;  9 Perceived type 
; 10 Owner 
; 11 Kinds 
; 12 Date taken 
; 13 Artists 
; 14 Album 
; 15 Year 
; 16 Genre 
; 17 Conductors 
; 18 Tags 
; 19 Rating 
; 20 Authors 
; 21 Title 
; 22 Subject 
; 23 Categories 
; 24 Comments 
; 25 Copyright 
; 26 # 
; 27 Length 
; 28 Bit rate 
; 29 Protected 
; 30 Camera model 
; 31 Dimensions 
; 32 Camera maker 
; 33 Company 
; 34 File description 
; 35 Program name 
; 36 Duration 
; 37 Is online 
; 38 Is recurring 
; 39 Location 
; 40 Optional attendee addresses 
; 41 Optional attendees 
; 42 Organizer address 
; 43 Organizer name 
; 44 Reminder time 
; 45 Required attendee addresses 
; 46 Required attendees 
; 47 Resources 
; 48 Free/busy status 
; 49 Total size 
; 50 Account name 
; 51 Computer 
; 52 Anniversary 
; 53 Assistant's name 
; 54 Assistant's phone 
; 55 Birthday 
; 56 Business address 
; 57 Business city 
; 58 Business country/region 
; 59 Business P.O. box 
; 60 Business postal code 
; 61 Business state or province 
; 62 Business street 
; 63 Business fax 
; 64 Business home page 
; 65 Business phone 
; 66 Callback number 
; 67 Car phone 
; 68 Children 
; 69 Company main phone 
; 70 Department 
; 71 E-mail Address 
; 72 E-mail2 
; 73 E-mail3 
; 74 E-mail list 
; 75 E-mail display name 
; 76 File as 
; 77 First name 
; 78 Full name 
; 79 Gender 
; 80 Given name 
; 81 Hobbies 
; 82 Home address 
; 83 Home city 
; 84 Home country/region 
; 85 Home P.O. box 
; 86 Home postal code 
; 87 Home state or province 
; 88 Home street 
; 89 Home fax 
; 90 Home phone 
; 91 IM addresses 
; 92 Initials 
; 93 Job title 
; 94 Label 
; 95 Last name 
; 96 Mailing address 
; 97 Middle name 
; 98 Cell phone 
; 99 Nickname 
;100 Office location 
;101 Other address 
;102 Other city 
;103 Other country/region 
;104 Other P.O. box 
;105 Other postal code 
;106 Other state or province 
;107 Other street 
;108 Pager 
;109 Personal title 
;110 City 
;111 Country/region 
;112 P.O. box 
;113 Postal code 
;114 State or province 
;115 Street 
;116 Primary e-mail 
;117 Primary phone 
;118 Profession 
;119 Spouse 
;120 Suffix 
;121 TTY/TTD phone 
;122 Telex 
;123 Webpage 
;124 Status 
;125 Content type 
;126 Date acquired 
;127 Date archived 
;128 Date completed 
;129 Date imported 
;130 Client ID 
;131 Contributors 
;132 Content created 
;133 Last printed 
;134 Date last saved 
;135 Division 
;136 Document ID 
;137 Pages 
;138 Slides 
;139 Total editing time 
;140 Word count 
;141 Due date 
;142 End date 
;143 File count 
;144 Filename 
;145 File version 
;146 Flag color 
;147 Flag status 
;148 Space free 
;149 Bit depth 
;150 Horizontal resolution 
;151 Width 
;152 Vertical resolution 
;153 Height 
;154 Importance 
;155 Is attachment 
;156 Is deleted 
;157 Has flag 
;158 Is completed 
;159 Incomplete 
;160 Read status 
;161 Shared 
;162 Creator 
;163 Date 
;164 Folder name 
;165 Folder path 
;166 Folder 
;167 Participants 
;168 Path 
;169 Contact names 
;170 Entry type 
;171 Language 
;172 Date visited 
;173 Description 
;174 Link status 
;175 Link target 
;176 URL 
;177 Media created 
;178 Date released 
;179 Encoded by 
;180 Producers 
;181 Publisher 
;182 Subtitle 
;183 User web URL 
;184 Writers 
;185 Attachments 
;186 Bcc addresses 
;187 Bcc names 
;188 Cc addresses 
;189 Cc names 
;190 Conversation ID 
;191 Date received 
;192 Date sent 
;193 From addresses 
;194 From names 
;195 Has attachments 
;196 Sender address 
;197 Sender name 
;198 Store 
;199 To addresses 
;200 To do title 
;201 To names 
;202 Mileage 
;203 Album artist 
;204 Beats-per-minute 
;205 Composers 
;206 Initial key 
;207 Mood 
;208 Part of set 
;209 Period 
;210 Color 
;211 Parental rating 
;212 Parental rating reason 
;213 Space used 
;214 EXIF version 
;215 Event 
;216 Exposure bias 
;217 Exposure program 
;218 Exposure time 
;219 F-stop 
;220 Flash mode 
;221 Focal length 
;222 35mm focal length 
;223 ISO speed 
;224 Lens maker 
;225 Lens model 
;226 Light source 
;227 Max aperture 
;228 Metering mode 
;229 Orientation 
;230 Program mode 
;231 Saturation 
;232 Subject distance 
;233 White balance 
;234 Priority 
;235 Project 
;236 Channel number 
;237 Episode name 
;238 Closed captioning 
;239 Rerun 
;240 SAP 
;241 Broadcast date 
;242 Program description 
;243 Recording time 
;244 Station call sign 
;245 Station name 
;246 Auto summary 
;247 Summary 
;248 Search ranking 
;249 Sensitivity 
;250 Shared with 
;251 Product name 
;252 Product version 
;253 Source 
;254 Start date 
;255 Billing information 
;256 Complete 
;257 Task owner 
;258 Total file size 
;259 Legal trademarks 
;260 Video compression 
;261 Directors 
;262 Data rate 
;263 Frame height 
;264 Frame rate 
;265 Frame width 
;266 Total bitrate 
 

 
83296GETFILEAGE583CollinGETFILEAGE() - get the nr. of days since a file was last modified0

code:

 ; Function GETFILEAGE()
 ; Author Collin van Raam (cfvr A T dds.nl) ;
 ; Version 2.0 (03-07-2002)
 ;
 ; Action: Returns the number of days since a file was last modified
 ;
 ; Syntax: GETFILEAGE($file)
 ;
 ; Parameters:
 ; $file - full path to the file
 ;
 ; Dependencies
 ; kixtart 4.x
 ;
 ; Examples
 ; 
 ; IF GETFILEAGE( "\\Server\Share\Inventory\MyPC.txt" ) > 7
 ;    ? "Inventory is older than 7 days, inventory is starting.."
 ;    CALL "Inventory.kix"
 ; ENDIF
 ;
 ; Source:
FUNCTION GETFILEAGE( $File )

$FileYear = SUBSTR( GETFILETIME( $File ) , 1 , 4 )
$FileMonth = SUBSTR( GETFILETIME( $File ) , 6 , 2 )
$FileDay = SUBSTR( GETFILETIME( $File ) , 9 , 2 )
$Day = SUBSTR( @DATE , 9 , 2 )

IF SUBSTR( $FileMonth , 1 , 1 ) = "0"
	$FileMonth = SUBSTR( $FileMonth , 2 , 1 )
ENDIF

$MonthDays = 0,0,31,59,90,120,151,181,212,243,273,304,334

$Counter = 1
WHILE $Counter <= UBOUND($MonthDays)
	IF $FileMonth = $Counter
		$FileYearDay = $MonthDays[$Counter] + $FileDay
	ENDIF

	IF @MONTHNO = $Counter
		$YearDay = $MonthDays[$Counter] + $Day
	ENDIF

	$Counter = $Counter + 1
LOOP

$GetFileAge = ((VAL(@YEAR)*365)+$YearDay) - ((VAL($FileYear)*365)+$FileYearDay)

ENDFUNCTION

Should work on all Operating systems     
 
 [ 10. September 2003, 15:33: Message edited by: Collin ]84383GetFileAgeMinutes3755GavenGetFileAgeMinutes() - Get the age of a file in minutes0

code:

;  Function:     GetFileAgeMinutes()
;
;  Author:       Gaven Henderson, Gaven@GavDogg.net
;  
;  Action:       GetFileAgeMinutes will return the age of a file in minutes.
;  
;  Syntax:       getfileageminutes("filename")
;
;  Version:      2.0
;
;  Post Date:    June 26, 2003
;
;  Revise Date:  June 26, 2003
;  
;  Returns:      Returns an integer representing the age of the specified file in
;                minutes.  If the file can not be located, an empty spring is returned.
;  
;                @ERROR
;                   0 - successful, result returned
;                   x - error x opening file
;
;  KiXtart Ver:  Designed on 4.20 but should work on any version.
;
Function getfileageminutes($file)
	Dim $x,$y,$m,$d,$hr,$mn,$y2,$m2,$d2,$hr2,$mn2
	$x=GetFileTime($file)
	If @Error Exit @Error EndIf
	$y=Val(@Year)
	$m=Val(@MonthNo)
	$d=Val(@MDayNo)
	$hr=Val(Left(@Time,2))
	$mn=Val(SubStr(@Time,4,2))
	$y2=Val(Left($x,4))
	$m2=Val(SubStr($x,6,2))
	$d2=Val(SubStr($x,9,2))
	$hr2=Val(SubStr($x,12,2))
	$mn2=Val(SubStr($x,15,2))
	if $m<3
		$m=$m+12
		$y=$y-1
	endif
	if $m2<3
		$m2=$m2+12
		$y2=$y2-1
	endif
	$getfileageminutes=((($d+(153*$m-457)/5+365*$y+$y/4-$y/100+$y/400-306)-($d2+(153*$m2-457)/5+365*$y2+$y2/4-$y2/100+$y2/400-306))*1440)+(($hr-$hr2)*60)+($mn-$mn2)
EndFunction


 
 [ 28. June 2003, 10:42: Message edited by: Gaven ]82854GetFileExt17SealeopardGetFileExt() - Returns the filename's extension0

code:

;FUNCTION      GetFileExt
;
;ACTION        Returns the filename's extension
;
;AUTHOR        Jens Meyer, Jooel Nieminen
;
;CONTRIBUTORS  ScriptLogic
;
;VERSION       2.0 (recoded SPLITS based on Jooels suggestions)
;              1.2 (enhanced ScriptLogic function)
;
;DATE CREATED  2002/01/18
;
;DATE MODIFIED 2003/07/06
;
;KIXTART       4.21
;
;SYNTAX        GETFILEEXT(FILE)
;
;PARAMETERS    FILE
;              The filename you wish to extract the extension from
;
;REMARKS       Based on the Scriptlogic function GetFileExt at
;              http://www.scriptlogic.com/kixtart/FunctionLibrary_ViewFunction.aspx?ID=GetFileExt
;
;DEPENDENCIES  none
;
;RETURNS       Returns the filename's extension extracted from the filespec. If there is
;              no extension, an empty string is returned.
;
;EXAMPLE       $extension=getfileext('c:\temp\myfile.txt')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000144
;
function getfileext($file)
  $file=split($file,'\')
  $file=split($file[ubound($file)],'.')
  $getFileExt=iif(ubound($file),$file[ubound($file)],'')
endfunction


 
 [ 07. July 2003, 03:46: Message edited by: sealeopard ]82586GetFilePath17SealeopardGetFilePath() - Returns the path-only portion of a given filespec0

code:

;FUNCTION      GetFilePath
;
;AUTHOR        ScriptLogic
;              Modified by Jens Meyer to return path folders an an array
;
;ACTION        Returns the path-only portion of a given file
;
;VERSION       1.3
;
;KIXTART       4.12
;
;SYNTAX        GETFILEPATH(FILENAME [,SEGMENTS])
;
;PARAMETERS    FILENAME
;              Required string containing the filespec (path+filename) you wish to extract the path from
;
;              SEGMENTS
;              Optional boolean indicating whether to return the path folders as an array
;
;RETURNS       filepath, otherwise an empty string
;
;REMARKS       Base on a scriptLogic function pasted at
;              http://www.scriptlogic.com/kixtart/FunctionLibrary_ViewFunction.aspx?ID=GetFilePath
;
;DEPENDENCIES  none
;
;EXAMPLE       $filepath = GETFILEPATH('c:\temp\myfile.txt')
;              $filepath = GETFILEPATH('c:\temp\myfile.txt',1)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000091
;
function getfilepath($filespec, optional $seg)
  if instr($filespec,'\')
    $getfilepath=split($filespec,'\')
    redim preserve $getfilepath[ubound($getfilepath)-1]
    if not val($seg)
      $getfilepath=join($getfilepath,'\')
    endif
  else
    $getfilepath=''
  endif
endfunction


 
 [ 02. March 2003, 20:20: Message edited by: sealeopard ]134443GetFolderDate3439AllenGetFolderDate() - Returns the date and time of a folder/directory1129938496Code:

;Function:  
; GetFolderDate(),  
;  
;Authors 
;Allen Powell  
;  
;Contributors 
;Glenn Barnas 
; 
;Version:  
; 1.1 
;  
;Action:  
; Gets the folder date and time 
; 
;Returns: 
;A string in the format of "YYYY/MM/DD HH:MM:SS" 
;  
;Syntax:  
; GetFolderDate($Folder) 
;  
;Parameters:  
; $Folder  Required. Name of directory.  To get the size of a remote directory, you must use an  
;          administrative share ("\\computername\c$\directory")  
;DEPENDENCIES  
;FSO (File System Object) 
; 
;Examples:  
; $folderdate=getfolderdate("c:\windows") 
; $folderdate=getfolderdate("\\remotepc\c$\windows") 
; 
; 
function getfolderdate($Folder)
  dim $datetime,$date,$time
  if right($Folder,1)="\"
    $Folder=substr($Folder,1,len($Folder)-1)
  endif
  if exist($Folder)
    $datetime=CreateObject("Scripting.FileSystemObject").getfolder($Folder).DateLastModified
    if @error=0
      $date=split($datetime," ")[0]
      $date=split($date,"/")[2] + "/" + right("0" + split($date,"/")[0],2) + "/" + right("0" + split($date,"/")[1],2)
      $time=split($datetime," ")[1]
      if right($datetime,2)="PM"
        $time="" + (val(split($time,":")[0])+12) + ":" + split($time,":")[1] + ":" + split($time,":")[2]
      endif
      $getfolderdate=$date + " " + $time    
    else
      exit @error
    endif
  else
    exit 2
  endif
endfunction
 

 

84560GetFreeSpace46kholmGetFreeSpace() - Get free space on remote drives where server sevice is not running0;Function:
;	GetFreeSpace()
;
;Author:
;	Kholm
;
;Version:
;	1.0 (17th of september 2003)
;
;Action: Returns available space on diskdrives on remote workstations (where the server service is NOT started)
;
;Syntax GetFreeSpace($WS,$Drive)
;
;Parameters:
; - $WS    = Name of remote workstation
; - $Drive = Driveletter for drive to be checked
;
;Returns: Free space on selected ws/drive
;
;Dependencies: WMI
;
;Remarks:
;	OBSERVE: You should use the KiXtart function: GetDiskSpace('\\' + $Computer + '\' + $Drive + '$$')
;	If the server service is startet on the workstation you want to check,
;
;Example:
;	$Free = GetFreeSpace('WS02','C')
;	'Free space on drive C: on workstation WS02 is: ' + $Free
;
;Source:

code:

Function GetFreeSpace($Computer,$Drive)
	Dim $oComputer,$cItems,$oItem
	$oComputer = GetObject("winmgmts:\\" + $Computer + "\root\cimv2")
	$cItems = $oComputer.ExecQuery("Select * from Win32_LogicalDisk where DeviceID='$Drive:'")
	For Each $oItem In $cItems
		$GetFreeSpace = 0.0009765625 * $oItem.FreeSpace
	Next
EndFunction

A small explanation to the code:
0.0009765625 is the same as 1 / 1024

This is for converting the result returned from bytes to kilobytes, and in the same run converting it to a double for KiX

-Erik114575GetFSavDate119LonkeroGetFSavDate() - retrieve FSecure AV's Def date0 Code:


;Function

;	GetFSavDate() 

; 

;Author

;	Lonkero 

; 

;Action

;	Returns the current definition date of F-secure AV product installed 

; 

;Syntax

;	GetFSavDate() 

; 

;Version

;	1.0 (2004-Feb-23)

; 

;Parameters

;	None 

; 

;Remarks

;	Tested only with FS AV client and FS AV for Internet Gateways

;	 but same technique seems to be suitable at least for all products under

;	 windows platform.

;

;Returns

;	F-Secure AV Def date 

; 

;Dependencies

;	None 

; 

;Example

; 

;	 ? 'Definition files are dated ' + GetFSavDate

;	get $

;

;Source

Function GetFSavDate() 

 Dim $,$bk,$e,$sk

 $bk="HKLM\SOFTWARE\Data Fellows\F-Secure"

 do

  $sk=enumkey($bk,$e)

  $ = ReadValue($bk+"\"+$sk, 'Path')

  if len($) and exist($+"\header.ini")

   $GetFSavDate=join(split(split(readprofilestring($+"\header.ini","FSAV_Database_Version","Version"),"_")[0],"-"),"/")

   $sk=""

  endif

 $e=$e+1

 until not len($sk)

EndFunction 

  83438GetGroups172Howard BullockGetGroups() - Another group UDF with a slight twist0


;FUNCTION GetGroups()
;
;VERSION 1.0
;
;AUTHOR Howard A. Bullock (habullock@comcast.net)
;
;ACTION Retrieves groups to which the specified account is a member.
;
;SYNTAX GetGroups($Domain, $Account, optional $Suppress)
;
;PARAMETERS $Domain (Required) - String value
; $Account (Required) - String value
; $Suppress (Optional) - Integer value [0|1] Default = 0
;
;REMARKS When a non-zero value is supplied for $Suppress, The screen output
; is omitted.
;
; Note: ADS_GROUP_TYPE_SECURITY_ENABLED is not shown using WinNT://
; only security groups exists in NT4 (WinNT://)
;
;RETURNS Two-Dimensional Array.
; 0,x = Group Name
; 1,x = Group Type
; x = number of groups
;
;DEPENDENCIES KiXtart 4.11
;
;EXAMPLES $Groups = GetGroups("Domain", @wksta + "$$") for the computer account
; $Groups = GetGroups("Domain", "User1") for a user account
;
Function GetGroups($Domain, $Account, optional $Suppress)

; Group Types
; ADS_GROUP_TYPE_GLOBAL_GROUP = 0x00000002,
; ADS_GROUP_TYPE_DOMAIN_LOCAL_GROUP = 0x00000004,
; ADS_GROUP_TYPE_LOCAL_GROUP = 0x00000004,
; ADS_GROUP_TYPE_UNIVERSAL_GROUP = 0x00000008,
; ADS_GROUP_TYPE_SECURITY_ENABLED = 0x80000000

; 

Dim $Groups[1,0], $i, $x, $Type[8]
$Type[2] = "GLOBAL_GROUP"
$Type[4] = "LOCAL_GROUP"
$Type[8] = "UNIVERSAL_GROUP"
$oAccount=getobject("WinNT://$Domain/$Account,user")

$x = -1
For Each $group In $oAccount.Groups
$x = $x + 1
ReDim Preserve $Groups[1,$x]
; Class is always 'Group'
; $class = $group.Class
$Groups[0,$x] = $group.Name
$Groups[1,$x] = $Type[$group.groupType]
Next

$GetGroups = $Groups
if not $Suppress
$x = ubound($Groups,2)
? $Domain + "\" + $Account + " is a member of " + ($x+1) + " groups."
For $i=0 to $x
? " '" + $Groups[0,$i] + "' (" + $Groups[1,$i] + ")"
Next
Endif
EndFunction 


 
 [ 05. April 2003, 17:52: Message edited by: Howard Bullock ]83149GetGUID415Christopher HillGetGUID() - Retrieves the local computer's GUID0

code:

;Function	GetGUID()
;
;Author		Christopher Hill (minkus@ntlworld.com)
;
;Action		Retrieve's the local computer's GUID
;
;Syntax		GetGUID()
;
;Parameters 	None
;
;Remarks 	The GUID is stored in the BIOS of PC98 compliant computers.
;			System administrators wanting to deploy Windows 2000 using
;			Remote Installation Services will want this value if they
;			are pre-staging clients in the Active Directory.
;			Uses WMI to retrieve the value. See Q302467 for more details.
;			Strikes me that this might make a nice built in KiXtart macro...
;
;			UPDATED: Now returns a MAC address based GUID for computers
;			that have no GUID stored in their BIOS, or for computers
;			that run Windows 9x
;
;			UPDATED: Now returns a MAC address based GUID for computers
;			that return a GUID of all zeros as well
;
;Returns 	Returns the GUID of the local computer.
; 
;Dependencies 	Requires Windows 2000/XP/NT4SP4 (or later) to retrieve BIOS GUID
;			Will provide MAC address based GUID on 9x clients
;
;Example(s)		$guid = GetGUID()
;
;Source

			Function GetGUID()
				If @InWin = 1
					$SystemSet = GetObject("winmgmts:").ExecQuery("select UUID from Win32_ComputerSystemProduct")

					For Each $SystemItem in $SystemSet
						$GetGUID = $SystemItem.UUID
					Next

					If $GetGUID = "FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF" Or $GetGUID = "00000000-0000-0000-0000-000000000000"
						$GetGUID = "00000000-0000-0000-0000-@Address"
					Endif
				Else
					$GetGUID = "00000000-0000-0000-0000-@Address"
				Endif
			EndFunction


 
 [ 29 May 2002, 10:28: Message edited by: Christopher Hill ]84332GetIEAutoDetect1642AbqBillGetIEAutoDetect() - returns IE's "Automatically detect settings" option0

code:

; Function      GetIEAutoDetect()
;
; Author        Bill Stewart (bill.stewart@frenchmortuary.com)
;
; Contributors  See http://omega.barnet.ac.uk/~polsy/ieauto.c (author unknown)
;
; Action        Returns the "Automatically detect settings" check box for IE
;
; Syntax        GetIEAutoDetect()
;
; Version       1.0
;
; Date          28 May 2003
;
; Date Revised  28 May 2003
;
; Parameters    None
;
; Remarks       Returns the setting based on the appropriate bit in the
;               registry setting HKCU\Software\Microsoft\Windows\
;               CurrentVersion\Internet Settings\Connections\
;               DefaultConnectionSettings (REG_BINARY).
;
; Returns       1 if the auto detect is enabled; 0 if disabled; -1 on error
;
; Dependencies  None
;
; KiXtart Ver   4.12
;
; Example(s)    $rc = GetIEAutoDetect()

function GetIEAutoDetect()
  dim $subkey, $value, $rc

  $subkey = "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections"
  $value = readvalue($subkey, "DefaultConnectionSettings")
  if @error = 0
    $rc = (val(substr($value, 18, 1)) & 8) <> 0
  else
    $rc = -1
  endif
  $GetIEAutoDetect = $rc
endfunction

84572GetIEVersion52NTDOCGetIEVersion() - Returns information about Internet Explorer0


;Function        GetIEVersion(optional $what,optional $remotepc) 

; 

;Author          NTDOC/Ron Lewis (ntdoc@@@@@kixhelp.com) 

; 

;Contributors    Based on script by Bill Leonard 

;                http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=1&t=003748 

; 

;Action          Returns information about Internet Explorer locally and remotely 

; 

;Syntax          GetIEVersion() or GetIEVersion(6,'someworkstation') 

; 

;Version         1.3 

; 

;Date            2003-Sep-27 

; 

;Date Revised    2003-Oct-01 

; 

;Revision Reason Added requests from other board members. 

;                1. Added newer versions per Masken 

;                2. Removed Q reference per Kent 

;                3. Added Path and Language (not request, but good idea, from Erik) 

;                4. Added argument request per Lonkero's request and code. 

;                5. Added remote support request by Al and Lonkero 

;                rev 1.3 to correct missing values per request by PRandal 

; 

; 

;Parameters      GetIEVersion(optional $what)   ie... GetIEVersion(4) would return Full Version 

;                0-9 parameters supported 

; 

;                Major Version:         0 

;                Minor Version:         1 

;                Build:                 2 

;                Sub Build:             3 

;                Full Version:          4 

;                Version:               5 

;                Name:                  6 

;                Customized String:     7 

;                Install Path:          8 

;                Language:              9 

; 

; 

;Remarks         Remote test on Win9x failed, but works on NT/2000/XP/2003 

; 

;Returns         Returns an array of values pertaining to Internet Explorer's version 

; 

;Dependencies    None 

; 

;KiXtart Ver     Written and tested with KiXtart v4.21 on NT/2000/XP 

; 

; 

;Example(1) 

; 

;                DEBUG OFF 

;                BREAK OFF 

;                DIM $iRC,$IE 

;                $iRC=SETOPTION('Explicit','ON') 

;                $iRC=SETOPTION('NoVarsInStrings','ON') 

;                $iRC=SETOPTION('WrapAtEOL','ON') 

;                $IE = GetIEVersion(,'remote-or-local-workstation') 

; 

;                ? 'IE Major Version: '+$IE[0] 

;                ? 'IE Minor Version: '+$IE[1] 

;                ? 'IE Build: '+$IE[2] 

;                ? 'IE Sub Build: '+$IE[3] 

;                ? 'IE Full Version: '+$IE[4] 

;                ? 'IE Ver: '+$IE[5] 

;                ? 'IE Name: '+$IE[6] 

;                ? 'IE Customized Version: '+$IE[7] 

;                ? 'IE Install Path: '+$IE[8] 

;                ? 'IE Language: '+$IE[9] 

; 

;Example(2)      $IE = GetIEVersion(6,'remote-or-local-workstation') 

;                ? 'IE Name: '+$IE 

; 

; 

;Source 



Function GetIEVersion(optional $what,optional $remotepc)

DIM $RC1,$RC2,$RC3,$IECustom,$TmpLen1,$TmpLen2,$TmpLen3,$IEMajor,$IEMinor,$IEBuild,$IESubBd,$IEFullVer,$IEVer,$IEName

DIM $IEArray[10],$IEPath,$IELang,$key

; **  Confirm Internet Explorer installed on system  (See MS TechNet article 164539) 

; **  http://support.microsoft.com/default.aspx?scid=kb;en-us;164539 

; **  Format of IE Version numbers: x.xx.xxxx.xxxx  (Major.Minor.Build.SubBuild) 

  if len($remotepc) $remotepc=iif("\\"=left($remotepc,2),$remotepc,"\\"+$remotepc)+"\" endif

  $key=$remotepc + 'HKLM\Software\Microsoft\Internet Explorer'

  $IEPath=SPLIT(ReadValue($remotepc + 'HKCR\CLSID\{0002DF01-0000-0000-C000-000000000046}\LocalServer32',''),'"',-1)

  $IELang=SUBSTR(GetFileVersion(Join($IEPath,''),'Language'),5)

  $RC1 = READVALUE ($key, 'Build')

  ; REM **  IE3 onward  (s/b build only, or xxxxx.xxxx) 

  $RC2 = READVALUE ($key, 'Version')

  ; REM **  IE4 or later only  (s/b xx.xx.xxxx.xxxx) 

  $RC3 = READVALUE ($key, 'IVer')

  ; REM **  IE3 only  (s/b xxx) 

  $IECustom = READVALUE ($key, 'CustomizedVersion')

  ; REM **  IE4 or later only: (IC = Internet Content Provider IS = Internet Service Provider CO = Corporate Administrator ) 

  $TmpLen1 = LEN ($RC1)

  $TmpLen2 = LEN ($RC2)

  $TmpLen3 = LEN ($RC3)

SELECT

    CASE ($TmpLen1 = 5) AND (SUBSTR ($RC2, 4, 1) = '.')

    ; REM **  IE6 (WinXP) - MS error w/IE 6 where minor id is single charcter, and build value only 5 characters 

      $IEMajor = SUBSTR ($RC2, 1, 1)

      $IEMinor = SUBSTR ($RC2, 3, 1) + '0'

      $IEBuild = SUBSTR ($RC2, 5, 4)

      $IESubBd = SUBSTR ($RC2, 10, $TmpLen2-9)

      $IEFullVer = $IEMajor + '.' + $IEMinor + '.' + $IEBuild + '.' + $IESubBd

    CASE ($TmpLen1 = 10) AND (SUBSTR ($RC2, 4, 1) = '.')

    ; REM **  IE6 (Win2K) - MS error w/IE 6 where minor id is single charcter 

      $IEMajor = SUBSTR ($RC2, 1, 1)

      $IEMinor = SUBSTR ($RC2, 3, 1) + '0'

      $IEBuild = SUBSTR ($RC2, 5, 4)

      $IESubBd = SUBSTR ($RC2, 10, $TmpLen2-9)

      $IEFullVer = $IEMajor + '.' + $IEMinor + '.' + $IEBuild + '.' + $IESubBd

    CASE ($TmpLen1 = 14) OR ($TmpLen2 >= 11)

    ; REM **  IE5/IE4 - 14 is MS error w/IE 5.01 SP1 for Win2K, >=11 for various IE4, 5 versions not 14-character 

      $IEFullVer = $RC2

      $IEMajor = SUBSTR ($RC2, 1, 1)

      $IEMinor = SUBSTR ($RC2, 3, 2)

      $IEBuild = SUBSTR ($RC2, 6, 4)

      $IESubBd = SUBSTR ($RC2, 11, $TmpLen2-9)

    CASE ($TmpLen1 >= 3) AND ($RC3 = '103')                     ; REM **  IE3 - the build number only 

      $IEMajor = '4'

      $IEMinor = '70'

      $IEBuild = '$RC1'

      $IESubBd = ''

      $IEFullVer = $IEMajor + '.' + $IEMinor + '.' + $IEBuild

    CASE (1)

      RETURN

  ENDSELECT

; REM **  Determine exact version installed on system, (See MS TechNet article 164539) 

  SELECT

    CASE ($IEFullVer>='6.00.3790.0000') $IEVer='6.00'      $IEName='Internet Explorer 6 for Windows Server 2003 (released)'

    CASE ($IEFullVer>='6.00.3718.0000') $IEVer='6.00'      $IEName='Internet Explorer 6 for Windows Server 2003 RC2'

    CASE ($IEFullVer>='6.00.3663.0000') $IEVer='6.00'      $IEName='Internet Explorer 6 for Microsoft Windows Server 2003 RC1'

    CASE ($IEFullVer>='6.00.2800.1106') $IEVer='6.00'      $IEName='Internet Explorer 6 Service Pack 1 (Windows XP SP1)'

    CASE ($IEFullVer>='6.00.2600.0000') $IEVer='6.00'      $IEName='Internet Explorer 6 (Windows XP)'

    CASE ($IEFullVer>='6.00.2479.0006') $IEVer='6.00'      $IEName='Internet Explorer 6 Public Preview (Beta) Refresh'

    CASE ($IEFullVer>='6.00.2462.0000') $IEVer='6.00'      $IEName='Internet Explorer 6 Public Preview (Beta)'

    CASE ($IEFullVer>='5.50.4807.2300') $IEVer='5.50'      $IEName='Internet Explorer 5.5 Service Pack 2'

    CASE ($IEFullVer>='5.50.4522.1800') $IEVer='5.50'      $IEName='Internet Explorer 5.5 Service Pack 1'

    CASE ($IEFullVer>='5.50.4308.2900') $IEVer='5.50'      $IEName='Internet Explorer 5.5 Advanced Security Privacy Beta'

    CASE ($IEFullVer>='5.50.4134.0600') $IEVer='5.50'      $IEName='Internet Explorer 5.5'

    CASE ($IEFullVer>='5.50.4134.0100') $IEVer='5.50'      $IEName='Internet Explorer 5.5 (Windows Me - 4.90.3000)'

    CASE ($IEFullVer>='5.50.4030.2400') $IEVer='5.50'      $IEName='Internet Explorer 5.5 & Internet Tools Beta'

    CASE ($IEFullVer>='5.50.3825.1300') $IEVer='5.50'      $IEName='Internet Explorer 5.5 Developer Preview (Beta)'

    CASE ($IEFullVer>='5.00.3700.1000') $IEVer='5.01'      $IEName='Internet Explorer 5.01 SP4 (Windows 2000 SP4 only)'

    CASE ($IEFullVer>='5.00.3502.1000') $IEVer='5.01'      $IEName='Internet Explorer 5.01 SP3 (Windows 2000 SP3 only)'

    CASE ($IEFullVer>='5.00.3315.1000') $IEVer='5.01'      $IEName='Internet Explorer 5.01 SP2 (Windows 2000)'

    CASE ($IEFullVer>='5.00.3314.2101') $IEVer='5.01'      $IEName='Internet Explorer 5.01 SP2 (Windows 95/98 and Windows NT 4.0)'

    CASE ($IEFullVer>='5.00.3105.0106') $IEVer='5.01'      $IEName='Internet Explorer 5.01 SP1 (Windows 95/98 and Windows NT 4.0)'

    CASE ($IEFullVer>='5.00.3103.1000') $IEVer='5.01'      $IEName='Internet Explorer 5.01 SP1 (Windows 2000)'

    CASE ($IEFullVer>='5.00.2920.0000') $IEVer='5.01'      $IEName='Internet Explorer 5.01 (Windows 2000, build 5.00.2195)'

    CASE ($IEFullVer>='5.00.2919.6307') $IEVer='5.01'      $IEName='Internet Explorer 5.01 (Also included with Office 2000 SR-1)'

    CASE ($IEFullVer>='5.00.2919.3800') $IEVer='5.01'      $IEName='Internet Explorer 5.01 (Windows 2000 RC2, build 5.00.2128)'

    CASE ($IEFullVer>='5.00.2919.800')  $IEVer='5.01'      $IEName='Internet Explorer 5.01 (Windows 2000 RC1, build 5.00.2072)'

    CASE ($IEFullVer>='5.00.2516.1900') $IEVer='5.01'      $IEName='Internet Explorer 5.01 (Windows 2000 Beta 3, build 5.00.2031)'

    CASE ($IEFullVer>='5.00.2614.3500') $IEVer='5.00'      $IEName='Internet Explorer 5 (Windows 98 Second Edition)'

    CASE ($IEFullVer>='5.00.2314.1003') $IEVer='5.00'      $IEName='Internet Explorer 5 (Office 2000)'

    CASE ($IEFullVer>='5.00.2014.0216') $IEVer='5.00'      $IEName='Internet Explorer 5'

    CASE ($IEFullVer>='5.00.0910.1309') $IEVer='5.00'      $IEName='Internet Explorer 5 Beta       (Beta 2)'

    CASE ($IEFullVer>='5.00.0518.10')   $IEVer='5.00'      $IEName='Internet Explorer 5 Developer Preview (Beta 1)'

    CASE ($IEFullVer>='4.72.3612.1713') $IEVer='4.01'      $IEName='Internet Explorer 4.01 Service Pack 2 (SP2)'

    CASE ($IEFullVer>='4.72.3110.8')    $IEVer='4.01'      $IEName='Internet Explorer 4.01 Service Pack 1 (SP1)'

    CASE ($IEFullVer>='4.72.2106.8')    $IEVer='4.01'      $IEName='Internet Explorer 4.01'

    CASE ($IEFullVer>='4.71.1712.6')    $IEVer='4.00'      $IEName='Internet Explorer 4.0'

    CASE ($IEFullVer>='4.71.1008.3')    $IEVer='4.00'      $IEName='Internet Explorer 4.0 Platform Preview 2.0 (PP2)'

    CASE ($IEFullVer>='4.71.544')       $IEVer='4.00'      $IEName='Internet Explorer 4.0 Platform Preview 1.0 (PP1)'

    CASE ($IEFullVer>='4.70.1300')      $IEVer='3.02'      $IEName='Internet Explorer 3.02 and 3.02a'

    CASE ($IEFullVer>='4.70.1215')      $IEVer='3.01'      $IEName='Internet Explorer 3.01'

    CASE ($IEFullVer>='4.70.1158')      $IEVer='3.00'      $IEName='Internet Explorer 3.0  (OSR2)'

    CASE ($IEFullVer>='4.70.1155')      $IEVer='3.00'      $IEName='Internet Explorer 3.0'

    CASE ($IEFullVer>='4.40.520')       $IEVer='2.00'      $IEName='Internet Explorer 2.0'

    CASE ($IEFullVer>='4.40.308')       $IEVer='1.00'      $IEName='Internet Explorer 1.0 (Plus!)'

  ENDSELECT

$IEArray[0]=$IEMajor

$IEArray[1]=$IEMinor

$IEArray[2]=$IEBuild

$IEArray[3]=$IESubBd

$IEArray[4]=$IEFullVer

$IEArray[5]=$IEVer

$IEArray[6]=$IEName

$IEArray[7]=$IECustom

$IEArray[8]=$IEPath[1]

$IEArray[9]=$IELang

$GetIEVersion=iif(vartype($what),$IEArray[val($what)],$IEArray)

EndFunction
  


 
 [ 02. October 2003, 01:53: Message edited by: NTDOC ]109275GetIEVersion252NTDOCGetIEVersion2() - Info on Explorer,Netscape,FireFox1122914322

;Function        GetIEVersion2(optional $what,$sComputer) 
; 
;Author          NTDOC 
; 
;Contributors    Based on script by Bill Leonard 
; 
;Action          Returns information about Internet Explorer,Netscape, and Firefox locally and remotely 
; 
;Syntax          GetIEVersion2() or GetIEVersion2(6,'someworkstation') 
; 
;Version         1.6 
; 
;Date            2003-Sep-27 
; 
;Date Revised    2005-Aug-01 
; 
;Revision Reason Added requests from other board members. 
;		Rev 1.1 
;			Added newer versions per Masken 
;			Removed Q reference per Kent 
;			Added Path and Language (idea, from Erik) 
;		Rev 1.2 
;			Added argument request per Lonkero's request. 
;			Added remote support request by Al and Lonkero 
;		Rev 1.3 
;			Corrected missing values per request by PRandal 
;		Rev 1.4  
;			Corrected code.  Previous version was not returning OLDER versions 
;			correctly.  Added check for 128Bit and check for Netscape version 
;		Rev 1.5  
;			Updated code for newer XP SP2 and 2003 SP1 entries, added 
;			support for Firefox, changed to dynamic remote path method, changed 
;			method for encryption checking. 
;		Rev 1.6  
;			Repaired invalid results introduced in v1.4 changes 
; 
;Parameters      GetIEVersion2(optional $what)   ie... GetIEVersion2(4) would return Full Version 
;                0-13 parameters supported 
; 
;                Major Version:         0 
;                Minor Version:         1 
;                Build:                 2 
;                Sub Build:             3 
;                Full Version:          4 
;                Version:               5 
;                Name:                  6 
;                Customized String:     7 
;                Install Path:          8 
;                Language:              9 
;                128Bit:                10 
;                Host Name:             11 
;                Netscape Version:      12 
;                Firefox Version:       13 
; 
;Remarks         Remote test on Win9x failed, but works on 98/NT/2000/XP/2003 
;                Remote sharing must be enabled on Win9x 
; 
;Returns         Returns an array of values pertaining to Internet Explorer,Netscape and Firefox versions 
; 
;Dependencies    KiXtart v4.23 released version 
; 
;KiXtart Ver     Written and tested with KiXtart v4.50 on 98/NT/2000/XP/2003 
;                MUST USE KiXtart v4.22 or newer, will not work correctly with older versions 
; 
;Example(1) 
; 
; 
;               Break On 
;               Dim $SO,$IE 
;               $SO=SetOption('Explicit','On') 
;               $SO=SetOption('NoVarsInStrings','On') 
;               $SO=SetOption('WrapAtEOL','On') 
;               $IE = GetIEVersion2(,'remote-or-local-workstation') 
; 
;               'IE Major Version: '+$IE[0] ? 
;               'IE Minor Version: '+$IE[1] ? 
;               'IE Build: '+$IE[2] ? 
;               'IE Sub Build: '+$IE[3] ? 
;               'IE Full Version: '+$IE[4] ? 
;               'IE Ver: '+$IE[5] ? 
;               'IE Name: '+$IE[6] ? 
;               'IE Customized Version: '+$IE[7] ? 
;               'IE Install Path: '+$IE[8] ? 
;               'IE Language: '+$IE[9] ? 
;               'IE Encryption Level         : '+$IE[10] ? 
;               'Remote Host Name            : '+$IE[11] ? 
;               'Netscape Version            : '+$IE[12] ? 
;               'Firefox  Version            : '+$IE[13] ? 
; 
;Example(2) 
;                $IE = GetIEVersion2(6,'remote-or-local-workstation') 
;                'IE Name: '+$IE ? 
; 
;Source 
 
Function GetIEVersion2(optional $What,$sComputer)
  ; **  How to determine which version of Internet Explorer is installed  
  ; **  http://support.microsoft.com/kb/164539  
  ; **  Format of IE Version numbers: x.xx.xxxx.xxxx  (Major.Minor.Build.SubBuild)  
  Dim $Host,$IEPath,$IELang,$HKLMSMIE,$RC1,$RC2,$RC3,$IECustom,$TmpLen1,$TmpLen2,$TmpLen3
  Dim $IEMajor,$IEMinor,$IEBuild,$IESubBd,$IEFullVer,$IEVer,$IEName,$IEArray[14],$Schannel,$128Bit
  Dim $NSPath,$NSVer,$FoxPath,$FoxVer,$SystemRootKey,$Rights,$AppPaths,$RemoteDrive
  $GetIEVersion2=$IEArray
  $sComputer=IIf(Not $sComputer,'','\\'+Join(Split($sComputer,'\'),'',3)+'\')
  $HKLMSMIE=$sComputer+'HKLM\SOFTWARE\Microsoft\Internet Explorer'
  If Not $sComputer $Host=@WKSTA Else $Host=Join(Split($sComputer,'\'),'',3) EndIf
  $SystemRootKey=$sComputer+'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion'
  $RemoteDrive=Left(ReadValue($sComputer+'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion','CommonFilesDir'),1)
  $AppPaths=$sComputer+'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\'
  $Rights=ReadValue($SystemRootKey,'ProductName')
  If $sComputer
    Select
      Case $Rights=5
        Exit 5
      Case $Rights=2
        $Schannel=GetFileVersion(($sComputer+'c:\windows\system\schannel.dll'),'FileDescription')
      Case 1
        ;Sytem should be NT/2000/XP/2003 
	$SChannel=GetFileVersion(($sComputer+$RemoteDrive+'$'+
	Right(ReadValue($SystemRootKey,'SystemRoot'),-2)+'\system32\schannel.dll'),'FileDescription')
    EndSelect
  Else
    If @INWIN=2
      $SChannel = GetFileVersion('%windir%\system\schannel.dll','FileDescription')
    Else
      $SChannel = GetFileVersion('%SystemRoot%\system32\schannel.dll','FileDescription')
    EndIf
  EndIf
  If $SChannel
    If InStr($SChannel,'Export Version')
      $128Bit='40'
    Else
      $128Bit='128'
    EndIf
  Else
    $128Bit='unknown'
  EndIf
  $IEPath=Join(Split(ReadValue($AppPaths+'IEXPLORE.EXE','path'),';'),"")
  If $sComputer
    If $Rights=2
      $IEPath=$sComputer+'c'+SubStr($IEPath,3)
    Else
      $IEPath=$sComputer+$RemoteDrive+'$'+SubStr($IEPath,3)
    EndIf
  EndIf
  $IELang	= Substr(GetFileVersion($IEPath + '\'+'IEXPLORE.EXE','Language'),5)
  $RC1		= Trim(ReadValue($HKLMSMIE,'Build'))
  $RC2		= Trim(ReadValue($HKLMSMIE,'Version'))
  $RC3		= Trim(ReadValue($HKLMSMIE,'IVer'))
  $IECustom	= ReadValue($HKLMSMIE,'CustomizedVersion')
  $TmpLen1	= Len($RC1)
  $TmpLen2	= Len($RC2)
  $TmpLen3	= Len($RC3)
  $NSPath	= ReadValue($AppPaths+'Netscape.exe','')
  $FoxPath	= ReadValue($AppPaths+'firefox.exe','')
  $FoxVer	= GetFileVersion(ReadValue($AppPaths+'firefox.exe',''),'FileVersion')
  If $sComputer
    If $Rights=2
      $NSPath		= $sComputer + 'c' + SubStr($NSPath,3)
      $FoxPath		= $sComputer + 'c' + SubStr($FoxPath,3)
    Else
      $NSPath		= $sComputer + $RemoteDrive+'$' + SubStr($NSPath,3)
      $FoxPath`		= $sComputer + $RemoteDrive+'$' + SubStr($FoxPath,3)
    EndIf
  EndIf
  $NSVer		= GetFileVersion($NSPath,'ProductVersion')
  $FoxVer		= GetFileVersion($FoxPath,'FileVersion')
  Select
   Case ($TmpLen1  = 5) And (SubStr ($RC2, 4, 1) = '.')
	; REM **  IE6 (WinXP) - MS error w/IE 6 where minor id is single charcter, and build value only 5 characters  
	$IEMajor	= SubStr ($RC2, 1, 1)
	$IEMinor	= SubStr ($RC2, 3, 1) + '0'
	$IEBuild	= SubStr ($RC2, 5, 4)
	$IESubBd	= SubStr ($RC2, 10, $TmpLen2-9)
	$IEFullVer	= $IEMajor + '.' + $IEMinor + '.' + $IEBuild + '.' + $IESubBd
   Case ($TmpLen1  = 10) And (SubStr ($RC2, 4, 1) = '.')
	; REM **  IE6 (Win2K) - MS error w/IE 6 where minor id is single charcter  
	$IEMajor	= SubStr ($RC2, 1, 1)
	$IEMinor	= SubStr ($RC2, 3, 1) + '0'
	$IEBuild	= SubStr ($RC2, 5, 4)
	$IESubBd	= SubStr ($RC2, 10, $TmpLen2-9)
	$IEFullVer	= $IEMajor + '.' + $IEMinor + '.' + $IEBuild + '.' + $IESubBd
    CASE ($TmpLen1 = 14) Or ($TmpLen2 >= 11)
	; REM **  IE5/IE4 - 14 is MS error w/IE 5.01 SP1 for Win2K, >=11 for various IE4, 5 versions not 14-character  
	$IEFullVer	= $RC2
	$IEMajor	= SUBSTR ($RC2, 1, 1)
	$IEMinor	= SUBSTR ($RC2, 3, 2)
	$IEBuild	= SUBSTR ($RC2, 6, 4)
	$IESubBd	= SUBSTR ($RC2, 11, $TmpLen2-9)
	$IEFullVer	= $IEMajor + '.' + $IEMinor + '.' + $IEBuild + '.' + $IESubBd
    CASE ($TmpLen1 >=3) And ($RC3 = '101')
	$IEMajor	= '4'
	$IEMinor	= '70'
	$IEBuild	= $RC1
	$IESubBd	= ""
	$IEFullVer	= $IEMajor + '.' + $IEMinor + '.' + $IEBuild
   Case ($RC1="") And ($RC2="") and ($RC3='100')
	$IEMajor	= '4'
	$IEMinor	= '40'
	$IEBuild	= '308'
	$IESubBd	= ""
	$IEFullVer	= $IEMajor + "." + $IEMinor + "." + $IEBuild
   Case ($RC1='520') And ($RC3='102')
	$IEMajor	= '4'
	$IEMinor	= '40'
	$IEBuild	= '520'
	$IESubBd	= ""
	$IEFullVer	= $IEMajor + "." + $IEMinor + "." + $IEBuild
   Case ($RC1="") And ($RC3="101")
	$IEMajor	= '4'
	$IEMinor	= '40'
	$IEBuild	= '520'
	$IESubBd	= ""
	$IEFullVer	= $IEMajor + "." + $IEMinor + "." + $IEBuild
   Case (1)
	Exit @ERROR
  EndSelect
  Select
    Case $IEFullVer ='6.00.3790.1830'  $IEVer='6.00' $IEName='IE 6 for Windows Server 2003 SP1'
    Case $IEFullVer ='6.00.3790.0000'  $IEVer='6.00' $IEName='IE 6 for Windows Server 2003 (released)'
    Case $IEFullVer ='6.00.3718.0000'  $IEVer='6.00' $IEName='IE 6 for Windows Server 2003 RC2'
    Case $IEFullVer ='6.00.3663.0000'  $IEVer='6.00' $IEName='IE 6 for Microsoft Windows Server 2003 RC1'
    Case $IEFullVer ='6.00.2900.2180'  $IEVer='6.00' $IEName='IE 6 for Windows XP SP2'
    Case $IEFullVer ='6.00.2800.1106'  $IEVer='6.00' $IEName='IE 6 Service Pack 1 (Windows XP SP1)'
    Case $IEFullVer ='6.00.2600.0000'  $IEVer='6.00' $IEName='IE 6 (Windows XP)'
    Case $IEFullVer ='6.00.2479.0006'  $IEVer='6.00' $IEName='IE 6 Public Preview (Beta) Refresh'
    Case $IEFullVer ='6.00.2462.0000'  $IEVer='6.00' $IEName='IE 6 Public Preview (Beta)'
    Case $IEFullVer ='5.50.4807.2300'  $IEVer='5.50' $IEName='IE 5.5 Service Pack 2'
    Case $IEFullVer ='5.50.4522.1800'  $IEVer='5.50' $IEName='IE 5.5 Service Pack 1'
    Case $IEFullVer ='5.50.4308.2900'  $IEVer='5.50' $IEName='IE 5.5 Advanced Security Privacy Beta'
    Case $IEFullVer ='5.50.4134.0600'  $IEVer='5.50' $IEName='IE 5.5'
    Case $IEFullVer ='5.50.4134.0100'  $IEVer='5.50' $IEName='IE 5.5 (Windows Me - 4.90.3000)'
    Case $IEFullVer ='5.50.4030.2400'  $IEVer='5.50' $IEName='IE 5.5 &amp; Internet Tools Beta'
    Case $IEFullVer ='5.50.3825.1300'  $IEVer='5.50' $IEName='IE 5.5 Developer Preview (Beta)'
    Case $IEFullVer ='5.00.3700.1000'  $IEVer='5.01' $IEName='IE 5.01 SP4 (Windows 2000 SP4 only)'
    Case $IEFullVer ='5.00.3502.1000'  $IEVer='5.01' $IEName='IE 5.01 SP3 (Windows 2000 SP3 only)'
    Case $IEFullVer ='5.00.3315.1000'  $IEVer='5.01' $IEName='IE 5.01 SP2 (Windows 2000)'
    Case $IEFullVer ='5.00.3314.2101'  $IEVer='5.01' $IEName='IE 5.01 SP2 (Windows 95/98 and Windows NT 4.0)'
    Case $IEFullVer ='5.00.3105.0106'  $IEVer='5.01' $IEName='IE 5.01 SP1 (Windows 95/98 and Windows NT 4.0)'
    Case $IEFullVer ='5.00.3103.1000'  $IEVer='5.01' $IEName='IE 5.01 SP1 (Windows 2000)'
    Case $IEFullVer ='5.00.2920.0000'  $IEVer='5.01' $IEName='IE 5.01 (Windows 2000, build 5.00.2195)'
    Case $IEFullVer ='5.00.2919.6307'  $IEVer='5.01' $IEName='IE 5.01 (Also included with Office 2000 SR-1)'
    Case $IEFullVer ='5.00.2919.3800'  $IEVer='5.01' $IEName='IE 5.01 (Windows 2000 RC2, build 5.00.2128)'
    Case $IEFullVer ='5.00.2919.800'   $IEVer='5.01' $IEName='IE 5.01 (Windows 2000 RC1, build 5.00.2072)'
    Case $IEFullVer ='5.00.2516.1900'  $IEVer='5.01' $IEName='IE 5.01 (Windows 2000 Beta 3, build 5.00.2031)'
    Case $IEFullVer ='5.00.2614.3500'  $IEVer='5.00' $IEName='IE 5 (Windows 98 Second Edition)'
    Case $IEFullVer ='5.00.2314.1003'  $IEVer='5.00' $IEName='IE 5 (Office 2000)'
    Case $IEFullVer ='5.00.2014.0216'  $IEVer='5.00' $IEName='IE 5'
    Case $IEFullVer ='5.00.0910.1309'  $IEVer='5.00' $IEName='IE 5 Beta       (Beta 2)'
    Case $IEFullVer ='5.00.0518.10')   $IEVer='5.00' $IEName='IE 5 Developer Preview (Beta 1)'
    Case $IEFullVer ='4.72.3612.1713'  $IEVer='4.01' $IEName='IE 4.01 Service Pack 2 (SP2)'
    Case $IEFullVer ='4.72.3110.8'     $IEVer='4.01' $IEName='IE 4.01 Service Pack 1 (SP1)'
    Case $IEFullVer ='4.72.2106.8'     $IEVer='4.01' $IEName='IE 4.01'
    Case $IEFullVer ='4.71.1712.6'     $IEVer='4.00' $IEName='IE 4.0'
    Case $IEFullVer ='4.71.1008.3'     $IEVer='4.00' $IEName='IE 4.0 Platform Preview 2.0 (PP2)'
    Case $IEFullVer ='4.71.544'        $IEVer='4.00' $IEName='IE 4.0 Platform Preview 1.0 (PP1)'
    Case $IEFullVer ='4.70.1300'       $IEVer='3.02' $IEName='IE 3.02 and 3.02a'
    Case $IEFullVer ='4.70.1215'       $IEVer='3.01' $IEName='IE 3.01'
    Case $IEFullVer ='4.70.1158'       $IEVer='3.00' $IEName='IE 3.0  (OSR2)'
    Case $IEFullVer ='4.70.1155'       $IEVer='3.00' $IEName='IE 3.0'
    Case $IEFullVer='4.40.520'         $IEVer='2.00' $IEName='IE 2.0'
    Case $IEFullVer='4.40.308'         $IEVer='1.00' $IEName='Internet Explorer 1.0 (Plus! for Windows 95)'
  EndSelect
  $IEArray[0]=$IEMajor     $IEArray[1]=$IEMinor     $IEArray[2]=$IEBuild
  $IEArray[3]=$IESubBd     $IEArray[4]=$IEFullVer   $IEArray[5]=$IEVer
  $IEArray[6]=$IEName      $IEArray[7]=$IECustom    $IEArray[8]=$IEPath
  $IEArray[9]=$IELang      $IEArray[10]=$128Bit     $IEArray[11]=$Host
  $IEArray[12]=$NSVer      $IEArray[13]=$FoxVer
  $GetIEVersion2=IIf(VarType($What),$IEArray[Val($What)],$IEArray)
EndFunction
 

 
115415GetINI28BryceGetINI()1078505886Code:


;Function: 

;     GetINI(FILE,[SECTION],[DELIMINATOR])

; 

;Author: 

;     Bryce

; 

;Version: 

;     1.0

; 

;Version history: 

;     1.0 March 3 2004 First publish

;

;Action: 

;     Reads an entire INI file into an array, or just a given section of an INI file

; 

;Syntax: 

;     GetINI(FILE,[SECTION],[DELIMINATOR])

; 

;Parameters: 

;     FILE          - the full path to the INI file to read

;     [SECTION]     - OPTIONAL section to read data from.

;     [DELIMINATOR] = OPTIONAL Deliminator

;

;Returns: 

;     An Array with a delimited string of data.

;     Each item of the array is a delimited string that is SECTION,KEY,DATA

;     The default Deliminator is a Comma

;

; 

;Errors Returned: 

;     0 = Function ran with out errors

;     2 = the INI file was not found

;     13 = the INI file has a bad data format

; 

;Dependencies: 

;     none 

; 

;Remarks: 

;     Another UDF that calles it self...

;     if no SECTION is given the UDF will read in the entire ini

; 

;Example: 

;     ;return an entire INI file

;     $data =  GetINI(@SCRIPTDIR + "\test.ini")

;     For Each $line In $data

;          ? $line

;     Next

;

;     ;Return just a section of a INI file

;     $data =  GetINI(@SCRIPTDIR + "\test.ini","Section2")

;     For Each $line In $data

;          ? $line

;     Next

;

;     ;Use ! as a string deliminator for each array item

;     $data =  GetINI(@SCRIPTDIR + "\test.ini","","!")

;     For Each $line In $data

;          ? $line

;     Next

;

;

;Source: 

Function GetINI($File,optional $Section, optional $d)

     DIM $Rootdata, $sec, $i, $ii, $secdata, $Error

     DIM $Tarray[0]

     If not $d $d = "," EndIf

     If not Exist($file) Exit(2) EndIf

     $Rootdata = Split(ReadProfileString($file,$section,""),CHR(10))

     If UBound($rootdata) = 0 Exit(13) EndIf

     ReDIM preserve $rootdata[ubound($rootdata)-1]

     If not $section

          $i = 0

          For Each $sec In $rootdata

               $secData = GetINI($file,$sec,$d)

               $error = @ERROR

               ReDIM preserve $tarray[UBound($tarray)+UBound($secdata)+1]

               For $ii = 0 To UBound($secdata)

                    $tarray[$i] = $secdata[$ii]

                    $i = $i + 1

               Next

          Next

          If UBound($tarray) > 0 ReDIM preserve $tarray[$i-1] EndIf

     Else

         ReDIM preserve $tarray[ubound($rootdata)]

         For $i = 0 To UBound($rootdata)

               $tarray[$i]=$section+$d+$Rootdata[$i]+$d+ReadProfileString($file,$section,$Rootdata[$i])

         Next

     EndIf

     $GetINI = $tarray

     Exit($error)

EndFunction

  82086GetIPinfo172Howard BullockGetIPinfo() - Support for when EnumIPinfo() fails0


;FUNCTION         GetIPinfo()

;

;AUTHOR           Howard A. Bullock (habullock@comcast.net)

;

;ACTION           Gathers a computers IP address, subnet mask, and default gateway on

;                 computers that do not support EnumIPinfo().

;

;SYNTAX           $IPinfo = GetIPinfo()

;

;PARAMETERS       None

;

;REMARKS          This UDF complements EnumIPinfo() for computers where EnumIPinfo() does not work.

;

;RETURNS          An array of three elements: IP Address, Subnet Mask, and Default Gateway.

;

;DEPENDENCIES     UDF OpenFile() by H. Bullock

;                 UDF WriteLog ()    WriteLog2() can be substituted for more flexibillity.

;

;

;EXAMPLES

;

;                $IPaddr = EnumIPinfo(0,0)

;                if $IPaddr = "0.0.0.0" or $IPaddr = ""

;                  $IPinfo = GetIPinfo()

;                  $IPaddr = $IPinfo[0]

;                  $SNmask = $IPinfo[1]

;                  $Gateway = $IPinfo[2]

;                else

;                  $SNmask = EnumIPinfo(0,1)

;                  $Gateway = EnumIPinfo(0,3)

;                endif



Function GetIPinfo()

    ; Purpose: Return network info on a computer where EnumIPinfo() fails.

    ; Uses ipconfig or winipcfg depending on @INWIN.

    ; Returns an array of three values: IP Addr., SN Mask, and Default Gateway.

    dim $IPinfo[2], $file, $RC, $Line, $pos, $loop, $x



    WriteLog("Gathering IP info using GetIPinfo()")

    $file = "%temp%\junk.txt"

    if @inwin=1

        shell "%comspec% /c ipconfig >$file"

    else

        shell "winipcfg /batch $file"

    endif

    $RC = OpenFile(5, $file, 2)

    if $RC = 0

        $Line=Readline(5)

        $loop = 1

        WHILE (@ERROR = 0 and $loop = 1)

            if instr($Line, "IP") > 1 and instr($Line, ". . :") > 0 and 

               right($Line, 7) <> "0.0.0.0"

                $x = 0

                WHILE (@ERROR = 0 and $loop = 1)

                    $IPinfo[$x] = substr($Line, instrrev($Line, ":")+2)

                    if $x<2

                        $x = $x + 1

                        do

                            $Line=ReadLine(5)

                        until $Line <> "" or @error <> 0

                    else

                        $loop = 0

                    endif

                LOOP

            else

                $Line=ReadLine(5)

            endif

        LOOP

        $RC=Close(5)

        del $file

    endif

    $GetIPinfo = $IPinfo

Endfunction


 
 [ 24. June 2003, 13:33: Message edited by: Howard Bullock ]159170GetIPOptions3439AllenGetIPOptions() - Get/Determine IP Related Settings0Code:

;Function:  
; GetIPOptions()  
;  
;Author:  
; Allen Powell  
;  
;Version:  
; 1.0 2006/03/15
;  
;Action:  
; Display/Get IP Settings   
; 
;Syntax:  
; GetIPOptions($Setting,optional $remotepc, optional $macaddress) 
;  
;Parameters:  
; $setting - Any valid property from Win32_NetworkAdapterConfiguration class, See examples below and 
;             http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wmisdk/wmi/win32_networkadapterconfiguration.asp 
; $remotepc - (Optional) Remote Computer Name 
; $macaddress - (Optional)  In Computers with more than Network Adapter, provide the MACAddress to target it settings 
; 
;Returns: 
; String containing setting 
; 
;Dependencies 
;  WMI with Windows XP, Windows 2000 Professional, or Windows NT Workstation 4.0 SP4 and later 
;  Tested with Kixtart 4.52 Beta 
; 
;Notes 
;  If a computer has more than one Network Adapter and the macaddress is not provided it will return the last adapter's information 
; 
;Example1:  
; 
;? "        Mac Address:  " + getipoptions("Macaddress") 
;? "     Static Address:  " + getipoptions("StaticIP") 
;? "       DHCP Enabled:  " + getipoptions("DHCPEnabled") 
;? "       IPaddress/SM:  " + getipoptions("IPAddress") 
;? "      IPaddress0/SM:  " + getipoptions("IPAddress0") 
;? "      IPaddress1/SM:  " + getipoptions("IPAddress1") 
;? "      IPaddress2/SM:  " + getipoptions("IPAddress2") 
;? "      IPaddress3/SM:  " + getipoptions("IPAddress3") 
;? "          DefaultGW:  " + getipoptions("DefaultGW") 
;? "        DNS Servers:  " + getipoptions("DNSServers") 
;? "       WINS Servers:  " + getipoptions("WINSServers") 
;? "          DNSSuffix:  " + getipoptions("DNSDomain") 
;? "   DNS Search Order:  " + getipoptions("DNSDomainSuffixSearchOrder") 
;? "        DHCP Server:  " + getipoptions("DHCPServer") 
;? "DHCP Lease Obtained:  " + getipoptions("DHCPLeaseObtained") 
;? " DHCP Lease Expires:  " + getipoptions("DHCPLeaseExpires") 
; 
;Example2:  List settings for Remote Computers including those with more than one Network Adapter. 
; Requires EnumNetworkConnections() - http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=138769&an=0&page=0#138769
; 
;break on 
;$remotepc="computername" 
;for each $nc in Enumnetworkconnections(3,$remotepc) 
;    $ConnectionName=split($nc,",")[0] 
;    $MACAddress=split($nc,",")[1] 
;    $AdapterName=split($nc,",")[2] 
;    ? "    Connection Name:  " + $connectionname 
;    ? "         MACAddress:  " + $MACAddress 
;    ? "       Adapter Name:  " + $AdapterName 
;    ? "        Mac Address:  " + getipoptions("Macaddress",$remotepc,$macaddress) 
;    ? "     Static Address:  " + getipoptions("StaticIP",$remotepc,$macaddress) 
;    ? "       DHCP Enabled:  " + getipoptions("DHCPEnabled",$remotepc,$macaddress) 
;    ? "       IPaddress/SM:  " + getipoptions("IPAddress",$remotepc,$macaddress) 
;    ? "      IPaddress0/SM:  " + getipoptions("IPAddress0",$remotepc,$macaddress) 
;    ? "      IPaddress1/SM:  " + getipoptions("IPAddress1",$remotepc,$macaddress) 
;    ? "      IPaddress2/SM:  " + getipoptions("IPAddress2",$remotepc,$macaddress) 
;    ? "      IPaddress3/SM:  " + getipoptions("IPAddress3",$remotepc,$macaddress) 
;    ? "          DefaultGW:  " + getipoptions("DefaultGW",$remotepc,$macaddress) 
;    ? "        DNS Servers:  " + getipoptions("DNSServers",$remotepc,$macaddress) 
;    ? "       WINS Servers:  " + getipoptions("WINSServers",$remotepc,$macaddress) 
;    ? "          DNSSuffix:  " + getipoptions("DNSDomain",$remotepc,$macaddress) 
;    ? "   DNS Search Order:  " + getipoptions("DNSDomainSuffixSearchOrder",$remotepc,$macaddress) 
;    ? "        DHCP Server:  " + getipoptions("DHCPServer",$remotepc,$macaddress) 
;    ? "DHCP Lease Obtained:  " + getipoptions("DHCPLeaseObtained",$remotepc,$macaddress) 
;    ? " DHCP Lease Expires:  " + getipoptions("DHCPLeaseExpires",$remotepc,$macaddress) 
;    ? "---------------" 
;next 
; 
; 
function GetIPOptions($Setting,optional $remotepc, optional $macaddress)
  dim $objWMIService, $colitems, $objnetadapter,$targetadapter,$,$allnics,$counter,$Mask,$SN, $IP, $IPAddress,$toggle
  if $remotepc=""
    $remotepc="."
  endif
  if $macaddress=""
    $allnics=1
  endif
  $objWMIService = GetObject("winmgmts:\\" + $remotepc + "\root\cimv2")
  if @error
    exit @error
  endif
  $colItems = $objWMIService.ExecQuery("Select * from Win32_NetworkAdapterConfiguration where IPEnabled=-1")
  For Each $objNetAdapter In $colItems
    if $macaddress=$objNetAdapter.macaddress or $allnics
      select
        case instr($setting,"IPAddress")>0
          if right($setting,1)="s" or val(right($setting,1))>3 or len($setting)>10
            $targetadapter=0
          else
            $targetadapter=right($setting,1)
          endif
          $counter=0
          for each $IP in $objNetAdapter.IPAddress
            if "" + $counter=$targetadapter
              $IPAddress=$IP
            endif
            $counter=$counter+1
          next
          $counter=0
          for each $SN in $objNetAdapter.IPSubnet
            if "" + $counter=$targetadapter
              $Mask=$SN
            endif
            $counter=$counter+1
          next
          $GetIPOptions=$IPAddress
          if $mask
            $GetIPOptions=$GetIPOptions + "," + $Mask
          endif  
        case $setting="WINSServers"
          $GetIPOptions=$objNetAdapter.WINSPrimaryServer
          if $objNetAdapter.WINSSecondaryServer<>"" 
            $GetIPOptions=$GetIPOptions + "," + $objNetAdapter.WINSSecondaryServer
          endif
        case 1
          select
            case $setting="DefaultGW" or $setting="DefaultGateway" or $setting="Gateway"
              $setting="DefaultIPGateway"
            case $setting="DNSServers"
              $setting="DNSServerSearchOrder"
            case $setting="StaticIP" or $setting="Static"
              $setting="DHCPEnabled"
              $toggle=1
          endselect
          $=execute("$" + "GetIPOptions=" + "$" + "objNetAdapter." + $setting)
          select 
            case vartype($GetIPOptions)>=8192 ;array 
              $GetIPOptions=join($GetIPOptions,",")
            case vartype($GetIPOptions)=11    ;boolean 
              if $GetIPOptions=0 - $toggle
                $GetIPOptions="False"
              else
                $GetIPOptions="True"
              endif
          endselect
      endselect
    endif
  Next
endfunction
 

82990GetLines487New Mexico MarkGetLines() - Retrieve one or more lines from a text file into an array0

;Function Get_Lines()
;
;Author New Mexico Mark (wmarkh@aol.com)
;
;Action Gets a line or range of lines from a text file.
;
;Syntax Get_Lines(FileSpec [,FirstLine] [,LastLine])
;
;Parameters
; FileSpec - Valid file specification
; FirstLine - The first line to be returned
; LastLine - The last line to be returned
;
;Returns An array with the first line in element 0 and the last line in
; element abs(last-first). If either line exceeds the file size,
; the array will be truncated to the actual number of valid 
; lines returned. I.e. If a file contains 100 lines and 90-110
; are requested, the returned array will have 11 elements with
; lines 90-100 in those elements.
; The function raises an error of -1 if it cannot instantiate
; the file system object or open the file. In this case, a one-
; element array (with empty string) will be returned.
;
;Dependencies Uses the file system object.
;
;Examples
$TFile = 'c:\test.txt'
IF Open(1,$TFile,5) = 0
FOR $i = 1 TO 100
$RC=WriteLine(1,'Line '+$i+@CRLF)
NEXT
$RC=Close(1)
$aTmp=GetLines($TFile) ; Get line 1 by default
$aTmp[0] ? ?
$aTmp=GetLines($TFile,1,5) ; Get lines 1-5
FOR EACH $j IN $aTmp $j ? NEXT ?
$aTmp=GetLines($TFile,50,48) ; Get lines 50-45
FOR EACH $j IN $aTmp $j ? NEXT ?
$aTmp=GetLines($TFile,95,105) ; Attempt to get lines 95-105
FOR EACH $j IN $aTmp $j ? NEXT ?
$aTmp=GetLines($TFile,110,115) ; Attempt to get lines 110-115
FOR EACH $j IN $aTmp $j ? NEXT ?
$aTmp=GetLines($TFile,100) ; Get line 100
$aTmp[0] ? ?
IF Exist($TFile) DEL $TFile ENDIF
ENDIF
;Console displays
;Line 1
;
;Line 1
;Line 2
;Line 3
;Line 4
;Line 5
;
;Line 50
;Line 49
;Line 48
;Line 47
;Line 46
;Line 45
;
;Line 95
;Line 96
;Line 97
;Line 98
;Line 99
;Line 100
;
;
;Line 100
;
;Source

code:


FUNCTION GetLines($sFileSpec, OPTIONAL $iFirst, OPTIONAL $iLast)
ÿÿÿDIM $i, $iPos, $vTmp, $iStep, $oFS, $oTextStream
ÿÿÿ$sFileSpec=''+$sFileSpec $iFirst=0+$iFirst $iLast=0+$iLast $iStep=1
ÿÿÿIF Exist($sFileSpec)
ÿÿÿÿÿÿIF $iFirst <= 0 $iFirst=1 ENDIF
ÿÿÿÿÿÿIF $iLast  <= 0 $iLast=$iFirst ENDIF
ÿÿÿÿÿÿ$iPos = 0
ÿÿÿÿÿÿIF $iFirst > $iLast
ÿÿÿÿÿÿÿÿÿ$vTmp=$iFirst $iFirst=$iLast $iLast=$vTmp ; Swap
ÿÿÿÿÿÿÿÿÿ$iStep=-1
ÿÿÿÿÿÿÿÿÿ$iPos=$iLast-$iFirst
ÿÿÿÿÿÿENDIF
ÿÿÿÿÿÿREDIM $GetLines[0]
ÿÿÿÿÿÿ$GetLines[0]=''
ÿÿÿÿÿÿ$oFS=CreateObject('Scripting.FileSystemObject')
ÿÿÿÿÿÿIF @ERROR EXIT -1 ENDIF
ÿÿÿÿÿÿ$oTextStream=$oFS.OpenTextFile($sFileSpec,1)
ÿÿÿÿÿÿIF @ERROR EXIT -1 ENDIF
ÿÿÿÿÿÿ$vTmp = $iLast - $iFirst
ÿÿÿÿÿÿREDIM $GetLines[$vTmp]
ÿÿÿÿÿÿFOR $i = 0 TO UBound($GetLines) $GetLines[$i]='' NEXT
ÿÿÿÿÿÿ; Position the pointer to the first line to be read into the array
ÿÿÿÿÿÿ$i=1
ÿÿÿÿÿÿWHILE $i < $iFirst AND @ERROR = 0
ÿÿÿÿÿÿÿÿÿ$i=$i+1
ÿÿÿÿÿÿÿÿÿ$oTextStream.SkipLine
ÿÿÿÿÿÿLOOP
ÿÿÿÿÿÿ; Read lines into the array.
ÿÿÿÿÿÿWHILE $i <= $iLast AND @ERROR = 0
ÿÿÿÿÿÿÿÿÿ$GetLines[$iPos]=$oTextStream.ReadLine
ÿÿÿÿÿÿÿÿÿ$iPos=$iPos+$iStep
ÿÿÿÿÿÿÿÿÿ$i=$i+1
ÿÿÿÿÿÿLOOP
ÿÿÿÿÿÿIF @ERROR
ÿÿÿÿÿÿÿÿÿIF $iPos < 2 $iPos=2 ENDIF
ÿÿÿÿÿÿÿÿÿREDIM PRESERVE $GetLines[$iPos-2]
ÿÿÿÿÿÿENDIF
ÿÿÿÿÿÿ$oTextStream.Close
ÿÿÿENDIF
ENDFUNCTION  ;GetLines()

[ 14 February 2002: Message edited by: New Mexico Mark ]84650GetLUDays3755GavenGetLUDays() - days until Norton LiveUpdate subscription expires0

code:

;  Function:     GetLUDays()
;
;  Author:       Gaven Henderson, Gaven@GavDogg.net
;  
;  Action:       GetLUDays will return the number of days remaining in the local Norton
;                AntiVirus LiveUpdate subscription.  Works for NAV 2002 and similar versions.
;
;  Remarks:      There are a number of event that will cause this function to report invalid
;                data.  In a nut shell, the function gets the date of "CfgWiz.dat" which is a
;                file in the NAV directory created on installation.  The function assumes the
;                subscription term is one year.  Here are factors which will result in invalid
;                data:
;                        - The system clock was not set when NAV was installed.
;                        - The system clock is not set when this function is run.
;                        - The CfgWiz.dat file has been modified since install.
;                        - The subscription was renewed with a renewal key.
;                        - NAV was reinstalled but an old subscription date was restored.
;  
;  Syntax:       getludays()
;
;  Version:      1.0
;
;  Post Date:    October 14, 2003
;
;  Revise Date:  October 14, 2003
;  
;  Returns:      Returns an integer representing the number of days remaining in the local
;                Norton AntiVirus LiveUpdate subscription.  If NAV cannot be located, "N/A"
;                is returned.
;  
;  KiXtart Ver:  Designed on 4.20 but should work on any version.
;
;  Example:      $days = getludays
;                $days "days remaining."
;
Function getludays()
	Dim $a,$b,$y,$y2,$m,$m2,$d,$d2
	$getludays="N/A"
	If KeyExist('HKLM\SOFTWARE\Symantec\InstalledApps')<>0
		$b=ReadValue('HKLM\SOFTWARE\Symantec\InstalledApps','NAV')
		If $b<>'' $b=$b+'\CfgWiz.dat' EndIf
	EndIf
	If Exist($b)
		$a=Left(GetFileTime($b),10)
		$y=Val(@Year)
		$m=Val(@MonthNo)
		$d=Val(@MDayNo)
		$y2=Val(Left($a,4))
		$m2=Val(SubStr($a,6,2))
		$d2=Val(Right($a,2))
		If $m<3
			$m=$m+12
			$y=$y-1
		EndIf
		If $m2<3
			$m2=$m2+12
			$y2=$y2-1
		EndIf
		$getludays=365-(($d+(153*$m-457)/5+365*$y+$y/4-$y/100+$y/400-306)-($d2+(153*$m2-457)/5+365*$y2+$y2/4-$y2/100+$y2/400-306))
	EndIf
EndFunction

84616GetMAC119LonkeroGetMAC - get physical addresses of net adapters (local or remote)0;FUNCTION  

;	GetMAC()  

;  

;AUTHOR  

;	Lonkero (Jooel_Nieminen@hotmail.com)  

;  

;ACTION  

;	Returns network interface MAC Addresses  

;  

;VERSION  

;	1.0.1 

;  

;VERSION HISTORY  

;	1.0.1	11. October 2003	 - some "fixes" 

;	1.0	10. October 2003	 - Initial, working, tested draft  

;  

;SYNTAX  

;	GetMAC( COMPUTER )  

;  

;PARAMETERS  

;  

;	COMPUTER	Computer to query on. optional.  

;			if omitted, local defaulted.  

;  

;RETURNS  

;	array of MAC addresses  

;  

;REMARKS  

;	hit me with request. remember this is just a draft.  

;	would be glad to improve.  

;  

;DEPENDENCIES  

;	WMI 

;	Kixtart 4.20 

;  

;EXAMPLE  

;	"mac-addies on my wksta:"  

;	for each $mac in GetMAC()  

;		$mac ?  

;	next  

;  

;SOURCE  

function GetMAC(optional $)

dim $u

 For Each $Adapter In GetObject("winmgmts:{impersonationLevel=impersonate}!\\"+iif(vartype($)=8,$,".")+"\root\cimv2").ExecQuery("Select * from Win32_NetworkAdapterConfiguration Where MacAddress<>''")

	$u=$u+1

	redim $GetMAC[$u]

	$GetMAC[$u]=$Adapter.MacAddress

 next

endfunction


 
 [ 12. October 2003, 02:42: Message edited by: Lonkero ]84515GetNavAntiVirusInfo52NTDOCGetNavAntiVirusInfo() - Returns Information and Date of installed Symantec AntiVirus0



;Function        GetNavAntiVirusInfo()

;

;Author          NTDOC/Ron Lewis (ntdoc@@@@@kixhelp.com)

;

;Contributors    Jochen Polster

;                Further ideas/improvements from this posting

;                http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000450

;Action          Returns information and date of installed Norton/Symantec Corporate Edition AntiVirus Defs

;

;Syntax          GetNavAntiVirusInfo(optional $wksta,optional $DateCheck,optional $WarnOldDef,optional $WarnNoNav)

;

;Version         1.04

;

;Date            2003-Aug-28

;

;Date Revised    2003-Sep-3

;

;Revision Reason 1.01 Updated code to allow NON-ADMINS to run on local system.

;                1.02 Updated code to support usage of array values.  Removed DateCalc()

;                     from this UDF code.  You must use DaeCalc() UDF to use this UDF.

;                1.03 Updated code to support "SILENT" operation via $Flag

;                1.04 Added a silent parameter for systems with SAV/NAV NOT installed

;                     modified the $Flag var name to $WarnOldDef and added $WarnNoNav to

;                     silence Messagebox when no NAV/SAV is found to be installed.

;

;Parameters      $wksta       = Name of the client machine, can be left out to check the local system



;                $DateCheck   = Threshold for AV definitions in days. Set it to '0' for 

;                               testing/results display. If not specified, the default date 

;                               threshold is 14 days.

;

;                $WarnOldDef  = If set to 1, the UDF will not display a messagebox when definition files

;                               are old, and returns an array with AV info only ("silent" mode).

;

;                $WarnNoNav   = If set to 1, the UDF will not display a messagebox when no Antivirus

;                               installation is found for Symantec/Norton Corporate Edtion

;                               returns an array with AV info only ("silent" mode).

;

;Remarks         * $wksta and $DateCheck must be in quotes. $WarnOldDef and  $WarnNoNav do not need 

;                  to be in quotes.

;                * If the system is up to date, nothing will be displayed to the user, however the values

;                  are still returned for logging purposes. If you want to check and see the date

;                  and other information in a dialog box regardless, set $DateCheck to '0'

;                * Remote systems require you to have Administrative Rights

;                             

;Returns         Returns an array and (if $WarnOldDef <> 1) OR (if $WarnNoNav <> 1) a messagebox with 

;                the following information is returned from either a local or remote system.  

;                * Antivirus Engine version [0]

;                * Antivirus Definitions Date [1]

;                * Parent Server [2]

;                * Client Type [3]

;                * Installation Folder [4]

;                * Workstation name [5]

;                * NAV Installation status [6] (value of 2 = not found)

;                * Notify settings [7] (check value - if set, definitions are old)

;                * Age of Definition Files [8]

;

;                GetNavAntiVirusInfo('station3','9',,)

;                Tells it to only show Messagebox if definition files are 9 days old or older

;

;                GetNavAntiVirusInfo('station3','4',1,)

;                Tells it to check if Definition files are 4 days old or newer and to show Messagebox

;                if definition files are 4 days old or older

;                but the last parameter 1 for $WarnOldDef tells it to NOT SHOW the Messagebox

;

;                GetNavAntiVirusInfo('station3',,1,1)

;                Tells it to check if definition files are 14 days or older, but to silence both the

;                Messagebox about old definition files, as well as the NAV Not Installed Messagebox

;

;Dependencies    DateCalc() UDF by Jochen Polster

;                http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000076

;                You MUST have Remote Administrator rights to return all data

;                Locally run should not require any special rights

;                DOES NOT SUPPORT Windows 9x REMOTELY but does support it LOCALLY

;

;KiXtart Ver     Written and tested with KiXtart v4.21 on 95B/NT/2000/XP ONLY!

;

;Example(1)

;                Break On

;                $nul=SetOption('WrapAtEOL','ON')

;                $nul=SetOption('Explicit','ON')

;                $nul=SetOption('NoVarsInStrings','ON')

;

;                DIM $NAVInfo

;                $NAVInfo = GetNavAntiVirusInfo('NTDOCWORK1','5',,)

;                ? 'Host Name: '+$NAVInfo[5]

;                ? 'Engine Ver: '+$NAVInfo[0]

;                ? 'Def Date: '+$NAVInfo[1]

;                ? 'Parent Server: '+$NAVInfo[2]

;                ? 'Client Type: '+$NAVInfo[3]

;                ? 'Install Folder: '+$NAVInfo[4]

;

;                This would check to make sure the definition files are newer then 5 days

;                on the system named NTDOCWORK1  You can also supply an IP address if wanted

;                In this example a Messagebox would only display if older then 5 days

;                but the DOS Console would always display each of the listed values.

;

;Example(2)      GetNavAntiVirusInfo

;

;                This would cause it to run against the local system and use 14 days as the

;                default check since no workstation or date was specified.  Will display

;                a Messagebox if def files are old and will display a Messagebox if NAV is

;                not found to be installed.

;

;Example(3)      GetNavAntiVirusInfo(,'8',1,1)

;

;                This would cause it to run against the local system and use 8 days as the

;                date check. Since no workstation was specified.  With the $WarnOldDef set to 1

;                a Messagebox WILL NOT be displayed.  The No NAV found Messagebox would also

;                not be displayed since it is set to 1

;

;Example(4)      GetNavAntiVirusInfo(,'7',1)

;                IF $NAVInfo[7]

;                  ;  NET SEND Message to Helpdesk... Def files old

;                  ;  Email Helpdesk... Def files old

;                  ;  Log Def files old

;                  ;  ETC...

;                  ;  ? 'Found Old Def Files'

;                ENDIF

;

;                This would cause it to run against the local system and use 7 days as the

;                date check. Since no workstation was specified.  With the $WarnOldDef set to 1

;                a Messagebox WILL NOT be displayed.  By checking the value of element 7 in

;                the array, if it returns a value then the Definition files were found to be old.

;

;Example(5)

;                Break On

;                $nul=SetOption('WrapAtEOL','ON')

;                $nul=SetOption('Explicit','ON')

;                $nul=SetOption('NoVarsInStrings','ON')

;

;                DIM $NAVInfo

;                $NAVInfo = GetNavAntiVirusInfo(,'12')

;

;                This could be used in a LOGON script to check to make sure the

;                definition files are newer then 12 days on the system logging in.

;                A Messagebox would be displayed to the user alerting them to call

;                the Helpdesk for assistance if their definition files were oler then

;                the number of days set to check.  If they are newer then nothing is

;                shown to the user.  To log it you could use the idea in the example

;                above in EXAMPLE(1) and write to file the values returned from the array.

;

;Source

Function GetNavAntiVirusInfo(optional $wksta,optional $DateCheck,optional $WarnOldDef,optional $WarnNoNav)

DIM $Defdate,$CurDef,$NAVHome,$NavExecutable,$NavParent,$OldDefs,$AlertOldDef,$NAVPath

DIM $ClientType,$ReadClientType,$RegPath,$FilePath,$CurWksta,$NAVInfoArray[9]

DIM $AlertNoNAV,$NoNavWarn,$NoNavMsg,$Notify

$CurWksta = @WKSTA

IF $wksta = "" $wksta = @WKSTA ENDIF

IF $wksta = $CurWksta $RegPath = "" ELSE $RegPath = '\\'+$wksta+'\' ENDIF

IF $wksta = $CurWksta $FilePath = "" ELSE $FilePath = '\\'+$wksta+'\c$' ENDIF

IF $DateCheck = "" $DateCheck = 14 ENDIF

$ReadClientType = ReadValue($RegPath+'HKLM\SOFTWARE\INTEL\LANDesk\VirusProtect6\CurrentVersion', 'ClientType')

$Defdate = left(right(readvalue($RegPath+'HKLM\SOFTWARE\Symantec\SharedDefs','NAVCORP_70'),12),8)

$Defdate = left($Defdate,4) + '/' + substr($Defdate,5,2) + '/' + right($Defdate,2)

$CurDef = DateCalc(@date, $Defdate)

$NoNavWarn = EXISTKEY($RegPath+'HKLM\SOFTWARE\INTEL\LANDesk\VirusProtect6\CurrentVersion\Quarantine')

$NoNavMsg = 'Unable to locate the Symantec/Norton AntiVirus program on this system. '+'[ '+$wksta+' ]'

$NoNavMsg = $NoNavMsg+@CRLF+'Please contact the Helpdesk to have the program installed or checked for problems '

$NoNavMsg = $NoNavMsg+'with a previous installation.'

$NoNavMsg = $NoNavMsg+@CRLF+@CRLF+'Helpdesk  x555-8888'

IF $NoNavWarn <> 0

  IF $WarnNoNav <> 1

   $AlertNoNAV = MessageBox($NoNavMsg,'AntiVirus Program Update', 16,)

  ENDIF

ENDIF

$NAVHome = ReadValue($RegPath+'HKLM\software\INTEL\LANDesk\VirusProtect6\CurrentVersion\', 'Home Directory')

$NAVPath = $NAVHome

IF $wksta <> $CurWksta

  $NAVPath = substr($NAVHome,3,)

  $NAVPath = $FilePath+$NAVPath

ENDIF

$NavExecutable = GETFILEVERSION($NAVPath +'\vpc32.exe','ProductVersion')

$NavParent = READVALUE($RegPath+'HKLM\SOFTWARE\Intel\LANDesk\VirusProtect6\CurrentVersion','Parent')

SELECT

  CASE $ReadClientType = 1 $ClientType = 'Connected Client'

  CASE $ReadClientType = 2 $ClientType = 'Stand-alone Client'

  CASE $ReadClientType = 4 $ClientType = 'Server'

    IF $NavParent = ""

      $ClientType = 'Primary Server'

    ENDIF

  CASE $ReadClientType = "" $ClientType = 'Unknown'

ENDSELECT

$OldDefs = 'Warning: Your ANTI-VIRUS definition files are dated '

$OldDefs = $OldDefs +$Defdate+' which makes them '+$CurDef +' days old.'

$OldDefs = $OldDefs +@CRLF+@CRLF+'Your system '+'[ '+$wksta+' ]'+' is vulnerable to recent worms or viruses.'

$OldDefs = $OldDefs +@CRLF+@CRLF+'Please contact the Helpdesk to help determine why your system '

$OldDefs = $OldDefs +'is not automatically updating.'

$OldDefs = $OldDefs +@CRLF+@CRLF+'Helpdesk x555-8888 '

$OldDefs = $OldDefs +@CRLF+@CRLF+'Antivirus Engine version: '+$NavExecutable

$OldDefs = $OldDefs +@CRLF+'Antivirus Definition date: '+$Defdate

$OldDefs = $OldDefs +@CRLF+'Age of Definition Files: '+$CurDef

$OldDefs = $OldDefs +@CRLF+'Antivirus Parent Server: '+$NavParent

$OldDefs = $OldDefs +@CRLF+'Antivirus Client Type: '+$ClientType

$OldDefs = $OldDefs +@CRLF+'Antivirus Installation Folder: '+$NAVHome

IF $CurDef > $DateCheck

  $Notify = 2

  IF $WarnOldDef <> 1

    $AlertOldDef = MessageBox($OldDefs,'AntiVirus - Old Definitions', 48,)

  ENDIF

ENDIF

$NAVInfoArray[0]=$NavExecutable

$NAVInfoArray[1]=$Defdate

$NAVInfoArray[2]=$NavParent

$NAVInfoArray[3]=$ClientType

$NAVInfoArray[4]=$NAVHome

$NAVInfoArray[5]=$wksta

$NAVInfoArray[6]=$NoNavWarn

$NAVInfoArray[7]=$Notify

$NAVInfoArray[8]=$CurDef

$GetNavAntiVirusInfo=$NAVInfoArray

EndFunction  



 
 [ 03. September 2003, 21:15: Message edited by: NTDOC ]114241GetNavDate52NTDOCGetNavDate() - Returns DEF dates of Symantec AV1077255027;Function GetNavDate() 

; 

;Author NTDOC / Lonkero

; 

;Action Returns the current definition date of Symantec Corp Edition AV 

; 

;Syntax GetNavDate()

; 

;Version 1.2

; 

;Date 2004-Feb-17 

; 

;Date Revised 2004-Feb-19

; 

;Revision Reason   Day value was returning invalid day, now corrected.

; 

;Parameters None 

; 

;Remarks Tested on NT/2000/XP 

; Returns Symantec Corp Edition AV definition date

; 

;Dependencies None

; 

;KiXtart Version Written and tested with KiXtart v4.22 

; 

;Example (Line with DateCalc required DateCalc UDF)

;



; Debug Off

; Break On

; Dim $iRC

; $iRC=SetOption('Explicit','On')

; $iRC=SetOption('NoVarsInStrings','On')

; Dim $DefAge



; $DefAge = DateCalc(@DATE,GetNavDate)

; ? 'Definition files are dated ' + GetNavDate

; ? 'Definition files are now ' + $DefAge + ' days old'





Function GetNavDate()

Dim $PD

    $PD = ReadValue('HKLM\SOFTWARE\INTEL\LANDesk\VirusProtect6\CurrentVersion', 'PatternFileDate')

    $PD = Execute("$"+"GetNavDate=''+(1970 +&"+SubStr($PD,1,2)+")+'/'+right('0'+(1 + &"+SubStr($PD,3,2)+"),2)+'/'+"+"&"+SubStr($PD,5,2))

EndFunction84699GetOfficeDetails52NTDOCGetOfficeDetails() - Returns the version numbers of Microsoft Office applications0;Function        GetOfficeDetails() 

; 

;Author          NTDOC/Ron Lewis (ntdoc@@@@@kixhelp.com) 

; 

;Action          Returns the version numbers of Microsoft Office applications 

; 

;Syntax          GetOfficeDetails() 

; 

;Version         1.0 

; 

;Date            2003-Oct-23 

; 

;Date Revised    xxxx-xxx-xx 

; 

;Revision Reason  

; 

; 

;Parameters      None 

; 

;Remarks         Tested on NT/2000/XP 

; 

;Returns         Returns an array of values pertaining to Microsoft Office versions 

; 

;Dependencies    None 

; 

;KiXtart Ver     Written and tested with KiXtart v4.21 on NT/2000/XP 

;                 

;Example 

;                debug off 

;                break on 

;                dim $iRC 

;                $iRC=setoption('Explicit','on') 

;                $iRC=setoption('NoVarsInStrings','on') 

;                $iRC=setoption('WrapAtEOL','on') 

; 

;                dim $OfficeApps 

; 

;                $OfficeApps = GetOfficeDetails() 

; 

;                ? 'Excel Version: '+$OfficeApps[0] 

;                ? 'Word Version: '+$OfficeApps[1] 

;                ? 'PowerPoint Version: '+$OfficeApps[2] 

;                ? 'Access Version: '+$OfficeApps[3] 

;                ? 'Publisher Version: '+$OfficeApps[4] 

;                ? 'Project Version: '+$OfficeApps[5] 

;                ? 'Visio Version: '+$OfficeApps[6] 

;                ? 'Outlook Version: '+$OfficeApps[7] 

; 

;Source 



function GetOfficeDetails()

dim $HKLMAppPaths,$app,$path,$Excelver,$Wordver,$PowerPointver,$Accessver

dim $Publisherver,$Projectver,$Visiover,$Outlookver,$Index

dim $DetailsArray[8]

$HKLMAppPaths = 'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths'

while @error = 0

  $app=enumkey($HKLMAppPaths+'\',$Index) $Index = $Index + 1

  Select

    case $app='excel.exe'

      $path=readvalue($HKLMAppPaths+'\'+$app,'path')

      $Excelver=getfileversion($path+'\'+$app,'Productversion')

    case $app='winword.exe'

      $path=readvalue($HKLMAppPaths+'\'+$app,'path')

      $Wordver=getfileversion($path+'\'+$app,'Productversion')

    case $app='powerpnt.exe'

      $path=readvalue($HKLMAppPaths+'\'+$app,'path')

      $PowerPointver=getfileversion($path+'\'+$app,'Productversion')

    case $app='msaccess.exe'

      $path=readvalue($HKLMAppPaths+'\'+$app,'path')

      $Accessver=getfileversion($path+'\'+$app,'Productversion')

    case $app='mspub.exe'

      $path=readvalue($HKLMAppPaths+'\'+$app,'path')

      $Publisherver=getfileversion($path+'\'+$app,'Productversion')

    case $app='winproj.exe'

      $path=readvalue($HKLMAppPaths+'\'+$app,'path')

      $Projectver=getfileversion($path+'\'+$app,'Productversion')

    case $app='visio32.exe'

      $path=readvalue($HKLMAppPaths+'\'+$app,'path')

      $Visiover=getfileversion($path+'\'+$app,'Productversion')

    case $app='outlook.exe'

      $path=readvalue($HKLMAppPaths+'\'+$app,'path')

      $Outlookver=getfileversion($path+'\'+$app,'Productversion')

  endselect

loop

$DetailsArray[0]=$Excelver   $DetailsArray[1]=$Wordver        $DetailsArray[2]=$PowerPointver

$DetailsArray[3]=$Accessver  $DetailsArray[4]=$Publisherver   $DetailsArray[5]=$Projectver

$DetailsArray[6]=$Visiover   $DetailsArray[7]=$Outlookver     $GetOfficeDetails=$DetailsArray

endfunction 
109278GetOfficeDetails252NTDOCGetOfficeDetails2() - Get MS Office version details1121669617

;Function	GetOfficeDetails2()  
;  
;Author		NTDOC 
;  
;Action		Returns the version numbers and Type of Microsoft Office applications  
;  
;Syntax		GetOfficeDetails2()  
;  
;Version	1.2 
;  
;Date		2003-Oct-23  
;  
;Date Revised	2005-Jul-17  
;  
;Revision Reason 
;		1.1 
;		Updated code for Outlook and added FrontPage.  Also added Office Type 
;		1.2 
;		Updated code method which was incorrectly using WHILE LOOP 
;		Changed the method a little to get the Office Type 
;		Added InfoPath to the lookup 
;  
;Parameters	None  
;  
;Remarks	Tested on NT/2000/XP (might work locally on Win9x but will not work remotely) 
;  
;Returns	Returns an array of values pertaining to Microsoft Office versions  
;  
;Dependencies	KiXtart 4.22 or newer  
;  
;KiXtart	Written and tested with KiXtart v4.50 on NT/2000/XP  
;  
;Example  
;		Break On  
;		Dim $SO 
;		$SO=SetOption('Explicit','on')  
;		$SO=SetOption('NoVarsInStrings','on')  
;		$SO=SetOption('WrapAtEOL','on')  
;  
;		Dim $OfficeApps  
;  
;		$OfficeApps = GetOfficeDetails2()  
;		'Office Type is      : ' + $OfficeApps[10] ? 
;		'Excel Version       : ' + $OfficeApps[0] ? 
;		'Word Version        : ' + $OfficeApps[1] ? 
;		'PowerPoint Version  : ' + $OfficeApps[2] ? 
;		'Access Version      : ' + $OfficeApps[3] ? 
;		'Publisher Version   : ' + $OfficeApps[4] ? 
;		'Project Version     : ' + $OfficeApps[5] ? 
;		'Visio Version       : ' + $OfficeApps[6] ? 
;		'Outlook Version     : ' + $OfficeApps[7] ? 
;		'FrontPage Version   : ' + $OfficeApps[8] ? 
;		'InfoPath Version    : ' + $OfficeApps[9] ? 
;  
;Source  
 
Function GetOfficeDetails2(optional $sComputer)
  Dim $A,$B,$P,$Excelver,$Wordver,$PowerPointver,$Accessver,$Publisherver
  Dim $Projectver,$FrontPagever,$Visiover,$Outlookver,$InfoPathver
  Dim $Product,$Office
  Dim $Officeindex,$Officekey,$DetailsArray[11]
  Dim $Index,$RP,$C,$D
  $sComputer=IIf(Not $sComputer,'','\\'+Join(Split($sComputer,'\'),'',3)+'\')
  $A=$sComputer+'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths'
  $C=$sComputer+'HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall\'
  $D=$sComputer+Left(ReadValue($sComputer+'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion','CommonFilesDir'),1)
  $Index=0
  $B=EnumKey($A+'\',$Index)
  If @ERROR Exit @ERROR EndIf
  While @ERROR=0
    If $sComputer 
      $RP=$D+'$'+Right(ReadValue($A+'\'+$B,'path'),-2)
    Else
      $RP=ReadValue($A+'\'+$B,'path')
    EndIf
    Select
      Case $B='excel.exe'
        $Excelver=GetFileVersion($RP+'\'+$B,'BinFileVersion')
      Case $B='winword.exe'
        $Wordver=GetFileVersion($RP+'\'+$B,'BinFileVersion')
      Case $B='powerpnt.exe'
        $PowerPointver=GetFileVersion($RP+'\'+$B,'BinFileVersion')
      Case $B='msaccess.exe'
        $Accessver=GetFileVersion($RP+'\'+$B,'BinFileVersion')
      Case $B='mspub.exe'
        $Publisherver=GetFileVersion($RP+'\'+$B,'BinFileVersion')
      Case $B='winproj.exe'
        $Projectver=GetFileVersion($RP+'\'+$B,'BinFileVersion')
      Case $B='visio32.exe'
        $Visiover=GetFileVersion($RP+'\'+$B,'BinFileVersion')
      Case $B='outlook.exe'
        $Outlookver=GetFileVersion($RP+'\'+'OUTLLIB.DLL','BinFileVersion')
      Case $B='frontpg.exe'
        $FrontPagever=GetFileVersion($RP+'\'+$B,'BinFileVersion')
      Case $B='infopath.exe'
        $InfoPathver=GetFileVersion($RP+'\'+$B,'BinFileVersion')
    EndSelect
    $Index=$Index+1
    $B=EnumKey($A+'\',$Index)
  Loop
  $Officeindex=0
  $Officekey=EnumKey($C,$Officeindex)
  If @ERROR Exit @ERROR EndIf
  While @ERROR=0 And $Office=0
    $Product=ReadValue($C+$Officekey,'DisplayName')
    If InStr ($Product, 'Microsoft Office') And Not InStr($Product,'Live Meeting') And Not InStr($Product,'Studio')
      $Office=$Product
    EndIf
    $Officeindex=$Officeindex+1
    $Officekey=EnumKey($C,$Officeindex)
  Loop
$DetailsArray[0]=$Excelver    $DetailsArray[1]=$Wordver        $DetailsArray[2]=$PowerPointver
$DetailsArray[3]=$Accessver   $DetailsArray[4]=$Publisherver   $DetailsArray[5]=$Projectver
$DetailsArray[6]=$Visiover    $DetailsArray[7]=$Outlookver     $DetailsArray[8]=$FrontPagever
$DetailsArray[9]=$InfoPathver $DetailsArray[10]=$Office        $GetOfficeDetails2=$DetailsArray
EndFunction
 

84569GetOSInfo70maskenGetOSInfo() - Returns Windows OS information0Expanded Glenn's OSVer() a bit...

; 

;Function: 

;   GetOSInfo() 

;   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000463 

; 

;Author: 

;   masken (mastermasken@lycos.com) 

; 

;Version: 

;   1.0 

; 

;Version History: 

; 

;   1.0 [2003-09-26] Initial version. 

; 

;Action: 

;   Reads registry keys to determin OS of remote PC's. 

; 

;Syntax: 

;   GetOSInfo(REMOTEPC) 

; 

;Parameters: 

;   [OPTIONAL] REMOTEPC: The name of the PC to get OS information from. 

; 

;Tested on: 

;   WinNT4, Win2000, Win98SE 

;Remarks: 

;   * If you're going to read the registry on 9x machines, you need the 

;     "Remote Registry Service" installed. See MS KB for more info: 

;     http://support.microsoft.com/default.aspx?scid=kb;en-us;141460 

;     For the remote registry service to work, you need to: 

;     1. Set Network > Properties > Access Control tab to 

;            (o) User-Level Access Control 

;            And speficy your domain as the the list to retrieve names from. 

;     2. Set Control Panel > Passwords > Remote Administration tab to: 

;            [v] Enable remote administration of this server 

;            And specify the account(s) that should have access. 

;     3. Install Remote Registry Service: 

;        Network > Properties > Add > Service > Have Disk > point to your: 

;        [Win98 CD]\Tools\Reskit\Netadmin\Remotereg\REGSRV.INF 

;   * Glenn Barnas's OSVer(): 

;     http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000382 

; 

;Returns: 

;   A variable containing: 

;   NT-based OS's: "[OS version] [role], [Service Pack]" 

;   9x-based OS's: "[OS version][minor version]" 

;   (on error):    "N/A" 

;Error codes: 

;   1        The remote registry could not be read. 

; 

;Dependencies: 

;   * KiX 4.12+ 

;   * Administrative rights on the remote PC 

;   * On Win9x remote PC's, Remote REgistry Service 

; 

;Examples: 

;   $PCToCheck = "MYWKSTA" 

;   $os = GetOSInfo($PCToCheck) 

;   IF @ERROR = 0 

;        ? "OS on $PCToCheck is: $os" 

;   ENDIF 

; 

;Source 



FUNCTION GetOSInfo(OPTIONAL $RemotePC)

	DIM $RemotePC, $NTKey, $NTVersion, $SysType, $SP, $9xVersion, $9xMajorVer, $9xMinorVer

        IF $RemotePC = ""

                $RemotePC = @WKSTA

        ENDIF

        IF LEFT($RemotePC, 2) <> "\\"

                $RemotePC = "\\" + $RemotePC

        ENDIF

        IF RIGHT($RemotePC, 1) <> "\"

                $RemotePC = $RemotePC + "\"

        ENDIF

        $NTKey = "HKEY_Local_Machine\SOFTWARE\Microsoft\Windows NT\CurrentVersion"

        $NTVersion = READVALUE($RemotePC + $NTKey, "CurrentVersion")

        IF @ERROR = 0

                $SysType = READVALUE($RemotePC + "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\ProductOptions", "ProductType")

                $SP      = READVALUE($RemotePC + $NTKey, "CSDVersion")

                SELECT

                        CASE $NTVersion = "4.0"

                                $GetOSInfo = "Windows NT4"

                        CASE $NTVersion = "5.0"

                                $GetOSInfo = "Windows 2000"

                        CASE $NTVersion = "5.1"

                                $GetOSInfo = "Windows XP"

                        CASE $NTVersion = "5.2"

                                $GetOSInfo = "Windows 2003"

                        CASE 1

                                $GetOSInfo = "Windows NT $NTVersion"

                ENDSELECT

                SELECT

                        CASE $SysType = "WinNT"

                                IF $NTVersion = "4.0"

                                        $GetOSInfo = $GetOSInfo + " Workstation"

                                ELSE

                                        $GetOSInfo = $GetOSInfo + " Professional"

                                ENDIF

                        CASE $SysType = "ServerNT"

                                $GetOSInfo = $GetOSInfo + " Member Server"

                        CASE $SysType = "LanmanNT"

                                $GetOSInfo = $GetOSInfo + " Domain Controller"

                        CASE 1

                                $GetOSInfo = $GetOSInfo + " $SysType"

                ENDSELECT

                IF $SP <> ""

                        $GetOSInfo = $GetOSInfo + ", " + $SP

                ENDIF

        ELSE

                $9xVersion = READVALUE($RemotePC + "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion", "VersionNumber")

                IF @ERROR = 0

                        $9xMajorVer = VAL(SUBSTR($9xVersion, 3, 2))

                        $9xMinorVer = VAL(SUBSTR($9xVersion, INSTRREV($9xVersion, ".") + 1, LEN($9xVersion)))

                        IF $9xMajorVer < 10

                                SELECT

                                        CASE $9xMajorVer = 0 AND $9xMinorVer = 950

                                                $GetOSInfo = "Windows 95A"

                                        CASE $9xMajorVer = 0  AND $9xMinorVer < 1200 ;1214 = OSR 2.5 

                                                $GetOSInfo = "Windows 95B OSR 2.0"

                                        CASE 1

                                                $GetOSInfo = "Windows 95B OSR 2.5"

                                ENDSELECT

                        ELSE

                                IF $9xMinorVer > 1998

                                        $GetOSInfo = "Windows 98SE"

                                ELSE

                                        $GetOSInfo = "Windows 98"

                                ENDIF

                        ENDIF

                ENDIF

        ENDIF

        IF $GetOSInfo = ""

                $GetOSInfo = "N/A"

                EXIT 1

        ENDIF

ENDFUNCTION


 
 [ 26. September 2003, 12:56: Message edited by: masken ]83278GetOwner1057BrianTXGetOwner() - Returns username and domain of file owner0

code:

;FUNCTION	GetOwner($fileinput)
;
;AUTHOR		BrianTX
;
;ACTION		Gets the Owner of a file's username and domain and
;		returns them in the form of an array.
;
;SYNTAX		GetOwner($fileinput)
;
;PARAMETERS	$fileinput (Required) -  Name of a file including the 
;		full path. UNC names are NOT supported.
;
;REMARKS	This UDF is designed to allow processing on files based
;		on who their owner is.
;		
;RETURNS	Always an array of 2 dimensions -- username, domain
;		Invalid filenames will return an array of 2 blank columns.
;
;DEPENDENCIES	Windows NT 4.0 or later (with WMI installed)
;
;EXAMPLE	$Owner = GetOwner("M:\testfile.txt")
;		RETURNS:
;		$Owner[0] = "MyUserID"
;		$Owner[1] = "MYDOMAIN"
;		
;NOTE		Sometimes the domain returns as BUILTIN instead of the
;		actual domain, especially when there is group ownership.


Function GetOwner($fileinput)
 $wmiobj=GetObject("Winmgmts:")
 $SIDObj = $wmiobj.ExecQuery("ASSOCIATORS OF {Win32_LogicalFileSecuritySetting='$fileinput'}
                              WHERE AssocClass=Win32_LogicalFileOwner ResultRole=Owner")
 For each $SID in $SIDobj
 $GetOwner = $SID.AccountName, $SID.ReferencedDomainName
 Next
 If VarType($GetOwner)=0 $GetOwner = "","" ENDIF  
EndFunction

I haven't been able to test this on every OS, so if you get a chance to test, please let me know if I need to change anything or add anything to the information posted.

Thanks!

Brian
 
 [ 26. June 2003, 17:16: Message edited by: BrianTX ]84418GetPage70maskenGetPage() - Loads a webpage into a variable0


;Function:
; GetPage()
;
;KiXtart URL:
; http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000436
;
;Author:
; Lonkero, masken
;
;Version:
; 1.1
;
;Version History:
;
; v.1.0 [2003-07-01 16:05] Original Version.
; v.1.1 [2003-09-05 10:52] Suggestion by Bryce implemented. The UDF now changes
; the IE cache settings to make sure a non-cached page
; is retrieved. The original cache setting is restored
; after each call.
;
;Action:
; Loads an (uncached version of a) webpage into a variable.
;
;Syntax:
; GetPage(STRING)
;
;Parameters:
; STRING [REQUIRED]: URL of the page you want to retrieve.
;
;
;Remarks:
; Lonkero has helped me out with this one I only added the Status bit, and
; posted it in a UDF-friendly format with a sample 
; HTTP Status Codes:
; http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winhttp/http/http_status_codes.asp
; For example, An unknown DNS name returns .Status = 12xxx (ex: 12007), and 
; .Statustext = "Unknown"
;
;Returns:
; * The Response text (non-cached version) if successful
; * Error code 1 along with the returned HTTP status code and status text if
; there was an error getting the page.
;
;Dependencies:
; KiX 4.02, IE v.5+
;
;Example:
; ; *** Get the webpage, and extract the title ***
; $myPage = GetPage("http://www.kixtart.org/cgi-bin/ultimatebb.cgi")
; IF @ERROR = 0
; $myPageTitle = SPLIT($myPage, "</title>")[0]
; $myPageTitle = SUBSTR($myPageTitle, INSTR($myPageTitle, "<title>") + 7, LEN($myPageTitle))
; ? "Web page title: " + $myPageTitle
; ELSE
; ? "An error occured: " + $myPage
; ENDIF


FUNCTION GetPage($URL)
DIM $HTML, $IECacheKey, $IECacheVal
$IECacheKey = "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
$IECacheVal = READVALUE($IECacheKey, "SyncMode5")
IF $IECacheVal <> 3
$nul = WRITEVALUE($IECacheKey, "SyncMode5", "3", "REG_DWORD")
ENDIF
$HTML = CREATEOBJECT("microsoft.XMLhttp")
$HTML.Open("GET", $URL, NOT 1)
$HTML.Send
IF $HTML.Status = 200
$GetPage = $HTML.ResponseText ;or ResponseBody
ELSE
$GetPage = "HTTP Status Code: " + $HTML.Status + " (" + $HTML.StatusText + ")"
EXIT 1
ENDIF
$nul = WRITEVALUE($IECacheKey, "SyncMode5", $IECacheVal, "REG_DWORD")
ENDFUNCTION


 
 [ 05. September 2003, 10:57: Message edited by: masken ]82249GetScreenRes46kholmGetScreenRes() - Get screen resolution0GetScreenRes()

Action:
Returns the screen resolution

Syntax:
$Res = GetScreenRes() 

Parameters: 
None

Returns:
String: X-resolution,Y-resolution

Dependencies:
KiXtart 4.0 
UDF: WMIQuery()

Remarks:
For Win9x,Me and NT the function retrieves the info from the registry
The function used WMI to get the information on OS's where WMI is buildin (2k+)

Example(s):

code:

$ScreenRes = GetScreenRes()
If $ScreenRes
  ? 'ScreenRes: ' + $ScreenRes
Else
  ? 'ScreenRes not found'
EndIf

Source:

code:

Function GetScreenRes()
  Dim $Dev,$Idx,$RKey,$ScreenXRes,$ScreenYRes,$SType
  $GetScreenRes = ''
  If @InWin = 1 
    If Split(@ProductType)[1] <> "NT"
      $Dev = Split('' + WMIQuery("VideoModeDescription","Win32_VideoController"))
      If UBound($Dev) > 1
        $GetScreenRes = $Dev[0] + "," + $Dev[2]
      EndIf
    Else
      $RKey="HKLM\SYSTEM\CurrentControlSet\Hardware Profiles\Current\System\CurrentControlSet\Services"
      $Dev = "\Device0"
      If KeyExist($RKey)
        $Idx = 0
        Do
          $SType = EnumKey($RKey,$Idx)
          If @Error = 0 And $SType <> "VgaSave"
              $ScreenXRes = '' + ReadValue($RKey + "\" + $SType + $Dev,"DefaultSettings.XResolution")
              $ScreenYRes = '' + ReadValue($RKey + "\" + $SType + $Dev,"DefaultSettings.YResolution")
          Else
            $Idx = $Idx + 1
          EndIf
        Until @Error Or $ScreenXRes
        If $ScreenXRes
          $GetScreenRes = $ScreenXRes + ',' + $ScreenYRes
        EndIf
      EndIf
    EndIf
  Else
    $RKey="HKLM\Config\0001\Display\Settings"
    If KeyExist($RKey)
      $GetScreenRes = ReadValue($RKey,"Resolution")
    EndIf
  EndIf
EndFunction
 
; For easier cut'n paste, here is the code stolen from Radimus
; Explanation for WMIQuery(): Look in the link under dependencies
FUNCTION WMIQuery($what,$where, optional $computer)
  dim $strQuery, $objEnumerator, $value
  if not $computer  $computer="@WKSTA"  endif
  $strQuery = "Select $what From $where"
  $SystemSet = GetObject("winmgmts:{impersonationLevel=impersonate}!//$computer")
  $objEnumerator = $SystemSet.ExecQuery($strQuery)
  For Each $objInstance in $objEnumerator
    If @Error = 0 and $objInstance <> ""
      $=execute("$$value = $$objInstance.$what")
      $WMIQuery="$value"+"|"+"$WMIQuery"
      EndIf
    Next
  $WMIQuery=left($WMIQuery,len($WMIQuery)-1)
  exit @error
ENDFUNCTION

Author(s):

Erik Kærholm and the KiXtart BBS

Added support for Win2k and newer by using WMI
 
 [ 02 August 2002, 00:49: Message edited by: kholm ]137632GetSessionID4837pearlyGetSessionID( ) - Returns the Terminal Server session id0Code:


;FUNCTION      GetSessionID() 
; 
;ACTION        Returns the Terminal Server session id 
; 
;AUTHOR        pearly 
; 
;CONTRIBUTORS  Richard H. (I'm almost reluctant to claiming this function as my own.  Thank you!) 
; 
;VERSION       1.0 
; 
;DATE CREATED  2005/03/06 
; 
;DATE MODIFIED 2005/03/06 
; 
;KIXTART       KiXtart 4.20 
; 
;SYNTAX        GetSession() 
; 
;PARAMETERS    None. 
; 
;RETURNS       Integer. 
; 
;REMARKS       Uses %TEMP% environment variable. 
; 
;DEPENDENCIES  None. 
; 
;EXAMPLE       Dim $session 
;			   $session = GetSessionID() 
; 
;KIXTART BBS    
; 
Function GetSessionID()
	Dim $s_sessionid
	Dim $iIndex
	$GetSessionID = 0
	$s_sessionid = SubStr(%TEMP%,1+InStrRev(%TEMP%,"\"))
	While $s_sessionid <> ""
		$iIndex = InStr("0123456789ABCDEF",Left($s_sessionid,1))
		If $iIndex
			$GetSessionID = $GetSessionID*16+(Cint($iIndex-1))
			$s_sessionid = SubStr($s_sessionid,2)
		Else
			$GetSessionID = 0
			$s_sessionid = ""
		EndIf
	Loop
EndFunction

185008GetShortcutAttr1024MartGetShortcutAttr() - Get the attributes of a shortcut1201950650

ÿCode:

;Function	GetShortcutAttr()
;
;Author:
;		Mart
;
;Action:
;		Get the attributes of a specific shortcut.
;
;Syntax:
;		GetShortcutAttr($shortcutname)
;
;Version:
;		1.0 February 1st 2008
;			Initial post.
;
;Date Revised:
;		Version 2.0 February 1st 2008.
;			Fixed some issues and added extra attributes.
;
;Parameters:
;		$shortcutname (required)
;			Shortcut to be queried.
;		$attribute (required)
;			Attribute to be returned.
;			1 = Arguments - Additional command-line arguments.
;			2 = Description - Description given to the shortcut.
;			3 = FullName - The complete path to the target application.
;			4 = HotKey - Keyboard shortcut.
;			5 = IconLocation - The location of the icon used.
;			6 = TargetPath - Complete path to the target application.
;			7 = WindowStyle - The initial window type For the application.
;				Returns: 1 = Normal Window, 3 = Maximized, 7 = Minimized.
;			8 = WorkingDirectory - The working directory for the application.
;		
;Returns:
;		Target of the selected shortcut or system error codes
; 
;Dependencies
;		Developed on Windows XP pro SP2 and KiXtart 4.60.
;
;Example(s):
;		;Get the arguments.
;		$rc = GetShortcutAttr("c:\someshortcut.lnk", "1")
;		?$rc
;
;		;Get the hot keys.
;		$rc = GetShortcutAttr("c:\someshortcut.lnk", "4")
;		?$rc

Function GetShortcutAttr($shortcutname, $attribute)
	
	Dim $obj
	
	;check if shortcut is empty or not.
	If $shortcutname = ""
		Exit 87
	EndIf

	;check if attribute is empty or not.
	If $attribute = ""
		Exit 87
	EndIf

	;chek if shortcut exists.
	If Not Exist ($shortcutname)
		$getshortcutattr = 2
		Exit 2
	EndIf

	;cretae shell object and get shortcut targetpath.
	$obj = CreateObject("WScript.Shell")
	;exit if shell object can not be created.
	If @ERROR
		$getshortcutattr = @ERROR
		Exit @ERROR
	EndIf
	$shortcut = $obj.CreateShortcut($shortcutname)

	Select
		Case $attribute = "1"
			$getshortcutattr = $Shortcut.Arguments
		Case $attribute = "2"
			$getshortcutattr = $Shortcut.Description
		Case $attribute = "3"
			$getshortcutattr = $Shortcut.FullName
		Case $attribute = "4"
			$getshortcutattr = $Shortcut.HotKey
		Case $attribute = "5"
			$getshortcutattr = $Shortcut.IconLocation
		Case $attribute = "6"
			$getshortcutattr = $Shortcut.TargetPath
		Case $attribute = "7"
			$getshortcutattr = $Shortcut.WindowStyle
		Case $attribute = "8"
			$getshortcutattr = $Shortcut.WorkingDirectory
	EndSelect

EndFunction
182375GetShortcutProperties3439AllenGetShortcutProperties() - Get Properties /  Attributes of Shortcut files0

 

;;  
;;======================================================================  
;;  
;;FUNCTION       GetShortcutProperties()  
;;  
;;ACTION         Returns a specific shortcut property, or an array of all properties  
;;  
;;AUTHOR         Allen Powell  (original) / Glenn Barnas (cleanup/adaptation)  
;;  
;;VERSION        1.0 / 2007/11/08  
;;  
;;SYNTAX         GetShortcutProperties(File [, Property])  
;;  
;;PARAMETERS     File		- REQUIRED, Fully Qualified File Name  
;;  
;;		 Property	- OPTIONAL, name of shortcut property to return from the following values: 
;;                                Path (or Target), Description, Icon (Includes IconLocation and IconIndex),  
;;                                IconLocation,IconIndex,Arguments, Style (or Run), Startin (or WorkingDirectory)         
;;  
;;REMARKS          
;;  
;;RETURNS        Variant with single property if property is requested, otherwise  
;;		 returns an Array with all 8 property values  
;;  
;;DEPENDENCIES   WSH  
;;  
;;TESTED WITH    W2K, WXP, W2K3, Vista  
;;  
;;EXAMPLES 
;;               ? "Individual Properties" 
;;               $SC='C:\Users\username\Desktop\MyDesktop.lnk'    
;;               $SCPath=GetShortcutProperties($SC,"Path")  
;;               $SCDescription=GetShortcutProperties($SC,"Description")  
;;               ? "Path: " + $SCPath 
;;               ? "Description: " + $SCDescription 
;;               ?? 
;; 
;;               ? "Array/Collection of Properties" 
;;		 $array = GetShortcutProperties($SC)   
;;		 For Each $property in $array 
;; 		   $property ?  
;;		 Next  
;  
Function GetShortcutProperties($_FqFn, OPTIONAL $_Property)
 
  Dim $_oShell				; shell object pointer  
  Dim $_iShortcut			; shortcut item in shell object array  
  Dim $_aTmp[7]				; temp array  
 
  ; Verify that the defined shortcut is present  
  If Exist($_FqFn)
 
    $_oShell = CreateObject("wscript.shell")
 
    If $_oShell
      $_iShortcut = $_oShell.CreateShortcut($_FqFn)	; get properties  
 
      ; place all properties into an array  
      $_aTmp[0] = $_iShortcut.Description
      $_aTmp[1] = $_iShortcut.targetpath
      $_aTmp[2] = $_iShortcut.workingdirectory
      $_aTmp[3] = $_iShortcut.Iconlocation
      $_aTmp[4] = split($_iShortcut.Iconlocation,",")[0]
      $_aTmp[5] = split($_iShortcut.Iconlocation,",")[1]
      $_aTmp[6] = $_iShortcut.Arguments
      $_aTmp[7] = $_iShortcut.windowstyle
 
      ; return a specific property if requested, otherwise return the array of all properties  
      If $_Property
        Select
         Case $_Property = "Description"
          $GetShortcutProperties = $_aTmp[0]
         Case $_Property = "Path" or $_Property = "Target"
          $GetShortcutProperties = $_aTmp[1]
         Case $_Property = "Startin" or $_Property = "WorkingDirectory"
          $GetShortcutProperties = $_aTmp[2]
         Case $_Property = "Icon"
          $GetShortcutProperties = $_aTmp[3]
         Case $_Property = "IconLocation"
          $GetShortcutProperties = $_aTmp[4]
         Case $_Property = "IconIndex"
          $GetShortcutProperties = $_aTmp[5]
         Case $_Property = "Arguments"
          $GetShortcutProperties = $_aTmp[6]
         Case $_Property = "Style" or "Run"
          $GetShortcutProperties = $_aTmp[7]
        EndSelect
      Else	; no property  
        $GetShortcutProperties = $_aTmp
      EndIf	; property  
 
    Else	; shell shortcut failed  
      Exit @ERROR	; return shell instantiation error  
    EndIf	; shell ?  
  Else
    Exit 2	; file not found  
  EndIf		; file ?  
 
  Exit 0		; return success  
 
EndFunction
83692GetShortFileName2280Lee WilmottGetShortFileName() - Returns the name/path (or both) of a given file in 8.3 format0

code:

Function GetShortFileName($FilePath, $FileOrPath, Optional $CapsReq)
	;Author: Lee Wilmott
	;Date: 27/11/02
	;Returns the name/path (or both) of a given file in 8.3 format
	;ARGS:	$FilePath		The full expanded path (inc. filename)
	;	$FileOrPath		1 = Return file in 8.3 format
	;				2 = Return path in 8.3 format
	;				3 = Return file AND path in 8.3 format
	;	$CapsReq (optional)	0 = Returns in lowercase
	;				1 = Returns in uppercase
	;				if not specified then returns with case untouched
	Dim $fso, $file, $FileNameAndPathArray, $ShortFileName, $ShortFilePath
	
	$fso = CreateObject("Scripting.FileSystemObject")
	$file = $fso.GetFile($FilePath)
	
	$GetShortFileName = ""
	If ($FileOrPath & 1) > 0
		$GetShortFileName = $GetShortFileName + $file.ShortName
	EndIf
	If ($FileOrPath & 2) > 0
		If $GetShortFileName <> ""
			$GetShortFileName = "\" + $GetShortFileName
		EndIf
		$GetShortFileName = Join(Split($file.ShortPath, "\", UBound(Split($file.ShortPath, "\"))), "\") + $GetShortFileName
	EndIf
	
	If VarType($CapsReq) <> 0
		If $CapsReq = 0
			$GetShortFileName = LCase($GetShortFileName)
		EndIf
		If $CapsReq = 1
			$GetShortFileName = UCase($GetShortFileName)
		EndIf
	EndIf
	
	$fso = "Release"
EndFunction

83064GetSID123LesGetSID() - Returns SID and converts it to string format0This function will get the SID of the domain object specified using ADSI.ÿ It is like the KiX @SID macro, but unlike @SID, is not limited to the current user (@UserID).

I really did not have a need for this function, but someone posted a question of how to hack the HKCU of a remote registry.ÿ I'm sure most of you know that HKCU is just "smoke and mirrors".ÿ That in reality it is a manufactured view of HKU\@SID.ÿ The need to get another user's SID was realized hence this function was born.

Be advised that I'm not a real programmer, that programming does not come easily for me, and that it was only with the help of Shawn that I was able to pull this off.ÿ If you need support, ask Shawn or search for his GetRID() UDF from which this is plagiarized.       

While it may be possible to get the SID of other objects beside users, I only tested it with user objects.

code:

;function	GetSID()
;
;Author		Les Ligetfalvy
;
;Contributors	Shawn, Bryce (90% of this code is Shawn's)
;
;Action		Returns the ASCII Security Identifier (SID) of the ADSI object specified
;
;Requires:
;		1) Windows 2000 or WindowsNT/9x with ADSI installed
;		2) ADsSecurity.DLL (from the ADSI SDK)
;
;Syntax		$SID = GetSID("WinNT://@LDOMAIN/@USERID,USER")
;
;Example
;
break on
$SID = GetSID("WinNT://ff/lligetfa,USER")
? $SID

Get $_
Exit 1
;
;Source
function GetSID($adspath)
 
  dim $rev,$sidobj,$sid,$sac,$x
  $GetSID=0

  $sidobj=createobject("adssid")
  $sidobj.setas(5,$adspath)
  $sid=$sidobj.getas(1)

  if not $sid
    $sidobj=0
    return
  endif

  $Rev=val(substr($sid,1,2))

  ; Extract the SubAuthority Count (SAC) from the SID (range of 1 - 8, hence no hex conversion necessary)
  $SAC=val(substr($sid,3,2))
  $IdentAuth=Val("&"+substr($sid,5,12))
  $GetSID="S-"+$Rev+"-"+$IdentAuth

  ; Convert SID little-endian, just re-reverse the bytes and convert to decimal...
  ; Recurse as per SAC
  For $X=1 to $SAC
    $GetSID=$GetSID+"-"+Val("&"+substr($sid,8*$X+15,2)+substr($sid,8*$X+13,2)+substr($sid,8*$X+11,2)+substr($sid,8*$X+9,2))
  Next

  $sidobj=0

EndFunction

{edit}
revised as per Howard's comment
 
 [ 04 May 2002, 17:19: Message edited by: LLigetfa ]84651GetSpecialFolders52NTDOCGetSpecialFolders() - Returns the Name and Path of Special Folders0;Function        GetSpecialFolders() 

; 

;Author          NTDOC/Ron Lewis (ntdoc@@@@@kixhelp.com) 

; 

;Contributors    Howard, Lonkero, Chris, Shawn 

; 

;Action          Queries the name and path of Special Folders 

; 

;Syntax          GetSpecialFolders($Folder) 

; 

;Version         1.01 

; 

;Date            2003-Oct-18 

; 

;Date Revised    2003-Oct-18 

; 

;Revision Reason Ver 1.00 Original release 

;                Ver 1.01 Updated code to be cleaner per suggestion by Radimus 

; 

;Parameters      $Folder  {Number of the Special Folder you want to retrieve} 

; 

;Remarks         The Windows operating system includes a number of special folders, folders that 

;                have a well-defined purpose and are generally present on all computers. 

;                These special folders include virtual folders, such as My Documents and Recycle Bin, 

;                as well as physical file system folders such as Program Files and Fonts. Because of 

;                the importance of these folders, it is useful for a system administrator to be able 

;                to locate and, if necessary, manipulate these folders on any computer 

; 

;Further Info    http://msdn.microsoft.com/library/default.asp?url=/library/en-us/shellcc/platform/shell/programmersguide/versions.asp 

; 

;                Common Folder Name                       Number  Supported OS 

; 

;                Internet Explorer                        =  1    2K/XP 

;                Programs                                 =  2    2K/XP 

;                Control Panel                            =  3    2K/XP 

;                Printers                                 =  4    2K/XP 

;                My Documents                             =  5    2K/XP 

;                Favorites                                =  6    2K/XP 

;                Startup                                  =  7    2K/XP 

;                Recent                                   =  8    2K/XP 

;                SendTo                                   =  9    2K/XP 

;                Recycle Bin                              = 10    2K/XP 

;                Start Menu                               = 11    2K/XP 

;                My Music                                 = 13    XP 

;                My Videos                                = 14    XP 

;                Desktop                                  = 16    2K/XP 

;                My Computer                              = 17    2K/XP 

;                My Network Places                        = 18    2K/XP 

;                NetHood                                  = 19    2K/XP 

;                Fonts                                    = 20    2K/XP 

;                Templates                                = 21    2K/XP 

;                All Users Start Menu                     = 22    2K/XP 

;                All Users Programs                       = 23    2K/XP 

;                All Users Startup                        = 24    2K/XP 

;                All Users Desktop                        = 25    2K/XP 

;                Application Data                         = 26    2K/XP 

;                PrintHood                                = 27    2K/XP 

;                Local Settings Application Data          = 28    2K/XP 

;                All Users Favorites                      = 31    2K/XP 

;                Local Settings Temporary Internet Files  = 32    2K/XP 

;                Cookies                                  = 33    2K/XP 

;                Local Settings History                   = 34    2K/XP 

;                All Users Application Data               = 35    2K/XP 

;                Windows                                  = 36    2K/XP 

;                System32                                 = 37    2K/XP 

;                Program Files                            = 38    2K/XP 

;                My Pictures                              = 39    2K/XP 

;                User Profile                             = 40    2K/XP 

;                System32                                 = 41    2K/XP 

;                Common Files                             = 43    2K/XP 

;                All Users Templates                      = 45    2K/XP 

;                All Users Documents                      = 46    2K 

;                All Users Administrative Tools           = 47    2K/XP 

;                Administrative Tools                     = 48    2K/XP 

;                Network Connections                      = 49    2K/XP 

; 

;                NUMBERS NOT USED:                        = 12,13,14,15,29,30,42,44 

;                NUMBERS RETURN GUID ONLY                 = 1,3,4,10,17,18,49 

; 

;Returns         Returns the Name and Path of Special Folders 

; 

;Dependencies    Windows 2000/XP, KiXtart 4.x, SHELL32.DLL 

; 

;KiXtart Ver     Written and tested with KiXtart v4.22 Release Candidate 1 on 2000/XP ONLY! 

;                It may work on Win9x/NT but has not been tested. 

; 

;Example(1)      debug off 

;                break on 

;                dim $iRC 

;                $iRC=setoption('Explicit','ON') 

;                $iRC=setoption('NoVarsInStrings','ON') 

;                $iRC=setoption('WrapAtEOL','ON') 

;                dim $SpFolder,$ 

; 

;                $SpFolder = GetSpecialFolders(22) 

;                ? 'Name of Special Folder: '+$SpFolder[0] 

;                ? 'Path of Special Folder: '+$SpFolder[1] 

;                get $ 

; 

;                {The above example using 22 should return something like this: 

;                Name of Special Folder: Start Menu 

;                Path of Special Folder: C:\Documents and Settings\All Users\Start Menu 

; 

;                Using 25 should return something like this: 

;                Name of Special Folder: Desktop 

;                Path of Special Folder: C:\Documents and Settings\All Users\Desktop 

; 

; 

;Example(2)      debug off 

;                break on 

;                dim $iRC 

;                $iRC=setoption('Explicit','ON') 

;                $iRC=setoption('NoVarsInStrings','ON') 

;                $iRC=setoption('WrapAtEOL','ON') 

;                dim $SpFolder,$AllUserDesktop,$File 

; 

;                $SpFolder = GetSpecialFolders(25) 

;                $AllUserDesktop=$SpFolder[1] 

;                $File='\\Server1\shared\imaging\toons.gif' 

;                if exist($File) 

;                  copy  $File $AllUserDesktop 

;                endif 

;                ? 'Copy was: '+@ERROR+'  '+@SERROR 

; 

;NOTE:           Your calling script should check to verify the existence of all folders queried 

;                before attempting to use the returned folder. 

; 

;Source 



function GetSpecialFolders($Folder)

  dim $objFolderItem

  $objFolderItem=createobject('Shell.Application').Namespace($Folder).Self

  $GetSpecialFolders=$objFolderItem.Name,$objFolderItem.Path

endfunction 

 
 [ 18. October 2003, 12:18: Message edited by: NTDOC ]84658GetSubnetClients70maskenGetSubnetClients() - Queries DHCP server(s) for leases, returns IP, MAC & up-status0Another variant to get (active) clients...

; 

;Function: 

;   GetSubnetClients() 

; 

;Author: 

;   masken (mastermasken@lycos.com) 

; 

;Version: 

;   1.0 

; 

;Version History: 

; 

;   1.0 [2003-10-20] Initial version. 

; 

;Action: 

;   Queries the specified DHCP server(s) for leases on the specified subnet, 

;   and returns an array with IP addresses, hostnames, and MAC addresses, 

;   optionally also an active-status. 

; 

;Syntax: 

;   GetSubnetClients(DHCPSERVER(s), SUBNET, optional ACTIVE) 

; 

;Parameters: 

;   [REQUIRED] DHCPSERVER(s): The IP address of the DHCP server. Multiple IP 

;                             addresses can be specified, separated with a semi- 

;                             colon: [IPADDRESS1;IPADDRESS2;IPADDRESS3]. 

; 

;   [REQUIRED] SUBNET:        Valid DHCP server subnet to check. 

; 

;   [OPTIONAL] ACTIVE:        If set to "1", the UDF will use nmap to perform 

;                             a ping on each of the existing DHCP lease 

;                             addresses. 

; 

;Remarks: 

;   * RAS leases (32 chr long) and leases without NetBIOS names are excluded. 

;   * This UDF optionally uses nmap.exe to perform quicker parallel pings. This 

;     tool can be considered unorthodox by some... 

;   * The point of this tool is to retrieve a "list" of clients, for use with 

;     other scripts, for example remote execution managers etc. 

;   * Supports both NT4 & 2000 DHCP servers. 

;   * KiXtart references: 

;     Radimus EnumDHCP() 

;     http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000325 

;     Glenn Barnas OSVer() 

;     http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000382 

; 

;Returns: 

;   An array with computer information in the following format: 

;   $SubnetClients[x] = "IPADDRESS;NETBIOSNAME;MACADDRESS;ACTIVE" 

;                       ACTIVE = 0  client didn't respond to ping. 

;                       ACTIVE = 1  client responded to ping. 

;                       ACTIVE = "" option disabled. 

;Error codes: 

;   1        Some or all of the required tools or UDF's could not be found. 

;   2        Malformed subnet. 

; 

;Dependencies: 

;   * Utilities and system: 

;        KiX 4.02+   - http://www.kixtart.org/ 

;        WSH 5.6     - Included with MS IE 6+. Also available at the MSDN website. 

;        dhcpcmd.exe - NT/2000 reskit utility. 

;        nmap.exe    - Available at http://www.insecure.org/nmap 

;   * UDF's @ http://www.kixtart.org/board/ 

;        WSHPipe()   - ultimatebb.php?ubb=get_topic;f=12;t=000218 

; 

;Example: 

;   $DHCPSrvIP = "192.168.1.2;192.168.1.3;192.168.1.4" 

;   $Subnet    = "192.168.4.0" 

;   $Active    = "1" 

; 

;   $ResultArray = GetSubnetClients($DHCPSrvIP, $Subnet, $Active) 

;   ? "Active clients on subnet $Subnet:" 

;   FOR EACH $ClientData IN $ResultArray 

;           $IsActive = SPLIT($ClientData, ";")[3] 

;           IF $IsActive = 1 

;                   $ClientName = SPLIT($ClientData, ";")[1] 

;                   ? "   $ClientName" 

;           ENDIF 

;   NEXT 

; 

;TODO: 

;   * Make the removal of RAS addresses optional? 

;   * Find and clean out duplicate DHCP entries? 

; 

;UDF status: 

;   * Done/working. 

; 

;Source: 

; 



FUNCTION GetSubnetClients($DHCPSrvIP, $Subnet, OPTIONAL $Active)



        DIM $ToolDir, $TempDir, $Tools, $NmapList, $ExistTempDir, $DHCPCMDCall, $DHCPReturns,

            $DHCPReturn, $ArrDHCPSrvIPs, $ArrDHCPSrvIP, $SubnetCheck, $Octets, $LineCheck,

            $Client, $NmapCall, $ActiveClients, $ActiveClient, $ActiveList, $ResultLine,

            $IPAddress, $NetBIOSName, $MACAddress, $NewResult, $IPAddressResult



        ;------------------------------------------------------------------------------- 

        ;--- Configuration 

        $ToolDir = "@SCRIPTDIR\Tools"   ; put nmap.exe & dhcpcmd.exe here. 

        $TempDir = "%TEMP%\GetSubnetClients"



        ;------------------------------------------------------------------------------- 

        ;--- Initial checks 

        $Tools    = "dhcpcmd.exe", "nmap.exe"

        $NmapList = "$TempDir\nmap_list.lst"



        FOR EACH $Tool IN $Tools

                IF EXIST("$ToolDir\$Tool") = 0

                        $GetSubnetClients = "Error: The tool " + CHR(34) + "$Tool" + CHR(34) + " couldn't be found in $ToolDir"

                        ;---TEST 

                        ? "$GetSubnetClients"

                        EXIT 1

                ENDIF

        NEXT



        IF EXIST("$NmapList") = 1

                DEL "$NmapList"

        ENDIF



        CALL "@SCRIPTDIR\WSHPipe.udf"

        IF @ERROR <> 0

                $GetSubnetClients = "Error: @ERROR (@SERROR), calling [@SCRIPTDIR\WSHPipe.udf]"

                EXIT 1

        ENDIF



        $ExistTempDir = GETFILEATTR("$OutputDir")

        IF $ExistTempDir <> 16

                MD "$TempDir"

        ENDIF



        IF INSTR($DHCPSrvIP, ";") <> 0

                $ArrDHCPSrvIPs = SPLIT($DHCPSrvIP, ";")

        ELSE

                REDIM $ArrDHCPSrvIPs[0]

                $ArrDHCPSrvIPs[0] = $DHCPSrvIP

        ENDIF



        $SubnetCheck = SPLIT($Subnet, ".")

        $Octets = UBOUND($SubnetCheck)

        IF $Octets <> 3 OR ASCAN($SubnetCheck, "") <> -1

                $GetSubnetClients = "Error: Malformed subnet ($Subnet)"

                EXIT 2

        ENDIF

        $LineCheck = $SubnetCheck[0] + "." + $SubnetCheck[1] + "."



        ;------------------------------------------------------------------------------- 

        ;--- Query DHCP server(s) for active leases and collect client info. 

        FOR EACH $ArrDHCPSrvIP IN $ArrDHCPSrvIPs

                $DHCPCMDCall = '$ToolDir\dhcpcmd.exe $ArrDHCPSrvIP EnumClients $Subnet -h'

                $DHCPReturns = WSHPipe($DHCPCMDCall, 1)

                IF NOT @ERROR

                        FOR EACH $DHCPReturn IN $DHCPReturns

                                IF INSTR($DHCPReturn, $LineCheck) <> 0

                                        $ResultLine  = SUBSTR($DHCPReturn, INSTR($DHCPReturn, $LineCheck), LEN($DHCPReturn))

                                        $IPAddress   = SUBSTR($ResultLine, 1, INSTR($ResultLine, " ") - 1)

                                        $NetBIOSName = TRIM(SUBSTR($ResultLine, INSTR($ResultLine, " "), INSTRREV($ResultLine, " ") - INSTR($ResultLine, " ")))

                                        IF INSTR($NetBIOSName, ".") <> 0

                                                ;|Win2000+ DHCP always tries to return FQDN, strip the trailing dot. 

                                                $NetBIOSName = SUBSTR($NetBIOSName, 1, INSTR($NetBIOSName, ".") - 1)

                                        ENDIF

                                        $MACAddress = SUBSTR($ResultLine, INSTRREV($ResultLine, " ") + 1, LEN($ResultLine))

                                        IF LEN($MACAddress) = 12 AND INSTR($NetBIOSName, "(null)") = 0

                                                ;|Exclude 32 chr long RAS address and leases without NetBIOS names. 

                                                $NewResult = $IPAddress + ";" + $NetBIOSName + ";" + $MACAddress

                                                IF $DHCPResult = ""

                                                        $DHCPResult = $NewResult

                                                        $IPAddressResult = $IPAddress

                                                ELSE

                                                        $IPAddressResult = $IPAddressResult + @CRLF + $IPAddress

                                                        $DHCPResult = $DHCPResult + "|" + $NewResult

                                                ENDIF

                                        ENDIF

                                ENDIF

                        NEXT

                ELSE

                        $GetSubnetClients = "Dhcpcmd.exe error on subnet [$Subnet] for server [$ArrDHCPSrvIP], errorcode @ERROR (@SERROR)"

                        EXIT 2

                ENDIF

        NEXT

        $GetSubnetClients = SPLIT($DHCPResult, "|")



        IF $Active = 1

                IF OPEN(1, "$NmapList", 5) = 0

                        $nul = WRITELINE(1, $IPAddressResult)

                        IF CLOSE(1) ENDIF

                        ;|Nmap will only return IP addresses of clients that are up. 

                        $NmapCall = '$ToolDir\nmap.exe -iL "$NmapList" -n -sP | find "$LineCheck"'

                        $ActiveClients = WSHPipe($NmapCall, 1)

                        FOR EACH $ActiveClient IN $ActiveClients

                                $ActiveClient = SUBSTR($ActiveClient, 6, INSTR($ActiveClient, " appears to be up.") - 6)

                                $ActiveList = $ActiveList + $ActiveClient + "|"

                        NEXT

                ENDIF



                FOR $Client = 0 TO UBOUND($GetSubnetClients)

                        $IPAddress = SPLIT($GetSubnetClients[$Client], ";")[0]

                        IF INSTR($ActiveList, $IPAddress) <> 0

                                $GetSubnetClients[$Client] = $GetSubnetClients[$Client] + ";" + "1"

                        ELSE

                                $GetSubnetClients[$Client] = $GetSubnetClients[$Client] + ";" + "0"

                        ENDIF

                NEXT



        ELSE

                FOR $Client = 0 TO UBOUND($GetSubnetClients)

                        $GetSubnetClients[$Client] = $GetSubnetClients[$Client] + ";"

                NEXT

        ENDIF

ENDFUNCTION

121110GetSubnetIPs28BryceGetSubnetIPs()1111597178Code:


;Function: 
;     GetSubnetIPs()
; 
;Author: 
;     Richard H.  (Bryce just stuck it in a UDF)
; 
;Version: 
;     2.0
; 
;Version history: 
;     1.0 June 10 2004 First publish
;     2.0 july 13 2004 Richards version is much faster!
;
;Action: 
;     This UDF will generate an array of ALL ip address in a given subnet.
; 
;Syntax: 
;     GetSubnetIPs(SUBNET,SUBNETMASK)
; 
;Parameters: 
;     SUBNET        - any ip address in the subnet that you want to return
;     SUBNETMASK    - The subnet mask indicating the sixe fo the subnet that 
;                     you want to return.  use dotted decimial format (255.255.0.0)
;Returns: 
;     An array of all ip address that are in a given subnet
; 
;Dependencies: 
;     IPDecimal()
; 
;Remarks: 
;     The first version that was writen by Bryce was slow and cumbersom compaired
;     the code that Richard gave us!  This is all Richards code!
; 
;Example: 
;     $ip = Getsubnetips("128.2.65.65","255.255.192.0")
;       ? $ip[0]
;       ? $ip[ubound($ip)]
;
;Source: 
Function GetSubnetIPs($ip,$mask)
	dim $network, $Hostaddresses,$i
	$Network=IPDecimal($IP) & IPDecimal($Mask)
	$HostAddresses=IPDecimal("255.255.255.255")-IPDecimal($Mask)-1
	; Create an array of all possible host addresses (not network or broadcast address)
	Dim $IPArray[$HostAddresses-1]
	For $i=1 To $HostAddresses
		$IPArray[$i-1]=IPDecimal($Network+$i)
	Next
	$GetSubnetIPs = $IPArray
endfunction

 156509Gettok5931apronkGettok() - Returns the tokens specified from an array1147100690Code:


;Function 	Gettok() - Returns the tokens specified from an array
;
;Author	  	Arend Pronk (arendpronk@chello.nl)
;
;Contributors	Basically Khaled Mardam-Bey since I (re)wrote his mIRC function $gettok()
; 		into Kix Language.
;
;Action		Returns the tokens specified from an array
;
;Syntax		Gettok($string,$part,$delim)
;
;Version  	1.1
;
;Date     	02-02-2006
;
;Date Revised	23-02-2006
;
;Revise Reason 	Didn't return the proper element when asked 1-3 it gave 2-3.
;
;Parameters 	$string can be as simple as: "hi.just.testing"
;		$part should be 0,1 or more but never higher then the amount of delimiters in the string.
;		The function will exit with error code 1 if you do. Best thing to do is to set $part to 0
;		to find out how many delimiters there are in your string.
;		$delim is the delimiter such as 46 would be a . (look at Chr() for details)
;
;Remarks  	Difference here between what normal Kix users are used to is that 0 will return the amount
;    		of delimiters instead of the first delimiter and 1 will return the first token and so on.
;
;Returns  	Returns the tokens specified from an array, look at the example for details
; 
;Dependencies 	None
;
;KiXtart Ver.	4.51
; 
;Example(s)	$x = Gettok("hi.just.testing","0",46) 
;		will return 3, because there are 3 .'s (dots) in the string.
;
;		$x = Gettok("hi.just.testing","1",46)
;		will return "hi", because it it the first element in the dot separated string.
;
;		$x = Gettok("hi.just.testing","3",46)
;		will return "testing", because it is the third element in the dot separated string.
;
;		$x = Gettok("hi.just.testing","2-3",46)
;		will return "just.testing", because it is the second and third element in the dot separated string.
;
;		$x = Gettok("hi.just.testing","1-3",46)
;		will return "hi.just.testing", because it is the first till the third element in the dot separated string.
;
Function Gettok($string,$part,$delim)
  Dim $sDelimiter, $sArray, $sCount, $sSplitArg, $sStartArg, $sStopArg, $x
  $sDelimiter = Chr(CInt($delim))
  $sArray = Split($string,$sDelimiter)
  $sCount = 0
  
  For Each $Element in $sArray
    $sCount = $sCount + 1
  Next

  $sSplitArg = Split($part,"-")

  If UBound($sSplitArg) = 0
    $sStartArg = $part
  Else
    $sStartArg = CINT($sSplitArg[0])
    If $sSplitArg[1] <> ""
      $sStopArg = CINT($sSplitArg[1])
    EndIf
  EndIf

  If $sStartArg > $sCount
    ? "You cannot provide a number higher then the amount of delimiters in the string"
    Exit 1
  EndIf

  If $sStartArg = 0
    $Gettok = $sCount
  EndIf

  If ($sStartArg > 0 AND $sStopArg = "")
    $Gettok = $sArray[CInt($sStartArg) - 1]
  EndIf

  If $sStopArg <> ""
    $sCount = 0
    $sStartArg = $sStartArg - 1
    $sStopArg = $sStopArg - 1
    For Each $Element in $sArray
      If ($sCount => $sStartArg AND $sCount < $sStopArg)
        $x = $x + $sArray[$sCount] + $sDelimiter
      EndIf
      If $sCount = $sStopArg
        $x = $x + $sArray[$sCount]
      EndIf
      $sCount = $sCount + 1
    Next
    $Gettok = $x
  EndIf
EndFunction

109517GetURL28BryceGetURL()0
Code:


;Function:	GetURL()
;
;Authors:	Bryce
;
;Version:	1.0 (12-2-2003)
;
;Action:	Gets the HTML from a given web page or FTP site.
;
;Syntax:	GetURL("URL",["USERNAME"],["PASSWORD"])
;
;Parameters:
;		URL	: full Path to the URL you want to get
;		USERNAME: Optional, a given username to be used
;		PASSWORD: Optional, A password to be used for the username
;
;Returns:
;		The HTML of the given URL
;
;		on error errorcodes returned and set:
;			1 -failed to initialize http-object
;			3 -failed to open connection
;
;Dependencies:
;		IE5 or higher
;
;Remarks:
;		I stole the error routines to match up with lonkeros own FTPGet() Udf
;
;Example:	
;		"Getting HTML Code from http://kix.isorg.com/other_scripts"
;		$html = GetURL("http://kix.isorg.com/other_scripts/")
;		? $html
;Source:
function GetURL($url,Optional $user, optional $passwd)
	dim $G_IECOM
	$G_IECOM = createobject("microsoft.xmlhttp")
	if @error exit(1) endif

	if $user and $passwd
		$g_iecom.open("GET", $url, not 1,$user,$passwd)
	else
		$g_iecom.open("GET", $url, not 1)
	endif
	if @error exit(3) endif
	$g_iecom.send
	$GetUrl = $g_iecom.responsetext
endfunction

 143861GetURLLinks28BryceGetURLLinks() - return a list of URL links from a HTML string1121871701Code:


/* 
Function        GetURLLinks()

Author          Bryce, with some code from Lonkero

Action          Returns 2 dimensional array of URL links and their names found in a HTML string

Syntax          GetURLLinks("HTML")

Version         2.0

Date            2005.07.19

Parameters      HTML 
                A string of HTML

Dependencies    None

KiXtart Ver     4.50

Example(s)
	For Each $Link In geturllinks(geturl("http://isorg.com"))
		? $Link[0] "=URL"
		? $link[1] "=NAME"
	Next
*/
Function GetURLLinks($html)
	DIM $link
	ReDIM $GetUrlLinks[0]
	$html = Split($html,'<a')

	For $c=1 to ubound($html)
		$link = split($html[$c],'</a>')[0] ;return the link only, no need to carry rest of the page with us
		$link=split($link,'>')
		If InSTR($link[0],"href")
			$link[0] = trim(SubSTR(split($link[0],'href')[1],InSTR(split($link[0],'href')[1],"=")+1))
			$link[1] = join($link,'>')
			$link[1] = trim(SubSTR($link[1],InSTR($link[1],'>')+1))
			redim preserve $link[1]
			$getUrlLinks[ubound($getUrlLinks)] = $link
			ReDIM preserve $GetURLLinks[ubound($getUrlLinks)+1]
		EndIf
	Next

	If ubound($GetURLLinks) > 0
		ReDIM preserve $getUrlLinks[ubound($GetURLLinks)-1]
	Else
		$getUrlLinks = 0
	EndIf
EndFunction

188576GetUserDN3439AllenGetUserDN() - Get the User Distinguished Name (OU) from Active Directory0

;  
;FUNCTION       GetUserDN()  
;  
;ACTION         Returns the Distinguished Name (OU) from Active Directory  
;  
;AUTHOR         Allen Powell    
;  
;VERSION        1.0.0 - 2008/07/07  
;  
;SYNTAX         getUserDN(optional $username)  
;  
;PARAMETERS     $username	- Optional, String in the format of: 
;                                  domain\username or 
;                                  username (assumes login domain)  
; 
;REMARKS        Great Writeup of nametranslate object - http://www.rlmueller.net/NameTranslateFAQ.htm 
;               Largely the same as TranslateName() but more direct and less options. 
;               TranslateName - http://www.kixtart.org/forums/ubbthreads.php?ubb=showflat&Number=83002#Post83002   
;  
;RETURNS        String containing the name of the users Distiguished Name (OU) 
;               or nothing if there is an error.  Check @error for more information. 
;  
;EXAMPLES 
; $UserDN=GetUserDN()                   ; get current user 
; $UserDN=GetUserDN("domain\username")  ; get domain\username 
; $UserDN=GetUserDN("username")         ; get currentdomain\username 
; 
Function getUserDN(optional $username)
  Dim $objTrans
  if $username=""
    $username=@ldomain + "\"+ @userid
  endif
  if not instr($username,"\")
    $username=@ldomain + "\" + $username
  endif
  $objTrans = CreateObject("NameTranslate")
  if @error
    exit @error
  else
    $objTrans.Init(3, "")
    $objTrans.Set(3,$username)
    $getUserDN = $objTrans.Get(1)
    if @error
      exit @error
    endif
  endif
EndFunction
113236GetUserOU4832RemkoGetUserOU() - Retrieve OU of user account0Well here goes my first post (and first UDF). Comments and/or suggestions are welcome.



;Function	    GetUserOU()

;

;Author		    Remko Weijnen

;

;Action		    Returns the DN of the OU/Container which the user is placed in

;

;Syntax		    GetUserOU()

;

;Version	    1.0

;

;Date               2004-0203

;

;Date Revised   

;

;Parameters	    None 

;

;Remarks	    None

;

;Returns	    If the DN eq CN=SomeUser,OU=SomeOU,DC=ad,DC=local

;                   it returns OU=SomeOU,dc=ad,dc=local

; 

;Dependencies 	None

;

;KiXtart Ver	4.22

; 

;Example(s)	$ComputerOU = $GetComputerOU

; 



Function GetUserOU()

  Redim $TempArray[0]

  Redim $GetUserOU

  $adSys = CreateObject("ADSystemInfo")

  $TempArray = Split($adSys.UserName,",")

  ; Check if there's a comma in the CN, eg if the user name = "Surname, Name" AD returns "Surname\, Name"

  If Right($TempArray[0],1) = "\" 

    $Start = 2

  Else

    $Start = 1

  EndIf

  

  For $Counter = $Start To UBound($TempArray)

    If Len($GetUserOU) = 0

      $GetUserOu = $TempArray[$Counter]

	Else

      $GetUserOu = $GetUserOu + "," + $TempArray[$Counter]

	EndIf

  Next



  $adSys = 0 

EndFunction GetUserOU()

  166753GetWSIPAddresses:5694WittoGetWSIPAddresses: Gets IP Address(es) , also in a terminal session0

;FUNCTION       GetWSIPAddresses  

;  

;ACTION         Gets the IP Address(es) of the Local Computer, also in a terminal session  

;  

;AUTHOR         Wim Rotty  

;  

;CONTRIBUTORS     

;  

;VERSION        1.0.0.0  

;  

;DATE CREATED   2006-09-02  

;  

;DATE MODIFIED    

;  

;KIXTART        Minimum 4.xx to support COM  

;  

;SYNTAX         GetWSIPAddresses()  

;  

;PARAMETERS     None  

;  

;RETURNS        String of IP Addresses, seperated by commas  

;               per example "10.32.15.8,192.168.0.2"  

;  

;REMARKS        A terminal session will always return only one IP Address  

;               In terminal sessions, this UDF will NOT return the IP Address(es) of the terminal server  

;               It will return the IP Address of the NIC in the workstation used to connect to the terminal server  

;  

;DEPENDENCIES   WTSManager.dll  

;               To use the COM Object wtsScript,  

;               WTSManager.dll has to be registered on the terminal servers 

;               http://kixhelp.com/Downloads/wtsmanager.zip 

;  

;EXAMPLE        Dim $IPAddresses, $IPAddress  

;               $IPAddresses = GetWSIPAddresses()  

;               For Each $IPAddress in Split($IPAddresses,",")  

;               	? $IPAddress  

;               Next  

;  

;KIXTART BBS      

;  

Function GetWSIPAddresses()

	; Dynamic error variable, can be used to catch errors and use it when exiting the function

	Dim $Error

	$Error = 0

	; Is this NOT a Windows Terminal (Citrix) session?

	If NOT @TSSESSION

		Dim $i

		; Is this NOT Windows NT4?

		If NOT @PRODUCTTYPE = "Windows NT Workstation"

			; Enumerate IP Addresses

			$i = 0

			; If EnumIPInfo finds no IP Address, @ERROR is set to 123, which is as designed

			While NOT EnumIPInfo($i,0,0) = ""

				; Noticed that p.e. WLAN NIC can give "0.0.0.0"

				If NOT EnumIPInfo($i,0,0) = "0.0.0.0"

					If $GetWSIPAddresses

						$GetWSIPAddresses = $GetWSIPAddresses + ","

					EndIf

					$GetWSIPAddresses = $GetWSIPAddresses + EnumIPInfo($i,0,0)

				EndIf

			$i = $i + 1

			Loop

			; Ignore @ERROR that has been set by EnumIPInfo

		; This IS a Windows NT4

		Else

			Dim $RC, $IPAddress, $OldMacroOption, $OldVarsOption

			; To avoid problems with @-sign and $-sign in string, use SetOption()

			$OldMacroOption = SetOption("NoMacrosInStrings","On")

			$OldVarsOption = SetOption("NoVarsInStrings","On")

			; Loop through maximum 4 possible IP Addresses with @IPADDRESSx macros

			For $i = 0 to 3 step 1

				$RC = Execute("$IPAddress = @IPADDRESS" + $i)

				If $IPADdress

					If $GetWSIPAddresses

						$GetWSIPAddresses = $GetWSIPAddresses + ","

					EndIf

					$GetWSIPAddresses = $GetWSIPAddresses + $IPAddress

				Else

					$i = 3

				EndIf

			Next

			$OldMacroOption = SetOption("NoMacrosInStrings",$OldMacroOption)

			$OldVarsOption = SetOption("NoVarsInStrings",$OldVarsOption)

		EndIf

	; This is a Windows Terminal (Citrix) session

	Else

		; Get the IP Address of the real WorkStation, not the Terminal Session

		Dim $oWts

		; If WTSManager.dll is not registered, an error is thrown here

		$oWts = CreateObject("WTSManager.Shell")

		If NOT @ERROR

			$GetWSIPAddresses = $oWts.MyIPAddress

		EndIf

		$Error = @ERROR

	EndIf

	Exit $Error

EndFunction
83879Get_Default_Printer39MCAGet_Default_Printer() - returns default printer in W9x and NTx environments0

code:

;
; Author:       MCA
; Action:       it returns the default printer in W9x and NTx environments.
; Syntax:       Get_Default_printer()
; Parameters:   none
; Version:      1.0
; Returns:      printer name
;               or
;               NONE (when no printer is default)
; Dependencies: none
; Kixtart:      4.x
; Examples:     ? "default_printer     "+Get_Default_Printer()
;              result
;               default_printer     HP Laserjet 8000
;
FUNCTION Get_Default_Printer()

    DIM $key, $info
    DIM $default_printer
    ;
    $info="NONE"

    ; - printer mapping information - NTx -

    $key="HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows"
    IF (existkey($key) = 0) ; - NT -
      $default_printer=ReadValue($key, "device")
      IF (len($default_printer) <> 0) ; - HKCU.CurrentVersion.Windows[NT:default.printer] -
        $info=$default_printer
      ENDIF
    ENDIF

    ; - printer mapping information - W9x -

   ;$key="HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\IDConfigDB:CurrentConfig" -> "0001"
    $key="HKEY_LOCAL_MACHINE\Config\0001\System\CurrentControlSet\Control\Print\Printers"
    IF (existkey($key) = 0) ; - 95 -
      $default_printer=ReadValue($key, "default")
      IF (len($default_printer) <> 0) ; - HKLM.print.printers[95:default.printer] -
        $info=$default_printer
      ENDIF
    ENDIF
   ;? "default_printer "+$info

    $Get_Default_Printer=$info
ENDFUNCTION

greetings.

{edit: move $info="NONE" to the begin + complete description}
 
 [ 05. May 2003, 00:23: Message edited by: MCA ]83885Get_Default_Printer_Status39MCAGet_Default_Printer_Status() - returns the connection status of default printer.0

code:

;
; Author:       MCA
; Action:       it returns the connection status of default printer. connected by LPT or server.
; Syntax:       Get_Default_printer_Status()
; Parameters:   none
; Version:      1.0
; Returns:      LPTx: or NONE
; Dependencies: none
; Kixtart:      4.x
; Examples:     ? "default_printer_status     "+Get_Default_Printer_Status()
;              result
;               default_printer_status     LPT1:
;
FUNCTION Get_Default_Printer_Status()
    DIM $key, $info
    DIM $default_printer, $default_port

    ; - printer mapping information - NTx -

    $key="HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows"
    IF (existkey($key) = 0) ; - NT -
      $default_printer=ReadValue($key, "device")
      $default_port=""
      IF (INSTR(LCASE($default_printer),",lpt") <> 0)
        $default_port=UCASE(substr($default_printer,INSTR(LCASE($default_printer),",lpt")+1,5))
      ENDIF
      ;
      IF (len($default_port) <> 0)
        $info=$info+$default_port ; - LPTx type -
      ELSE
        $info="NONE"
      ENDIF
    ELSE
      IF (@inwin = 1)
        $info="NONE"
      ENDIF
    ENDIF

    ; - printer mapping information - W9x -

   ;$key="HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\IDConfigDB:CurrentConfig" -> "0001"
    $key="HKEY_LOCAL_MACHINE\Config\0001\System\CurrentControlSet\Control\Print\Printers"
    IF (existkey($key) = 0) ; - 95 -
      $default_printer=ReadValue($key, "default")
      $default_port=""
      $key="HKEY_LOCAL_MACHINE\System\CurrentControlSet\control\Print\Printers\"+$default_printer
      IF (existkey($key) = 0)
        $default_port=ReadValue($key, "Port")
      ENDIF
      ;
      IF (len($default_port) = 0)
        $default_port="NONE"
      ENDIF
      ;
      $info="" ; - HKLM.print.printers[95:default.printer] -
      IF (len($default_port) <> 0)
        $info=$default_port
      ELSE
        $info=$info+"NONE"
      ENDIF
    ELSE
      IF (@inwin <> 1)
        $info="NONE"
      ENDIF
    ENDIF
   ;? "default_printer_status "+$info

    $Get_Default_Printer_Status=$info
ENDFUNCTION

greetings.

{edit: correct mistyping in example + complete description}
 
 [ 05. May 2003, 00:27: Message edited by: MCA ]82696GMT_DateTime46kholmGMT_DateTime() - Transform local time to GMT time or GMT date and time0Transform your local time to GMT Date and time or to GMT time

Functions included:

GMT_DateTime() transform local time to GMT date and time

GMT_Time() transform local time to GMT time
Function: GMT_DateTime() transform local time to GMT date and time 
 
Action: 
Retrieve GMT date and time from local Time (Input parameter)
 
Syntax: 
$DT = GMT_DateTime($Time)
Parameters:$Time : Time on the format TT:MM:SS
Returns:
Change input time to GMT date and time
Date and time in Grenwitch derieved from your local time, format: YYYY/MM/DD TT:MM:SS

Dependencies:
KiXtart 4.01
Functions:
  GMT_Time() ; Author: kholm (included in this post)
  SerialDate() ; Author: ScriptLogic SerialDate()

Examples:
$GMT = GMT_DateTime(@Time)

Source


Function GMT_DateTime($Time)
; Return GMT date and time from local time on format: YYYY/MM/DD TT:MM:SS
Dim $GMTime,$Date
$GMTime = GMT_Time($Time)
If $GMTDay ; Not today
$Date = SerialDate(SerialDate(@Date) + $GMTDay)
Else
$Date = @Date
EndIf
$GMT_DateTime = $Date + ' ' + $GMTime
EndFunction


 
Function: GMT_Time() transform local time to GMT time

Action:
Retrieve GMT time from the local Time, change input time to GMT time

Syntax:
$DT = GMT_Time($Time)

Parameters:
$Time : Time on the format TT:MM:SS

Returns:
Time in Grenwitch derieved from your local time (TT:MM:SS)
Global: $GMTDay (-1 = Yesterday, 0 = Today, 1 = Tomorrow) 

Dependencies:
KiXtart 4.01

Example:
$GMT = GMT_DateTime(@Time)

Source


Function GMT_Time($Time)
; Returns GMT time from local time
; Also return Global var: $GMTDay (-1 = Yesterday, 0 = Today, 1 = Tomorrow) 
Dim $Min,$Sec,$Bias,$Tmp,$H,$M
Global $GMTDay
$GMTDay = 0
$Min = Val(Left($Time, 2)) * 60 + Val(SubStr($Time, 4, 2))
$Sec = Right($Time, 3)
$Tmp = ReadValue("HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation","ActiveTimeBias")
If ReadType("HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation","ActiveTimeBias") = "REG_BINARY"
For $i = Len($Tmp) - 1 To 1 Step - 2 ; Reverse binary string to Hex string (Win 9x)
$Bias = "" + $Bias + SubStr($Tmp, $i, 2)
Next
$Bias = Val("&" + $Bias)
Else
$Bias = Val($Tmp)
EndIf
If $Bias = 0
$GMT_Time = $Time
Return
EndIf
$GMT_Chg = $Min + $Bias
Select
Case $GMT_Chg >= 60 * 24
$GMT_Chg = $GMT_Chg - 60 * 24
$GMTDay = 1 ; Tomorrow in G
Case $GMT_Chg <= 0
$GMT_Chg = $GMT_Chg + 60 * 24
$GMTDay = -1 ; Yesterday in G
EndSelect
$H = $GMT_Chg / 60
$M = "" + ($GMT_Chg - $H * 60)
If Len($M) = 1
$M = "0" + $M
EndIf
$H = "" + $H
If Len($H) = 1
$H = "0" + $H
EndIf
$GMT_Time = $H + ":" + $M + $Sec
EndFunction


Function SerialDate($ExpD)
;Author: ScriptLocig SerialDate()
;Algorithms used obtained from: http://www.capecod.net/~pbaum/date/date0.htm 
Dim $z,$h,$a,$b,$c,$y,$m,$d
If InStr($ExpD,'/') ; date passed, return an integer
$y = Val(Left($ExpD,4))
$m = Val(SubStr($ExpD,6,2))
$d = Val(Right($ExpD,2))
If $m < 3
$m = $m + 12
$y = $y - 1
EndIf
$SerialDate = $d + (153 * $m - 457) / 5 + 365 * $y + $y / 4 - $y / 100 + $y / 400 - 306
Else ; integer passed, return a string date
$z = 0 + $ExpD + 306
$h = 100 * $z - 25
$a = $h / 3652425
$b = $a - $a / 4
$y = (100 * $b + $h) / 36525
$c = $b + $z - 365 * $y - $y / 4
$m = (5 * $c + 456) / 153
$d = $c - (153 * $m - 457) / 5
If $m > 12
$y = $y + 1
$m = $m - 12
EndIf
If $m <= 9
$m = '0'+$m
EndIf
If $d <= 9
$d = '0'+$d
EndIf
$SerialDate = '' + $y + '/' + $m + '/' + $d
EndIf
EndFunction


-Erik

{Edit}
No change to the code, but the code has been syntax colored using: Post Prep
 
 [ 21. February 2003, 17:52: Message edited by: kholm ]82135GroupAdd28BryceGroupAdd() - Ads a User/Group to a Group Global/Local1111596279Code:


;NAME        GroupAdd
;
;ACTION      Add's a object (user or group) to a group (global or local)
;
;SYNTAX      GroupAdd(Target, Group, Object To add)
;
;PARAMETERS  Target
;               The Domain name or Workstation To work with.  For faster workstation 
;               execution, include the Domain Name that the workstation is a meber of.
;
;               "Kixtart/beanbag" would be working with the workstation Beanbag In the 
;               Kixtart domain
;
;            Group
;               The Group you want To add To
;
;            Object To add
;               This can be a local group or a userid, depending on what type of group 
;               the Group variable is.  Always try To give the full name of the object.
;
;
;RETURNS     @ERROR code
;
;REMARKS     ADSI com object must be installed.
;
;EXAMPLES    ;this adds the domain user "testuser" To the Global group "Domain Admins"
;            $nul = groupadd("kixtart","Domain admins","testuser")
;
;            ;this adds the user "testuser" In the domain "kixtart" To the local administrators 
;            ;group on the workstation beanbag
;            $nul = Groupadd("kixtart/beanbag", "administrators", "kixtart\testuser")
Function GroupAdd($Target, $Group, $ObjToAdd)
	DIM $target, $group, $OBJToAdd, $obj, $objhome
	
	If SubSTR($target,1,2) = '\\'
		$target = SubSTR($target,3,Len($target))
	EndIf
	If InSTR($objtoadd,'\') <> 0
		$objtoadd = Split($objtoadd,'\')
	If UBound($objtoadd) <> 1 Exit 13 EndIf
		$objhome = $objtoadd[0]
		$obj = $objtoadd[1]
	Else
		$objhome = $target
		$obj = $objtoadd
	EndIf
	
	$group = GetObject('WinNT://' + $target + '/' + $group)
	If VarType($group) = 9 and @ERROR = 0
		$group.Add ('WinNT://'+$objhome+'/'+$obj)
	Else
		$GroupAdd = @ERROR
		Exit @ERROR
	EndIf
	$GroupAdd = @ERROR
	Exit @ERROR
EndFunction

175481GroupEnum119LonkeroGroupEnum() - List AD groups0

;Function:	GroupEnum()
;
;Author:	Jooel
;
;Action:	Lists groups from active directory
;
;Syntax:	GroupEnum([WHAT], [DOMAIN])
;
;Version:	1.0 (18.4.2007)
;
;Parameters:
;		WHAT
;		  optional. if given, returns ADsPath, otherwise groupname.
;		DOMAIN
;		  optional. domain from which the list is gathered.
;		  syntax: "dc=fabricanos, dc=cons"
;
;Remarks:
;		just wrapped this together as didn't find anything similar on
;		our site and needed the ADsPath-version really bad.
;
;Returns:	the requested grouplist.
; 
;Dependencies None
;
;KiXtart Requirement: 4.50
; 
;Example:
;	for each $group in groupEnum
;		"	" $group ?
;	next
;	
;	get $
;
;Source:
function GroupEnum(optional $what, $dom)
 dim $oConnection, $oCommand, $oRS, $tOut[0]
  $oConnection = CreateObject("ADODB.Connection")
  $oCommand = CreateObject("ADODB.Command")
  $oConnection.Open("PROVIDER=ADSDSOOBJECT;")
  $oCommand.ActiveConnection = $oConnection

  if $what
    $what="ADsPath"
  else
    $what="cn"
  endif
  if not $dom
   $dom = GetObject("LDAP://rootDSE").Get("defaultNamingContext")
  endif

  $oCommand.CommandText = "SELECT "+$what+" FROM 'LDAP://"+$dom+"' WHERE objectCategory='group'"
  $oRS = $oCommand.Execute
  $oRS.MoveFirst

  while not $oRS.EOF
    $tOut[ubound($tOut)] = "" + $oRS.Fields($what)
    redim preserve $tOut[ubound($tOut)+1]
    $oRS.MoveNext
  loop
  if ubound($tOut)>0
    redim preserve $tOut[ubound($tOut)-1]
  endif
  $GroupEnum = $tOut
endfunction
82136GroupMembers28BryceGroupMembers() - returns all members of a given group.0

code:


Function Groupmembers($target, $group, optional $flag)
;NAME        GroupMembers
;
;ACTION      Returns an array of all group members of the specified group
;
;SYNTAX      GroupMembers(Target, Group, [FLAG])
;
;PARAMETERS  Target
;               The Domain name or Workstation to work with.  For faster workstation 
;               execution, include the Domain Name that the workstation is a meber of.
;
;               "Kixtart/beanbag" would be working with the workstation Beanbag in the 
;               Kixtart domain
;
;            Group
;               The Group you want to query
;
;            [FLAGS]
;               To use the flags options add the numbers of the desired flags toghthers and
;               Use that number in the flag field.
;
;                  Filter :(only one filter flag at a time please)
;                     1 = all
;                     2 = Users only
;                     4 = Groups only
;
;                  ADSI Information(return ADSI information "pick only one")
;                     8  = ADSPath field
;                     16 = ADSI Object Handle
;
;RETURNS     an array containing , if the ADSPath option is used the ADSPath 
;            will also be returned |.
;
;REMARKS     ADSI com object must be installed.
;
;EXAMPLES    ;this return all members of the Domain Admins group in the kixtart domain.
;            $members = groupmembers("kixtart","Domain admins")
;
;            ;this will will return all groups in the local administrators group on 
;            ;the Workstation beanbad in the kixtart domain.  Also the 
;            $groups = groupmembers("kixtart/beanbag","Administratoos","group")

	DIM $temparray[8], $member, $i, $chunk, $flag, $ADSIFlag, $filterFlag
	$chunk = ubound($temparray)
	$flag = val($flag)
	$i = 0
	$group = getobject("WinNT://$target/$group")
	if vartype($group) <> 9 exit(@error) endif

	select
		case $flag & 1
			$filterflag = 1
		case $flag & 2
			$filterflag = 2
		case $flag & 4
			$filterflag = 4
		case 1
			$filterflag = 1
	endselect
	select
		case $flag & 8
			$ADSIFlag = 8
		case $flag & 16
			$ADSIFlag = 16
	endselect

	for each $member in $group.members
		select
			case $filterflag = 2 AND $member.class = "user"
				if substr($member.name,len($member.name),1) <> "$"
					$temparray[$i] = $member.name
					select
						case $adsiflag = 8
							$temparray[$i] = $member.adspath
						case $adsiflag = 16
							$temparray[$i] = $member
					endselect
					$i = $i + 1
				endif
			case $filterflag = 4 AND $member.class = "Group"
				if substr($member.name,len($member.name),1) <> "$"
					$temparray[$i] = $member.name
					select
						case $adsiflag = 8
							$temparray[$i] = $member.adspath
						case $adsiflag = 16
							$temparray[$i] = $member
					endselect
					$i = $i + 1
				endif
			case $filterflag = 1
				if substr($member.name,len($member.name),1) <> "$"
					$temparray[$i] = $member.name
					select
						case $adsiflag = 8
							$temparray[$i] = $member.adspath
						case $adsiflag = 16
							$temparray[$i] = $member
					endselect
					$i = $i + 1
				endif
			case $filterflag
				;bit bucket
		endselect
		if $i = ubound($temparray)
			redim preserve $temparray[Ubound($temparray)+$chunk]
		endif
	next
	if $i <> 0
		redim preserve $temparray[$i-1]
		$groupmembers=$temparray
	endif
endfunction

[ 18 January 2002: Message edited by: Bryce ]

[ 18 January 2002: Message edited by: Bryce ]132636gSort3755GavengSort() - Function to sort a two dimensional array by up to two columns1106197167Code:


;  Function:     gSort()

;

;  Author:       Gaven Henderson, Gaven@GavDogg.net

;

;  Action:       gSort will sort a 2D array by a primary and secondary column

;

;  Syntax:       gsort($Array, $SortCol1, Optional $SortCol2, Optional $Descending)

;

;  Parameters:   Array      - A two-dimensional array, must contain two dimensions

;                SortCol1   - The primary column to sort by

;                SortCol2   - Optional, the secondary column to sort by.  If omitted, no secondary comparison.

;                Descending - Set to 0 for ascending, 1 for descending.

;

;  Returns:      The array sorted, error 1 if called with invalid $Array or $SortCol1.

;

;  Dependencies: none

;

;  Remarks:      This function only works with two-dimensional arrays, if you feed it a 1D array,

;                it will return no data with an error code of one.  Leaving $SortCol2 blank is the

;                same as setting it to the same value as $SortCol1, no secondary sorting will be

;                done and rows with matching column values will remain in original order.

;

;                There may be some serious room for improvement in this script, and there may not.

;                I threw this together in about 20 minutes and performed no speed tests, although

;                there isn't much to compare it with.

;

;  Column/Row:   The first dimension of the array is the column, the second the row.  Data will never move

;                from one column to another, only rows will be swapped.  The examples below contain two

;                columns, last name and first name, and four rows, to represent four people.  Additional

;                columns could be added to contain additional information as additional rows could be added

;                to contain additional people.

;

;  Version:      1.0

;

;  Post Date:    January 18, 2005

;

;  KiXtart Ver:  Requires version 4.11 or newer.

;

;  Example:      Dim $array[1,3]

;                $array[0,0] = "Smith"

;                $array[0,1] = "Jones"

;                $array[0,2] = "Smith"

;                $array[0,3] = "Cho"

;                $array[1,0] = "Bill"

;                $array[1,1] = "Hank"

;                $array[1,2] = "Anita"

;                $array[1,3] = "Linda"

;

;                $array=gsort($array,0,1) ; would result in...

;                $array[0,0] = "Cho"

;                $array[0,1] = "Jones"

;                $array[0,2] = "Smith"

;                $array[0,3] = "Smith"

;                $array[1,0] = "Linda"

;                $array[1,1] = "Hank"

;                $array[1,2] = "Anita"

;                $array[1,3] = "Bill"

;

;                $array=gsort($array,1,0,1) ; would result in...

;                $array[0,0] = "Cho"

;                $array[0,1] = "Jones"

;                $array[0,2] = "Smith"

;                $array[0,3] = "Smith"

;                $array[1,0] = "Linda"

;                $array[1,1] = "Hank"

;                $array[1,2] = "Bill"

;                $array[1,3] = "Anita"

;

Function gsort($a,$b,Optional $c,$d)

 Dim $e,$f,$g,$h,$z[0]

 If $b>UBound($a,1) Or UBound($a,2)<0 Exit 1 EndIf

 If $c>UBound($a,1) Or $c="" $c=$b EndIf

 If $d<>1 $d=0 EndIf

 If UBound($a,2)>0

  ReDim $z[UBound($a,1)]

  For $e=1 To UBound($a,2)

   For $f=0 To $e-1

    If ($d=0 And ($a[$b,$e]<$a[$b,$f] Or ($a[$b,$e]=$a[$b,$f] And $a[$c,$e]<$a[$c,$f]))) Or ($d=1 And ($a[$b,$e]>$a[$b,$f] Or ($a[$b,$e]=$a[$b,$f] And $a[$c,$e]>$a[$c,$f])))

     For $g=0 To UBound($z) $z[$g]=$a[$g,$e] Next

     For $g=$e-1 To $f Step -1 For $h=0 To UBound($z) $a[$h,$g+1]=$a[$h,$g] Next Next

     For $g=0 To UBound($z) $a[$g,$f]=$z[$g] Next

     $f=$e

    EndIf

   Next

  Next

 EndIf

 $gsort=$a

EndFunction

 122606GSPDF5439acmpGSPDF() - batch process of PostScript files to PDF0Code:


;Function		GSPDF()
;
;Author		acmp
;
;Contributors	
;
;Action		The function will check the given path for postscript files
;		to pass to your GhostScript ps2pdf file.
;		A log of the process is also created in the same folder so
;		you can see what happened.		
;
;Syntax		GSPDF($file, $gspath, optional $mode)
;
;Version		1.0
;
;Date		11/Jul/04
;
;Date Revised	
;
;Parameters 	$path:	the path to the folder to check, include a training '\'
;		$gspath:	The fully qualified path to your ps2pdf.cmd file
;		$mode:	Optional, either 1 or 0, if 1 will behave like
;			Adobe Distiller in that it checks an 'in' subfolder
;			for files to process then output to an 'out' folder.
;
;Remarks		I had to save some money on making PDF's at work, so I looked
;		around, PDF995 looked OK, but after some investigation I realised
;		that it is just a print driver and front end for GhostScript.
;		As you can get a PostScript print driver from Adobe for free
;		and that ghostScript is also free I put 2 and 2 together and 
;		developed this little routine.
;
;Returns		If the processing folders cannot be found it returns 2
;		Otherwise check the generated log files and your system event log for info.
; 
;Dependencies 	Writelog2(), Pipe(), GhostScript, PostScript printer driver
;		GhostScript can be downloaded from: www.GhostScript.com
;		A free Postscript print driver can be downloaded from:
;			www.adobe.com/support/downloads/main.html
;
;KiXtart Ver	4.02
; 
;Example(s)	$=GSPDF("c:\PS2PDF","C:\gs\gs81.4\lib\ps2pdf13.bat",1)
;		This will Check c:\ps2pdf\in for postscript file and convert them
;		to PDF's in the c:\ps2pdf\out folder
;		If an invalid file format is processed then Ghostscript will
;		generate errors that are recorded to the .log file
; 
Function PDF($path, $gspath, Optional $mode)
;Will scan the input folders ($path) 'in box' looking for files to PDF
;It will attempt to pass all files through GhostScript. The PDF output 
;is passed to the Out folder.
;the input file is removed to prevent rescanning, a log is created in the
;out folder with the same name as the PDF.
;any failed PDF's are removed.
;Function by acmp 11/7/04

	Dim $Filename, $InputPath, $OutputPath, $errorhappened
	Dim $line, $ok, $process
	If $mode=1
		dist_in="in"
		dist_out="out"
	EndIf
	
	$InputPath = $path + $dist_in
	$OutputPath = $path + $dist_out
	If NOT Exist $inputpath OR NOT Exist $outputpath
		Exit(2)
	EndIf
	$Filename = Dir($InputPath)

	While $Filename <> "" AND @ERROR = 0
		If $Filename <>"." AND $Filename <>".." AND Right($Filename,4) <>".pdf" AND Right($Filename,4) <>".log" ;don't process directories
			$ok=Open (1,"$InputPath\$Filename",4) ;check file is not in use
			If $ok = 0
				Close (1)
				?"Processing @time"
				?"$InputPath\$Filename"
				?"$OutputPath\$Filename.pdf"
				?""
				$process=pipe('$gspath "$InputPath\$Filename" "$OutputPath\$Filename.pdf"')
				Del "$InputPath\$Filename" /c /f
				writelog2("$OutputPath\$Filename.log","Process log for $Filename @time")
				$errorhappened=0
				For Each $line In $process
					?$line
					If InStr ($line,"Error:")
						Del "$OutputPath\$Filename.pdf" /c /f
						LogEvent(1,995,"Can't process $InputPath\$Filename",,"KiXPDF")
						$errorhappened=1
					EndIf
					writelog2("$OutputPath\$Filename.log","$line")
				Next 
				writelog2("$OutputPath\$Filename.log","Finished @time")
				?"done $errorhappened @TIME"
				If $errorhappened=0
					LogEvent(0,995,"Process $InputPath\$Filename OK",,"KiXPDF")
				EndIf
			EndIf
  		EndIf
  		$Filename = Dir() ; retrieve next file
	Loop
	$GSPDF="0"
EndFunction

 

Ok, this is my second UDF, and the first with dependencies. I'm not 100% sure 
of the precedure for listing dependencies, I can post them or provide a link to 
them, whatever is required.

As always I'd like comments on this. Good or bad.

Thanks

acmp<><

p.s. This UDF has saved my company over £4,000 in Adobe licences or £2000 for PDF995!  83357GUICopy953Chris S.GUICopy() - Use the Animated 'Copying Files' Progress Dialog0


;
;Function GUICopy()
;
;Author Christopher Shilt (christopher.shilt@relizon.com)
;
;Version 2.0
;
;Version History
; 03/20/2003 Version 2.1 Converts COM error codes to Win32 error code. Fixed version
; check.
;
; 03/04/2003 Version 2.0 Complete rework of GUICopy() function.
;
; 07/19/2002 Version 1.0
;
;Action Uses the Shell Object to copy or move files/folders. Displays the animated
; 'Copying Files' progress dialog as files/folders are being copied.
;
;Syntax GUICopy("Source", "Destination", optional FLAGS, optional MOVE)
;
;Parameters 
; SOURCE : REQUIRED. Path to source file or folder.
;
; DESTINATION : REQUIRED. Path to the destination folder.
;
; FLAGS : OPTIONAL. Specifies options for the operation. See remarks for
; options.
;
; COMMAND : OPTIONAL. Copy = 0 (or undefined); Move = 1
;
;Remarks
;
; 4 Do not display a progress dialog box.
; 8 Give the file being operated on a new name in a move, copy, or rename
; operation if a file with the target name already exists.
; 16 Respond with "Yes to All" for any dialog box that is displayed.
; 64 Preserve undo information, if possible.
; 128 Perform the operation on files only if a wildcard file name (*.*) is
; specified.
; 256 Display a progress dialog box but do not show the file names.
; 512 Do not confirm the creation of a new directory if the operation requires
; one to be created.
; 1024 Do not display a user interface if an error occurs.
; 2048 Version 4.71. Do not copy the security attributes of the file.
; 4096 Only operate in the local directory. Don't operate recursively into
; subdirectories. 
; 8192 Version 5.0. Do not copy connected files as a group. Only copy the
; specified files.
;
;Returns The exitcode of the command in the @ERROR macro.
; @ERROR = 0 The operation completed successfully.
; @ERROR = 2 The system cannot find the file specified. (Refers to Source file.)
; @ERROR = 3 The system cannot find the path specified. (Bad destination path.)
; @ERROR = 9 The storage control block address is invalid. (Most likely cancelled copy.)
; @ERROR = 10 The environment is incorrect. (Incorrect Shell32.dll version.)
; @ERROR = 87 The parameter is incorrect. (Use 0 or 1 to specify Copy or Move.)
; 
;Dependencies KiX 4.02 (or higher)
; Shell32.dll version 4.71 or later. (Included with: Windows 2000, Windows NT 4.0
; with Internet Explorer 4.0, Windows 98, Windows 95 with Internet Explorer
; 4.0.)
; 
;Example:
; ; Copy all KiX files in 'C:\' to 'E:\':
; GUICopy("C:\*.kix", "E:\")
; @ERROR " : " @SERROR ?
;
; ; Copy all KiX files in 'C:\' to 'E:\', but do not overwrite. Instead, make a
; ; new copy of the files:
; GUICopy("C:\*.kix", "E:\", 8)
; @ERROR " : " @SERROR ?
;
; ; Copy a folder in 'C:\KiXScripts' to 'E:\'
; GUICopy("C:\KiXScripts", "E:\")
; @ERROR " : " @SERROR ?
;
; ; Move the folder in 'C:\KiXScripts' to 'E:\'
; GUICopy("C:\KiXScripts", "E:\",0,1)
; @ERROR " : " @SERROR ?
;Source
Function GUICopy($sSrc, $sDest, OPTIONAL $lFlags, OPTIONAL $bMove)
Dim $sVer,$objShell,$objFldr
If Not Exist($sSrc) Exit 2 Endif
If Not Exist($sDest) Exit 3 Endif
If @INWIN=1
$sVer=GetFileVersion(%WINDIR%+"\System32\Shell32.dll","FileVersion")
Else
$sVer=GetFileVersion(%WINDIR%+"\System\Shell32.dll","FileVersion")
Endif
If $sVer<"4.71" Exit 10 Endif
$objShell=CreateObject("Shell.Application")
$objFldr=$objShell.NameSpace($sDest)
If @ERROR<0 Exit VAL("&"+Right(DecToHex(@ERROR),4)) EndIf
Select
Case $bMove=1 $objFldr.MoveHere($sSrc,$lFlags)
Case $bMove=0 $objFldr.CopyHere($sSrc,$lFlags)
Case 1 Exit 87
EndSelect
If @ERROR<0 Exit VAL("&"+Right(DecToHex(@ERROR),4)) EndIf
Exit @ERROR
EndFunction


 
 [ 20. March 2003, 20:42: Message edited by: Chris S. ]83851GUIDialog119LonkeroGUIDialog() - GUI dialog for selecting folder, file, printer or computer0

code:

;FUNCTION	GUIDialog()
;
;AUTHOR	Lonkero
;
;ACTION		GUI for selecting folder/file/computer/printer...
;
;SYNTAX	GUIDialog(TITLE,[ROOT][,MODE])
;
;PARAMETERS
;		TITLE
;		 - Title to show in dialog
;		ROOT
;		 - Optional. Specifies the root of the Browse dialog box.
;		 The user cannot browse higher in the architecture than this folder.
;		 If this value is not specified, the root of the Browse dialog box is the desktop.
;		MODE
;		 - Optional. Changes the mode to show in dialog:
;		2	= Do not include network folders below the domain level in the dialog box's tree view control.
;		16	= Include an edit control in the browse dialog box that allows the user to type the name of an item.
;		4096	= Only return computers. If the user selects anything other than a computer, the OK button is grayed.
;		8192	= Only return printers. If the user selects anything other than a printer, the OK button is grayed.
;		16384	= The browse dialog box will display files as well as folders.
;
;RETURNS
;		the full path to folder, or error if user pressed cancel.
;
;DEPENDENCIES   Minimum operating systems: Windows 2000, Windows ME
;
;EXAMPLE
;		GUIdialog("kix ass")
;		if @error
;		 "user pressed cancel"
;		endif
;
;CODE
function GUIDialog($_title, optional $_root, optional $_mode)
 dim $
 $=createobject("shell.application")
 $GUIDialog=$.BrowseForFolder(0,$_title,0+$_mode,$_root).self.path
 if not len($GUIDialog) exit 1 endif
endfunction


 
 [ 01. March 2003, 02:50: Message edited by: Lonkero ]83556Hash172Howard BullockHash() Library UDF's0

;FUNCTION         Hash() 

; 

;AUTHOR           Howard A. Bullock (habullock@comcast.net) 

; 

;ACTION           Creates and maintains a set of associative arrays 

; 

;SYNTAX           Hash($HashName, $Key, $Value) 

; 

;PARAMETERS       $HashName (Required) -  String value 

;                 $Key (Required) -  String value 

;                 $Value (Required) 

; 

;REMARKS          This function creates and maintains a pair of arrays and manipulates 

;                 in a such that the function yields multiple hashses. 

;                 Given the hash name, the function either sets a key and value pair or 

;                 returns the value of the specofed hash and key. 

; 

;RETURNS          Value if no $value is input 

; 

;DEPENDENCIES 

; 

;EXAMPLES         Hash("Colors","Green","Favorite Color") Sets a hash value 

;                 ? "Green Color= " + Hash("Colors","Green") return a hash value 

; 

Function Hash($HashName, $Key, optional $Value)

   Dim $KeyLimit, $key, $found, $x, $y, $rc

   $HashKey = $HashName + "key"

   $HashValue = $HashName + "value"

   $Hash = chr(0)

   $y = '

   If Ubound($$HashKey) = -1

      Global $$$HashKey[0], $$$HashValue[0]

   Endif



   $$KeyLimit = Ubound($$$HashKey)



   If VarTypeName($$Value) <> "Empty"

      ; Set a value

      $$found = 0

      For $$x=0 to $$KeyLimit

         If $$Key = $$$HashKey[$$x]

            $$$HashValue[$$x] = $$Value

            $$x = $$KeyLimit + 1

            $$found = 1

         Endif

      Next

      If $$found = 0

         Redim Preserve $$$HashKey[$$KeyLimit+1]

         Redim Preserve $$$HashValue[$$KeyLimit+1]

         $$$HashKey[$$KeyLimit+1] = $$Key

         $$$HashValue[$$KeyLimit+1] = $$Value

      Endif

   Else

      ; Read a value

      For $$x=0 to $$KeyLimit

         If $$Key = $$$HashKey[$$x]

            $$Hash = $$$HashValue[$$x]

            $$x = $$KeyLimit + 1

         Endif

      Next

   Endif'

   $rc = execute($y)

Endfunction



;FUNCTION         HashKeys() 

; 

;AUTHOR           Howard A. Bullock (habullock@comcast.net) 

; 

;ACTION           Creates and maintains a set of associatice arrays 

; 

;SYNTAX           HashKeys($HashName) 

; 

;PARAMETERS       $HashName (Required) -  String value 

; 

;REMARKS          This function returns an array of values that represent keys of 

;                 the HASH named $HashName. 

; 

;RETURNS          Array 

; 

;DEPENDENCIES 

; 

;EXAMPLES         $array = HashKeys("Colors") 

; 

; 

Function HashKeys($HashName)

   Dim $rc, $HashKey

   $HashKey = $HashName + "key"

   $rc = execute("$$HashKeys = $$$HashKey")

Endfunction





;FUNCTION         DelHashKey() 

; 

;AUTHOR           Howard A. Bullock (habullock@comcast.net) 

; 

;ACTION           Creates and maintains a set of associatice arrays 

; 

;SYNTAX           DelHashKey($HashName, $Key) 

; 

;PARAMETERS       $HashName (Required) -  String value 

;                 $Key (Required) -  String value 

; 

;REMARKS          This function deletes the key/value pair from the hash named $HashName. 

; 

;RETURNS          Nothing 

; 

;DEPENDENCIES 

; 

;EXAMPLES         DelHashKey("Colors","Green") 

; 

Function DelHashKey($HashName, $Key)

   Dim $KeyLimit, $Key, $found, $x, $y, $rc

   $HashKey = $HashName + "key"

   $HashValue = $HashName + "value"

   $Hash = chr(0)

   $y = '

   $$KeyLimit = Ubound($$$HashKey)



   If VarTypeName($$Key) <> "Empty"

      ; Set a value

      $$found = 0

      For $$x=0 to $$KeyLimit

         If $$Key = $$$HashKey[$$x]

            $$found = 1

         Endif

         If  $$found = 1 and $$x < $$KeyLimit

            $$$Hashkey[$$x] = $$$Hashkey[$$x+1]

            $$$HashValue[$$x] = $$$HashValue[$$x+1]

         Endif

      Next

      If $$found = 1

         Redim Preserve $$$HashKey[$$KeyLimit-1]

         Redim Preserve $$$HashValue[$$KeyLimit-1]

         exit 0

      Else

         exit 2

      Endif

   Endif'

   $rc = execute($y)

Endfunction
 
 [ 15. October 2003, 23:15: Message edited by: Howard Bullock ]113271Hex2Dec2980Glenn BarnasHex2Dec() - Convert hex string to Decimal value0Converts a hex string (up to 10 hex chars or 40 bits) to a decimal value. That is a decimal value over 1 Trillion!

May be able to be extended to larger numbers, depending on the limits of Kix double-precision aritmetic.

Code:

;; 
;;====================================================================== 
;; 
;;FUNCTION       Hex2Dec() 
;; 
;;ACTION         Convert a Hex string to a decimal number 
;; 
;;AUTHOR         Glenn Barnas / FRIT-EROC 
;; 
;;SYNTAX         Hex2Dec(HexValue) 
;; 
;;PARAMETERS     HexValue - REQUIRED - Hex value to be converted to Decimal 
;; 
;;REMARKS        Converts hex strings to decimal values. Currently set to  
;;               use a max of 40 bits (10 hex digits), which is a maximum 
;;               decimal value of of 1,099,511,627,775 (that's 1 Trillion) 
;; 
;;RETURNS        Decimal value 
;; 
;;DEPENDENCIES   Kix 4.1+ 
;; 
;;TESTED WITH    WinNT, Win2K, WinXP, Win2K3 
;; 
;;EXAMPLES       $DecVal = Hex2Dec('3f79cb00') 
; 
; Convert Hex-number to string representation of Decimal value 
Function Hex2Dec($Hex)
 

  ; Define the limit 
  ; 40 bits for max value of 549,755,813,888 (1023G or 1023 Billion!) 
  Dim $MaxBits
  $MaxBits = 40
 

  Dim $HexArr, $BinArr, $P, $Ch, $nb, $BinStr, $V, $D
  Dim $DecArr[$MaxBits]
 

  $HexArr = '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
  ; Note that the bits in each element are BACKWARDS! - This allows easier L-R LSB->MSB processing 
  $BinArr = '0000','1000','0100','1100','0010','1010','0110','1110','0001','1001','0101','1101',
'0011','1011','0111','1111'
 

  ; Process check - can't handle more than MaxBits/4 hex digits 
  If Len($Hex) > ($MaxBits / 4)
    $Hex2Dec = 0
    Exit 87
  EndIF
 

  ; Init the Decimal Array 
  $DecArr[1] = 1.0
  For $P = 2 to $MaxBits 
    $DecArr[$P] = $DecArr[$P - 1] * 2
  Next
 

 

  ; Convert Hex-number to binary string 
  $BinStr = ''
 

  For $P = 1 To Len($Hex)
    $Ch = SubStr($Hex, $P, 1)
    $nb = AScan($HexArr, $Ch)
    If $nb < 0 ; Error in hex-string, contains non-valid characters 
      'invalid hex-string' ?
      $BinStr = '0'
      Exit 87
    EndIf
    ; Add the string value for the current hex digit 
    $BinStr = $BinArr[$nb] + $BinStr
  Next
 

  ; Convert binary string to a decimal number 
  $Hex2Dec = 0.0
  For $P = 1 to Len($BinStr)
    $Ch = SubStr($BinStr, $P, 1)
    If $Ch = 1
      $Hex2Dec = 0.0 + $Hex2Dec + CDbl($DecArr[$P])
    EndIf
  Next
 

  exit 0
 

EndFunction
 

 

 

    84483HOSTSINSTALL79KdyerHOSTSINSTALL() - Upate/change HOSTS file1200686743

ÿCode:

;Function:
;    HOSTSINSTALL()
;
;Author:
;    kdyer (leptonator@hotmail.com)
;
;Version:
;    1.2 (18 january 2007)
;       Originally posted at -
;       http://www.scriptlogic.com/kixtart/FunctionLibrary_ViewFunction.aspx?ID=HOSTSINSTALL
;       http://www.kixtart.org/forums/ubbthreads.php?ubb=showflat&Board=7&Number=84483
;
;Version hisotry:
;    1.0 (04th of February 2003) - initial version
;    1.1 (25th of August 2003) - Post on http://kixtart.org , no code changes
;    1.2 (18 January 2007) - Cleaned up and simplified code, and now using FREEFILEHANDLE
;                          - Fixed issue with inserting new entry if using several entries
;
;Action:
;    Checks for an IP Address and alias name. If needed, it will update.
;
;Syntax:
;    HOSTSINSTALL()
;
;Parameters:
;    None, picks up regular HOSTS file, compares what is in there and makes changes
;
;Returns:
;        Nothing
;Dependencies:
;    Windows NT-Classed system
;Remarks:
;        user would need Power User or Administrative Access to modify the HOSTS file.
;
;Examples:  HOSTSINSTALL('www.xxx.yyy.zzz exchange # exchange server')
;Source:
Function HOSTSINSTALL($i) 
	Dim $h, $l, $r, $f
	$h = '%windir%\system32\drivers\etc\hosts'
	$f = FreeFileHandle
	$r = Open($f, $h)
	$l = ReadLine($f)
	While (@error = 0) 
		If $l = $i 
			$r = Close($f)
			Return
		EndIf
		$l = ReadLine($f)
	Loop
	$r = Close($f)
	$r = Open($f, $h, 4)
	$r = WriteLine($f, $i + @crlf)
	$r = Close($f)
EndFunction

84344HTMLtoText70maskenHTMLtoText() - Converts an HTML formatted string into plain text1130925431Code:


;FUNCTION      HTMLtoText()
;
;ACTION        Convert a HTML coded text (special characters) string into plain text
;
;AUTHOR        masken, Lonkero, Richard H.
;
;VERSION       1.0 [2003-06-06] First version. Used arrays for all codes.
;              1.1 [2003-06-10] Uses CHR() for Numeric (decimal) codes. Two arrays
;                               for Name (alternative) codes. Case sensitivity has
;                               to be activated for Name codes to work properly
;                               (see CodeAlts 45 & 77 for example).
;              1.2 [2003-06-12] Different approach by Lonkero. One array, static
;                               Split and Joins by array entries.
;              1.3 [2005-11-01] Bugfixes:
;               		* Case sensitivity on
;               		* alphabetical alt-codes treated correctly
;               		* goto-statement removed
;               		* All variables DIM:ed
;               		Enchancements:
;               		* CodeAlt-list updated
;               		* Arrays remade
;               		* Added check for numerical special chars.
;
;DATE CREATED  2003-06-06
;
;DATE MODIFIED 2005-11-01
;
;KIXTART       4.12+
;
;SYNTAX        HTMLtoText([STRING])
;
;PARAMETERS    STRING
;              The string you want to convert.
;
;RETURNS       The string with special HTML characters removed.
;
;REMARKS       * The purpose is solely to convert character codes in HTML documents
;              * Handles Numeric and Name formats (not hex, could be used in some pages)
;              * Does NOT handle Cyrillic codes or other special character sets.
;              * Small tilde (code: "&tilde") "" not handled since it has no ending ";"
;
;              The list of decimal codes used for the arrays were taken from here:
;              http://webdesign.about.com/od/charactersets/l/bl_htmlcodes.htm
;              References:
;              http://www.zytrax.com/tech/web/entities.html
;              http://www.w3.org/TR/REC-html40/charset.html
;
;DEPENDENCIES  None
;
;EXAMPLE       $htmlstring = "Implac&#225;vel"
;              $result = HTMLtoText($htmlstring)
;              ; $result will be: "Implacável"
;
;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Board=UBB12&Number=113805
;
;===============================================================================

FUNCTION HTMLtoText($String)
	DIM $Counter, $String, $PrevCaseState, $CodeAlts[115]
	$PrevCaseState = SETOPTION("CaseSensitivity", "ON")
	IF INSTR($String, "&") <> 0
		;we only need to process if there's html-code in the string
		$CodeAlts[0] = "aacute", "á"
		$CodeAlts[1] = "Aacute", "Á"
		$CodeAlts[2] = "Acirc", "Â"
		$CodeAlts[3] = "acirc", "â"
		$CodeAlts[4] = "acute", "´"
		$CodeAlts[5] = "aelig", "æ"
		$CodeAlts[6] = "AElig", "Æ"
		$CodeAlts[7] = "Agrave", "À"
		$CodeAlts[8] = "agrave", "à"
		$CodeAlts[9] = "amp", "&"
		$CodeAlts[10] = "Aring", "Å"
		$CodeAlts[11] = "aring", "å"
		$CodeAlts[12] = "atilde", "ã"
		$CodeAlts[13] = "Atilde", "Ã"
		$CodeAlts[14] = "Auml", "Ä"
		$CodeAlts[15] = "auml", "ä"
		$CodeAlts[16] = "brvbar", "¦"
		$CodeAlts[17] = "Ccedil", "Ç"
		$CodeAlts[18] = "ccedil", "ç"
		$CodeAlts[19] = "cedil", "¸"
		$CodeAlts[20] = "cent", "¢"
		$CodeAlts[21] = "copy", "©"
		$CodeAlts[22] = "curren", "¤"
		$CodeAlts[23] = "dagger", ""
		$CodeAlts[24] = "Dagger", ""
		$CodeAlts[25] = "dbquo", ""
		$CodeAlts[26] = "deg", "°"
		$CodeAlts[27] = "divide", "÷"
		$CodeAlts[28] = "Eacute", "É"
		$CodeAlts[29] = "eacute", "é"
		$CodeAlts[30] = "ecirc", "ê"
		$CodeAlts[31] = "Ecirc", "Ê"
		$CodeAlts[32] = "Egrave", "È"
		$CodeAlts[33] = "egrave", "è"
		$CodeAlts[34] = "ETH", "Ð"
		$CodeAlts[35] = "eth", "ð"
		$CodeAlts[36] = "Euml", "Ë"
		$CodeAlts[37] = "euml", "ë"
		$CodeAlts[38] = "frac12", "½"
		$CodeAlts[39] = "frac14", "¼"
		$CodeAlts[40] = "frac34", "¾"
		$CodeAlts[41] = "gt", ">"
		$CodeAlts[42] = "Iacute", "Í"
		$CodeAlts[43] = "iacute", "í"
		$CodeAlts[44] = "Icirc", "Î"
		$CodeAlts[45] = "icirc", "î"
		$CodeAlts[46] = "iexcl", "¡"
		$CodeAlts[47] = "igrave", "ì"
		$CodeAlts[48] = "Igrave", "Ì"
		$CodeAlts[49] = "iquest", "¿"
		$CodeAlts[50] = "iuml", "ï"
		$CodeAlts[51] = "Iuml", "Ï"
		$CodeAlts[52] = "laquo", "«"
		$CodeAlts[53] = "ldquo", ""
		$CodeAlts[54] = "lsaquo", ""
		$CodeAlts[55] = "lsquo", ""
		$CodeAlts[56] = "lt", "<"
		$CodeAlts[57] = "macr", "¯"
		$CodeAlts[58] = "mdash", ""
		$CodeAlts[59] = "micro", "µ"
		$CodeAlts[60] = "middot", "·"
		$CodeAlts[61] = "nbsp", " "
		$CodeAlts[62] = "ndash", ""
		$CodeAlts[63] = "not", "¬"
		$CodeAlts[64] = "ntilde", "ñ"
		$CodeAlts[65] = "Ntilde", "Ñ"
		$CodeAlts[66] = "Oacute", "Ó"
		$CodeAlts[67] = "oacute", "ó"
		$CodeAlts[68] = "ocirc", "ô"
		$CodeAlts[69] = "Ocirc", "Ô"
		$CodeAlts[70] = "Ograve", "Ò"
		$CodeAlts[71] = "ograve", "ò"
		$CodeAlts[72] = "ordf", "ª"
		$CodeAlts[73] = "ordm", "º"
		$CodeAlts[74] = "Oslash", "Ø"
		$CodeAlts[75] = "oslash", "ø"
		$CodeAlts[76] = "otilde", "õ"
		$CodeAlts[77] = "Otilde", "Õ"
		$CodeAlts[78] = "Ouml", "Ö"
		$CodeAlts[79] = "ouml", "ö"
		$CodeAlts[80] = "para", "¶"
		$CodeAlts[81] = "permil", ""
		$CodeAlts[82] = "plusmn", "±"
		$CodeAlts[83] = "pound", "£"
		$CodeAlts[84] = "quot", '"'
		$CodeAlts[85] = "raquo", "»"
		$CodeAlts[86] = "rdquo", ""
		$CodeAlts[87] = "reg", "®"
		$CodeAlts[88] = "rsaquo", ""
		$CodeAlts[89] = "rsquo", ""
		$CodeAlts[90] = "sbquo", ""
		$CodeAlts[91] = "sect", "§"
		$CodeAlts[92] = "shy", "­"
		$CodeAlts[93] = "sup1", "¹"
		$CodeAlts[94] = "sup2", "²"
		$CodeAlts[95] = "sup3", "³"
		$CodeAlts[96] = "szlig", "ß"
		$CodeAlts[97] = "THORN", "Þ"
		$CodeAlts[98] = "thorn", "þ"
		$CodeAlts[99] = "tilde", "~"
		$CodeAlts[100] = "times", "×"
		$CodeAlts[101] = "trade", ""
		$CodeAlts[102] = "uacute", "ú"
		$CodeAlts[103] = "Uacute", "Ú"
		$CodeAlts[104] = "ucirc", "û"
		$CodeAlts[105] = "Ucirc", "Û"
		$CodeAlts[106] = "ugrave", "ù"
		$CodeAlts[107] = "Ugrave", "Ù"
		$CodeAlts[108] = "uml", "¨"
		$CodeAlts[109] = "uuml", "ü"
		$CodeAlts[110] = "Uuml", "Ü"
		$CodeAlts[111] = "yacute", "ý"
		$CodeAlts[112] = "Yacute", "Ý"
		$CodeAlts[113] = "yen", "¥"
		$CodeAlts[114] = "yuml", "ÿ"
		$CodeAlts[115] = "Yuml", ""

		;Convert numerical special chars. Only run this routine if
		;there's numerical special chars, or it might destroy the string.
	        IF INSTR($String, "&#") <> 0
		        $String = SPLIT($String, "&#")
		        FOR $Counter = 0 TO UBOUND($String)
		        	$String[$Counter] = CHR(SPLIT($String[$Counter], ";")[0]) + SUBSTR($String[$Counter], INSTR($String[$Counter], ";") + 1)
		        NEXT
		        $String = JOIN($String,"")
		ENDIF

		;Convert alphabetical special characters using the predefined array
	        FOR $Counter = 0 TO UBOUND($CodeAlts)
	                $String = JOIN(SPLIT($String, "&" + $CodeAlts[$Counter][0] + ";"),$CodeAlts[$Counter][1])
	        NEXT
	ENDIF
	$HTMLtoText = $String
        $nul = SETOPTION("CaseSensitivity", $PrevCaseState)
ENDFUNCTION

83479IdentifyRemoteUser52NTDOCIdentifyRemoteUser()    Identifies the User Logged on to a Computer1141632432;Function:	IdentifyRemoteUser() - Identifies the User Logged on to a Computer
;
;Author:	NTDOC
;
;Version:	1.3
;
;Date:		2006-03-05
;
;History:
;		2005-09-05 Version 1.0
;		2005-03-31 Version 1.1
;		2005-01-11 Version 1.2
;		2006-03-05 Version 1.3
;
;Revision Reason:
;		Modified the exit codes to support COM returned errors
;
;Action:
;		Uses the WMI Win32_ComputerSystem to query the user name of the logged on user
;		Though initially designed to check a remote computer it can also test the local system
;
;Syntax:	IdentifyRemoteUser(optional $sComputer)
;
;Parameters:	$sComputer(the name of the remote computer you want to query, if blank local system used)
:
;Remarks:
;
;Dependencies:	KiX 4.51, WMI Enabled PC, Admin rights on remote system
;
;Example:
Code:

Dim $WMICheck, $User
$WMICheck = WMIConfirm('Some Remote PC')
If @ERROR
  'An error occurred while checking for WMI access.  ERROR:' + @ERROR + ' - ' + @SERROR ?
Else
  'WMI version okay: ' + $WMICheck ?
  $User = IdentifyRemoteUser('Some Remote PC')
  If @ERROR
    'An error occurred while checking the logged on user.  ERROR:' + @ERROR + ' - ' + @SERROR ?
  Else
    'Logged on user is: ' + $User ?
EndIf


 
;Source
 
  
 
Code:

Function IdentifyRemoteUser(Optional $sComputer)
  Dim $objWMIService,$colComputer,$objComputer
  $sComputer=IIf(Not $sComputer,'','\\'+Join(Split($sComputer,'\'),'',3)+'\')
  $objWMIService=GetObject('winmgmts:{impersonationLevel=impersonate}!'+$sComputer+'root\cimv2')
  If @ERROR
    $IdentifyRemoteUser = ''
    Exit Val('&' + Right(DecToHex(@ERROR), 4))
  EndIf
  $colComputer = $objWMIService.ExecQuery ("Select * from Win32_ComputerSystem")
  If @ERROR
    $IdentifyRemoteUser = ''
    Exit Val('&' + Right(DecToHex(@ERROR), 4))
  EndIf
  For Each $objComputer In $colComputer
    $IdentifyRemoteUser = $objComputer.UserName
  Next
  Exit  Val('&' + Right(DecToHex(@ERROR), 4))
EndFunction


83277IeVer46kholmIeVer() - Get version and language of installed Internet Explorer0IeVer() - Get version and language of installed Internet Explorer 

Action:
Retrieve version and language of installed Internet Exlorer

Syntax:
$IeVer = IeVer()
 
Parameters:
None
 
Returns:
Version of Internet Explorer (Unknown if not found)
Global variable: $IeLang - Language of installed Internet Explorer

Remarks:
Version info is found for all known versions of IExplore in the range 1.0 - 6.0 except for some developer/beta versions.

Language retrieval is not reliable for all versions:
For some of the minor versions  < 5.0 the language is always English for Iexplore.exe

The language is retrieved in english:
Danish
German
Italian
Spanish ... etc. 

Example:

code:

? 'Internet Exlorer version: ' + IeVer()
? 'IE Language : ' + $IeLang

Source:

code:

Function IeVer()
  ; Reference: Q164539
  Global $IeLang
  Dim $IV,$IePrg,$Build,$ProgFilesDir
  $IeVer = 'Unknown'
  $IeLang = ''
  $IV = Left('' + ReadValue("HKLM\Software\Microsoft\Internet Explorer","Version"),8)
  If $IV
    Select
      Case Left($IV,4) = '4.71'
        $ieVer = '4.00'
      Case $IV = '4.72.210'
        $IeVer = '4.01'
      Case $IV = '4.72.311'
        $IeVer = '4.01 SP1'
      Case $IV = '4.72.361'
        $IeVer = '4.01 SP2'
      Case InStr('-5.00.251-5.00.291-5.00.292',$IV) > 1
        $IeVer = '5.01'
      Case $IV = '5.00.310'
        $IeVer = '5.01 SP1'
      Case $IV = '5.00.331'
        $IeVer = '5.01 SP2'
      Case Left($IV,4) = '5.00'
        $IeVer = '5.00'
      Case InStr('-5.50.403-5.50.413',$IV) > 1
        $IeVer = '5.50'
      Case $IV = '5.50.452'
        $IeVer = '5.50 SP1'
      Case $IV = '5.50.480'
        $IeVer = '5.50 SP2'
      Case InStr('-6.0.2462-6.0.2479-6.0.2600',$IV) > 1
        $IeVer = '6.00'
      Case $IV = '6.0.2800'
	    $IeVer = '6.00 SP1'
      Case $IV > '6.0.2800'
	    $IeVer = '6.+'
      Case 1
        Return
    EndSelect
    $IePrg = '' + ReadValue('HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\IE4\SETUP','Path')
    If $IePrg
      $RC = Execute('$$IePrg="$IePrg" + "\Iexplore.exe"')
      $IeLang = SubStr('' + GetFileVersion($IePrg,'Language'),5)
    EndIf
  Else
    $IV = '' + Left(ReadValue("HKLM\Software\Microsoft\Internet Explorer","IVer"),3)
    If $IV
      Select
        Case $IV = '100'
          $ieVer = '1.00'
        Case $IV = '101'
          $ieVer = '1.01 NT4'
        Case $IV = '102'
          $ieVer = '2.00'
        Case $IV = '103'
          $Build = '' + ReadValue("HKLM\Software\Microsoft\Internet Explorer","Build")
          Select
            Case InStr('-1155-1158',$Build) > 1
              $ieVer = '3.00'
            Case $Build = '1215'
              $ieVer = '3.01'
            Case $Build = '1300'
              $ieVer = '3.02'
            Case 1
              Return
          EndSelect
        Case 1
          Return
      EndSelect
      $ProgFilesDir = ReadValue('HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion','ProgramFilesDir')
      $IePrg = $ProgFilesDir + '\Internet Explorer\Iexplore.exe'
      If Exist($IePrg)
        $IeLang = SubStr('' + GetFileVersion($IePrg,'Language'),5)
      EndIf
    EndIf
  EndIf
EndFunction

Author:

-kholm
Erik Kærholm

{edit}
Upgraded to include: 6.00 SP1
 
 [ 08. October 2002, 21:39: Message edited by: kholm ]154504ImportRegFile119LonkeroImportRegFile - Imports .Reg files to registry same way as "regedit /s"0Code:


/*
Function: ImportRegFile

Author:   Lonkero (Jooel at pp dot inet dot fi)  

Action:   Imports .Reg export files to registry same way as "regedit /S"

Version:  1.0 - the result of [url=http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=154033]KiXtart Golf Tournament III[/url] with fixed layout

Syntax:   ImportRegFile(FILE)

Parameters:
          FILE - Path to the file to import

Returns:  Nothing

Remarks:  As this was coded like years ago, can't know if this even works with 4.50. any testers?
          Some real odd thingies in the reg-file might not get caught as this is not proven 100% perfect.

Dependencies:
          KiXtart - 4.1x - no quarantee of working with newer versions

Example:
          ImportRegFile("c:\scripts\exported.reg")

*/
function ImportRegfile($)
 if ubound($)<1 $=$,"" endif
 for each $ in $
  dim $k,$v,$m,$d,$s
  $=open(1,$)
  do
   if "["=left($,1) $=substr($,2,len($)-2) if "-"=left($,1) $=delkey(substr($,2)) else $k=$ $=addkey($) endif endif
   if $k&$
    while \=right($,1) $=left($,len($)-1)+trim(readline(1)) loop
    $v=substr($,2,instr($,"=")-3) $=split($,"=")[1]
    if '"'=left($,1)
     $m="SZ" $s=substr($,2,len($)-2)
    else
     $s="" $m=instr($,":") $d=substr($,$m-2,1)
     for each $ in split(substr($,$m+1),",")
      $m=val("&"+$)
      if $d="r" $=$m $m="DWORD" endif
      if $d="e" $m="BINARY" endif
      if $d=2|$d=7 $=chr($m) $m="EXPAND_SZ" endif
      $s=$s+$
     next
     if $d=7 $m="MULTI_SZ" for each $ in split($s,00) $s=$+"|" next endif
    endif
    if '-'=$s $=delvalue($k,$v) else $=writevalue($k,$v,$s,"reg_"+$m) endif
   endif
   $=readline(1)
  until @error
  $=close(1)
 next
endfunction

83048InArray588SchuliebugInArray() - search in a multi-dimensional array for a string0Sometime ago i saw the function InArray. I have changed it a littlebit, so it can handle normal
arrays as wel as multi-dimensional arrays. See for yourself       

code:

;Function       InArray
;
;Parameters     1: Required, array.
;               2: Required, string to search for in array. Wildcard is supported.
;               3; Optional, used in UDF.
;
;Remarks        none.
;
;Returns        Array of the element in which the string was first found. If the search
;               string matches an element in the array, it returns the position of that
;               element + 1 (so it starts with 1!). @error=0 if succesfull, >0 if failed
;
;Dependencies   IsArray UDF
;
;Example(s)     $Array11='aaa','bbb','ccc'
;               $Array12='abc','def','ghi','jkl','mno','pqr'
;               $Array13='kix32','is','great!'
;               $Array1=$Array11,$Array12,$Array13
;               $Array2='123','456','789','100'
;               $Array3='no array'
;               $Array4='if','then','else','endif'
;               $Array=$Array1,$Array2,$Array3,$Array4
;
;               $Array = InArray($Array,'else') returns '4,3'
;               $Array = InArray($Array,'great!') returns '1,3,3'
;               $Array = InArray($Array,'*array') returns '3'
;
Function InArray($Array,$String,Optional $Ptr)
	Dim $RC,$Count,$Str,$Cnt
	$InArray=0 $Str=''

	; Check parameters..
	If Not VarType($String) Exit(2) EndIf
	If Not IsArray($Array)  Exit(1)
	Else
		For $Count=0 to UBound($Array)
			Select
			  ; Is Array..
			  Case IsArray($Array[$Count])
				$RC=InArray($Array[$Count],$String,1)
				If $RC<>0
					$InArray=''+($Count+1)+',$RC'
					$Count=UBound($Array)
				EndIf

		  	  ; Wildcards in string..
			  Case InStr($String,'*')<>0
				If $Str='' $Str=Strip($String,'*') EndIf

				; Search in string..
			  	If InStr($Array[$Count],$Str)<>0
			  		$InArray=$Count+1
					$Count=UBound($Array)
				EndIf

			  ; Just string compare..
			  Case $Array[$Count]=$String
			  	$InArray=$Count+1
				$Count=UBound($Array)

			EndSelect
		Next
	EndIf

	; Return array, only at top level..
	If Not $Ptr And InStr($InArray,',') $InArray=Split($InArray,',') EndIf
EndFunction


 
 [ 28. October 2002, 19:47: Message edited by: Radimus ]83928Include2980Glenn BarnasInclude() - load a UDF from standard locations0This issue came up when I wrote the Task Scheduler Admin tool... we use a standard location for our UDF Libraries - \usr\lib. We also use .KXF (KiXtart Functions) because .UDF conflicts with applications on some servers. I quickly got tired of maintaining two sets of code, so I changed how I loaded the libraries.

The Include("lib") function tries to load library files from three locations using two different file extensions. These locations and extensions can easily be changed or added to.

Extensions include .KXF and .UDF. Locations searched include %SystemDrive%\usr\lib, then the path defined by %KIXLIBPATH%, and then the @ScriptDir - the directory where the script was run from.

Now, a simple 

code:

 Include("tsControl") 

will find and load the library. This concept can be expanded with the FindPath() function to locate a library anywhere in the system PATH variable. (I'll leave that mod to you guys)           

By default, this function terminates the script if the library isn't located. An optional argument changes this behavior to return an error, but the programmer must handle the lack of functionality if the library isn't loaded.

Glenn

PS - Updated to remove the "Exit" after "Quit" so Lonk will smile again, and added the "AltLibPath" to make Richard smile..         

Thanks for the suggestions!


;;
;;======================================================================
;;
;;FUNCTIONÿ ÿ ÿ ÿInclude()
;;
;;ACTIONÿ ÿ ÿ ÿ ÿLoadsÿaÿKIXÿlibraryÿ(UDF)-ÿchecksÿmultipleÿlocations
;;
;;AUTHORÿ ÿ ÿ ÿ ÿGlennÿBarnasÿ/ÿFRIT-EROC
;;
;;SYNTAXÿ ÿ ÿ ÿ ÿInclude("IncludeFile"ÿ[,AltLibPathÿ[,ÿFlagÿ]]ÿ)
;;
;;PARAMETERSÿ ÿ ÿIncludeFileÿ-ÿLibraryÿnameÿtoÿlocateÿandÿloadÿ-ÿNOÿExtension!
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿAltLibPathÿ -ÿAlternateÿpathÿtoÿsearchÿforÿUDFs
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿFlagÿ ÿ ÿ ÿ -ÿReturnÿanÿerrorÿinsteadÿofÿterminatingÿwhen
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿtheÿlibraryÿcan'tÿbeÿfound
;;
;;REMARKSÿ ÿ ÿ ÿ Terminatesÿtheÿscriptÿifÿtheÿlibarayÿisn'tÿfoundÿunlessÿtheÿ
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿSoftErrÿvalueÿisÿset.ÿIfÿSoftErrÿisÿsetÿandÿtheÿlibraryÿcan't
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿbeÿfound,ÿtheÿcallingÿroutineÿmustÿhandleÿtheÿlackÿof
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿfunctionality.ÿUnlessÿcustomized,ÿitÿtriesÿtoÿloadÿ.KXFÿandÿ
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ.UDFÿfilesÿfromÿ\usr\lib,ÿ%KixLibPath%,ÿorÿ@ScriptDir.
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿAltLibPathÿcanÿbeÿusedÿtoÿspecifyÿadditionalÿsearchÿdirectories,
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿtheseÿdirectoriesÿwillÿbeÿsearchedÿFIRST.
;;
;;RETURNSÿ ÿ ÿ ÿ nothingÿ-ÿloadsÿtheÿspecifiedÿUDFÿorÿterminates
;;
;;DEPENDENCIESÿ ÿnone
;;
;;TESTEDÿWITHÿ ÿ NT4,ÿW2K,ÿWXP
;;
;;EXAMPLESÿ ÿ ÿ ÿInclude("tsControl")ÿ ÿ ÿ ;ÿfindÿandÿloadÿtscontrol.udf,ÿterminateÿ
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿifÿnotÿfound
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿInclude("tsControl","",1)ÿ;ÿfindÿandÿloadÿtscontrol.udf,ÿreturnÿan
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿerrorÿifÿnotÿfound
;
FunctionÿInclude($LibFile,ÿOPTIONALÿ$AltLibPath,ÿOPTIONALÿ$SoftErr)
ÿ Dimÿ$Extensions,ÿ$LoadPath,ÿ$PATHS,ÿ$PATH,ÿ$EXTS,ÿ$EXT
ÿ
ÿ ;ÿdefineÿaÿcomma-separatedÿlistÿofÿallowedÿlibraryÿfileÿextensionsÿ
ÿ $Extensionsÿ=ÿ".udf,ÿ.kxf"
ÿ
ÿ ;ÿdefineÿtheÿlocationsÿwhereÿtheÿUDFsÿareÿmaintained
ÿ ;ÿdefaultÿisÿC:\usr\lib,ÿthenÿ%KIXLIBPATH%,ÿthenÿscript-startÿdirectory
ÿ $DefPathÿ=ÿ"%SystemDrive%\usr\lib;%KixLibPath%;@ScriptDir"
ÿ
ÿ ;ÿMakeÿsureÿAltLibPathÿendsÿwithÿ";"ÿifÿspecified
ÿ Ifÿ$AltLibPathÿ<>ÿ""
ÿ ÿ IfÿRight($AltLibPath,1)ÿ<>ÿ";"
ÿ ÿ ÿ $AltLibPathÿ=ÿ$AltLibPathÿ+ÿ";"
ÿ ÿ EndIF
ÿ EndIf
ÿ
ÿ ;ÿDefineÿtheÿdefaultÿsearchÿlocations
ÿ $PATHSÿ=ÿSplit($AltLibPathÿ+ÿ$DefPath,ÿ";")
ÿ
ÿ ;ÿuseÿsplitÿtoÿinsureÿarrayÿformat,ÿevenÿwithÿoneÿextensionÿname
ÿ $EXTSÿ =ÿSplit($Extensions,ÿ",")
ÿ ForÿEachÿ$PATHÿinÿ$PATHS
ÿ ÿ ForÿEachÿ$EXTÿinÿ$EXTS
ÿ ÿ ÿ $LoadPathÿ=ÿ$PATHÿ+ÿ"\"ÿ+ÿ$LibFileÿ+ÿTrim($EXT)
ÿ ÿ ÿ IfÿExist($LoadPath)
ÿ ÿ ÿ ÿ Callÿ$LoadPAth
ÿ ÿ ÿ ÿ Exitÿ0
ÿ ÿ ÿ EndIf
ÿ ÿ Next
ÿ Next
ÿ
ÿ ;ÿLibÿnotÿfound!ÿReturnÿerrorÿifÿSoftErrÿisÿsetÿorÿDIE!
ÿ Ifÿ$SoftErr
ÿ ÿ Exitÿ1
ÿ Else
ÿ ÿ "Failedÿtoÿloadÿrequiredÿlibrary:ÿ"ÿ+ÿ$LibFileÿ+ÿ"ÿ-ÿAborting!"
ÿ ÿ Quitÿ1
ÿ EndIf
ÿ
EndFunction


 
 [ 26. March 2003, 20:55: Message edited by: Glenn Barnas ]83022InContainer172Howard BullockInContainer() - Determines if the current account or computer is in a container1112649460Code:

;FUNCTION         InContainer()
;
;AUTHOR           Howard A. Bullock (hbullock@tycoelectronics.com)
;
;VERSION          1.5
;
;DATE             20-Mar-2002
;REVISED          04-Apr-2005
;
;ACTION           Determines if the current NT4 account name type is a member of a specific container (OU, Computers, etc)
;                 in Active Directory
;
;SYNTAX           InContainer ($Container, $NameType)
;
;PARAMETERS       $Container (Required)
;                  -  String value
;                 Dinstinghished name of the container to check. This must be the fully qualified DN to
;                 accurately make a determination.
;
;                 $NameType (Required)
;                  -  String value
;                 "Computer" or "User" are currently the only valid values
;
;REMARKS          This function returns true if the object being checked in the the specified container
;                 or a child container of that specified.
;
;RETURNS          An ARRAY of three values:
;                    InContainer return code
;                      1 = object is a member of the exact container specified.
;                      2 = object is a member of the container hierarchy.
;                      0 = object is not a member of the container hierarchy.
;                     -1 = Invalid input for $NameType
;                     -2 = Error in TranslateName
;                    TranslateName ErrorCode
;                    TranslateName ErrorText
;
;DEPENDENCIES     OS: Active Directory aware client
;                 Other Functions: TranslateName()
;
;EXAMPLES         $rc = InContainer ("OU=test,OU=9826,OU=NCS,OU=Machines,DC=us,DC=tycoelectronics,DC=com", "Computer")
;                 select
;                   case $rc[0]=1  ? "object is a member of the specified container."
;                   case $rc[0]=2  ? "object is a member of a child container lower in the hierarchy."
;                   case $rc[0]=0  ? "object is NOT a member of this container or a child of this container."
;                   case $rc[0]=-1 ? "InContainer() Error - Invalid input for $NameType "
;                   case $rc[0]=-2 ? "TranslateName() Error"
;                   case 1         ? "Unknown return code"
;                 endselect
;
;
Function InContainer ($Container, $NameType)
   Dim $CurrentContainer, $Name1, $Name2, $Found, $commaloc

   select
      case $NameType = "Computer"  $Name1 = @Domain + "\" + @wksta + "$$"
      case $NameType = "User"      $Name1 = @LDomain + "\" + @UserID
      case 1                       $Name1 = ""
   endselect

   if $Name1 <> ""
      $Name2 = TranslateName (3, "", 3, $Name1, 1)

      if $Name2[1] = 0

        $Found=0
        while $Found=0
          $commaloc = instr($Name2[0], ",")
          if $commaloc > 1
            if substr($Name2[0],$commaloc-1,1) = "\"
              $Name2[0] = substr($Name2[0], $commaloc+1)
            else
              $Found=1
              $CurrentContainer = substr($Name2[0], $commaloc+1)
            endif
          else
            $Found=1
          endif
        loop

        select
           case $CurrentContainer=$Container  $InContainer = 1, $Name2[1], $Name2[2]
           case instr($Name2[0], $Container)  $InContainer = 2, $Name2[1], $Name2[2]
           case 1                             $InContainer = 0, $Name2[1], $Name2[2]
        endselect
      else
        $InContainer = -2, $Name2[1], $Name2[2]
      endif
   else
     $InContainer = -1, 0, ""
   endif
EndFunction


 
[ 12. October 2003, 01:42: Message edited by: Howard Bullock ]83461InGroups588SchuliebugInGroups(): checks membership of user against array of groups0

code:

;Author         Jan.Schulenburg@tui.nl
;
;Function       InGroups
;
;Parameters     1: required, groups array to check.
;               2: optional, log messages in file
;
;Remarks        This function checkes if user is member of groups in array. Returned
;               errors are the same as InGroup function
;
;Returns        @Error=1 if succesfull, 0 if failed.
;
;Dependencies   Log,IsArray UDF
;
;Example(s)     $RC=InGroups(Split('Desktop|Supervisors','|'),'c:\Temp\Logfile.txt')
;
Function InGroups($Groups,Optional $Log)
	; Function variables..
	Dim $GrpStr,$GrpStrErr,$Count
	$GrpStr='' $GrpStrErr=''

	; Check parameters..
	If Not VarType($Groups) Exit(1) Else If IsArray($Groups)<>1 Exit(2) EndIf EndIf

	; Check group membership..
	$InGroups=1
	For $Count=0 To UBound($Groups) Step 1
		If InGroup($Groups[$Count])=0
			$InGroups=0
			If $GrpStrErr='' $GrpStrErr=$Groups[$Count] Else $GrpStrErr='$GrpStrErr,'+$Groups[$Count] EndIf
		EndIf

		; Create string containing all groups..
		If $GrpStr='' $GrpStr=$Groups[$Count] Else $GrpStr='$GrpStr,'+$Groups[$Count] EndIf
	Next

	; Logging..
	If $Log
		If $GrpStrErr<>'' $RC=Log('  ++ Error: @UserID not a member of $GrpStrErr ++',$Log) EndIf
		If $Debug $RC=Log('Dbg: Groups $GrpStr checked for @UserID (returnvalue InGroups UDF: $InGroups) ++',$Log) EndIf
	EndIf
EndFunction

135393Ini2Ary2980Glenn BarnasIni2Ary() - Enumerate an INI file to an array0

ÿCode:

[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;====================================================================== [/color]
[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;FUNCTION       Ini2Ary() [/color]
[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;ACTION         Enumerates all data of an INI file [/color]
[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;AUTHOR         Glenn Barnas / FRIT-EROC [/color]
[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;VERSION        1.1 [/color]
[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;DATE CREATED   2005/03/04 [/color]
[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;DATE MODIFIED  2005/03/11 [/color]
[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;SYNTAX         Ini2Ary($File) [/color]
[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;PARAMETERS     $File - 	REQUIRED, path/name of INI file to examine [/color]
[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;REMARKS        Populates an array of arrays with the data in a specified INI file.   [/color]
[color:"#2E8B57"];;               Array[0][#] = section name where key/data exists [/color]
[color:"#2E8B57"];;               Array[1][#] = key name  [/color]
[color:"#2E8B57"];;               Array[2][#] = data value [/color]
[color:"#2E8B57"];;               Returning three, equal-sized sub-arrays allows a 1:1 relationship between  [/color]
[color:"#2E8B57"];;               the section, key, and data in each element record. This permits easy [/color]
[color:"#2E8B57"];;               cross-referencing between data, key, and section using AScan(). [/color]
[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;RETURNS        Array of arrays [/color]
[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;DEPENDENCIES   EnumIni() [/color]
[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;TESTED WITH    Kix 4.2+, NT4, W2K, WXP, W2K3 [/color]
[color:"#2E8B57"];; [/color]
[color:"#2E8B57"];;EXAMPLES       Ini2Ary('Ini', 'c:\temp\test.ini') [/color]
[color:"#2E8B57"];;               $ = AScan($Ini[1], 'Filter') [/color]
[color:"#2E8B57"];;               'Key "Filter" found in section "' $Ini[0][$] '" and contains "' $Ini[2][$] '"' ? [/color]
[color:"#2E8B57"]; [/color]
[color:"#0000FF"]Function[/color] Ini2Ary([color:"#000000"]$File[/color])
 

  [color:"#0000FF"]Dim[/color] [color:"#000000"]$WorkAry[/color][[color:"#4682B4"]2[/color]]
  [color:"#0000FF"]Dim[/color] [color:"#000000"]$Sects[/color], [color:"#000000"]$Sect[/color], [color:"#000000"]$Keys[/color], [color:"#000000"]$Key[/color], [color:"#000000"]$Count[/color]
 
 

  [color:"#2E8B57"]; Load the array of arrays [/color]
  [color:"#2E8B57"]; Determine the number of entries in the INI file [/color]
  [color:"#000000"]$Count[/color] = [color:"#4682B4"]0[/color]					[color:"#2E8B57"]; init the record count [/color]
  [color:"#000000"]$Sects[/color] = [color:"#000000"]EnumIni[/color]([color:"#000000"]$File[/color])			[color:"#2E8B57"]; get the sections [/color]
 

  [color:"#0000FF"]If[/color] [color:"#000000"]@ERROR[/color]
    [color:"#0000FF"]Exit[/color] [color:"#000000"]@ERROR[/color]					[color:"#2E8B57"]; Exit on any file error, including empty file [/color]
  [color:"#0000FF"]EndIf[/color]
 

  [color:"#0000FF"]For[/color] [color:"#0000FF"]Each[/color] [color:"#000000"]$Sect[/color] [color:"#0000FF"]in[/color] [color:"#000000"]$Sects[/color]
    [color:"#000000"]$Keys[/color] = [color:"#000000"]EnumIni[/color]([color:"#000000"]$File[/color], [color:"#000000"]$Sect[/color])		[color:"#2E8B57"]; get the keys [/color]
    [color:"#000000"]$Count[/color] = [color:"#000000"]$Count[/color] + [color:"#FF1493"]UBound[/color]([color:"#000000"]$Keys[/color]) + [color:"#4682B4"]1[/color]		[color:"#2E8B57"]; count them [/color]
  [color:"#0000FF"]Next[/color]
  [color:"#000000"]$Count[/color] = [color:"#000000"]$Count[/color] - [color:"#4682B4"]1[/color]				[color:"#2E8B57"]; adjust for element 0 [/color]
 

  [color:"#2E8B57"]; Declare the INI arrays SECTION / KEY / DATA [/color]
  [color:"#0000FF"]Dim[/color] [color:"#000000"]$aS[/color][[color:"#000000"]$Count[/color]], [color:"#000000"]$aK[/color][[color:"#000000"]$Count[/color]], [color:"#000000"]$aD[/color][[color:"#000000"]$Count[/color]]
 

  [color:"#2E8B57"]; Enumerate the file [/color]
  [color:"#000000"]$Count[/color] = [color:"#4682B4"]0[/color]
  [color:"#0000FF"]For[/color] [color:"#0000FF"]Each[/color] [color:"#000000"]$Sect[/color] [color:"#0000FF"]in[/color] [color:"#000000"]$Sects[/color]			[color:"#2E8B57"]; parse each section [/color]
    [color:"#000000"]$Keys[/color] = [color:"#000000"]EnumIni[/color]([color:"#000000"]$File[/color], [color:"#000000"]$Sect[/color])
    [color:"#0000FF"]If[/color] [color:"#000000"]@ERROR[/color] <> [color:"#4682B4"]0[/color] And [color:"#000000"]@ERROR[/color] <> [color:"#4682B4"]13[/color]
      [color:"#0000FF"]Exit[/color] [color:"#000000"]@ERROR[/color]				[color:"#2E8B57"]; exit on hard failures - no keys is OK [/color]
    [color:"#0000FF"]EndIf[/color]
    [color:"#0000FF"]For[/color] [color:"#0000FF"]Each[/color] [color:"#000000"]$Key[/color] [color:"#0000FF"]in[/color] [color:"#000000"]$Keys[/color]			[color:"#2E8B57"]; then the keys in each section [/color]
      [color:"#000000"]$aS[/color][[color:"#000000"]$Count[/color]] = [color:"#000000"]$Sect[/color]
      [color:"#000000"]$aK[/color][[color:"#000000"]$Count[/color]] = [color:"#000000"]$Key[/color]
      [color:"#000000"]$aD[/color][[color:"#000000"]$Count[/color]] = [color:"#FF1493"]ReadProfileString[/color]([color:"#000000"]$File[/color], [color:"#000000"]$Sect[/color], [color:"#000000"]$Key[/color])
      [color:"#000000"]$Count[/color] = [color:"#000000"]$Count[/color] + [color:"#4682B4"]1[/color]
    [color:"#0000FF"]Next[/color]
  [color:"#0000FF"]Next[/color]
 

  [color:"#000000"]$WorkAry[/color][[color:"#4682B4"]0[/color]] = [color:"#000000"]$aS[/color]				[color:"#2E8B57"]; Section Name [/color]
  [color:"#000000"]$WorkAry[/color][[color:"#4682B4"]1[/color]] = [color:"#000000"]$aK[/color]				[color:"#2E8B57"]; Key Name [/color]
  [color:"#000000"]$WorkAry[/color][[color:"#4682B4"]2[/color]] = [color:"#000000"]$aD[/color]				[color:"#2E8B57"]; Data value [/color]
  [color:"#000000"]$Ini2Ary[/color] = [color:"#000000"]$WorkAry[/color]				[color:"#2E8B57"]; return it [/color]
 

[color:"#0000FF"]EndFunction[/color]
 

 



The format of the array returned can be thought of as:
Section_1 - Key_1 - Data
Section_1 - Key_2 - Data
Section_2 - Key_1 - Data
and so on...
   84427InitKFConstants17SealeopardInitKFConstants() - Initializes KiXforms constants1076011842;FUNCTION      InitKFConstants

;

;ACTION        Initializes KiXforms constants

;

;AUTHOR        Jens Meyer (sealeopard@usa.net)

;

;CONTRIBUTORS  Ch Melin

;

;VERSION       1.1 (updated to comply with KiXforms 2.3.0.42 beta 4)

;              1.0

;

;DATE CREATED  2003/07/07

;

;DATE MODIFIED 2004/02/05

;

;KIXTART       4.02+

;

;SYNTAX        INITKFCONSTANTS()

;

;PARAMETERS    none

;

;RETURNS       0 if successful, otherwise error code

;

;REMARKS       requires KiXforms 2.3.0.42 beta 4 or later

;

;DEPENDENCIES  none

;

;EXAMPLE       CALL @SCRIPTDIR+'\InitKFConstants.kxf'

;

;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Number=83493

;

function InitKFConstants()



;-- AnchorStyles --

global $AnchorStylesNone, $AnchorStylesTop, $AnchorStylesBottom, $AnchorStylesLeft, $AnchorStylesRight

global $AnchorStylesAll, $AnchorStylesBottomRight, $AnchorStylesTopLeft

$AnchorStylesNone        =  0    ; not AnchorStylesed to any edges of its container

$AnchorStylesTop         =  1    ; Anchored to the top edge of its container

$AnchorStylesBottom      =  2    ; Anchored to the bottom edge of its container

$AnchorStylesLeft        =  4    ; Anchored to the left edge of its container

$AnchorStylesRight       =  8    ; Anchored to the right edge of its container

$AnchorStylesAll         = 15    ; Anchored to all edges of its container

$AnchorStylesBottomRight = 10    ; Anchored to the bottom and right edge of its container

$AnchorStylesTopLeft     =  5    ; anchored to the top and left edge of its container



;-- Appearance constants --

global $AppearanceButton, $AppearanceNormal

$AppearanceButton = 1 ; appearance of a Windows button

$AppearanceNormal = 0 ; default appearance defined by the control class



;-- BorderStyle --

global $BorderStyleNo, $BorderStyleFixedSingle, $BorderStyleFixed3D, $BorderStyleRaised, $BorderStyleFramed, $BorderStyleRecessed

$BorderStyleNo          = 0   ; No border

$BorderStyleFixedSingle = 1   ; A single-line border

$BorderStyleFixed3D     = 2   ; A three-dimensional border. The behavior of this setting depends on the derived class

$BorderStyleRaised      = 3   ; A three-dimensional raised border. This setting is not support in .NET

$BorderStyleFramed      = 4   ; A three-dimensional framed border. This setting is not support in .NET

$BorderStyleRecessed    = 5   ; A three dimensional, lightly sunken border. This setting is not supported in .NET



;-- CheckState --

global $CheckStateUnchecked, $CheckStateChecked, $CheckStateUndeterminate

$CheckStateUnchecked     = 0   ; The checkbox is unchecked.

$CheckStateChecked       = 1   ; The checkbox is checked

$CheckStateUndeterminate = 2   ; The checkbox is indeterminate. An indeterminate checkbox generally has a shaded appearance.



;-- ColorDepth --

global $ColorDepthDepth4Bit, $ColorDepthDepth8Bit, $ColorDepthDepth16Bit, $ColorDepthDepth24Bit, $ColorDepthDepth32Bit

$ColorDepthDepth4Bit  = 4    ; A 4-bit image

$ColorDepthDepth8Bit  = 8    ; A 8-bit image

$ColorDepthDepth16Bit = 16   ; A 16-bit image

$ColorDepthDepth24Bit = 24   ; A 24-bit image

$ColorDepthDepth32Bit = 32   ; A 32-bit image



;-- ColumnHeaderStyle --

global $ColumnHeaderStyleNone, $ColumnHeaderStyleNonclickable, $ColumnHeaderStyleClickable

$ColumnHeaderStyleNone         = 0   ; The column header is not displayed in report view.

$ColumnHeaderStyleNonclickable = 1   ; The column headers do not respond to the click of a mouse.

$ColumnHeaderStyleClickable    = 2   ; The column headers function like buttons and can carry out an action, such as sorting, when clicked.



;-- ComboBoxStyle --

global $ComboBoxStyleSimple, $ComboBoxStyleDropDown, $ComboBoxStyleDrowDownList

$ComboBoxStyleSimple       = 0   ; The text portion is editable. The list portion is always visible.

$ComboBoxStyleDropDown     = 1   ; The text portion is editable. The user must click the arrow button to display the list portion.

$ComboBoxStyleDrowDownList = 2   ; The user cannot directly edit the text portion. The user must click the arrow button to display the list portion.



;-- ContentAlignment --

global $ContentAlignmentTopLeft, $ContentAlignmentTopCenter, $ContentAlignmentTopRight

global $ContentAlignmentMiddleLeft, $ContentAlignmentMiddleCenter, $ContentAlignmentMiddleRight

global $ContentAlignmentBottomLeft, $ContentAlignmentBottomCenter, $ContentAlignmentBottomRight

$ContentAlignmentBottomLeft   = 256    ; Text is vertically aligned at the bottom, and horizontally aligned on the left.

$ContentAlignmentBottomCenter = 512    ; Text is vertically aligned at the bottom, and horizontally aligned at the center.

$ContentAlignmentBottomRight  = 1024   ; Text is vertically aligned at the bottom, and horizontally aligned on the right.

$ContentAlignmentMiddleLeft   = 16     ; Text is vertically aligned in the middle, and horizontally aligned on the left.

$ContentAlignmentMiddleCenter = 32     ; Text is vertically aligned in the middle, and horizontally aligned at the center.

$ContentAlignmentMiddleRight  = 64     ; Text is vertically aligned in the middle, and horizontally aligned on the right.

$ContentAlignmentTopLeft      = 1      ; Text is vertically aligned at the top, and horizontally aligned on the left.

$ContentAlignmentTopCenter    = 2      ; Text is vertically aligned at the top, and horizontally aligned at the center.

$ContentAlignmentTopRight     = 4      ; Text is vertically aligned at the top, and horizontally aligned on the right.



;-- CursorStyle --

global $CursorStyleDefault, $CursorStyleArrow, $CursorStyleCross, $CursorStyleIBeam, $CursorStyleSizeNESW, $CursorStyleSizeNS

global $CursorStyleSizeNWSE, $CursorStyleSizeWE, $CursorStyleUpArrow, $CursorStyleWaitCursorStyle, $CursorStyleNo

global $CursorStyleAppStarting, $CursorStyleHelp, $CursorStyleSizeAll, $CursorStyleHand

$CursorStyleDefault     = 0

$CursorStyleArrow       = 1

$CursorStyleCross       = 2

$CursorStyleIBeam       = 3

$CursorStyleSizeNESW    = 6

$CursorStyleSizeNS      = 7

$CursorStyleSizeNWSE    = 8

$CursorStyleSizeWE      = 9

$CursorStyleUpArrow     = 10

$CursorStyleWaitCursorStyle  = 11

$CursorStyleNo          = 12

$CursorStyleAppStarting = 13

$CursorStyleHelp        = 14

$CursorStyleSizeAll     = 15

$CursorStyleHand        = 16



;-- DialogResult --

global $DialogResultNone, $DialogResultOK, $DialogResultCancel, $DialogResultAbort

global $DialogResultRetry, $DialogResultIgnore, $DialogResultYes, $DialogResultNo

$DialogResultNone   = 0   ; Nothing is returned from the dialog box. This means that the modal dialog continues running.

$DialogResultOK     = 1   ; The dialog box return value is OK (usually sent from a button labeled OK).

$DialogResultCancel = 2   ; The dialog box return value is Cancel (usually sent from a button labeled Cancel).

$DialogResultAbort  = 3   ; The dialog box return value is Abort (usually sent from a button labeled Abort).

$DialogResultRetry  = 4   ; The dialog box return value is Retry (usually sent from a button labeled Retry).

$DialogResultIgnore = 5   ; The dialog box return value is Ignore (usually sent from a button labeled Ignore).

$DialogResultYes    = 6   ; The dialog box return value is Yes (usually sent from a button labeled Yes).

$DialogResultNo     = 7   ; The dialog box return value is No (usually sent from a button labeled No).



;-- FlatStyle --

global $FlatStyleFlat, $FlatStylePopupToolButton, $FlatStyleFlatStandard

$FlatStyleFlat            = 0   ; The control appears flat.

$FlatStylePopupToolButton = 1   ; The control appears flat until the mouse pointer moves over it, at which point it appears three-dimensional.

$FlatStyleFlatStandard    = 2   ; The control appears normal.



;-- FontStyle --

global $FontStyleBold, $FontStyleItalic, $FontStyleRegular, $FontStyleStrikeOut, $FontStyleUnderline

$FontStyleBold      = 1   ; Bold text

$FontStyleItalic    = 2   ; Italic text

$FontStyleRegular   = 0   ; Normal text

$FontStyleStrikeOut = 8   ; Text with a line through the middle

$FontStyleUnderline = 4   ; Undelined text



;-- formborderstyle --

global $FormBorderStyleNone, $FormBorderStyleFixedSingle, $FormBorderStyleFixed3D

global $FormBorderStyleFixedDialog, $FormBorderStyleSizable, $FormBorderStyleFixedToolWindow

global $FormBorderStyleSizableToolWindow

$FormBorderStyleNone              = 0   ; No border.

$FormBorderStyleFixedSingle       = 1   ; A fixed, single-line border.

$FormBorderStyleFixed3D           = 2   ; A fixed, three-dimensional border.

$FormBorderStyleFixedDialog       = 3   ; A thick, fixed dialog-style border.

$FormBorderStyleSizable           = 4   ; A resizable border

$FormBorderStyleFixedToolWindow   = 5   ; A tool window border that is not resizable.

$FormBorderStyleSizableToolWindow = 6   ; A resizable tool window border.



;-- FormStartPosition --

global $FormStartPositionManual, $FormStartPositionCenterScreen

global $FormStartPositionWindowsDefaultLocation, $FormStartPositionWindowsDefaultBounds

global $FormStartPositionCenterParent

$FormStartPositionManual                 = 0   ; The position of the form is determined by the Location property.

$FormStartPositionCenterScreen           = 1   ; The form is centered on the current display, and has the dimensions specified in the form's size.

$FormStartPositionWindowsDefaultLocation = 2   ; The form is positioned at the Windows default location and has the dimensions specified in the form's size.

$FormStartPositionWindowsDefaultBounds   = 3   ; The form is positioned at the Windows default location and has the bounds determined by Windows default.

$FormStartPositionCenterParent           = 4   ; The form is centered within the bounds of its parent form.



;-- FormWindowState --

global $FormWindowStateNormal, $FormWindowStateMinimized, $FormWindowStateMaximized

$FormWindowStateNormal    = 0

$FormWindowStateMinimized = 1

$FormWindowStateMaximized = 2



;-- HorizontalAlignment --

global $HorizontalAlignmentLeft, $HorizontalAlignmentRight, $HorizontalAlignmentCenter

$HorizontalAlignmentLeft   = 0   ; The object or text is aligned on the left of the control

$HorizontalAlignmentRight  = 1   ; The object or text is aligned on the right of the control

$HorizontalAlignmentCenter = 2   ; The object or text is aligned in the center of the control



;-- MessageBoxButtons --

global $MessageBoxButtonsOK, $MessageBoxButtonsOKCancel, $MessageBoxButtonsAbortRetryIgnore

global $MessageBoxButtonsYesNoCancel, $MessageBoxButtonsYesNo, $MessageBoxButtonsRetryCancel

$MessageBoxButtonsOK               = 0   ; Displays OK button.

$MessageBoxButtonsOKCancel         = 1   ; Displays OK and Cancel buttons.

$MessageBoxButtonsAbortRetryIgnore = 2   ; Displays Abort, Retry, and Ignore buttons.

$MessageBoxButtonsYesNoCancel      = 3   ; Displays Yes, No, and Cancel buttons.

$MessageBoxButtonsYesNo            = 4   ; Displays Yes and No buttons.

$MessageBoxButtonsRetryCancel      = 5   ; Displays Retry and Cancel buttons.



;-- MessageBoxDefaultButton

global $MessageBoxDefaultButtonButton1, $MessageBoxDefaultButtonButton2, $MessageBoxDefaultButtonButton3

$MessageBoxDefaultButtonButton1 = 0     ; First button is default.

$MessageBoxDefaultButtonButton2 = 256   ; Second button is default.

$MessageBoxDefaultButtonButton3 = 512   ; Third button is default.



;-- MessageBoxIcon

global $MessageBoxIconError, $MessageBoxIconQuestion

global $MessageBoxIconExclamation, $MessageBoxIconInformation

$MessageBoxIconError       = 16   ; The message box contains a symbol consisting of white X in a circle with a red background.

$MessageBoxIconQuestion    = 32   ; The message box contains a symbol consisting of a question mark in a circle.

$MessageBoxIconExclamation = 48   ; The message box contains a symbol consisting of an exclamation point in a triangle with a yellow background.

$MessageBoxIconInformation = 64   ; The message box contains a symbol consisting of a lowercase letter i in a circle.



;-- MessageBoxOptions

global $MessageBoxOptionsDefaultDesktopOnly, $MessageBoxOptionsRightAlign, $MessageBoxOptionsRtlReading

global $MessageBoxOptionsServiceNotification

$MessageBoxOptionsDefaultDesktopOnly  =  131072   ;The message box is displayed on the active desktop. This constant is the same as ServiceNotification except that the system displays the message box only on the default desktop of the interactive window station.

$MessageBoxOptionsRightAlign          =  524288   ;The message box text is right-aligned.

$MessageBoxOptionsRtlReading          = 1048576   ;Specifies that the message box text is displayed with right to left reading order.

$MessageBoxOptionsServiceNotification = 2097152   ;The message box is displayed on the active desktop. The caller is a service notifying the user of an event. The function displays a message box on the current active desktop, even if there is no user logged on to the computer.



;-- Orientation --

global $OrientationHorizontal, $OrientationVertical

$OrientationHorizontal = 0   ; The control is oriented horizontally.

$OrientationVertical   = 1   ; The control is oriented vertically.



;-- ProgressBarStyle --

global $ProgressBarStyleNormal, $ProgressBarStyleSmooth

$ProgressBarStyleNormal = 0   ; The progress bar displays a segmented bar.

$ProgressBarStyleSmooth = 1   ; The progress bar displays a smooth scrolling bar.



;-- ScrollBars --

global $ScrollBarsNone, $ScrollBarsHorizontal, $ScrollBarsVertical, $ScrollBarsBoth

$ScrollBarsNone       = 0   ; No scroll bars are shown.

$ScrollBarsHorizontal = 1   ; Only horizontal scroll bars are shown.

$ScrollBarsVertical   = 2   ; Only vertical scroll bars are shown.

$ScrollBarsBoth       = 3   ; Both horizontal and vertical scroll bars are shown.



;-- SizeGripStyle --

global $SizeGripStyleAuto, $SizeGripStyleShow, $SizeGripStyleHide

$SizeGripStyleAuto = 0   ; The sizing grip is automatically displayed when needed. This setting is still under development.

$SizeGripStyleShow = 1   ; The sizing grip is always shown on the form.

$SizeGripStyleHide = 2   ; The sizing grip is hidden.



;-- TabAlignment --

global $TabAlignmentTop, $TabAlignmentBottom

$TabAlignmentTop    = 0   ; The tabs are located across the top of the control

$TabAlignmentBottom = 1   ; The tabs are located across the bottom of the control



;-- TabAppearance --

global $TabAppearanceNormal, $TabAppearanceButtons, $TabAppearanceFlatButtons

$TabAppearanceNormal      = 0   ; The tabs have the standard appearance of tabs

$TabAppearanceButtons     = 1   ; The tabs have the appearance of three-dimensional buttons

$TabAppearanceFlatButtons = 2   ; The tabs have the appearance of flat buttons



;-- TabSizeMode --

global $TabSizeModeNormal, $TabSizeModeFillToRight, $TabSizeModeFixed

$TabSizeModeNormal      = 0   ; The width of each tab is sized to accommodate what is displayed on the tab, and the size of tabs in a row are not adjusted to fill the entire width of the container control.

$TabSizeModeFillToRight = 1   ; The width of each tab is sized so that each row of tabs fills the entire width of the container control. This is only applicable to tab controls with more than one row.

$TabSizeModeFixed       = 2   ; All tabs in a control are the same width.



;-- TickStyle --

global $TickStyleNone, $TickStyleTopLeft, $TickStyleBottomRight, $TickStyleBoth

$TickStyleNone        = 0   ; No tick marks appear in the control.

$TickStyleTopLeft     = 1   ; Tick marks are located on the top of a horizontal control or on the left of a vertical control.

$TickStyleBottomRight = 2   ; Tick marks are located on the bottom of a horizontal control or on the right side of a vertical control.

$TickStyleBoth        = 3   ; Tick marks are located on both sides of the control.



;-- ToolButtonStyle --

global $ToolButtonStylePushButton, $ToolButtonStyleToggleButton

$ToolButtonStylePushButton     = 0   ; A standard, three-dimensional button.

$ToolButtonStyleToggleButton   = 1   ; A toggle button that appears sunken when clicked and retains the sunken appearance until clicked again.



;-- view --

global $ViewLargeIcon, $ViewDetails, $ViewSmallIcon, $ViewList

$ViewLargeIcon = 0   ; Each item appears as a full-sized icon with a label below it.

$ViewDetails   = 1   ; Each item appears on a separate line with further information about each item arranged in columns. The left most column contains a small icon and label, and subsequent columns contain sub items as specified by the application. A column displays a header which can display a caption for the column. The user can resize each column at runtime.

$ViewSmallIcon = 2   ; Each item appears as a small icon with a label to its right.

$ViewList      = 3   ; Each item appears as a small icon with a label to its right. Items are arranged in columns with no column headers.



;-- Keycode --

global $KeycodeBACKSPACE, $KeycodeTAB, $KeycodeCLEAR, $KeycodeENTER

global $KeycodeSHIFT, $KeycodeCONTROL, $KeycodeALT, $KeycodePAUSE

global $KeycodeCAPSLOCK, $KeycodeESCAPE, $KeycodeSPACEBAR

$KeycodeBACKSPACE = 8

$KeycodeTAB       = 9

$KeycodeCLEAR     = 12

$KeycodeENTER     = 13

$KeycodeSHIFT     = 16

$KeycodeCONTROL   = 17

$KeycodeALT       = 18

$KeycodePAUSE     = 19

$KeycodeCAPSLOCK  = 20

$KeycodeESCAPE    = 27

$KeycodeSPACEBAR  = 32



;-- MouseButton --

global $MouseButtonNone, $MouseButtonLeft, $MouseButtonRight, $MouseButtonMiddle

$MouseButtonNone   = 0   ; No mouse button was pressed.

$MouseButtonLeft   = 1   ; The left mouse button was pressed.

$MouseButtonRight  = 2   ; The right mouse button was pressed.

$MouseButtonMiddle = 4   ; The middle mouse button was pressed.



;-- RootFolder --

global $RootFolderApplicationData, $RootFolderCommonApplicationData

global $RootFolderCommonProgramFiles, $RootFolderCookies, $RootFolderDesktop

global $RootFolderDesktopDirectory, $RootFolderFavorites, $RootFolderHistory

global $RootFolderInternetCache, $RootFolderLocalApplicationData, $RootFolderMyComputer, $RootFolderMyMusic

global $RootFolderMyPictures, $RootFolderPersonal, $RootFolderProgramFiles

global $RootFolderPrograms, $RootFolderRecent, $RootFolderSendTo, $RootFolderStartMenu

global $RootFolderStartup, $RootFolderSystem, $RootFolderTemplates

$RootFolderApplicationData       = 26   ; The directory that serves as a common repository for application-specific data for the current roaming user. A roaming user works on more than one computer on a network. A roaming user's profile is kept on a server on the network and is loaded onto a system when the user logs on.

$RootFolderCommonApplicationData = 35   ; The directory that serves as a common repository for application-specific data that is used by all users.

$RootFolderCommonProgramFiles    = "?"  ; The directory for components that are shared across applications.

$RootFolderCookies               = 33   ; The directory that serves as a common repository for Internet cookies.

$RootFolderDesktop               = 0    ; The logical Desktop rather than the physical file system location.

$RootFolderDesktopDirectory      = 16   ; The directory used to physically store file objects on the desktop. Do not confuse this directory with the desktop folder itself, which is a virtual folder.

$RootFolderFavorites             = 6    ; The directory that serves as a common repository for the user's favorite items.

$RootFolderHistory               = 34   ; The directory that serves as a common repository for Internet history items.

$RootFolderInternetCache         = 32   ; The directory that serves as a common repository for temporary Internet files.

$RootFolderLocalApplicationData  = 26   ; The directory that serves as a common repository for application-specific data that is used by the current, non-roaming user.

$RootFolderMyComputer            = 17   ; The "My Computer" folder.

$RootFolderMyMusic               = 13   ; The "My Music" folder.

$RootFolderMyPictures            = 39   ; The "My Pictures" folder.

$RootFolderPersonal              = "?"  ; The directory that serves as a common repository for documents.

$RootFolderProgramFiles          = 38   ; The program files directory.

$RootFolderPrograms              = 2    ; The directory that contains the user's program groups.

$RootFolderRecent                = 8    ; The directory that contains the user's most recently used documents.

$RootFolderSendTo                = 9    ; The directory that contains the Send To menu items.

$RootFolderStartMenu             = 11   ; The directory that contains the Start menu items.

$RootFolderStartup               = 7    ; The directory that corresponds to the user's Startup program group. The system starts these programs whenever a user logs on or starts Windows NT or later, or starts Windows 98.

$RootFolderSystem                = 37   ; The System directory.

$RootFolderTemplates             = 21   ; The directory that serves as a common repository for document templates.



;-- MessageBoxStyle

global $MessageBoxStyleApplicationModal, $MessageBoxStyleSystemModal

$MessageBoxStyleApplicationModal = 0      ; Application is modal. The user must respond to the message box before continuing work in the current application.

$MessageBoxStyleSystemModal      = 4096   ; System is modal. All applications are suspended until the user responds to the message box.



exit 0

endfunction

116901INIUPDATE79KdyerINIUPDATE() - Update INI Files from an array0Code:

;Function       INIUPDATE()
;
;Author		Kent Dyer (leptonator@hotmail.com)
;
;Action		Updates an INI type of file using an array.
;
;Syntax		INIUPDATE($file,$section,$key,$string,optional $operator)
;
;Version	1.0
;
;Date           26 March 2004
;
;Date Revised   26 March 2004
;
;Parameters 	File
;		File you are checking/modifying
;
;               Section
;               Section header you want to target in the file
;
;               Key
;               Which Key under the Header you are checking
;
;               String
;               Resulting string you are checking/setting
;
;               Operator (optional)
;               Default is <> or the Not operator, You could
;               use =, >=, <=, etc.               
;
;Remarks        The inspiration for this was to see how to compact down
;               INI type of structures.
;               The idea is to read in a structure of variables and conditions
;               This process then splits them out and checks and uses them.
;               This could be used for READVALUE/WRITEVALUE too.
;
;Returns	Nothing
; 
;Dependencies 	None
;
;KiXtart Ver	4.02
; 
;Example(s)
; $rc=SETOPTION('Explicit','On')
; $rc=SETOPTION('NoVarsInStrings','On')
; DIM $profiledir,$prf,$prffile,$g,$header
; $profiledir='%temp%'
; $prf='Outlook.prf'
; $prffile=$profiledir+'\'+$prf
;
; FOR EACH $g IN Split('ProfileName @userid,DefaultProfile Yes,OverwriteProfile Yes,BackupProfile No',',')
;    $header='General'
;    $g=SPLIT($g)
;    INIUPDATE($prffile,$header,$g[1],$g[0])
; NEXT
; Code
 FUNCTION INIUPDATE($file,$section,$key,$string,optional $operator)
 DIM $rc
    IF NOT $operator
       $operator='<>'
    ENDIF
    REDIM $operator
       IF $string $operator ReadProfileString($file,$section,$key)
          $rc=WriteProfileString($file,$section,$key,$string)
       ENDIF
 ENDFUNCTION


  84010InPath588SchuliebugInPath() - Check if file is in path0Function to check if file/exe is in path. I use it to check if postie is available so i can add mail functionality (button) to my scripts.


;FUNCTION InPath()
;
;ACTION Checks if the given executable is in the path
;
;AUTHOR SchulieBug jan.schulenburg@tui.nl
;
;VERSION 1.0
;
;KIXTART Minimum required Kixtart version 4.02
;
;SYNTAX InPath($File,$Concat)
;
;PARAMETERS $File
; Name of the file to search for in the path
; $ConCat (anything goes)
; Value indicating to return found path + $file if found
;
;RETURNS The part of %Path% the file is in or path+file. @Error=0 if found, 1 if not&n bsp;found.
;
;DEPENDENCIES KiXtart 4.02 +
;
;EXAMPLE #1
; If InPath('postie.exe')<>''
; ; postie actions here..
; Else
; ; Action if not in path..
; EndIf
;
; #2
; $=InPath('postie.exe')
; If Not @Error
; ; postie actions here..
; Else
; ? @SERROR
; EndIf
;
;KIXTART BBS http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000390
;
Function InPath(Optional $Exe, Optional $Concat)
Dim $Path,$i,$Error
$InPath=''
$Error=3 ; Path not found

If ''+$Exe<>''
$Path=Split('%Path%',';')
For $i=0 To UBound($Path)
If $Path[$i]<>'' And Exist($Path[$i]+'\'+$Exe)=1
If Not $ConCat
$InPath=$Path[$i]
Else
$InPath=$Path[$i]+'\'+$Exe
EndIf

$Error=0
$i=UBound($Path)
EndIf
Next
Else
$Error=1
EndIf

Exit $Error
EndFunction


 
 [ 22. April 2003, 08:37: Message edited by: Schuliebug ]82610InputSelect75d.adamsInputSelect() - InputBox like interface with a dropdown box to choose from0

code:

;InputList()
 
;Action:
;Provide a InputBox like interface using a combobox for users to select from
 
;Syntax:
;SelectList(List)
 
;Parameters:
;List - An array of all items to be displayed in the dropdown for the user
;to choose from
 
;Returns:
;A character string containing the value of the combobox
 
;Remarks:
;Concept function, no error checking included on parameters passed
 
;Dependencies:
;KiXtart 4.0 (final), Excel 97 or above, Join() UDF
 
;Example(s):
 
;Dim $Selected
;Dim $arFruit[4]
 
;$arFruit[0] = "apples"
;$arFruit[1] = "oranges"
;$arFruit[2] = "bananas"
;$arFruit[3] = "peaches"
;$arFruit[4] = "pears"
 
;$Selected = InputList($arFruit, "Select a fruit")
 
;? $Selected
;Sleep 5
 
;Source:

Function InputList($arList, 
  $tsPrompt,
  Optional $tsTitle,
  Optional $tsDefault,
  Optional $tnXPos,
  Optional $tnYPos)
  
  Dim $xls, $wb, $Selection
  
  $xls = CreateObject("excel.application")
  
  If $xls
    $wb = $xls.WorkBooks.Open(@SCRIPTDIR + "\InputSelect.xls")
    
    If $wb
      $Selection = $wb.InputSelect(Join($arList, ";"), $tsPrompt, $tsTitle, $tsDefault, $tnXPos, $tnYPos)
      $ = $wb.Close(0)
      $wb = 0
    EndIf
    
    $xls.Quit
    $xls = 0
    
    $InputList = $Selection
  EndIf
EndFunction

Join() UDF

You will have to create your own .xls file to be able to use this function.

Step 1 - Start Excel 97 or above.

Step 2 - Start the VBA Editor

Step 3 - In the Project Window, you should see a reference to ThisWorkbook.  Double click this reference to display its code window.

Step 4 - Copy the code below and paste into the ThisWorkbook code window

code:

Public Function InputSelect(tsList As String, tsPrompt As String, _
    Optional tsTitle As String, Optional tsDefault As String, _
    Optional xPos As Long, Optional yPos As Long) As String
    
    Dim frmSelect As frmInputSelect
    Dim lnCnt As Integer
    
    Set frmSelect = New frmInputSelect
    
    PopulateList tsList, frmSelect.ComboBox1
    frmSelect.Label1.Caption = tsPrompt
    frmSelect.Caption = tsTitle
    frmSelect.ComboBox1.Value = tsDefault
    
    If xPos > 0 Or yPos > 0 Then
        With frmSelect
            .StartUpPosition = 0
            .Left = xPos
            .Top = yPos
        End With
    End If
    
    frmSelect.Show
    
    If frmSelect.OK Then
        InputSelect = frmSelect.ComboBox1.Value
    Else
        InputSelect = ""
    End If
    
    Set frmSelect = Nothing
End Function

Private Sub PopulateList(tsList As String, toControl As ComboBox)
    Dim lsList As String
    
    lsList = Trim(tsList)
    
    If Right(lsList, 1) <> ";" Then
        lsList = lsList + ";"
    End If
    
    Do While InStr(lsList, ";")
        toControl.AddItem (Left(lsList, InStr(lsList, ";") - 1))
        
        lsList = Right(lsList, Len(lsList) - (InStr(lsList, ";")))
    Loop
End Sub

Step 5 - Copy the following code into a text file with the extension .frm

code:

VERSION 5.00
Begin {C62A69F0-16DC-11CE-9E98-00AA00574A4F} frmInputSelect 
   Caption         =   "UserForm1"
   ClientHeight    =   1320
   ClientLeft      =   45
   ClientTop       =   390
   ClientWidth     =   4710
   OleObjectBlob   =   "InputSelect.frx":0000
   StartUpPosition =   1  'CenterOwner
End
Attribute VB_Name = "frmInputSelect"
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Private mblnOK As Boolean

Public Property Get OK() As Boolean
    OK = mblnOK
    
End Property

Private Sub cmdCancel_Click()
    mblnOK = False
    Me.Hide
End Sub

Private Sub cmdOK_Click()
    mblnOK = True
    Me.Hide
End Sub

Step 6 - Select Import File... from the VBA Editors file menu

Step 7 - Navigate to the .frm file saved above, select and open it.  You should now be able to display the form in the VBA Editor.

Step 8 - Save the file as InputSelect.xls where you will run the calling script from. (i.e.:@SCRIPTDIR)

That should do it.  Sorry about all this work, but I could not post my .xls file.  You should now be able to pass an array to the function and have it display the array elements in a dropdown combobox.  It will then return the value displayed in the combobox when the user clicks OK.  An empty string ("") will be returned on Cancel.

I hope someone can use it.   
 
 [ 04. October 2003, 09:48: Message edited by: NTDOC ]83045InsertIntoArray588SchuliebugInsertIntoArray() UDF0Please have a look at the following UDF  I think they maybe usefull when messing around with arrays. The DelFromArray is moved this post.


ÿCode:

;Author        Schuliebug
;
;Function        InsertIntoArray
;
;Parameters    1: Required, array.
;        2: Required, string to insert into array.
;        3: Optional, number indicating pointer to insert string. If none or number
;            is greater then the number of elements in array, string will be added to
;            the end of the array.
;
;Remarks        none.
;
;Returns        array, @error=0 if succesfull, >0 if failed
;
;Dependencies    None
;
;Example(s)    $Array = 'aaa','bbb','ddd'
;        $Array = InsertIntoArray($Array,'eee')
;           returns an array containing 'aaa','bbb','ddd','eee'
;
;        $Array = InsertIntoArray($Array,'ccc',2)
;           returns an array containing 'aaa','bbb','ccc','ddd','fff'
;
;        $Array = InsertIntoArray($Array,'ccc',-100)
;           returns an array containing 'aaa','bbb','ccc','ddd','fff'
;
Function InsertIntoArray($Array,$Element,Optional $Pointer)
    Dim $Index,$Elm,$UArray

    ; Check parameters..
    If Not VarType($Array)   Exit(1)                   Else $InsertIntoArray=$Array $UArray=UBound($Array)+1   EndIf
    If Not VarType($Element) Exit(2)                   Else If $Element=''          Exit(3)                    EndIf EndIf
    If Not VarType($Pointer) $Pointer=$UArray
    Else Select
        Case Val($Pointer)<0
            Exit(4)
        Case 0+$Pointer > 0+$UArray
            $Pointer=$UArray
         EndSelect
    EndIf

    Redim $InsertIntoArray[$UArray]
    $Index=0

    ; Loop given array..
    For Each $Elm In $Array
        If $Index=$Pointer
            ; Insert new element..
            $InsertIntoArray[$Index]=$Element
            $Index=$Index+1
        EndIf

        ; Add existing element..
        $InsertIntoArray[$Index]=$Elm
        $Index=$Index+1
    Next

    ; Add to end of array..
    If $Index=$Pointer
        $InsertIntoArray[$Index]=$Element
    EndIf
EndFunction
84403InsertLine3755GavenInsertLine() - insert, replace, or delete any line in a text file0This function is a little longer then it could be because I didn't use any goto commands - I hope you anti-goto people are happy.

code:

;  Function:     InsertLine()
;
;  Author:       Gaven Henderson, Gaven@GavDogg.net
;  
;  Action:       Insertline can be used to insert, replace, or delete any existing line in a text file.
; 
;  Remarks:      InsertLine does not automatically append a <Carriage Return>, so if you want to write a
;                <Carriage Return>, you should add it to the string (as in : $LineToWrite + @CRLF).
;
;  Syntax:       insertline(["File"], [Position], optional ["LineToWrite"], optional [Mode])
;
;  Version:      1.0
;
;  Post Date:    June 26, 2003
;
;  Revise Date:  June 26, 2003
;
;  Parameters:   File
;                   File to act on.
;
;                Position
;                   Line number to insert on, 0 = top.
;
;                LineToWrite (optional)
;                   String to write in file specified.  If LineToWrite is blank, Mode 1 is assumed.
;
;                Mode (optional)
;                   0 - Default, insert line before existing line
;                   1 - Replace existing line
;  
;  Returns:      -3 - Invalid line number specified
;                -2 - No file handles available
;                -1 - Invalid file name specified
;                0  - Success
;                >0 - System error
;
;  KiXtart Ver:  Designed on 4.20 but should work on just about any version.
;
;  Example:      $rc = insertline("file.txt",0)                   ;  This would delete the first line in file.txt
;                $rc = insertline("file.txt",3,"was 4"+@Crlf,1)   ;  This would replace the fourth line with "was 4"
;                $rc = insertline("file.txt",8,"Information: ")   ;  This would add "Information: " before (not above) line 8
;
Function insertline($a, $b, optional $c, optional $d)
	Dim $e,$f,$h,$x,$y
	If $b<0 Exit -3 EndIf
	If $c="" $d=1 EndIf
	$f="%temp%\~kixil00.tmp" ; temporary file to use
	Del $f
	If $d<>1 $d=0 EndIf
	$e=FreeFileHandle
	$insertline=-2
	If $e=0 Exit -2 EndIf
	$insertline=Open($e,$a)
	If $insertline<>0 Exit @Error EndIf
	$h=FreeFileHandle
	If $h=0
		$insertline=-2
		$x=Close($e)
		Exit -2 
	EndIf
	$insertline=Open($h,$f,5)
	If $insertline<>0
		$x=Close($e)
		Exit @Error
	EndIf
	If $b<>0
		For $x=0 To $b-1
			$y=ReadLine($e)
			If @Error<>0
				$x=Close($e)
				$x=Close($h)
				Del $f
				$insertline=-3
				Exit -3
			Else
				$insertline=WriteLine($h,$y+@Crlf)
			EndIf
		Next
	EndIf
	$insertline=WriteLine($h,$c)
	$y=ReadLine($e)
	If @Error<>0
		$x=Close($e)
		$x=Close($h)
		Del $f
		$insertline=-3
		Exit -3
	EndIf
	If $d=0
		$x=WriteLine($h,$y+@Crlf)
	EndIf
	$y=ReadLine($e)
	While @Error=0
		$insertline=Writeline($h,$y+@Crlf)
		$y=ReadLine($e)
	Loop
	$x=Close($e)
	$x=Close($h)
	Copy $f $a
	Del $f
	$insertline=0
	Exit 0
EndFunction

83936Install2980Glenn BarnasInstall() - remove R/O, delete, then copy files0This process takes two directory paths as arguments. It locates the files in the first directory, and for each file found:
 

Removes the R-O attribute from a same-name file in the target directory

Removes a same-name file if it exists in the target directory

Copies the file from the source to target directory
Our customization process creates a directory structure and copies a collection of admin tools (kix, xnet, and several "ps" tools) to that directory. That directory is then added to the system PATH.
I found that if the admin tools were originaly installed from CD, the R-O attributes would prevent the later copy commands from succeeding when we re-ran the customization tool to upgrade the components. Since our environment is mixed NT/2K, the Attrib parameters to run recursively didn't work on the NT systems.. This handles everything internal to Kix.

Glenn


;;
;;======================================================================
;;
;;FUNCTIONÿ ÿ ÿ ÿInstall()
;;
;;ACTIONÿ ÿ ÿ ÿ ÿInstallsÿallÿfilesÿfromÿSourcePathÿtoÿDestinationPath
;;
;;AUTHORÿ ÿ ÿ ÿ ÿGlennÿBarnasÿ/ÿFRIT-EROC
;;
;;SYNTAXÿ ÿ ÿ ÿ ÿInstall("Sourcepath",ÿ"DestinationPath")
;;
;;PARAMETERSÿ ÿ ÿSourcePathÿ ÿ ÿ -ÿDirectoryÿcontainingÿfilesÿtoÿcopy
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿDestinationPathÿ-ÿDirectoryÿwhereÿfilesÿwillÿbeÿinstalled
;;
;;REMARKSÿ ÿ ÿ ÿ InstallÿlocatesÿtheÿfilesÿinÿtheÿSourcePath.ÿForÿeachÿfile
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿfoundÿitÿfirstÿremovesÿanyÿread-onlyÿattributeÿandÿdeletesÿ
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿanyÿfileÿwithÿtheÿsameÿnameÿfoundÿinÿtheÿdestinationÿdirectory.
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿItÿthenÿcopiesÿtheÿfileÿtoÿtheÿdestinationÿfolder.ÿThisÿinsures
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿthatÿtheÿlatestÿversionÿofÿaÿfileÿisÿinstalled.
;;
;;RETURNSÿ ÿ ÿ ÿ nothingÿ-ÿcreatesÿdirectoryÿpath
;;
;;DEPENDENCIESÿ ÿPathSplit()
;;
;;EXAMPLESÿ ÿ ÿ ÿInstal(".\system32",ÿ"\\server\c$\winnt\system32")
;
FunctionÿInstall($SrcDir,ÿ$DstDir)

ÿ Dimÿ$FileName

ÿ ;ÿAddÿtrailingÿslashesÿifÿnotÿprovided
ÿ IfÿRight($SrcDir,1)ÿ<>ÿ"\"
ÿ ÿ $SrcDirÿ=ÿ$SrcDirÿ+ÿ"\"
ÿ EndIf
ÿ IfÿRight($DstDir,1)ÿ<>ÿ"\"
ÿ ÿ $DstDirÿ=ÿ$DstDirÿ+ÿ"\"
ÿ EndIf

ÿ $FileNameÿ=ÿDir($SrcDirÿ+ÿ"*.*")
ÿ Whileÿ$FileNameÿ<>ÿ""ÿAndÿ@ERRORÿ=ÿ0

ÿ IfÿLeft($FileName,1)ÿ<>ÿ"."ÿ ;ÿskipÿ"."ÿandÿ".."

ÿ ÿ ÿ ;ÿIfÿtheÿtargetÿfileÿexists,ÿremoveÿallÿattributesÿandÿdeleteÿit
ÿ ÿ ÿ IfÿExist($DstDirÿ+ÿ$FileName)
ÿ ÿ ÿ ÿ $RCÿ=ÿSetFileAttr($DstDirÿ+ÿ$FileName,ÿ0)
ÿ ÿ ÿ ÿ Delÿ$DstDirÿ+ÿ$FileName
ÿ ÿ ÿ EndIf

ÿ ÿ ÿ ;ÿCopyÿtheÿnewÿfileÿtoÿtheÿdestination
ÿ ÿ ÿ Copyÿ$SrcDirÿ+ÿ$FileNameÿ$DstDirÿ

ÿ ÿ EndIf

ÿ ÿ $FileNameÿ=ÿDir()
ÿ Loop

EndFunction

84048InstallFont119LonkeroInstallFont() - Install Font(s)0


;Function:

;	InstallFont()

;

;Author:

;	Lonkero (Jooel_Nieminen@hotmail.com)

;

;Version:

;	1.2

;

;Version History:

;	1.2 - 26.4.2003 - answers all questions with yes (thus removing any interactivity)

;	1.1 - 25.4.2003 - added error checking

;	1.0 - 24.4.2003 - initial release

;

;Action:

;	Installs font(s)

;

;Syntax:

;	InstallFont(SOURCE)

;

;Parameters:

;	SOURCE - Full path to font-file(s) to install

;

;Remarks:

;	Flashes screen once. but don't be scared, it does not harm anyone   

;

;Returns:

;	1 - shell32.dll too old

;	2 - no IE4 or higher present

;

;Dependencies:

;	shell32.dll version 4.71 or later

;	Internet Explorer 4.0 or better

;

;Example:

;	if InstallFont("\\Primary\corpfonts\*.*")

;	 "Dependency Error Occured: @error"

;	else

;	 "Fonts installed."

;	endif

;

;Source:

function InstallFont($source)

 dim $Window,$Shell

 $Shell = CreateObject("Shell.Application")

 $Window = createobject("internetexplorer.application")

 if 9<>vartype($shell)

  $InstallFont=1

  exit 1

 endif

 if 9<>vartype($window)

  $InstallFont=2

  exit 2

 endif

 $Shell.NameSpace(20).CopyHere($source,20)

 $Window.navigate2(20)

 $Window.visible = not 0

 $Window.quit

endfunction


 
 [ 29. April 2003, 14:01: Message edited by: Lonkero ]147435IntegrityCheck8257RedfoxdnIntegrityCheck() - Returns the SHA1 sum of a file/compares 2 SHA1 sums0I wrote this function so that I can verify scripts located on each workstation against ones found on a read-only share on a server. It can also be used to verify the version of a file for sure. I initially was going to use MD5 sums but lately that has been proven to be non-reliable as much as SHA1 sums.

I don't know of any easy way to code an actual SHA1 sum calculator, but you can get an open source version from: http://ftp.gnupg.org/gcrypt/binary/

Maybe the next version of Kix could include that as an new built-in function...
Honestly, RSA/Certificate support would be better though but that's a WHOLE different topic.

Suggestions/improvements are welcome!

Code:


; FUNCTION - IntegrityCheck
;
; ACTION - Retrieve the sha1sum of a file AND/OR compare it to another file
;
; VERSION 1.00
;
; DATE CREATED - 9/8/2005
;
; KIXTART - 4.50 (older versions may work ok...)
;
; AUTHOR - David Nemeth
;
; PARAMETERS 
;    $Filename  - Path+File to check the integrity of
;    $Filename2 - Path+File of a 2nd file to compare the checksum to the first parameter.
;
; DEPENDENCIES 
;  Pipe()       - Glenn Barnas / FRIT-EROC; Conrad Wheeler (RADIMUS) AUTHOR AJH
;  sha1sum.exe  - Found at http://ftp.gnupg.org/gcrypt/binary/
;     
; RETURN CODES
;     40 chars - [Default] Returns the 40 character SHA1 sum of $Filename
;     0        - File Error or a problem with the path
;     1        - SHA1SUM of $Filename equals the SHA1 sum of $Filename2
;     2        - SHA1SUM of $Filename DOES NOT equal the SHA1 sum of $Filename2
;
; REMARKS - This code is hereby donated to public domain
;
; EXAMPLE 
;$rc = IntegrityCheck("C:\windows\kix32.exe")
;? $rc     ; Output: 047f78e70b72eb864f9deee26991c695a515b239 for kix32.exe v4.50
;$rc = IntegrityCheck("C:\windows\wkix32.zzz")
;? $rc     ; Output: 0
;$rc = IntegrityCheck("C:\windows\kix32.exe", "C:\windows\kix32.exe")
;? $rc     ; Output: 1
;$rc = IntegrityCheck("C:\windows\kix32.exe", "C:\windows\wkix32.exe")
;? $rc     ; Output: 2

Function IntegrityCheck($FileName, optional $FileName2)

   Dim $PipeArray1, $NewPipeArray

   ; Assume the integrity check will fail
   $IntegrityCheck = 0

   ; Call the sha1sum application 
   $PipeArray1 = Pipe("sha1sum "  + $Filename)   
   $NewPipeArray = Split($PipeArray1[0], " ")

   ; Only proceed if the array bound = 2, anything more indicates a problem
   If UBound($NewPipeArray) = 2

      ; Verify that the first element (checksum) only has 40 characters
      ;   And that the last element (#2) matches $FileName parameter
      If ((Len(Trim($NewPipeArray[0])) = 40) And (Trim($NewPipeArray[2]) = $FileName))
         
         ; Retrieve the Checksum
         $IntegrityCheck = Trim($NewPipeArray[0])
         
         ; Optional Comparison feature for $FileName2
         If (Len($Filename2) > 0)
            
            ; Recursively call IntegrityCheck with $Filename2
            If (IntegrityCheck($Filename2) = $IntegrityCheck)
               ; The two files ARE equal, set the return value to 1
               $IntegrityCheck = 1
            Else 
               ; The two are NOT equal, set the return value to 2
               $IntegrityCheck = 2
            EndIf
         EndIf
      EndIf
   EndIf

EndFunction  

84639IofSubStr119LonkeroIofSubStr() - Index of Substring in string from given start point0

;FUNCTION 

;	IofSubStr() 

; 

;AUTHOR 

;	Lonkero (Jooel_Nieminen@hotmail.com) 

; 

;ACTION 

;	Index of Substring in string from given start point 

; 

;VERSION 

;	1.0 

; 

;VERSION HISTORY 

;	1.0 

;		13. October 2003 

;		Initial draft per request 

; 

;SYNTAX 

;	 IofSubStr( STRING , FIND , START ) 

; 

;PARAMETERS 

; 

;	STRING	- 	the string to search in 

;	FIND	- 	the string to search for 

;	START	-	index where to start search 

; 

;RETURNS 

;	index where the searched string starts. 

;	0 index means not found. 

; 

;REMARKS  

;	with start value of 1 it works just like substr. 

;  

;DEPENDENCIES 

;	kixtart 4.20 

; 

;EXAMPLE  

;	"first occurance of 'ubba' in 'hubba bubba' after char 3 is at: " 

;	IofSsubStr("hubba bubba","ubba",3) 

;  

;SOURCE  

function IofSubStr($Str,$Find,$Start)

 dim $

 $=split(substr($Str,$Start),$Find)

 $IofSubStr=iif(0=ubound($),0,len($[0])+$Start)

endfunction

112606IpAutoConfigure119LonkeroIpAutoConfigure() - manipulate ipautoconfig0Code:

;Function:
;	IPautoconfig()
;
;Author:
;	Lonkero
;
;Version:
;	1.0 (27th of jan 2004)
;
;Version history:
;	1.0 (27th of jan 2004) - initial version
;
;Action:
;	set or view IPautoConfiguration state on a machine
;
;Syntax:
;	IPautoconfig(MODE, MACHINE)
;
;Parameters:
;	MODE
;		0 - disable autoconfig
;		1 - enable autoconfig
;		2 - view autoconfig state
;
;	MACHINE
;		optional
;		specifies the machine to work on (defaults local)
;
;Returns:
;	nothing on set (see the @error for success)
;	the current state (0/1) on view mode
;
;Dependencies:
;	none
;
;Remarks:
;	I can write in also the win98 part but thought not yet as nobody should need that. ;)
;
;	I still hate this board soft.
;	don't ever think of buying infopop soft!
;
;Example:
;	; policy says, no thanks for ipautoconfig, so lets check.
;	if IPautoconfig(2)
;	 ? "setting ip autoconfig to disabled"
;	 IPautoconfig(0)
;	endif
;	get $
;
;Source:
function IPautoconfig($m, optional $)
dim $c,$n,$b,$g
 if $ $="\\"+$+"\" endif
 $c=$+"HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces"
 $g=$+"HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkCards"
 $=0
 $b=enumkey($g,$)
 while @error=0
	$=$+1
	$n=$c+"\"+readvalue($g+"\"+$b,"ServiceName")
	if $m=2
	 $IPautoconfig=readvalue($n,"IPAutoconfigurationEnabled")
	else
	 $n=writevalue($n,"IPAutoconfigurationEnabled",$m,"REG_DWORD")
	 exit @error
	endif
	$b=enumkey($g,$)
 loop
endfunction

 121121IPDecimal22Richard H.IPDecimal() - IP Address to Decimal (network calc)0This is a utility UDF to convert network addresses in dotted quad form (127.0.0.1) to decimal and back again.

Once in decimal form the address can be manipulated very easily.  See the example section for some useful tricks.

Code:

;Function: 
;     IPDecimal()
; 
;Author: 
;     R. Howarth (rhowarth@sgb.co.uk)
; 
;Version: 
;     1.0
; 
;Version history: 
;     1.0 RMH 11 June 2004 Initially created
;
;Action: 
;     Takes an IP address and returns the decimal value, or takes a decimal value
;     and returns the IP address.
;     Used for network calculations.
; 
;Syntax: 
;     IPDecimal(Dotted_IP_Address | Decimal_Network_Address)
; 
;Parameters: 
;     Dotted_IP_Address        - IP address in standard form i.e. 127.0.0.1
;     Decimal_Network_Address  - Network address as decimal number
; 
;Returns: 
;     IP converted to decimal or decimal converted to IP
; 
;Dependencies: 
;     None
;
; 
;Remarks: 
; 
;Example: 
;      ; Get primary NIC details
;      $IP=EnumIPInfo(0,0)
;      $Mask=EnumIPInfo(0,1)
;      
;      ; Calculate info
;      $Network=IPDecimal($IP) & IPDecimal($Mask)
;      $HostAddresses=IPDecimal("255.255.255.255")-IPDecimal($Mask)-1
;      $Broadcast=$Network | (IPDecimal("255.255.255.255")-IPDecimal($Mask))
;      
;      ; Display it
;      "This computer is on network: "+IPDecimal($Network) ?
;      "Broadcast address for this network is: "+IPDecimal($Broadcast) ?
;      "This network has "+$HostAddresses+" possible host addresses." ?
;      "Do you want me to display them?" Get $k ?
;      If $k="y"
;      	For $i=1 To $HostAddresses
;      	   $i " : " IPDecimal($Network+$i) ?
;      		If Not($i mod 20) "Hit a key for next page: " Get $k ? EndIf
;      	Next
;      EndIf
;
;Source:

Function IPDecimal($v)
	If InStr($v,".")
		For Each $v In Split($v,".") $IPDecimal=$IPDecimal+Right("00"+DecToHex($v),2) Next
		$IPDecimal=Val("&"+$IPDecimal)
	Else
		; Convert to hex and zero fill to 32 bit.
		; This avoids problems caused by twos complement representation
		$v=Right("00000000"+DecToHex($v),8)
		While $v
			$IPDecimal=$IPDecimal+"."+Execute("Exit &"+Left($v,2))
			$v=SubStr($v,3)
		Loop
		$IPDecimal=SubStr($IPDecimal,2)
	EndIf
	Exit 0
EndFunction

  82356IPMask17SealeopardIPMask() - Masks an IP address with another IP address (binary AND)0

code:


;FUNCTION      IPMask
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Masks an IP address with another IP address
;
;SYNTAX        IPMASK(IPADDRESS1,IPADDRESS2)
;
;PARAMETERS    IPADDRESS1
;              Required string containing IP address 1 in binary format
;
;              IPADDRESS2
;              Required string containing IP address 2 in binary format
;
;REMARKS       none
;
;DEPENDENCIES  none
;
;RETURNS       masked IP address
;
;EXAMPLE       $retcode=ipmask('10000000110001011011010101100110','11111111111111111111111100000000')
;
;KIXTART BBS   http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000054 
;
function ipmask($ipaddress1, $ipaddress2)
  Dim $bit

  if instr($ipaddress1,'.') or instr($ipaddress2,'.') or len($ipaddress1)<>32 or len($ipaddress2)<>32
    exit 87
  endif

  $ipmask=''
  for $bit=1 to 32
    $ipmask=$ipmask+(val(substr($ipaddress1,$bit,1)) & val(substr($ipaddress2,$bit,1)))
  next

endfunction

[ 18 December 2001: Message edited by: sealeopard ]82997IPPortConnect170Will HetrickIPPortConnect() Connect a printer to an IP port without User intervention.0

code:

;Function		IpPortConnect()
;
;Author		Wilbur Hetrick (Wvhetrick@hotmail.com)
;
;Action		adds a printer with the given printer name and ip address and 
;			given make and model.
;
;Syntax		IPPortconnect("Name or printer"," IP address","Windows inf printername")
;
;Parameters 	
;			For The printer model, it must match the Windows inf file settings.
;
;Remarks 		This is for those people out there who do not use the 
;			Windows share print server but print directly to the ip address
;			of the printer.  
;
;			This can also be used to install LPT and com printers with a little modification
;
;Returns 		Returns a 0 for success or a 1 for a non success.
;			
;Dependencies 	To install IP printer in Windows. IP PORT MUST Exist(for now).
; 
;Addons		I am going to work on if the IP port does not exist it will be created.
;			
;
;Example(s)		Break ON
;				
;				? "Type in name a name for the Printer " 
;				? Gets $Pname
;				? "Type in the IP address of the printer ex: 100.100.100.100" 
;				? Gets $Port
;				? "Type in the printer driver name for windows 2000 (must be exact)ex: HP Laserjet 4000 Series PCL" ?
;				Gets $Type
;				
;				$RC = $IPportconnect($Pname,$port,$type)
;				If $RC = 0 
;					? "Command Sucessful!  "
;				Else
;					? "There was a problem!  "
;				EndIf
; 				Exit
;
;Source			

Function IPportConnect($PrinterName,$IPPort,$printertype)
	
	If Len($printername)=0 OR Len($ipport) = 0 OR Len($printertype) = 0
		? "One or more of the variables was empty.  "
		Exit 1
	EndIf

	$IPport = "IP_" + $IPport
		
	Shell 'rundll32 printui.dll,PrintUIEntry /if /b "$printername" /f %windir%\inf\ntprint.inf /r "$IPPort" /m "$Printertype" /Z /u'
	If @ERROR = 0 
		Exit 0
	Else
		Exit 1
	EndIf

EndFunction


Finally created some code to create the port at  [URL=http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000324]FnTCPIPPort  Creates IP Printer Port[/URL] 
  


 
 [ 20. December 2002, 20:25: Message edited by: Will Hetrick ]82572IsArray17SealeopardIsArray() - Checks whether a variable is an array0

code:


;FUNCTION      IsArray
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Checks whether a variable is an array
;
;SYNTAX        ISARRAY(VARIABLE)
;
;PARAMETERS    VARIABLE
;              Required variable to be checked for being an array
;
;RETURNS       1 if array, otherwise 0
;
;REMARKS       none
;
;DEPENDENCIES  none
;
;EXAMPLE       Dim $array[10]
;              $retcode=isarray($array)
;
;KIXTART BBS   http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000088 
;
function isarray($variable)
  $isarray=((vartype($variable) & 8192)=8192)
endfunction

[ 18 December 2001: Message edited by: sealeopard ]138960IsArray1399Christophe MelinIsArray() - function to identify if a var is an array1115007080 Code:

;------------------------------------------------------------------------------ 
;function: 
;   IsArray 
; 
;Action: 
;   Read one element in an array with control on the value of index 
;   index must be between 0 and UBound($arr). 
;   if not, an empty string is returned 
; 
;Author: 
;   Christophe MELIN 
; 
;Contributors: 
; 
;Version: 
;   1.0 
; 
;Version History: 
; 
;Date created: 
;   10/09/2004 
; 
;Date modified: 
; 
;KIXTART     KiXtart 4.02 
; 
;Syntax: 
;   IsArray( $var ) 
; 
;Parameters: 
;   var        : REQUIRED. variable to be tested 
; 
;returns: 
;   a boolean : 0 if $var is not an array 
;               1 if $var is an array 
; 
;Dependencies: 
; 
;------------------------------------------------------------------------------ 
function IsArray( $var )
    $IsArray=((vartype($var) & 8192)=8192)
endfunction



useful if you don't remember the function VarType and the value 8192
and make script more readable.82615IsInArray17SealeopardIsInArray() - Checks if a string is part of a array of strings0

code:

;FUNCTION      IsInArray
;
;ACTION        Checks if a string is an element of an array of strings
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.4 (changed output to array only if element positions
;                   are to be returned, corrected example)
;              1.3
;
;DATE CREATED  2001/12/19
;
;DATE MODIFIED 2003/05/31
;
;KIXTART       4.20
;
;SYNTAX        ISINARRAY(ARRAY, STRING [, POS])
;
;PARAMETERS    ARRAY
;              Array of strings
;
;              STRING
;              Required string to search for in array
;
;              POS
;              Optional boolean indicating whether to return the
;              indices of all found strings as an array
;
;RETURNS       1 if string is found in any element of the array, otherwise 0
;              Alternatively an array of string indices
;
;REMARKS       Function handles an array with a maximum of 26 dimensions
;
;DEPENDENCIES  none
;
;EXAMPLE       $string='User1'
;              $array[0]='User0'
;              $array[1]='User1'
;              $rc=isinarray($array,$string)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000098
;
function isinarray($array,$string, optional $pos)
  Dim $element, $cmd, $vars, $arraydim, $a, $rc, $posvars

  $isinarray=0
  $pos=val($pos)

  select
  case vartype($array) & 8192
    select
    case ubound($array,2)=-1
      if ascan($array,$string)=-1
        $isinarray=0
        return
      else
        if $pos
          $isinarray=''
          for $a=0 to ubound($array)
            if $array[$a]=$string
              $isinarray=$isinarray+','+$a
            endif
          next
          $isinarray=split(substr($isinarray,2),',')
          if ubound($isinarray)=0
            $isinarray=$isinarray[0]
          endif
        else
          $isinarray=1
        endif
        return
      endif
    case ubound($array,27)=-1
      $arraydim=0
      do
        $arraydim=$arraydim+1
      until ubound($array,$arraydim)=-1
      $arraydim=$arraydim-1
      $vars='$sub_a'
      for $a=2 to $arraydim
        $vars=$vars+', $sub_'+chr($a+96)
      next
      $cmd='dim '+$vars+@CRLF
      $cmd=$cmd+'$isinarray=""'+@CRLF
      for $a=1 to $arraydim
        $cmd=$cmd+'for $sub_'+chr($a+96)+'=0 to ubound($array,'+$a+')'+@CRLF
        $posvars=$posvars+'+","+$sub_'+chr($a+96)
      next
      $posvars=substr($posvars,6)
      $cmd=$cmd+'if $array['+$vars+']=$string'+@CRLF
      $cmd=$cmd+'if $pos'+@CRLF
      $cmd=$cmd+'$isinarray=$isinarray+chr(13)+'+$posvars+@CRLF
      $cmd=$cmd+'else'+@CRLF
      $cmd=$cmd+'$isinarray=1'+@CRLF
      $cmd=$cmd+'return'+@CRLF
      $cmd=$cmd+'endif'+@CRLF
      $cmd=$cmd+'endif'+@CRLF
      for $a=1 to $arraydim
        $cmd=$cmd+'next'+@CRLF
      next
      $cmd=$cmd+'$isinarray=split(substr($isinarray,1),chr(13))'+@CRLF
      $cmd=$cmd+'if ubound($isinarray)=0'+@CRLF
      $cmd=$cmd+'$isinarray=$isinarray[0]'+@CRLF
      $cmd=$cmd+'endif'+@CRLF
      $rc=execute($cmd)
    case 1
      $isinarray=0
    endselect
  case $string=''
    $isinarray=0
  case $string=$array
    $isinarray=1
  case 1
    $isinarray=0
  endselect
endfunction


 
 [ 31. May 2003, 22:40: Message edited by: sealeopard ]82657IsIncluded17SealeopardIsIncluded() - Check if a user/computer is included in the constraints0

code:

;FUNCTION      IsIncluded
;
;ACTION        Check if a user/computer is included in the constraints
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.3
;
;KIXTART       4.20+
;
;SYNTAX        ISINCLUDED(GROUPIN, COMPEX, USERIN)
;
;PARAMETERS    GROUPIN
;              Required string/array of groups to be included
;
;              COMPEX
;              Required string/array of computernames to be excluded
;
;              USERIN
;              Required string/array of userids to be included
;
;RETURNS       1 if included based on constraints, otherwise 0
;
;REMARKS       $compex overrides $groupin and $userin overrides both $groupin and $compex
;
;DEPENDENCIES  none
;
;EXAMPLE       $groupin[0]='DOMAIN\GROUP1'
;              $groupin[1]='DOMAIN\GROUP2'
;              $compex[0]='COMP1'
;              $userin[0]='USER1'
;              $rc=isincluded($groupin,$compex,$userin)
;              ; $rc would be 1 if user is in either of the groups and not at computer COMP1 or
;              ; user is USER1
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000105
;
function isincluded($groupin, $compex, $userin)
  if not (vartype($compex) & 8192)
    redim preserve $isincluded[0]
    $isincluded[0]=$compex
    $compex=$isincluded
  endif
  if not (vartype($userin) & 8192)
    redim preserve $isincluded[0]
    $isincluded[0]=$userin
    $userin=$isincluded
  endif

  $isincluded = (ingroup($groupin) and (ascan($compex,@WKSTA)=-1)) or (ascan($userin,@USERID)+1)
endfunction


 
 [ 21. April 2003, 00:57: Message edited by: sealeopard ]82613IsInGroup17SealeopardIsInGroup() - deprecated UDF0

code:

;FUNCTION      IsInGroup
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Check if a user is a member of any of the groups provided in an array
;
;SYNTAX        ISINGROUP(GROUPS)
;
;PARAMETERS    GROUPS
;              Required string/array of groups
;
;RETURNS       1 if member of any group, otherwise 0
;
;REMARKS       this UDF has been deprecated in favor of INGROUP()
;
;DEPENDENCIES  ISARRAY() @ [URL=http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000088]http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000088[/URL] 
;
;EXAMPLE       $groups(0)='DOMAIN\Group1'
;              $groups(1)='DOMAIN\Group2'
;              $retcode=isingroup($groups)
;
;KIXTART BBS   [URL=http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000097]http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000097[/URL] 
;
function isingroup($array)
  dim $element

  $isingroup=0

  if isarray($array)
    for each $element in $array
      if ingroup($element)
        $isingroup=1
        return
      endif
    next
  else
    if ingroup($array)
      $isingroup=1
      return
    endif
  endif
endfunction


 
 [ 07. August 2003, 18:13: Message edited by: sealeopard ]83619IsInIPRange17SealeopardIsInIPRange() - Checks if IP address is part of a network (deprecated)0

code:

;FUNCTION      IsInIPRange
;
;ACTION        Checks if IP address is part of a network as defined by the network ID and subnet mask
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2
;
;DATE CREATED  2002/10/25
;
;DATE MODIFIED 2003/05/31
;
;KIXTART       4.12+
;
;SYNTAX        ISINIPRANGE(IPADDRESS, IPRANGE)
;
;PARAMETERS    IPADDRESS
;              Required string containing an ip adress
;
;              IPRANGE
;              Required string/array of IP ranges (e.g. 10.10.10.0/24)
;              Each IP range must be in the format NetworkID/Subnetmask
;              Valid formats are aaa.bbb.ccc.ddd/n and aaa.bbb.ccc.ddd/www.xxx.yyy.zzz
;
;RETURNS       True if IP address is part of any of the ipranges, otherwise false
;
;REMARKS       This function is deprecated in favor of IsInSubnet() at
;              http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000053
;
;
;DEPENDENCIES  BINARYIP()   @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000029
;              ISINSUBNET() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000053
;
;EXAMPLE       $ipaddress='10.10.0.5'
;              $iparray[0]='10.10.0.0/24'
;              $iparray[1]='192.168.0.0/255.255.255.224'
;              $rc = isiniprange($ipaddress,$iparray)
;
;KIXTART BBS   http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000289
;
function isiniprange($ipaddress,$iprangearray)
  Dim $iprange, $networkid, $subnetmask, $bit

  if $ipaddress=''
    exit 87
  endif

  if ubound($iprangearray)=-1
    $iprange=$iprangearray
    redim preserve $iprangearray[0]
    $iprangearray[0]=$iprange
  endif

  $ipaddress=binaryip($ipaddress)

  for each $iprange in $iprangearray

    if instr($iprange,'/')
      $iprange=split($iprange,'/')
      $networkid=binaryip($iprange[0])

      if instr($iprange[1],'.')
        $subnetmask=binaryip($iprange[1])
      else
        $subnetmask=''
        for $bit=1 to val($iprange[1])
          $subnetmask=$subnetmask+'1'
        next
        for $bit=(val($iprange[1])+1) to 32
          $subnetmask=$subnetmask+'0'
        next
      endif

      if isinsubnet($ipaddress,$networkid,$subnetmask)
        $isiniprange=1
        return
      else
        $isiniprange=0
      endif
    endif
  next

endfunction


 
 [ 01. August 2003, 19:03: Message edited by: sealeopard ]82333IsInSubnet17SealeopardIsInSubnet() - Checks if a given IP address is in a specified subnet1156986633Code:

;FUNCTION      IsInSubnet
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Checks if a given IP address is in a specified subnet
;
;VERSION       2.2 (fixed a problem with CIDRs smaller than 10, added IP address validation)
;              2.1 (fixed a problem if only a single networkID/subnetmask combinations was
;                   provided as the second parameter)
;              2.0 (completely rewritten code, removed all dependencies, added support for
;                   array of network IDs and subnet masks, added return options, fully
;                   backward compatible with version 1.1)
;              1.1
;
;DATE CREATED  2001/12/03
;
;DATE MODIFIED 2003/08/18
;
;KIXTART       4.21+
;
;SYNTAX        ISINSUBNET(IPADDRESS,NETWORKID [,SUBNETMASK, RETURN])
;
;PARAMETERS    IPADDRESS
;              Required string containing the IP number
;
;              NETWORKID
;              Required string containing a networkid or a string/array of network ID/subnet mask
;
;              SUBNETMASK
;              Optional string containing a subnet mask (octets or CIDR) if the network ID is a
;              string. The subnetmask is not rquired when providing a string/array of
;              network ID/subnet mask
;
;              RETURN
;              Optional return options when providing an array of network IDs/subnet masks
;              1 = IP address is in ANY of the provided networks
;              2 = IP address is in ALL of the provided networks
;
;REMARKS       based on code provided in the KiXgolf MOAN() tournament on the KiXtart BBS
;
;DEPENDENCIES  none
;
;RETURNS       1 if IP address is part of any/all networks, otherwise 0. Alternatively, if an array
;              of networks is provided, it returns an array of 1/0 corresponding to the input array
;              of networks.
;
;EXAMPLE       $ip='10.10.10.1'
;              $networkid='10.10.10.0'
;              $subnetmask='255.255.255.0'
;              $answer = isinsubnet($ip,$networkid,$subnetmask)
;              ? 'Error = '+@ERROR+ ' - '+@SERROR
;              ? 'IsInSubnet = '+$answer
;              redim $networkid[2]
;              $ip='10.10.10.1'
;              $networkid[0]='10.10.10.0/24'
;              $networkid[1]='10.10.10.0/27'
;              $networkid[2]='10.10.0.0/255.255.0.0'
;              $answer = isinsubnet($ip,$networkid)
;              $answer = isinsubnet($ip,$networkid,,1)
;              $answer = isinsubnet($ip,$networkid,,2)
;
;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=81873
;
function isinsubnet($ip,$network, optional $subnetmask, optional $bin)
  dim $a, $b, $c, $, $e, $f, $g, $h, $m[32]
  
  ; convert IP address to array
  if vartype($ip) & 8192
    exit 87
  endif

  ; check whether IP addresses are in correct format
  if ubound(split($ip,'.'))<>3
    exit 87
  endif
  
  ; check for valid IP address range
  $a=split($ip,'.')
  for each $b in $a
    if $b<>1*$b or 0>$b or 255<$b
      exit 87
    endif
  next

  ; check for network ID format and extract subnet masks if necessary
  select
  case vartype($network) & 8192
    $subnetmask=$network
    for $a=0 to ubound($network)
      $b=split($network[$a],'/')
      if ubound($b)<>1
        exit 87
      endif
      if ubound(split($b[0],'.'))<>3
        exit 87
      endif

      $network[$a]=$b[0]
      $subnetmask[$a]=$b[1]
    next
  case instr($network,'/')
    $network=split($network,'/')
    $subnetmask=split($network[1],'')
    $network=split($network[0],'')
  case ubound(split($network,'.'))<>3
    exit 87
  case 1
    $network=split($network,'')
  endselect

  ; convert subnetmask address to array
  if not (vartype($subnetmask) & 8192)
    $subnetmask=split($subnetmask,'')
  endif

  ;Begin build mask array (Howard Bullock)
  $f=0,128,192,224,240,248,252,254,255
  for $e=0 to 32
    Dim $h
    $=$e
    for $g=1 to 4
      $h=''+$h+iif($/8,'255',$f[$ mod 8])+iif($g<4,'.','')
      $=iif($>8,$-8,0)
    next
    $m[$e]=$h
  next
  ;End build mask array

  ; convert CIDR addresses into octets
  for $a=0 to ubound($subnetmask)
    $b=$subnetmask[$a]
    if not instr($b,'.')
      if 0<=$b and 32>=$b
        $subnetmask[$a]=$m[$subnetmask[$a]]
      else
        exit 87
      endif
    endif
  next

  ; check whether IP & SubnetMask = NetworkID
  $ = ubound($network)
  redim $isinsubnet[$]
  $b=split($ip,'.')
  for $c=0 to $
    $e=split($network[$c],'.')
    $f=split($subnetmask[$c],'.')

    $g=0
    for $h=0 to 3
      $g = $g + ((val($b[$h]) & val($f[$h]))=val($e[$h]))
    next
    $isinsubnet[$c]=($g=4) + $isinsubnet[$c]
  next

  ; convert array back to string value if only one networkid/subnetmask address provided
  select
  case $=0
    $isinsubnet=$isinsubnet[0]
  case val($bin)=1
    $isinsubnet=(ascan($isinsubnet,1)>-1)
  case val($bin)=2
    $isinsubnet=(instr(join($isinsubnet,''),'0')=0)
  endselect
endfunction

 84566IsLaptop17SealeopardIsLaptop() - Determines whether a local/remote computer is a laptop0


;FUNCTION IsLaptop
;
;ACTION Determines whether a local/remote computer is a laptop
;
;AUTHOR Jens Meyer (sealeopard@usa.net)
;
;CONTRIBUTOR CitrixMan (Shane)
;
;VERSION 1.1 (shortened code)
; 1.0
;
;DATE CREATED 2003/09/23
;
;DATE MODIFIED 2003/09/23
;
;KIXTART 4.02
;
;SYNTAX ISLAPTOP([COMP,DETAIL])
;
;PARAMETERS COMP
; Optional string denoting a remote computer
;
; DETAIL
; Optional boolean variable indicating whether to return unknown states, too
;
;RETURNS Tri-state variable with the following values
; -1 = unknown (only if DETAIL=1)
; 0 = not a laptop
; 1 = laptop
;
;REMARKS Relies on correct ACPI setup
;
;DEPENDENCIES none
;
;EXAMPLE if islaptop()
; ? 'This is a laptop'
; else
; ? 'This is not a laptop'
; endif
;
;KIXTART BBS http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000462
;
function IsLaptop(optional $sComp, optional $bDetail)
dim $sRegKey

$sComp=trim($sComp)

$sRegKey='HKLM\SYSTEM\CurrentControlSet\Enum\ACPI\PNP0C0A'

select
case $sComp and $sComp<>@WKSTA
$sComp='\\'+$sComp+'\'
if val($bDetail) and not keyexist($sComp+'HKLM')
$islaptop=-1
exit @ERROR
endif
if keyexist($sComp+'HKLM\SOFTWARE\Microsoft\Windows NT')
$sRegKey=$sComp+$sRegKey
else
$sRegKey=$sComp+'HKLM\Enum\ACPI\*PNP0C0A'
endif
case @INWIN=2
$sRegKey='HKLM\Enum\ACPI\*PNP0C0A'
endselect
$islaptop=keyexist($sRegKey)
exit @ERROR

endfunction
 
 [ 24. September 2003, 16:44: Message edited by: sealeopard ]82843IsStringInFile17SealeopardIsStringInFile() - Checks whether a string is present in a file0

code:

;FUNCTION      IsStringInFile
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Checks whether a string is present in a file
;
;VERSION       1.2
;
;KIXTART       4.12
;
;SYNTAX        ISSTRINGINFILE(STRING,FILENAME)
;
;PARAMETERS    FILENAME
;              File to search for the presence of STRING
;
;              STRING
;              Required string to search for
;
;RETURNS       1 if the file contains the search string, otherwise 0
;
;REMARKS       none
;
;DEPENDENCIES  none
;
;EXAMPLE       $rc=IsStringInFile('teststring','c:\temp\testfile.txt')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000141
;
function IsStringInFile($filename,$string)

  $isstringinfile=0
  if $string=''
    exit 87
  endif
  if not exist($filename)
    exit 2
  endif

  shell '%COMSPEC% /e:1024 /c find /c /i "'+$string+'" "'+$filename+'" > nul'

  if @ERROR=0
    $IsStringInFile=1
  endif
  exit 0
endfunction


 
 [ 02. March 2003, 20:21: Message edited by: sealeopard ]115790IsSubnetMask17SealeopardIsSubnetMask() - Validates subnet masks1078869545Code:


;FUNCTION      IsSubnetMask()

;

;AUTHOR        Jens Meyer (sealeopard@usa.net)

;

;ACTION        Checks whether an IP address is a valid subnet mask

;

;VERSION       1.0

;

;DATE CREATED  2004/03/09

;

;DATE MODIFIED 2004/03/09

;

;KIXTART       4.20+

;

;SYNTAX        ISSUBNETMASK(SUBNETMASK)

;

;PARAMETERS    SUBNETMASK

;              Required string containing a subnetmask in octet form

;

;

;REMARKS       none

;

;DEPENDENCIES  none

;

;RETURNS       1 if subnetmask, otherwise 0

;

;EXAMPLE       $rc=issubnetmask('255.255.255.0')

;

;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=114496

;

function IsSubnetMask($s)

  dim $e, $f, $g, $h, $, $m[32]



  $s=join(split($s,' '),'')



  $f=0,128,192,224,240,248,252,254,255

  for $e=0 to 32

    Dim $h

    $=$e

    for $g=1 to 4

      $h=''+$h+iif($/8,'255',$f[$ mod 8])+iif($g<4,'.','')

      $=iif($>8,$-8,0)

    next

    $m[$e]=$h

  next



  $IsSubnetMask=iif(ascan($m,$s)+1,1,0)

endfunction

 116875IsUnicode288jtokachIsUnicode() - Determines if a file is unicode0 Code:

;FUNCTION       IsUnicode()

;

;ACTION         Detects whether a file is unicode or not

;

;AUTHOR         James Tokach (james.tokach@lmco.com)

;

;CONTRIBUTERS	None

;

;VERSION        1.0

;

;DATE CREATED   2004/10/24

;

;DATE MODIFIED  N/A

;

;KIXTART        Tested only with 4.22

;

;SYNTAX         $ReturnCode = IsUnicode($FileName)

;

;PARAMETERS     $FileName

;               The path and filename of the file to check

;

;RETURNS        0 if the file is unicode

;               Negative value if open command failed

;               Positive value not unicode

;

;REMARKS        None

;

;DEPENDENCIES   None

;

;EXAMPLE        $FSO = CreateObject("Scripting.FileSystemObject")

;               If IsUnicode($File)=0

;                   $FileData = $FSO.OpenTextFile($File,,,-1) ; The -1 says use unicode

;               Else

;                   $FileData = $FSO.OpenTextFile($File) ; DOS Format

;               Endif

;

;KIXTART BBS	http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=115616&page=0&view=collapsed&sb=5&o=&fpart=&vc=

;

Function IsUnicode($FileName)

    Dim $handle,$Line,$nul

    $handle=FreeFileHandle()

    If Open($handle, $FileName) = 0

        $Line = ReadLine($handle)

        $nul=Close($handle)

        $IsUnicode=IIf(Asc($Line)=255,0,1)

    Else

        $IsUnicode=@Error

    EndIf

EndFunction  

  82358IsVPNConnection17SealeopardIsVPNConnection() - Checks if client is logging in through a virtual private network0

code:

;FUNCTION      IsVPNConnection
;
;ACTION        Checks if client is logging in from a virtual private network connection
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2 (added error code)
;              1.1
;
;DATE CREATED  2001/12/03
;
;DATE MODIFIED 2003/06/24
;
;KIXTART       4.12+
;
;SYNTAX        ISVPNCONNECTION(IPRANGE)
;
;PARAMETERS    IPRANGE
;              Required array of IP ranges (e.g. 10.10.10.0/24)
;              Each IP range must be in the format NetworkID/Subnetmask
;              Valid formats are aaa.bbb.ccc.ddd/n and aaa.bbb.ccc.ddd/www.xxx.yyy.zzz
;
;RETURNS       True if VPN connection, otherwise false
;
;REMARKS       Designed to work with the Cisco 3000 VPN Concentrator and the Cisco VPN client 3.x
;
;DEPENDENCIES  ISINIPRANGE() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000052
;
;EXAMPLE       $iparray[0]='10.10.0.0/24'
;              $iparray[1]='192.168.0.0/255.255.255.224'
;              $rc = isvpnconnection($iparray)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000056
;
function isvpnconnection($iparray)
  Dim $rc, $vpnlocation, $shellcommand, $clientaddress, $clientfile, $searchstring

  $vpnlocation=readvalue('HKEY_LOCAL_MACHINE\SOFTWARE\Cisco Systems\VPN Client','InstallPath')
  if $vpnlocation<>''
    $vpnlocation=$vpnlocation+'\vpnclient.exe'
    if exist($vpnlocation)
      $searchstring='Client Address'
      $clientfile='%TEMP%\vpninfo.txt'
      $shellcommand='"'+$vpnlocation+'" stat tunnel >'+$clientfile
      shell '%COMSPEC% /c /e:1024 start /min /wait '+$shellcommand
      if exist($clientfile)
        if open(1,$clientfile,2)=0
          do
            $clientaddress=readline(1)
          until @ERROR or instr($clientaddress,$searchstring)
          $rc=close(1)
          del $clientfile
          if instr($clientaddress,$searchstring)
            $clientaddress=substr($clientaddress,len($searchstring)+3,len($clientaddress)-len($searchstring)-2)
            if isiniprange($clientaddress,$iparray)
              $isvpnconnection=1
              exit @ERROR
            endif
          endif
        endif
      endif
    endif
  endif

  $isvpnconnection=0
  exit @ERROR
endfunction


 
 [ 25. June 2003, 03:37: Message edited by: sealeopard ]84684JoinArrays11ShawnJoinArrays - Join two arrays into single array0I later found that Lee Wilmott (korg member) did one similar over at SL ...

JoinArray

but here's another quick and dirty anyhow ...


Function JoinArrays($Array1, $Array2)

 

 ; Join two arrays into single array, return single array.

 

 Dim $n,$i

 

 $n = UBound($Array1) + 1

 

 REDIM PRESERVE $Array1[$n+UBound($Array2)]

 

 For $i = 0 to UBound($Array2)

  $Array1[$n+$i] = $Array2[$i]

 Next

 

 $JoinArrays = $Array1

 

EndFunction



-Shawn82569JulianDayNo75d.adamsJulianDayNo() - To calculate Julian day number for any given Gregorian date0

code:

;==============================================================================
;=== DESCRIPTION: KiX32 Julian Day Number calculation
;=== AUTHOR: Masken - mastermasken@lycos.com
;=== DATE: 2001-10-18 15:04 (week 42  
;=== PURPOSE: To calculate Julian day number for any given Gregorian
;=== date. The result is returned as a simple day number
;=== PARAMETERS: $Date must be in the format "YYYY/MM/DD"
;=== REViSiONS: Rev 0: Initial version. Clumsy KiX32 MOD calculations.
;=== Rev 1:  Broke the code out of Masken's script for use as a function
;=== By d.adams on 12/17/2001
;=== EXAMPLE: ? JulianDayNo(@DATE)
;=== RETURNS: The Julian day number for the date specified.
;=== DEPENDENCIES: K2K 4.01
;=== COMMENTS: For more info: [URL=http://webexhibits.org/calendars/week.html]http://webexhibits.org/calendars/week.html[/URL]  
;=== here you will also find calculations for the Julian week-
;=== numbers.
;==============================================================================

Function JulianDayNo($Date)
  Dim $JDN, $a, $y, $m, $Month, $Day, $Year
  
  $Day = Val(SubStr($Date, 9, 2))
  $Month = Val(SubStr($Date, 6, 2))
  $Year = Val(SubStr($Date, 1, 4))

  ;--- Calculate the Julian Day Number - JDN, for the given Gregorian date -------
  $a = (14 - $Month) / 12
  $y = $Year + 4800 - $a
  $m = $Month + 12 * $a - 3
  $JDN = $Day + (153 * $m + 2) / 5 + $y * 365 + $y / 4 - $y / 100 + $y / 400 - 32045
  
  $JulianDayNo = $JDN
EndFunction


 
 [ 09. June 2003, 03:43: Message edited by: Radimus ]181921kfNSLookup2980Glenn BarnaskfNSLookup() - returns hostname/ip via NSLookup - Kixforms0Returns a name/address pair using the Kixforms Shell proces. This is an advantage for KF GUI scripts as it does not cause the command window to flash the way the WSH version does, and does not require external files to capture the output.


Glenn



;; 
;;====================================================================== 
;; 
;;FUNCTION       kfNSLookup() 
;; 
;;ACTION         Return a name/address pair via NSLookup 
;; 
;;AUTHOR         Glenn Barnas 
;; 
;;VERSION        1.0 - 2007/10/25 - replacement for WSH based functions used in KF apps 
;; 
;;SYNTAX         kfNSLookup(Target) 
;; 
;;PARAMETERS     Target - REQUIRED - name or IP address to resolve 
;; 
;;REMARKS        This function is designed for use with KixForms GUI apps, where WSH 
;;		 based functions cause a command window to briefly appear. This prevents 
;;		 that from occurring. KF-Classic DLL is required to be registered. 
;; 
;;RETURNS        String - hostname,address, or empty string if not resolved 
;; 
;;DEPENDENCIES   OS Command NSLookup.exe, KixForms.DLL (classic) 
;; 
;;TESTED WITH    W2K, WXP, W2K3, Vista, X64 
;; 
;;EXAMPLES       If kfNSLookup($Host) 
;;		   $Host ' is in DNS!' ? 
;;		 EndIf 
; 
Function kfNSLookup($Target)
 
  Dim $_oSys				; System KixForms object 
  Dim $_aData				; Array of results 
  Dim $_X, $_Y				; Index vars of results 
  Dim $_Cmd				; command to run 
 
  $_oSys = CreateObject('Kixtart.System')
  $_Cmd   = '%COMSPEC% /c nslookup.exe ' + $Target
  $_aData = Split($_oSys.Shell($_Cmd,0,3), @CRLF)
  $_oSys = 0
 
  $_X = AScan($_aData, 'Name:', 0, , 1)
  $_Y = AScan($_aData, 'Address:', $_X, , 1)
  If $_X = -1 Or $_Y = -1
    $kfNSLookup ''
    Exit 67
  Else
    $kfNSLookup = Trim(Split($_aData[$_X], ':')[1]) + ',' + Trim(Split($_aData[$_Y], ':')[1])
    Exit 0
  EndIF
 
EndFunction
 
   

181920kfPing2980Glenn BarnaskfPing() - ping using KixForms Shell0Advantage, primarily for KixForms, is that this doesn't cause the command window to flash like the WSH version does, and it requires no external files.


Glenn



;; 
;;====================================================================== 
;; 
;;FUNCTION       kfPing() 
;; 
;;ACTION         Pings a host, returns status or IP address 
;; 
;;AUTHOR         Glenn Barnas 
;;		 Based on Ping() by Jochen Polster  
;;		 rewritten to use WSH and now Kixforms.Shell 
;; 
;;VERSION	 1.0 - 2007/10/25 - replacement for WSH based functions used in KF apps 
;; 
;;SYNTAX         kfPing(host, [Flag], [Wait]) 
;; 
;;PARAMETERS     host - name of host to ping 
;;               FLAG - if negative, returns IP Address 
;;                      if >0, specifies number of tries (default is 1) 
;;               Wait - optional ping timeout value 
;;                
;; 
;;REMARKS        ERROR is set to 0 if success, 1 otherwise. 
;; 
;;RETURNS        FLAG >= 0: returns 1 if host is reachable, 0 if not 
;;               FLAG <  0: Returns IP address if resolvable, 0.0.0.0 if not 
;; 
;;DEPENDENCIES   OS Command Ping.exe, KixForms.DLL (classic) 
;; 
;;TESTED WITH    NT4, W2K, WXP, Vista, X64 
;; 
;;EXAMPLES       kfPing('hostname')       ; returns Success/Failure 
;;               kfPing('hostname',-1)    ; returns IP Address 
; 
Function kfPing($_Host, OPTIONAL $_Flag, OPTIONAL $_Wait)
 
  Dim $_oSys				; System KixForms object 
  Dim $_Tries				; # of times to ping 
  Dim $_Timeout				; Ping timeout value 
  Dim $_Response			; Response Flag 
  Dim $_aData				; Line returned from command string 
  Dim $_Cmd				; first part of command string 
  Dim $_Count				; current ping count 
 
  $_Flag    = Val($_Flag)		; determine what to do 
  $_Wait    = Val($_Wait)		;  
  $_Tries   = 1				; one ping 
  $_Timeout = 1				; 1 second timeout 
 
  ; set timeout if Wait is non-zero 
  If $_Wait > 0
    $_Timeout = $_Wait
  EndIf
 
  If $_FLAG > 0        ; Multiple pings - return on first reply 
    $_Tries = $_FLAG
  EndIf
 
  ; Ping the host $_Tries times, but only until a response is received 
  $_Count = 0
 
  ; search for reply from host during PING 
  $_Cmd = '%COMSPEC% /c ping.exe -4 -n 1 -w ' + $_Timeout + ' ' + $_Host 
 
  $_oSys = CreateObject('Kixtart.System')
  If $_Flag < 0
    $_aData = Split($_oSys.Shell($_Cmd,0,3), @CRLF)
    $_Response = AScan($_aData, 'Pinging', 0, , 1)
    If $_Response >= 0
      $_Response = $_aData[$_Response]
      ; In this mode we return the IP address - we should have the HOSTNAME 
      ; handle the 'duh' factor for times when we get the IP address instead! 
      If InStr($_Response,'[') > 0
        $kfPing= Split(Join(Split($_Response,']',-1),'['), '[')[1]
      Else
        $kfPing = Split(Split($_Response,' ',-1)[1], ':')[0]
      EndIf
    Else
      $kfPing = '0.0.0.0'
    EndIf
  Else
    Do
      $_aData = Split($_oSys.Shell($_Cmd,0,3), @CRLF)
      $_Response = IIf(AScan($_aData, 'TTL=', 0, , 1) = -1, 0, 1)
      If $_Response
        $_Count = $_Tries
      EndIf
      $_Count = $_Count + 1
    Until $_Count >= $_Tries
    $kfPing = $_Response
  EndIf
  $_oSys = 0
 
  Exit Not $_Response       ; set the error code 
 
EndFunction
 
 
 
   

156136KillProcess5931apronkKillProcess() - Kills the Process specified1147101380Code:


;Function	KillProcess() - Kills the Process specified 
;   
;Author		Arend Pronk (apronk on the forum)
;   
;Contributors	Chris S. (based on his ProcessMon)
;    		Radimus (his suggestions to change some code)
;   
;Action		Kills the Process specified and returns a 1 for success or 0 for failure  
;   
;Syntax		KillProcess($sProcessName,Optional $sComputer)
;    		Where $sProcessName is the name of the process you are trying to kill
;    		and $sComputer is the name of the computer to kill the process on.
;    		If no computer is specified it is done on the local computer.
;    		Remote computers require this script to be run as an admin of the remote computer 
;   
;Version  	1.0  
;   
;Date		2006-Jan-27 
;   
;Date Revised	2006-Jan-29   
;   
;Revision Reason
;    		Revised per Radimus's suggestions.
;   
;Returns  	0 for success, Errorlevel for failure  
;   
;Dependencies	KiXtart 4.02 Recommend 4.51 or newer 
;   
;KiXtart Ver.	Written and tested with KiXtart v4.52 Beta 2 on Windows XP/2003  
;   
;Example 
;		Dim $KP 
;		$KP = KillProcess("notepad.exe") 
;		If $KP = 0 
;		  ? "Process killed succesfully!" 
;		Else 
;		  ? "Process killing failed!"
;		EndIf 
;   
Function KillProcess($sProcessname, Optional $sComputer)
  Dim $objWMIService, $objInstance, $colItems, $objItem, $strWBEMPath
  If $sComputer = ""
    $sComputer = "."
  EndIf

  $objWMIService = GetObject("winmgmts:\\" + $sComputer + "\root\cimv2")

  If @ERROR
    Exit @error
  EndIf

  $colItems = $objWMIService.ExecQuery("Select * from Win32_Process",,48)

  For Each $objItem In $colItems
    If $objItem.Name = $sProcessname
      $strWBEMPath = "Win32_Process.Handle=" + $objItem.ProcessID
      $objInstance = $objWMIService.Get($strWBEMPath)
      $KillProcess = $objInstance.Terminate(1)
    EndIf
  Next
  Return $KillProcess
EndFunction

82430KillProg46kholmKillProg() - Terminate a program on all platforms0KillProg($Program)

Kill (force close) of program on all platforms: Win9x,NT,2000

Action:
Force a running program to close,
Will close ALL programs that match parameter $Program

Syntax:
ProgKill("Program") 

Parameter: 
$Program : Only Filename Or Complete filename (Drive\Path\Filename)
If you are sure that only one program with that filename exists(is running), you only specify the Filename for the program
To make sure that it is the correct program you kill, use the fully qualified name of the program.

Returns:
Nothing

Remarks:
Handle with care
ALL programs that match the name of parameter $Program are KILLED/Terminated/Closed whithout warning !!!

Dependencies:
KiXtart 4.01
UDF: OpenFile()
FreewareProgram : Commandline utility of ProcessView, find it here: Process Viewer  for Windows
(Thank You bleonard for revealing this site)
The commandline utility pv.exe must be in current dir or in the path

Example(s):

code:

; Kill ALL processes with the name : NOTEPAD.EXE
ProgKill('NOTEPAD.EXE')
 
; Make sure it is windows own notepad you kill, not another program with the same name
ProgKill('%WinDir%\NOTEPAD.EXE')

Source:

code:

Function ProgKill($Prog)
	Dim $CurProg, $Pos, $PrgChkFile
	$PrgChkFile = '%TEMP%\~Kill.prc'

	Shell '%COMSPEC% /C pv.exe -e > ' + $PrgChkFile
	
	$PrgChkFile = OpenFile($PrgChkFile, 'Read')
	If Not $PrgChkFile
		? 'ProcKill(), ' + $UdfErrMsg
		Get $x
		Return
	EndIf
	$Line = ReadLine($PrgChkFile) ; Skip title line
	$Line = ReadLine($PrgChkFile)
	While $Line
		$Pos = InStr($Line, ' ')
		$CurProg = Left($Line, $Pos - 1)
		$Line = LTrim(SubStr($Line, $Pos))
		$ProgID = Left($Line, InStr($Line, ' ') - 1)
		If InStr($Prog, '\') ; Fully qualified path to program
			$CurProg = SubStr($Line, InStrRev($Line, ':') - 1)
		EndIf
		
		If $CurProg = $Prog
			Shell '%COMSPEC% /C pv.exe -k -i -f $ProgID > Nul'
		EndIf
		
		$Line = ReadLine($PrgChkFile)
	Loop
	$RC = Close($PrgChkFile)
EndFunction

Erik
 
 [ 04. October 2002, 22:33: Message edited by: kholm ]84595KixGolf119LonkeroKixGolf() - KixGolf Score Calculator1158689104Code:


;Function		KixGolf 
; 
;Author		Howard Bullock  (hbullock@tycoelectronics.com) 
; 
;Contributors 
;		Lonkero 
;		Sealeopard 
;		Fernando Madruga 
; 
;Action		Calculates and returns KixGolf score for the specified file. 
; 
;Version		3.3 
; 
;Version History 
;		3.3 (8.9.2006)	- Lonkero - added support for block comments
;		3.2 (28.9.2003)	- Lonkero - modified to fit UDF "standards" 
;		3.1 (unknown)	- Sealeopard - dimming 
;		3.0.1 (23.8.2003)	- Fernando Madruga - added ascii 127 to scoring 
;		3.0 (15.7.2003)	- Howard Bullock 
;		... 
; 
;Syntax		KixGolf(FILE) 
; 
;Parameters 
;		FILE 
;		Full path for the file to score 
; 
;Returns 
;		The total number of key strokes used to build a script not counting comments, 
;		 spaces, tabs, or any ASCII character above 127. 
;		OR 
;		Error Description. Error value is also set. 
; 
;Remarks 
;		The script will start counting on "odd" (1,3,5,...) occurrences of ";!" 
;		and the script will stop counting after "even" (0,2,4,...) instances of ";!". 
;		Note that ";!" must be placed starting in column number 1. 
; 
;		The debug mode is controlled with the use of ";~" at the beginning 
;		of the line like the count controller (;!) above. You start and stop 
;		debugging as many time as you like while counting is enabled. 
; 
;		Debug data is written to a file in the same directory that this program resides. 
;		The file name is that of the target file name with ".debug" as an extension. 
;		Data will only be written while counting is active. 
; 
;		The data written if the character being analyzed, it's ASCII decimal 
;		value, if it was counted or not, and a running total. 
; 
;Dependencies 
;	 	Writelog2 (for debug) 
; 
;Example 
;		"KixGolf  score for c:\!KiX\golfer.kix is " 
;		 KixGolf("c:\!KiX\golfer.kix") 
;  
;Source 
Function KixGolf($F)
  Dim $debugfile, $Line, $Y, $ZZ, $debug, $olddebug, $Z, $h, $x, $A, $D, $S, $L, $Q, $oldQ, $text, $

   $debugfile=@ScriptDir+"\"+$F+".debug"
   Del $debugfile
   $Line=0
   $Y=0 $D=0 $S=0
   If Open (1,$F)
    $KixGolf="Bad File Name: $F"
    Exit 4
   EndIf
   Do
      If $L
         $Line = $Line + 1
         $ZZ = (Left($L,2)=";~")
         $debug = $debug + $ZZ & 1
         If $debug & $olddebug<>$debug
            WriteLog2($debugfile,"Debug Started at Line: " + $Line,1)
            WriteLog2($debugfile,"--------------------------------------------------")
            $olddebug=$debug
         EndIf
         If Not $debug & $olddebug<>$debug
            WriteLog2($debugfile,"--------------------------------------------------")
            WriteLog2($debugfile,"Debug Stopped at Line: " + $Line,1)
            $olddebug=$debug
         EndIf
         $Z = (Left($L,2)=";!")
         $Y = $Y + $Z & 1
         If Not $Z & Not $ZZ
            $x=Len($L)
            For $h=1 to $x
               $A=Asc(SubStr($L,$h,1))-32
               $D = $D + ($A=2) & 1 & Not $S
               $S = $S + ($A=7) & 1 & Not $D
               If $debug
                  $Q = $D | $S
                  If $Q<>$oldQ
                     If $Q
                        WriteLog2($debugfile,"Quotes ON at: " + Chr($A+32))
                     Else
                        WriteLog2($debugfile,"Quotes OFF at: " + Chr($A+32))
                     EndIf
                  EndIf
                  $oldQ=$Q
               EndIf
               If Not $D & Not $S & "/*" = SubStr($L,$h,2)
                  If $debug
                     WriteLog2($debugfile,Chr($A+32) + " " + ($A+32) + " Count=0 ")
                     $text="Block Comment found.  Ignore to End Mark. Next character should be 1st character after */."
                     WriteLog2($debugfile,$text)
                  EndIf
                  If InStr(SubStr($L,$h+2),"*/")
                     $h = $h + 3 + InStr(SubStr($L,$h+2),"*/")
                  Else
                     Do $L=ReadLine(1) Until InStr($L,"*/") Or @ERROR
                     If @ERROR
                        $KiXGolf="No End for Block Comment."
                        Exit 13
                     EndIf
                     $h = InStr($L,"*/") + 1
                  EndIf
               Else
                  If Not $D & Not $S & ($A=27)
                     $h=$x+1
                     If $debug
                        WriteLog2($debugfile,Chr($A+32) + " " + ($A+32) + " Count=0 ")
                        $text="Comment found.  Ignore to EOL. Next character should be 1st char of new line."
                        WriteLog2($debugfile,$text)
                     EndIf
                  Else
                     $=$+($Y & (($A>0 & $A<96) | $D | $S))
                     If $debug
                        $text=Chr($A+32) + " " + ($A+32) + " Count=" + ($Y & (($A>0 & $A<96) | $D | $S)) + "  " + $
                        WriteLog2($debugfile,$text)
                     EndIf
                  EndIf
               EndIf
            Next
         EndIf
      EndIf
      $L=ReadLine(1)
   Until @error
   $L=Close(1)
   If $D | $S
      $KiXGolf="Mis-matched quotes."
      Exit 13
   EndIf
   If $olddebug
        $=""+$+", Debug File: " +$debugfile
   EndIf
   $KixGolf=$
EndFunction

83939KixVer2980Glenn BarnasKixVer() - Die or Carp if not at specific Kix version0


;;
;;======================================================================
;;
;;FUNCTIONÿ ÿ ÿ ÿKixVer(Minimumÿ[,ÿRETURN,ÿBRC])
;;
;;ACTIONÿ ÿ ÿ ÿ ÿExitsÿifÿnotÿrunningÿminimumÿKixÿorÿBetaÿversionÿ
;;
;;AUTHORÿ ÿ ÿ ÿ ÿGlennÿBarnasÿ/ÿFRIT-EROC
;;
;;SYNTAXÿ ÿ ÿ ÿ ÿKixVer(verÿ[,SoftErrÿ[,BRC]])
;;
;;PARAMETERSÿ ÿ ÿMinimumÿ-ÿValueÿofÿminimumÿallowableÿKixÿversion
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿSoftErrÿ-ÿReturnÿerrorÿifÿnon-zero,ÿdefaultÿisÿEndÿProgram
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿBRCÿ ÿ ÿ-ÿAllowsÿuseÿofÿBetaÿorÿReleaseÿCandidate
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿifÿdefinedÿandÿnon-zero
;;
;;REMARKSÿ ÿ ÿ ÿ ThisÿfunctionÿisÿusedÿtoÿinsureÿuseÿofÿproperÿKixÿversions
;;
;;RETURNSÿ ÿ ÿ ÿ KixtartÿversionÿstringÿifÿReturnÿisÿset,ÿotherwiseÿitÿterminatesÿ
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿtheÿscriptÿifÿminimumÿversionÿrequirementÿisÿnotÿmet.
;;
;;DEPENDENCIESÿ ÿnone
;;
;;TESTEDÿWITHÿ ÿ NT4,ÿW2K,ÿWXP,ÿW2K3
;;
;;EXAMPLESÿ ÿ ÿ ÿKixVer(4.21,0,1)ÿ ;ÿrequiresÿverÿ4.21,ÿallowsÿBetaÿversion
;;
;
FunctionÿKixVer($Minimum,ÿOPTIONALÿ$SoftErr,ÿOPTIONALÿ$BRC)

ÿ Dimÿ$CVer,ÿ$VerOK,ÿ$MSG,ÿ$fPtr,ÿ$fX
ÿ $fPtrÿ=ÿ0

ÿ $CVerÿ=ÿSplit(@KIX,"ÿ")
ÿ Forÿ$fXÿ=ÿ0ÿtoÿUBound($CVer)
ÿ ÿ IfÿInStr('Kix200',ÿLeft($CVer[$fX],3))
ÿ ÿ ÿ $fPtrÿ=ÿ$fPtrÿ+ÿ1
ÿ ÿ EndIf
ÿ Next

ÿ $VerOKÿ=ÿ1ÿ ÿ ÿ ÿ ÿ ÿ ÿ ;ÿassumeÿgoodÿversion

ÿ Ifÿ$CVer[$fPtr]ÿ<ÿ$Minimum
ÿ ÿ ;ÿVersionÿrunningÿisÿlessÿthanÿminimumÿallowed
ÿ ÿ $VerOKÿ=ÿ0
ÿ ÿ $MSGÿ=ÿ"Can'tÿrunÿwithÿOutdatedÿKixÿVersion!"
ÿ Else
ÿ ÿ ;ÿIfÿanyÿcommentaryÿexists,ÿitÿisn'tÿaÿproductionÿversion.ÿ$BRCÿtrueÿallowsÿit,ÿthough.
ÿ ÿ IfÿUBound($CVer)ÿ>ÿ0ÿAndÿ$BRCÿ=ÿ0
ÿ ÿ ÿ $VerOKÿ=ÿ0ÿ ÿ ÿ ÿ ;ÿcurrent,ÿbutÿnotÿproduction
ÿ ÿ ÿ $MSGÿ=ÿ"Can'tÿrunÿwithÿBetaÿorÿReleaseÿCandidate!"
ÿ ÿ EndIf
ÿ EndIf

ÿ ;ÿPrepareÿtoÿreturnÿtheÿcurrentÿkixtartÿversion
ÿ $KixVerÿ=ÿ@KIX

ÿ ;ÿMinimumÿversionÿwasÿnotÿfound
ÿ Ifÿ$VerOKÿ=ÿ0
ÿ ÿ Ifÿ$SoftErrÿ=ÿ0
ÿ ÿ ÿ ;ÿcomplainÿandÿterminateÿscriptÿifÿversionÿisÿnotÿacceptable
ÿ ÿ ÿ ;ÿuseÿhardÿprintÿandÿnotÿMSGÿfunctionÿwhenÿterminating!
ÿ ÿ ÿ ?ÿ"VersionÿCheck!ÿNeedÿ"ÿ+ÿ$Minimumÿ+ÿ",ÿrunningÿ@KIX"
ÿ ÿ ÿ ?ÿ$MSGÿ?
ÿ ÿ ÿ Quitÿ120
ÿ ÿ Else
ÿ ÿ ÿ Exitÿ120
ÿ ÿ EndIf
ÿ EndIf

ÿ Exitÿ0

EndFunction



This function will cause a script to die if the version of Kix does not meet a minimum level, or is not a production version.

Two optional parameter control the actions - one allows the script to continue if Beta or Release Candidate versions are encountered, while the other returns an error code for alternate processing instead of terminating the script.

Usage is simple:
 

code:

$KV = Version(4.12)
$KV = Version(4.21,0,1)
$KV = Version(4.2,1,0) 

The first form will die if the version is below 4.12 or is a Beta or Release Candidate.
The second form will die if the version is below 4.21, but will permit Betas and Release Candidates.
The third form requires 4.2 or greater, won't permit Beta/Release Candidate versions, and returns an error to allow the script to perform alternate processing.

10/31/03 - Updated to work with Kix 4.22

Glenn
 
 [ 31. October 2003, 20:46: Message edited by: Glenn Barnas ]83870Label119LonkeroLabel() - Read & Write Drive Label0

code:

;FUNCTION	Label (version 1.1)
;
;AUTHOR		Lonkero
;
;ACTION		Read and Write Drive Label
;
;SYNTAX		Label("DRIVE","LABEL")
;
;PARAMETERS
;		DRIVE
;		 - drive to rename
;		LABEL
;		 - new name of the drive
;		   to read the label, leave out
;
;RETURNS
;		nothing on write.
;		on read the current label.
;		check @error for possible errors
;
;DEPENDENCIES
;		Minimum operating systems: Windows 2000/ME
;
;EXAMPLE
;		"Current Label for C: is:"
;		Label('c:')
;		? "Changing it..."
;		Label('c:\','my fancy new name')
;		if @error
;		 ? "ERROR OCCURED:" @serror
;		else
;		 ? "New Label for C: is:"
;		 Label('c:')
;		endif
;
;CODE
function label($_d,optional $_s)
 $=createobject("shell.application")
 if vartype($_s)
  $.namespace(left($_d,1)+":\").self.name=$_s
  exit @error
 else
  $label = $.namespace(left($_d,1)+":\").self.name
  exit @error
 endif
endfunction


 
 [ 07. March 2003, 11:06: Message edited by: Lonkero ]82562LASTLOGDATE79KdyerLASTLOGDATE() - Determine last Logged on or logged off1195850063

ÿCode:

;Function LASTLOGDATE()
;
;Author		Kent Dyer (leptonator@hotmail.com)
;
;Contributors	Les Ligetfalvy for code inspiration and NTDoc
;
;Action		Returns Last Logged on and Logged off dates of users using ADSI
;
;Syntax		LASTLOGDATE($DC,$Username)
;
;Version	1.2
;
;Date           16 - December - 2001
;
;Date Revised   21 - November - 2007
;
;Parameters 	DC 
;		Domain Controller were the client logs into
;
;		User
;		User you want to query
;
;Remarks	Thanks Les for pointing out the reference for IADsUser
;		Do you have people that never logoff or login? Check this out...
;		The MSDN LINK is -
;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/adsi/adsi/iadsuser_property_methods.asp
;		Update - Thanks Mart as there maybe an issue with the original posting
;
;Returns	Last Date the user Logged in ($lastlogofb, $lastloginb, $lastlogofp, $lastloginp )
; 
;Dependencies 	Kixtart 4.0, ADSI
;
;KiXtart Ver	4.02
; 
;EXAMPLE(s)	$rc=LASTLOGDATE('DC','kdyer')
;$rc=LASTLOGDATE(@LSERVER,@USERID)
; Note: The Modification on the next line maybe necessary
;$rc=LASTLOGDATE(SubStr(@LSERVER, 3),@USERID)
;

Function LASTLOGDATE($DC,$Username)
  Dim $Usr,$LLIn,$LLOff
  $Usr   = GetObject('WinNT://'+$DC+'/'+$Username+',user')
  $LLIn  = $Usr.LastLogin
  $LLOff = $Usr.LastLogoff
  $LASTLOGDATE=$LLIn,$LLOff
  Exit @ERROR
EndFunction

128590LastUserToLogin288jtokachLastUserToLogin()1098999953Code:

;FUNCTION       LastUserToLogin()

;

;ACTION         Determines the last user to interactively login to a workstation 

;               and when they logged in.

;

;AUTHOR         James Tokach ()

;

;VERSION        1.0

;

;DATE CREATED   10/28/2004

;

;DATE MODIFIED  N/A

;

;KIXTART        Tested with 4.22

;

;SYNTAX         $strVariable = LastUserToLogin()

;

;PARAMETERS     None

;

;RETURNS        NT user id and login time as comma separated values 

;

;REMARKS        wmiprvse.exe throttles way up due to WQL query

;               

;               Don't ask me to make this networkable, I wouldn't advise it nor

;               will I need it.  Feel free to post the code in this topic below.

;

;DEPENDENCIES   WMI

;               OS that has an event log

;               Must be auditing logon/logoff event in the security log

;

;EXAMPLE        Break on

;               $nul=SetOption("Explicit","On")

;               Dim $x,$aryLU

;               For Each $x in Split(LastUserToLogin(),",")

;                   ? $x

;               Next

;               ?? "Press any key to quit."

;               Get $x

;

;KIXTART BBS	http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=127669&page=0&view=collapsed&sb=5&o=&fpart=&vc=

;

Function LastUserToLogin()

    Dim $objWMI,$strMostRecentTime,$strMostRecentUser,$Event,$Events

    

    $objWMI=GetObject('winmgmts:{impersonationLevel=impersonate, (Security)}')

    If @Error<>0 Exit @Error EndIf

    

    $Events = $objWMI.ExecQuery("SELECT * FROM Win32_NTLogEvent WHERE Logfile='Security' AND EventCode=528")

    If @Error<>0 Exit @Error EndIf

    

    For Each $Event In $Events

        Dim $aryInsertionStrings,$strTimeValue,$strFormattedTime

    

        $aryInsertionStrings=$Event.InsertionStrings

    

        ; Array element 3 contains the logon type

        ; The value of 2 is an interactive logon

        If $aryInsertionStrings[3]="2"

    

            ; Reformat the time string

            $strTimeValue=$Event.TimeGenerated

            $strFormattedTime=left($strTimeValue,4)+'/'+substr($strTimeValue,5,2)+'/'+substr($strTimeValue,7,2)+' '

            $strFormattedTime=$strFormattedTime+substr($strTimeValue,9,2)+':'+substr($strTimeValue,11,2)+':'+substr($strTimeValue,13,2)

    

            ; Bubble sort

            If $strFormattedTime>$strMostRecentTime

                $strMostRecentTime=$strFormattedTime

                $strMostRecentUser=$Event.User

            EndIf

        EndIf

    Next

    

    ;? "The last user to logon was: "$strMostRecentUser

    ;? "The logon time was:         "$strMostRecentTime

    

    $LastUserToLogin=$strMostRecentUser+","+$strMostRecentTime

    

    $objWMI=""

    $Events=""

EndFunction

   83690Like1634maciepLike() - Compares two strings using wildcards0

code:

  

;*************************************************************************************************
;  Function:      Like
;  Author:        Eric Macintosh (maciep)
;  Syntax:        Like($string1, $string2, Optional $wc, Optional $sc)
;  Action:        Compares two strings using wildcards.  
;  Parameters:    
;                 $string1-  The string to be compared
;                 $string2-  The string containing the wildcards to compare against
;                 $wc-       Optional, multi-char wildcard (defaults to "*")
;                 $sc-       Optional, sing-char wildcard (defaults to "?")
;
;  Returns:       Like() returns 1 if $string1 is like $string2 otherwise it returns 0
;
;  Dependencies:  
;                 KiXtart 4.02 (I think)
;                 External udf search()
;
;  Remarks:
;                 Like has limitations based on the instr() function.  The limitations will effect 
;                 only those comparisons which have the sing-char ("?") wildcard in $string2.  Limitations 
;                 are made clear in the "Examples" section below
;
;  Examples:  
;                 Like("kixtart rules", "kix*") returns 1     
;                 Like("kixtart rules", "*ta?t*") returns 1
;                 Like("kixtart rules", "*x?a*l?s")  returns 1 
;                 Like("kixtart rules", "*t?t*")   returns 0
;                 Like("kixtart rules", "ki*r?es") returns 0
;                 
;                 Limitations - instr returns the first instance it finds. Therefore, the following 
;                               will find the 'r' in "kixtart" which will result in result in a 
;                               comparison of "t rules" and "?les" which returns 0 even though it
;                               logically makes sense that it should return 1.  So be careful and I  
;                               will work on correcting this.
;
;                 Like("kixtart rules", "*r?les") RETURNS 0
;                 
;                 
;                
; ************************************************************************************************************
function Like($string1, $string2, optional $wc, optional $sc) 
  
   if(NOT $wc)
      $wc = "*"
   endif

   if(NOT $sc)
      $sc = "?"
   endif
   
   ; base case
   if $string2 = "" or $string2 = $wc or ($string2 = $sc and len($string1) = 1)
     $Like = 1
     return
   endif
   if($string2 = $sc and len($string1) <> 1)
      $Like = 0
      return
   endif

   ; different places we may want to look for the substring.  Default to exact
   $anyWhere = 0
   $exact = 1
   $front = 2
   $back = 3
   
   $case = $exact

   $j = 1
   $subString = ""
   
   ;if the first character is the single character wildcard
   ;remove the first character from both strings and
   ;call Like() again
   if(substr($string2, 1, 1) = $sc)
      $string2 = substr($string2, 2, len($string2) -1)
      $string1 = substr($string1, 2, len($string1) -1)
      $Like = Like($string1, $string2, $wc, $sc)
      return
   endif
   
   
   ;if the first two characters of the string are 
   ;the multi-char wildcard and the sing-char wildcard (i.e. "*?string")
   ;then that together represents 1 or more characters.  
   if(substr($string2, 1, 1) = $wc and substr($string2, 2, 1) = $sc) 
      if(len($string2) = 2 and $string1 = "")
         $Like = 0
         return
      endif
      $string2 = $wc + substr($string2, 3, len($string2) - 2)
      $string1 = substr($string1, 2, len($string1) -1)
      $Like = Like($string1, $string2, $wc, $sc)
      return
   endif
         

   ;if the first character of the string is the
   ;multi-char wildcard then set the appropriate case
   ;and move onto the next character

   if(substr($string2, 1, 1) = $wc)
      $j = 2                        
      $case = $back                 
   endif
   
   ;Build the search string
   $curChar = substr($string2, $j, 1)
   while($curChar <> "" And $curChar <> $wc And $curChar <> $sc)   ; build the substring until we hit a wildcard
      $subString = $subString + $curChar                           ; or until we get to the end of $string2
      $j = $j + 1
      $curChar = substr($string2, $j, 1)                       ; building the substring
   loop
   
   if($curChar = $wc or $curChar = $sc)  ; there was a wildcard found in $string2
      if($case = $back)
        $case = $anyWhere  ; one percent in front and one in back, ex: *string2*
      endif
      if($case = $exact)  ; one percent in back, ex: string2*
        $case = $front    
      endif
   endif

   $inThere = search($string1, $subString, $case) ; search for substring given where to look for it
   
   if(NOT $inThere)
     $Like = 0
     return
   endif
   $string1 = substr($string1, $inThere + len($subSTring))            
   $string2 = substr($string2, $j)                                     
   $Like = Like($string1, $string2, $wc, $sc)
   
endfunction   

;************************************************************************************************

function search($searchIn, $searchFor, $searchHow)

   $posInString = instr($searchIn, $searchFor)
   if($searchHow = 0)             ;look anywhere for $searchFor in $searchIn
     $search = $posInString
   endif

   if($searchHow = 1)             ; must be an exact match (no wildcards)
      if($searchIn = $searchFor) ;$posInString <> 0 and len($searchIn) = len($searchFor))
         $search = $posInString
      else
         $search = 0
      endif
   endif

   if($searchHow = 2)            ;$searchIn must start with $searchFor
       if($posInString = 1)
          $search = $posInstring
       else
          $search = 0
       endif
   endif

   if($searchHow = 3)           ;$searchIn must end with $searchFor
       if(substr($searchIn, len($searchIn) - len($searchFor) + 1) = $searchFor) 
          $search = len($searchIn) - len($searchFor) + 1
       else
          $search = 0
       endif
   endif
 endfunction


 
 [ 26. November 2002, 15:19: Message edited by: Radimus ]159690ListNestedGroups52NTDOCListNestedGroups() - Query AD for all groups of an account + nested0

;Function	ListNestedGroups()    
;      
;Authors	NTDOC and Glenn Barnas  
;		(Glenn came up with new method to Golf down the original code) 
;      
;Action		Retrieves a list of all the groups an account is a member of including 
;		nested groups which normally are not seen.  This can be useful for locating 
;		security holes where users have rights they shouldn't have due to nested groups. 
; 
;NOTE: 
;		Based on The Scripting Guys code from here 
;	        MS Scripting Guys 
; 
;		Grabbing again from the MS Scripting Guys 
;		Due to the way the Groups method and Active Directory work, normal scripts cant return  
;		all of Ken Myers group memberships unless it checks to see whether Groups A and B belong  
;		to any other groups.  This script can now do that. 
; 
;		The Scripting Guys code shows the nested groups but also allowed duplicates to be returned. 
;		This KiX UDF does not because the guys at Korg cared the most to bring you the best 
;		In the example you'll see Administrators twice, but strictly speaking they're not duplicates 
;		Running the Scripting Guys code returns 3 entries for Administrators 
;          
;		The Source looks large only because we commented it and showed a good example of running it 
;      
;Syntax		ListNestedGroups($_Account,Optional $_Nested)   
;      
;Version	1.0      
;      
;Date		2006-Mar-23      
;      
;Date Revised	xxxx-xxx-xx   
;      
;Revised Reason   
;      
;Parameters	ListNestedGroups($_Account,Optional $_Nested)  
;		$_Account = The full LDAP path to the account you want to check  
;		$_Nested  = This is a two part flag to determine what nested groups to show  
;		0 or blank = Show all groups including nested 
;		1 = Show all groups but flag the nested groups with <Nested> tag 
;		2 = Show only Nested groups 
;		 
;Returns	Array of the groups, or Error level on error 
;      
;Dependencies	None, this is a two part UDF that uses a sub-function to operate 
;      
;KiXtart Ver	Written and tested with KiXtart v4.52 beta 2 on 2000/XP/2003 against 2003-AD and 2000-AD 
; 

 

;Source 
 
Function ListNestedGroups($_Account,Optional $_Nested)
  Dim $_objUser, $_colGroups, $_objGroup, $_Grps, $_NFlag
  Dim $_W, $_Element, $_TempString, $_OD, $_CN, $_ERR
 
  ; init the vars 
  $ListNestedGroups = 0                          ; default return value if errors occur 
  $_Nested = Val($_Nested)                       ; force to numeric value 
  $_NFlag = IIf($_Nested = 1, ' <Nested>', '')   ; set the output message for nested groups 
 
  $_objUser = GetObject($_Account)               ; instantiate the object 
  $_ERR = Val('&' + Right(DecToHex(@ERROR), 4))  ; get last 4 nybbles (2 bytes) of the error code 
  If $_ERR Exit $_ERR EndIf
 
  $_colGroups = $_objUser.Groups                 ; get the collection 
 
  For Each $_objGroup in $_colGroups
 
    $_OD = GetNested($_objGroup)                 ; nested group name 
    $_CN = $_objGroup.CN                         ; parent group name 
 
    ; Write the nested group name (and optional NESTED tag) to the index file 
    If $_OD <> ''
      If InStr($_TempString, $_OD) = 0
         $_TempString = $_TempString + $_OD + $_NFlag + Chr(10)
      EndIf
    EndIf
 
    ; write the parent group name to the index file, unless in nested-only mode 
    If $_Nested < 2
      If InStr($_TempString, $_CN) = 0
         $_TempString = $_TempString + $_CN + Chr(10)
      EndIf
    EndIf
 
  Next
 
  ; enumerate the index and put the value(s) into an array 
  $_Grps = Split(Left($_TempString,Len($_TempString)-1), Chr(10))
 
  ; Return the array of groups, and exit with success 
  $ListNestedGroups = $_Grps
  Exit 0
EndFunction
 
; Sub-Function for returning nested groups 
Function GetNested($objGroup)
  Dim $_colMembers, $_strMember, $_strPath, $_objNestedGroup, $_ERR
  ; init the return value to a null string 
  $GetNested = ''
  ; get the collection 
  $_colMembers = $objGroup.GetEx("memberOf")
  ; enumerate the collection 
  For Each $_strMember in $_colMembers
    $_strPath = "LDAP://" + $_strMember
    $_objNestedGroup = GetObject($_strPath)
    $GetNested = $_objNestedGroup.CN
  Next
  Exit 0
EndFunction
 

;Example Note: REQUIRES CombSort UDF to run this example as intended 
;              CombSort() - The combsort algorithm for kixtart arrays  
;              http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=81993 
;              The ListNestedGroups UDF will run without CombSort, it just won't be sorted. 
;Example:    
 
 
Break On
Dim $SO, $LDAP
$SO=SetOption('Explicit','On')
$SO=SetOption('NoVarsInStrings','On')
$SO=SetOption('NoMacrosInStrings','On')
 
   ; Need to fill in the $LDAP var with the account you want to get  
   ; the list of groups for 
$LDAP = "LDAP://CN=Ken Myer,OU=Finance,DC=fabrikam,DC=com"
 
CLS
Dim $Group, $Groups, $Index, $CC
 
; Create and set an index to show numbers 
$Index = 0
 
; Grab the current console colors 
$CC = @Color
Color G+/R+
'ALL Groups' ?
 
; Reset the previous console colors back 
Color $CC
 
; Assign the returned data to $Groups var 
; Make the call to CombSort() with the returned data from ListNestedGroups() UDF 
; to sort the returned data 
$Groups = CombSort(ListNestedGroups($LDAP, 0))
 
If @ERROR
  'Unexpected error retrieving groups. ' + @ERROR + ' - ' + @SERROR ?
Else
  If UBound($Groups) >= 0
    For Each $Group In $Groups
      ; Show our list of groups sorted, including the index number 
      ''+$Index + ': ' + $Group ?
 
      ; Increment the index 
      $Index = $Index + 1
    Next
  EndIf
EndIf
 
$Index = 0
$CC = @Color
Color R+/W+
? 'ALL Groups [ with nested flagged ]' ?
Color $CC
$Groups = CombSort(ListNestedGroups($LDAP, 1))
If @ERROR
  'Unexpected error retrieving groups. ' + @ERROR + ' - ' + @SERROR ?
Else
  If UBound($Groups) >= 0
    For Each $Group In $Groups
      ''+$Index + ': ' + $Group ?
      $Index = $Index + 1
    Next
  EndIf
EndIf
 
$Index = 0
$CC = @Color
Color B+/W+
? 'Nested Groups only' ?
Color $CC
$Groups = CombSort(ListNestedGroups($LDAP, 2))
If @ERROR
  'Unexpected error retrieving groups. ' + @ERROR + ' - ' + @SERROR ?
Else
  If UBound($Groups) >= 0
    For Each $Group In $Groups
      ''+$Index + ': ' + $Group ?
      $Index = $Index + 1
    Next
  EndIf
EndIf
 
 
Function CombSort($v, Optional $o)
  Dim $i,$j,$m,$s,$g,$n
  $n=UBound($v)
  $g = $n
  If $g
    While $g > 1 Or Not $s
      $g=($g*1000)/1279
      If $g < 1
        $g = 1
      EndIf
      $s=1
      For $i = 0 To $n-$g
        $j=$i+$g
        If ($v[$i] > $v[$j] And Not $o) Or ($v[$i] < $v[$j] And $o)
          $m = $v[$i]
          $v[$i] = $v[$j]
          $v[$j] = $m
          $s=0
        EndIf
      Next
    Loop
    $CombSort = $v
  Else
    $CombSort = 0
  EndIf
EndFunction
 
 
 
Here is an image of what the above Example Code will produce.
 
  
 
 
138962LoadArrayFromFile1399Christophe MelinLoadArrayFromFile() - load a file in an array1115029989 Code:


;------------------------------------------------------------------------------ 
;function: 
;   LoadArrayFromFile 
; 
;Author: 
;   Christophe MELIN 
; 
;Version: 
;   1.0 
; 
;Version History: 
; 
;Action: 
;   load a file in an array 
; 
;Syntax: 
;   LoadArrayFromFile( $filename, optional $commentchar, optional $sort ) 
; 
;Parameters: 
;   filename        : REQUIRED. name of the file 
;   commentchar     : OPTIONAL. if beginning of lines read in the file matchs this string, 
;                     line is not added in the array (considered as comments) 
;                     (useful to comment lines in a .csv file for example) 
;   sort            : OPTIONAL. sort the array after file is loaded 
; 
;Remarks: 
; 
;returns: 
;   the array that contains lines of the file. 
;   errorcode in the @ERROR macro. 
;------------------------------------------------------------------------------ 
function LoadArrayFromFile( $filename, optional $commentchar, optional $sort )
    dim $, $comment, $handle

    if not $sort    $sort = 0    endif
    if not $commentchar
        $comment = 0
    else
        $comment = 1
    endif

    $handle = freefilehandle()
    if open($handle, $filename, $vbOpen | $vbForReading )<0
        exit 1
    endif

    ;-- declare variables -- 
    dim $arrSize, $arrSizeIncrement
    $arrSizeIncrement = 1024
    $arrSize = 0
    dim $arr[$arrSize]

    dim $CurrentIndex
    dim $Line, $add

    ;-- load file -- 
    $CurrentIndex = -1
    $line = ReadLine($handle)
    while (not @error)
        if $line
            $add = 1
            if $comment
                if left($line,len($commentchar))=$commentchar
                    $add = 0
                endif
            endif

            if $add
                $CurrentIndex = $CurrentIndex + 1
                if $CurrentIndex>$arrSize
                    $arrSize = $arrSize + $arrSizeIncrement
                    Redim preserve $arr[$arrSize]
                endif
                $arr[$CurrentIndex] = $line
            endif
        endif

        $line = ReadLine($handle)
    loop
    $=close($handle)
    if ($CurrentIndex>-1)
        Redim preserve $arr[$CurrentIndex]

        if $sort
            ;-- sort the array -- 
            $LoadArrayFromFile = QuickSort( $arr )
        else
            $LoadArrayFromFile = $arr
        endif
        exit 0
    else
        exit 2
    endif
endfunction

 

Load a file in an array and can sort the result.
Can also skip line considered as comment (as defined by a parameter)

useful to load a data file in .csv format165959LoadFile28BryceLoadFile() - Load a file into a variable/array1176381965

ÿCode:

/* 
Function	LoadFile()

Author		Bryce Lindsay Bryce@isorg.net

Action		Loads a file in to a variable or an array.

Syntax		LoadFile("Filename",[Array Delim], [UNI/ANSI file type])

Version	1.1

Date Revised	9:14 AM 8/15/2006

Parameters	Filename
		name of the file that you want to load.

		Optional Array
		set this option if you want to return the 
		information as an array split on the given value

		Unicode/ANSI file type
		3 = force file open as ANSI
		2 = forse file open as UNI
		1 = Opens the file using the system default. (the UDF will use this as default)

Remarks		finaly made this into a UDF and posted it... got tired 
		of having to hunt it down.

Returns		if the array flag is not set it returns a variable 
		containing the contents of the file.

		if the array flag is set, it will return an array 
		of the file split on the value of the given variable

Dependencies	Scripting.FileSystemObject

KiXtart Ver	4.51
 
Example(s)	
		;load the file test.txt into a variable
		$Data=loadfile('test.txt')
		? $data 

		;load the file "test.txt" into an array split on @crlf
		$data = loadfile('test.txt',@crlf)
		for each $line in $data
			? $line
		next
*/
Function loadfile($file, optional $array, $Uni)
	DIM $fso,$f,$fs
	if $uni $uni = $uni-3 else $uni = -2 endif

	if not $uni $uni = -2 endif
	$fso = CreateObject("Scripting.FileSystemObject")
	$f = $fso.GetFile($file)
	If @ERROR Exit 2 EndIf
	$fs = $f.OpenAsTextStream(1,$uni)
	if not $array
		$loadfile = $fs.Read($f.size)
	else
		$loadfile = Split($fs.Read($f.size),$array)
	endif
	Exit @ERROR 
EndFunction
84156LocalAdmin119LonkeroLocalAdmin() - checks for membership of local admin group0


;Function:

;	LocalAdmin()

;

;Author:

;	Lonkero (Jooel_Nieminen@hotmail.com)

;

;Version:

;	1.0

;

;Version History:

;	1.0 - 5.5.2003 - initial release

;

;Action:

;	Checks if user is member of workstation's administrators group

;

;Syntax:

;	LocalAdmin()

;

;Parameters:

;	none

;

;Remarks:

;	this is more like an macro than a UDF   

;	and only reason for this is to handle all windows versions and languages

;

;Returns:

;	1 - User has Administrative rights over the Workstation

;	0 - User doesn't have administrative rights

;

;Dependencies:

; 	none

;

;Example:

;	if LocalAdmin

;	 "Dude we are powerfull!"

;	else

;	 "sad to say this but you are screwed."

;	endif

;

;Source:

function LocalAdmin()

 $LocalAdmin=ingroup('@wksta\'+sidtoname('S-1-5-32-544'))-1+@inwin

endfunction

83453Log588SchuliebugLog(): Log string to file or console0

code:

;Author         Jan.Schulenburg@tui.nl
;
;Parameters     1: required indicating message to display or log.
;               2: optional indicating logfile to write message to.
;
;Remarks        this function displays the text if $LogFile="" or empty and logs
;               the text if $LogFile is a file.
;
;Returns        nothing, errorlevel>0 if failes.
;
;Dependencies   None
;
;Example(s)     $ReturnCode = Log("Map of drive $Drive failed !!")
;
Function Log($Message,Optional $LogFile)
	Dim $LogFile

	; Check parameters.
	$Log=''
	$LogFile=''+$LogFile
	If 0=VarType($Message) Exit(1) EndIf
	If $LogFile
		; Check if logfile directory exists..
		If Not GetFileAttr(SubStr($LogFile,1,InStrRev($LogFile,'\')-1)) & 16 Exit(2) EndIf

		If RedirectOutput($LogFile,0)=0
			? "@DATE, @TIME: $Message"
			$=RedirectOutput("")
		Else Exit(3) EndIf
	EndIf
EndFunction


 
 [ 30. August 2002, 17:06: Message edited by: Schuliebug ]82988LoggedinUsers17SealeopardLoggedinUsers() - Retrieves a list of users/SIDs currently logged into a computer0

code:

;FUNCTION      LOGGEDINUSERS()
;
;ACTION        Retrieves a list of users/SIDs currently logged into the specified computer
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.4 (cleaned up code, added error code return)
;              1.3 (removed dependency)
;              1.2
;
;DATE CREATED  2002/02/13
;
;DATE MODIFIED 2003/06/24
;
;KIXTART       4.20+
;
;SYNTAX        ARRAY = LOGGEDINUSERS([COMPUTER])
;
;PARAMETERS    COMPUTER
;              Optional string specifying the remote computer to check, by default the local
;              computer will be used to retrieve the list of users
;
;RETURN        List of usernames/SIDs
;
;REMARKS       Services that run under a specific user account will be returned, too. This function is
;              not limited to interactive sessions.
;
;DEPENDENCIES  none
;
;EXAMPLE       $array = loggedinusers('WORKSTATION')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000167
;
function loggedinusers(optional $computer)
  Dim $regkey, $hivelist, $hive, $usersid, $username
  Dim $userlist

  $loggedinusers=''
  $regkey='HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\HiveList'
  if trim($computer)
    $regkey='\\'+trim($computer)+'\'+$regkey
  endif
  if keyexist($regkey)
    do
      $hive=enumvalue($regkey,ubound($hivelist)+1)
      if not @ERROR
        redim preserve $hivelist[ubound($hivelist)+1]
        $hivelist[ubound($hivelist)]=$hive
      endif
    until $hive=259 or @ERROR

    for each $hive in $hivelist
      if instr($hive,'\REGISTRY\USER') and not instr($hive,'\REGISTRY\USER\.DEFAULT')
        $usersid=right($hive,len($hive)-instrrev($hive,'\'))
        $username=sidtoname($usersid)
        if $username=''
          $username=$usersid
        endif
        if ascan($userlist,$username)=-1
          redim preserve $userlist[ubound($userlist)+1]
          $userlist[ubound($userlist)]=$username
        endif
      endif
    next
  endif

  if ubound($userlist)+1
    $loggedinusers=$userlist
  endif
  exit 0
endfunction


 
 [ 25. June 2003, 02:53: Message edited by: sealeopard ]83638LOGGER79KdyerLOGGER() - Write to log when available0

code:

;Function	LOGGER($logfil,$logdat)
;
;Author		Kent Dyer (leptonator@hotmail.com)
;
;Contributors	MBrecht on CramSession.com
;                http://infocenter.cramsession.com/TechLibrary/GetHtml.asp?ID=721&GetDes=&CatID=293
;               "Create Loginlog"
;               Jooel (Lonkero) - Code cleanup
;               Howard Bullock
;
;Action		Writes to a Server Log
;
;Syntax		LOGGER($logfile,$logdata)
;
;Version	1.2 - Recommendation by Howard Bullock
;                1.1 - Clean-up by Lonkero
;
;Parameters 	$logfile - Specify what server, share, and file is needed
;               $logdata - Data to be written to the log
;
;Remarks	This script addresses an issue with writing to logs if the file is open by
;               another user it waits until they are done and has the log file closed.
;               It does a 1 second wait until ready to write to the log till a maximum of 6 seconds and then exits the routine.
;               The 5x3 wait routine is not used anymore.
;
;Returns	Writes to a file.  No visible user output.
; 
;Dependencies 	All Domain Users being able to write to a server share
;
;KiXtart Ver	4.02
; 
;Example(s)	; -- Data
;               $logshare='\\SERVER\LOGINFO'
;               $logfile=$logshare+'\HOTBAR.TXT'
;               $logdata=@date + ',' + @time + ',' + @userid + ',WinNT,' + @wksta + @CRLF
;               ; -- Example
;               LOGGER($logfile,$logdata)
; 
FUNCTION LOGGER($logfile,$logdata)
  DIM $n
       While Open(1,$logfile,5)<>0
             If $n
                   '.'
             Else
                   ? 'Please wait'
             EndIf
             $n=$n+1
             If $n=6
                Exit(1)
             Endif
             Sleep 1
       LOOP
  $n=WriteLine(1, $logdata)
  $n=Close(1)
 ENDFUNCTION


 
 [ 28. October 2003, 16:49: Message edited by: kdyer ]82774LogInfo170Will HetrickLogInfo() - Login Script Information to Log File.0FUNCTION Loginfo() 
AUTHOR
Wilbur Hetrick (WVHetrick@hotmail.com) 
ACTION
Used to make login script log files.
SYNTAX
LogInfo (\\Path\File, "Info") 
PARAMETERS
\\path\file (Required)
- Path and file name of the log file. 
Info (Required)
- Information to put in log file. i.e. 
- If Information is left out, the log will just show a blank line 
REMARKS
I wrote this to condense my login script
RETURNS
Nothing - Use @error to test for success. 
DEPENDENCIES
Kix 4.0 
EXAMPLES 
LogInfo("\\server\log$\VERSION.LOG","@DATE @TIME,@WKSTA,@USERID,$Macver,$regver,$engver")
LogInfo($Server16 + "log$\version.log","@DATE @TIME,@WKSTA,@USERID,$Macver,$regver,$engver")
$String = "@DATE @TIME,@WKSTA,@USERID,$Macver,$regver,$engver"
LogInfo($serverpath,$string)

code:

 
FUNCTION LOGINFO($FILE,$STRING)
	$junk = RedirectOutput($file)
	$string ?
	$junk = RedirectOutput("")
ENDFUNCTION

 


 
 [ 28. October 2002, 19:48: Message edited by: Radimus ]82773LogNote1**DONOTDELETE**LogNote() - Log a quick note a text delimited file0FUNCTION LogNote()

AUTHOR
 Mark Pearce (mpearce009@earthlink.net)

ACTION
 Writes a simple note to a comma separated text file.

SYNTAX
 LogNote( LogFile, "Note")

PARAMETERS
 LogFile (Required)
 - Path and file name of the logfile to record the note.

 Note (Optional)
 - Text to put in log file.  i.e. "Script start" or "Install done"
 - If Note is left out, the log will just show Workstation name, UserID, Login server, Date, Time

REMARKS
 I know I didn't invent this, but I use it all the time so I thought it would make a good UDF.

RETURNS
 Nothing - Use @error to test for success.

DEPENDENCIES
 Kix 4.0

EXAMPLES

 $logpath = "\\server1\reports\"
 $logfile = $logpath + "logtest.log"
 $infofile = $logpath + "Infotest.log"
 LogNote($LogFile, "Start")
   Gosub "DoStuff"
 LogNote($LogFile, "Finish")
 LogNote($InfoFile, @COMMENT+","+@FULLNAME+","+@HOMEDIR+","+@HOSTNAME+","+@IPADDRESS0+","+@ADDRESS)
 exit(0)

code:

Function LogNote($logfile,Optional $var1)
 DIM $y, $e1, $e2, $s, $filenum
 $filenum = 3 ; File Number - Possible values range from 1 to 10.
 $s = ","     ; Separator - character to separate the data for import into Excel.
 $y = @wksta + $s +  @userid + $s + SUBSTR(@lserver, 3,LEN(@lserver)) + $s + @date + $s + @time + Chr(13) + Chr(10)
 If $var1 <> ""
   $y = $var1 + $s + $y
 ENDIF
 IF Open( $filenum , "$logfile" , 5 ) = 0
   $e1 = WriteLine( $filenum , $y)
   $e2 = Close($filenum)
 ELSE
   $e1 = 1
 ENDIF
 exit($e1 + $e2)
ENDFunction


 
 [ 21. February 2003, 18:18: Message edited by: mpearce ]83564Lookup31RadimusLookup() - resolves IP to hostname0Uses nslookup to resolve ip to host name

Example: $hostname=lookup($ip)

Returns: Hostname or '' and @error=1

requires WSHPipe()

Ver: 1.1 - Feb 07, 03


Function Lookup($ip)
Dim $return
$return=WSHPipe('%comspec% /c nslookup $ip | find "Name:"',1)[0]
if instr($return,"Name:")
$lookup=trim(split($return,':')[1])
else
exit 1
$lookup=""
endif
endfunction


 
 [ 07. February 2003, 15:29: Message edited by: Radimus ]119986LookupIP46kholmLookupIP() - Get IP-address for a DNS-name0Code:

;FUNCTION LookupIP() 
;
;ACTION:
;   Get IP-address for a DNS-name
; 
;AUTHOR:
;   KHOLM
; 
;VERSION:
;   1.0
;
;DATE CREATED:
;   23 may 2004
;
;KIXTART:
;   4.22
; 
;SYNTAX;
;   LookupIP($Name) 
;
;PARAMETERS:
;   $Name:  Name of target
;
;RETURNS:
;   IP_address. if successfull
;   otherwise noting and @Error = 1
;
;DEPENDENCIES:
;   Windows XP or Server 2003
;
;EXAMPLE:
;   $Name = 'KiXtart.org'
;   $Res = LookupIP('KiXtart.org')
;   If @Error
;      ? 'IP-address for: ' + $Name + ' not found'
;   Else
;      ? 'IP-address for: ' + $Name + ' is: ' + $Res
;   EndIf
;
;SOURCE:
Function LookupIP($Name)
   Dim $Query,$oWMI,$oItem,$cItems
   
   $Query = "Select ProtocolAddress,StatusCode From Win32_PingStatus Where Address='" +
      $Name + "' And ResolveAddressNames=-1"
   $oWMI = GetObject("winmgmts:root\cimv2")
   $cItems = $oWMI.ExecQuery($Query)
   For Each $oItem In $cItems
      If (VarTypeName($oItem.StatusCode) = 'Null') Or $oItem.StatusCode
         Exit 1
      Else
         $LookupIP = $oItem.ProtocolAddress
      EndIf
   Next
EndFunction



-Erik  119987LookupName46kholmLookupName() - Get DNS-name for an IP-address0Code:

;FUNCTION LookupName() 
;
;ACTION:
;   Get DNS-name for an IP-address
; 
;AUTHOR:
;   KHOLM
; 
;VERSION:
;   1.0
;
;DATE CREATED:
;   23 may 2004
;
;KIXTART:
;   4.22
; 
;SYNTAX;
;   LookupName($Address) 
;
;PARAMETERS:
;   $Address:   IP-address of target
;
;RETURNS:
;   DNS-name. if successfull
;   otherwise noting and @Error = 1
;
;DEPENDENCIES:
;   Windows XP or Server 2003
;
;EXAMPLE:
;   $Add = '195.140.240.55'
;   $Res = LookupName($Add)
;   If @Error
;      ? 'DNS-name for: ' + $Add + ' not found'
;   Else
;      ? 'DNS-name for: ' + $Add + ' is: ' + $Res
;   EndIf
;
;SOURCE:
Function LookupName($Address)
   Dim $Query,$oWMI,$oItem,$cItems
   
   $Query = "Select ProtocolAddressResolved,StatusCode From Win32_PingStatus Where Address='" +
      $Address + "' And ResolveAddressNames=-1"
   $oWMI = GetObject("winmgmts:root\cimv2")
   $cItems = $oWMI.ExecQuery($Query)
   For Each $oItem In $cItems
      If (VarTypeName($oItem.StatusCode) = 'Null') Or $oItem.StatusCode
         Exit 1
      Else
         $LookupName = $oItem.ProtocolAddressResolved
      EndIf
   Next
EndFunction



-Erik  84708MAILER79KdyerMAILER() - e-mail recipient/recipients0Code:


 ;Function MAILER() 

 ;Author  Kent Dyer(Leptonator@hotmail.com) 

 ;Action  e-Mail a recipient or recipients 

 ;Syntax  MAILER($recipient,$sender,$subject, $body,$attachment) 

 ;Version 1.2

 ;Revision History:

 ;               1.0,1.1: 28-Oct-2003 - Initial Version

 ;               1.2: 13-May-2004 - Added Functionality

 ;Date           28-October-2003 

 ;Date Revised   15-May-2004

 ;Parameters	recipient

 ;		Recipient of the e-mail

 ;		Optional sender

 ;		Sender of the e-mail 

 ;              Optional subject

 ;              Subject line of the e-mail 

 ;              Optional body 

 ;              Content of the e-mail to send 

 ;              Optional attachment

 ;              Attachment to add to the e-mail

 ;Remarks This is a e-mailer script 

 ;        There are a number of other example or methods used at 

 ;        http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Board=UBB10&Number=113701

 ;       "How do I send e-mail from KiXtart- (SMTP)" 

 ;        You need to replace smtp.company.com with yours..

 ;Returns Nothing 

 ;Dependencies 

 ;       BLAT 

 ;       http://www.blat.net/194/ (Now part of SourceForge)

 ;       SMTP server to e-mail through 

 ;KiXtart Ver 4.02 

 ;Example(s) MAILER('recipient@@company.com','sender@@company.com','Offline','Server is off-line '+@time) 

 ;           MAILER('recipient@@company.com,recipient2@@company.com','sender@@company.com','Offline','Server is off-line '+@time) 

 ;	     MAILER('recipient@@company.com,recipient2@@company.com',,,$log)

 ;           MAILER('recipient@@company.com',,,$log)

 ;KIXTART BBS 	http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Board=UBB12&Number=83710

  FUNCTION MAILER($recipient,OPTIONAL $sender,OPTIONAL $subject,OPTIONAL $body, OPTIONAL $attachment)

    DIM $mailhost,$mailline

    $mailhost = 'smtp.company.com'

    IF NOT $sender

       $sender = 'ProfileRemoveReport'

    ENDIF

    $mailline=@ldrive+'Programs\blat.exe '

    IF $attachment

       $mailline=$mailline+$attachment

    ELSE

       $mailline=$mailline+'-'

    ENDIF

    IF $subject

       $mailline=$mailline+' -subject '+$subject

    ENDIF

    $mailline=$mailline+' -to '+$recipient

    $mailline=$mailline+' -server '+$mailhost

    IF $body

       $mailline=$mailline+' -body '+$body

    ENDIF

    $mailline=$mailline+' -f '+$sender

    $mailline=$mailline+' -q'

    SHELL $mailline

 ENDFUNCTION

84308MakeCab119LonkeroMakeCab() - Create windows cabinet file package with specified files included1119309401;Function:  
;        MakeCab()
;  
;Authors:  
;        Lonkero  
;  
;Version:  
;        1.1
;  
;Version History:  
;        1.1.2      21.6.2005
;                fixed problems with w2k3
;
;        1.1        19.5.2003
;                added some errorcodes and fixed many buggies
;
;        1.0        19.5.2003
;                initial code
; 
;Action:  
;        Makes Cabinet file
;  
;Syntax:  
;        MakeCab(CAB,FILES)
;  
;Parameters:  
;        CAB  
;                REQUIRED STRING
;                Cabinet file to create
;        FILES
;                REQUIRED STRING OR ARRAY OF STRINGS
;                Full paths to files to include
;
;Remarks:  
;        Tested only on w2k and XP (thanks shawn)
;        YEAH, Nice KIXpackager finally!
;  
;Returns:  
;        if one file added, returns it's adding error.
;        if multiple files added (array) returns same sized array with 
;        errorcode for each file in their respective element.
;
;        if fatal error (can't even create the cab), sets errorcode but returns nothing
;
;Errorcodes:
;        0        Success
;        2        File does not exist
;        183        CAB file already exist
;        120        Failed to create makecab-object
;        156        Unknown error while adding file to cabinet
;
;Dependencies:  
;        None that I know of
;  
;Examples:
;        1,
;        $return=MakeCab("c:\myCabFile.cab","C:\boot.ini")
;        if @error
;         "error Occured: @error"
;        else
;         if not $return
;          "cab created successfully"
;         else
;          "error adding file boot.ini - " $return
;         endf
;        endif
;
;        2,
;        $my_files="c:\winnt\uptime.exe","c:\winnt\winhelp.exe"
;        $returns=MakeCab("c:\my_multifile.cab",$my_files)
;        if @error
;         "cab creation failed"
;        else
;         "these were the errors that occured during adding files:"
;         for $counter=0 to ubound($my_files)
;          ? $my_files[$counter] " - " $returns[$counter]
;         next
;        endif
;  
;Source:  
function MakeCab($Cab,$Files)
 dim $[0],$!,$maker
 if exist($Cab) exit 183 endif
 if 8=vartype($Files) $[0]=$Files $Files=$ endif
 $maker=CreateObject("MakeCab.MakeCab.1")
 if @error exit 120 endif
 $MakeCab=$Files
 if @dos>"5.0"
  $maker.CreateCab($Cab,0,0, not 1)
 else
  $maker.CreateCab($Cab,0,0)
 endif
 for $=0 to ubound($Files)
  if not exist($Files[$])
   $MakeCab[$]=2
  else
   $!=split($Files[$],"\")
   $maker.AddFile($Files[$],$![ubound($!)])
   if @error
    $MakeCab[$]=156
   else
    $MakeCab[$]=0
   endif
  endif
 next
 $maker.closecab
 if not ubound($MakeCab) $=$MakeCab $MakeCab=$[0] endif
endfunction


[ 19. May 2003, 01:25: Message edited by: Lonkero ]

board messed the html up but well...
now it should be copy&pasteable code.82282MakePath11ShawnMakePath() - Create deep directory paths on local and remote systems0MakePath()

Action:

Create deep directory paths on local and remote systems

Syntax:

MakePath("Path")

Parameters:

Path (Required): A string representing the the directory path 
to create. Can be UNC or local path. Creates all directories along 
along the path if they do not already exist.

Returns:

@ERROR set to 0 (zero) on success -1 on invalid path or relevent error code on failure

Remarks:

Dependencies:

KiXtart 4.0 (Final)

Example(s):

MakePath("c:\folder1\folder2")

MakePath("\\server\share\folder1\folder2")

Source:

code:


Function MakePath($Path)
 dim $dirs,$maxdirs,$index,$count,$rpath
 $dirs = split($Path, "\")
 $maxdirs = ubound($dirs)
 if instr($Path, "\\") = 1
  if $maxdirs < 4
   exit -1
  else
   $rpath = "\\"+$dirs[2]+"\"+$dirs[3]
   $index = 4
  endif
 else
  $rpath = $dirs[0]
  $index = 1
 endif
 select
 case $maxdirs < $index
  exit -1
 case $maxdirs = $index and $dirs[$maxdirs] = ""
  exit -1
 case 1
  for $count = $index to $maxdirs
   $rpath = $rpath + "\" + $dirs[$count]
   if not exist($rpath)
    md "$rpath"
    if @ERROR
     exit(@ERROR)
    endif
   endif
  next
 endselect
EndFunction 

Author(s):

Idornak #2051
with mods by:
Shawn Tassie #173

[ 27 November 2001: Message edited by: Shawn ]83567MakePathsFromADlocation172Howard BullockMakePathsFromADlocation () - Builds an array of paths from OU hierarchy0


;FUNCTION         MakePathsFromADlocation()

;

;VERSION          1.1

;

;AUTHOR           Howard A. Bullock (hbullock@tycoelectronics.com)

;

;ACTION           Use TranslateName() to return the Conical Name of an account from the ActiveDirectory.

;                 The concical name is then split up and the parts are used to build a seies of directory

;                 paths that are stored in an array. Certain characters that are invalid in in directory

;                 names are removed from the conical name and are not included in the final path.

;

;

;SYNTAX           MakePathsFromADlocation($Domain, $Account)

;

;PARAMETERS       $Domain (Required) -  String

;                 $Account (Required) -  String

;

;

;REMARKS          This function is called to build various paths that leverage the AD OU hierachy of where

;                 the account resides.

;

;RETURNS          Array

;

;DEPENDENCIES     TranslateName() UDF

;

;EXAMPLES         MakePathsFromADlocation(@LDomain, @UserID)

;                 MakePathsFromADlocation(@Domain, @wksta + "$$")

;

;

Function MakePathsFromADlocation ($Domain, $Account)

   Dim $Conicalname, $char, $piece, $path[0]



   ;retrieve conical name from AD's global catalog

   $Conicalname = TranslateName (3, "", 3, $Domain + "\" + $Account, 2)

   If $Conicalname[1] = 0

      ;Remove characters that are invalid in directory names.

      $chars = '\/', '\', ':', '*', '?', '"', '<', '>', '|'

      for each $char in $chars

         ; JOIN requires KiXtart 4.11 or higher.

         ;$Conicalname[0] = join(split($Conicalname[0], $char),"")

         ;



         ;Start KiXtart 4.02 compatible code for JOIN replacement

         Dim $temp

         for each $piece in split($Conicalname[0], $char)

            $temp = $temp + $piece

         next

         $Conicalname[0] = $temp

         ;End KiXtart 4.02 compatible code for JOIN replacement

      next





      ; Build and array of directory paths

      ; Stripping off the domain and the (computer or user)



      ; split full name into pieces (directories names)

      $piece = split($Conicalname[0], "/")

      ReDim $path[ubound($piece)-1]

      $path[0] = "netlogon";

      for $i=1 to ubound($path)

         $path[$i] = $path[$i-1] + "\" + $piece[$i]

      next

   Else

      $path =""

      WriteLog('Error: MakePathsFromADlocation ($Domain, $Account)')

      WriteLog('Error: ' + $Conicalname[1] + " " + $Conicalname[2] + " (TranslateName)")

   Endif

   $MakePathsFromADlocation = $path

Endfunction  




 
 [ 29. April 2003, 15:40: Message edited by: Howard Bullock ]82949MapDrive31RadimusMapDrive() - Map drives to deep paths with custom Icons and labels0Description - This UDF is to map a network drive. It will enable a specific Label and Icon to be specified for the item displayed in explorer. The delete parameter cleans previous setings and allows overwriting of an existing mapping. It allows for Deep Mapping on all NT based OS'es and will map for all OS'es within the limits of the OS itself. Icons and labels can be set for win2k or better (perhaps WinMe, but who cares to try)

Syntax - MapDrive("driveletter","UNC Path","Optional Desired label", "Optional Icon path","optional Delete")

Example - MapDrive("x","\\a06\e$","Admin root on Area Server","C:\WINNT\system32\moricons.dll,21",1)
 - MapDrive("h","\\server\share\folder\@userid","home drive",,1)

Author - Yours Truly, Radimus & a little help from my friends (and RTFM).  Special thanks to Lonkero for the cool Shell.Application code that I borrowed from Label() UDF

Updated - 2-25-03 Added persistence switch

code:

Function MapDrive($DriveLetter, $UNC, optional $Label, optional $Icon, optional $Delete, optional $persistent)
	dim $subcmd, $pt, $d, $di, $shell, $per
	$d = left($DriveLetter,1) 
	$di= "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\DriveIcons"
	$pt= @producttype
	if $pt = "Windows NT Workstation"
		$subcmd="subst"
		$per=''
	else	
	       	$subcmd="net use"
		if $persistent		$per='/PERSISTENT '		endif
		endif
	if $delete
		shell '%comspec% /c $subcmd $d: /d $per 1>Nul 2>&1'
		$=deltree("$di\$D")
		endif
	shell '%comspec% /c $subcmd $D: "$UNC" $per 1>Nul 2>&1'
		if not exist('$D:\')		exit 1		return		endif
	if $pt="Windows XP Professional" or $pt="Windows 2000 Professional"
		if $Label
			$shell=createobject("shell.application")
			$shell.namespace('$D:\').self.name=$Label
			endif
		if $icon
		 	$=writevalue('$di\$D\DefaultIcon','','$Icon',REG_SZ)
			endif
		endif
	ENDFUNCTION


 
 [ 26. March 2003, 03:24: Message edited by: Radimus ]82943MapDrive588SchuliebugMapDrive() - Maps a share to a given drive letter0This is a MapDrive(s) UDF i'm using (thankz to Jens, Bryce en Shawn).

code:

;Author         Jan.Schulenburg@tui.nl
;               Special thanks to Jens Meyer, Bryce Lindsay and Shawn.
;
;Parameters     1: required, drive letter to connect to
;               2: required, the UNC resource to map to
;               3: optional boolean indicationg to force the drive to connect, even when another drive is connected.
;               4: optional boolean indicating a persistent connection
;               5: optional string, indicating the logfile to write info to
;
;Remarks        this function will try to map a drive and return an error if failed.
;
;Returns        @error will equal 0 if successful, original @error if failed. In case
;               of forced net use @error contains also original UNC of the deleted connection.
;
;Dependencies   Log UDF
;
;Example(s)     $ReturnCode = mapdrive("g","\\server\share",0,,"c:\temp\map.err")
;               $ReturnCode = mapdrive("h","\\server\user",1,0,"c:\temp\map.err")
;
Function MapDrive($Drive,$Resource,optional $Force,optional $Persistent,optional $Log)
	Dim $MapErr,$OrgDrive,$OrgResource,$Message
	Dim $Network,$Drives,$NrDrives,$i

	; Determine optionals..
	If Not VarType($Force) $Force=0 EndIf
	If Not VarType($Persistent) $Persistent=0 EndIf
	If $Persistent And @INWIN=1
		$Persistent="/Persistent"
	Else
		$Persistent=""
	EndIf

	; Create network object..
	$Network = CreateObject("Wscript.Network")
	$Drives = $Network.EnumNetworkDrives
	$NoDrives = $Drives.Count

	; Step through network list..
	For $i=0 to $NoDrives-1 step 2
		If $Drives.item($i)=$Drive+":"
			$OrgDrive=$Drives.item($i)
			$OrgResource=$Drives.item($i+1)
		EndIf
	Next

	Select
	  Case $Force
	  	; Other mapping exists, if $Force then reconnect to $Resource..
		Use "$Drive:" /Delete /Persistent
		Use "$Drive:" "$Resource" $Persistent
		$MapErr=@Error $Message=" (connection $Drive: to $OrgResource deleted)"

	  Case $OrgDrive=$Drive+":"
		; Same drive map, $MapErr=0..
	  	$MapErr=0 $Message=" (drive $Drive: already connected to $OrgResource)"

	  Case $OrgDrive=""
		; New drive map..
		Use "$Drive:" "$Resource" $Persistent
		$MapErr=@ERROR

	  Case 1
		; Generate error message..
		Use "$Drive:" "$Resource" $Persistent
		$MapErr=@Error $Message=" (drive $Drive already connected to $OrgResource)"
	EndSelect

	If $MapErr<>0 $MapDrive='Connect $Device to $Resource: error @ERROR' EndIf

	Select
	  Case $MapErr<>0 And $log<>""
		$RC=Log('@SERROR, error @ERROR$Message..',$Log)
	  Case $Log<>""
		$RC=Log('Connecting $Device: to $resource succesfull$Message..',$Log)
	EndSelect

	Exit($MapErr)
EndFunction

Changed: if an errorred, the function returns error as string. This can be used if you want to
generate a message if one or more errors occurs. For example:

code:

	$RC=Map('g','\\server\share',,,$MappingLog)
	If $RC<>'' $Message=$Message+$RC+$NL EndIf

	$RC=Map('h','\\server\@UserID$$',,,$MappingLog)
	If $RC<>'' $Message=$Message+$RC+$NL EndIf

	If $Message<>''
		$RC=MessageBox($Message,'Errors when connecting drives:',48)
	EndIf

Furthermore, for logging a seperate Log UDF is used. Any Log UDF can be used (of course the
parameters must be the same or must be altered to comply with the chosen UDF)
 
 [ 23 May 2002, 11:58: Message edited by: Schuliebug ]82660MapDrive17SealeopardMapDrive() - Maps a UNC name to a specific driveletter1084242211Code:


;FUNCTION      MapDrive

;

;ACTION        Maps an UNC to a driveletter or removes a mapped UNC

;

;AUTHOR        Jens Meyer (sealeopard@usa.net)

;

;VERSION       2.01 (added optional username/password macro)

;              2.0  (major rewrite, switched the label-creation code from COM to registry writes,

;                    enabled unmapping, enabled SUBST under NT4)

;              1.44 (removed issue where label was not applied when mapping to already mapped drive)

;              1.43

;

;DATE CREATED  2001/12/20

;

;DATE MODIFIED 2004/02/04

;

;KIXTART       4.22+

;

;SYNTAX        MAPDRIVE(DRIVE [UNC , PERSIST, LABEL, USER, PASS])

;

;PARAMETERS    DRIVE

;              Required string containing driveletter or *

;

;              UNC

;              Optional string containing UNC name

;

;              PERSIST

;              Optional boolean indicating a persistent connection

;

;              LABEL

;              Optional integer/string to relabel a mapped share (Windows 2000/XP/2003 only)

;              0 = remove existing label

;              1 = apply Windows NT/2000-style label "sharename on 'computer name' (DriveLetter:)"

;              otherwise a label (no more than 32 characters under Windows 2000)

;

;              USER

;              Optional string containing the username to be used to authenticate the UNC

;

;              PASS

;              Optional string containing the password for the username

;

;RETURNS       0 or the error code @error. If a share is being mapped to any available drive letter

;              via '*', then @RESULT will contain the driveletter.

;

;REMARKS       A) 'Persist' is not supported under Windows 9x to prevent different users

;                 from receiving drive shares they should not have access to.

;              B) Deep mapping is not supported under Windows 9x.

;              C) Deep mapping under Windows NT will require two driveletters (one for the main share,

;                 and a second one for SUBST to simulate the deep map)

;              D) Omitting the LABEL parameter or providing an empty string will not change the

;                 existing label in Windows 2000/XP/2003.

;              E) Providing only a driveletter will remove the share (persistently if PERSIST is true)

;              F) UNCs and labels can contain macros, e.g '\\server\@USERID$'

;

;DEPENDENCIES  none

;

;EXAMPLE       ; persistent map of \\SERVER\share to Z:

;              $rc = MAPDRIVE('z','\\SERVER\share',1)

;              ;non-persistent map of \\SERVER\share to first available driveletter with NT/2000-style label

;              $rc = MAPDRIVE('*','\\SERVER\share',0,1)

;              ;non-persistent map of \\SERVER\share to first available driveletter with label 'whatever'

;              $rc = MAPDRIVE('*','\\SERVER\share',0,'whatever')

;              ;non-persistent map of \\SERVER\share to Z: with e.g. label "Jens Meyer's personal share"

;              $rc = MAPDRIVE('P','\\SERVER\@USERID$',0,"@FULLNAME's personal share")

;              ;removal of mapped drive N:

;              $rc = MAPDRIVE('N',)

;

;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Number=110547

;

function mapdrive($drive, optional $unc, optional $persist, optional $label, optional $user, optional $pass)

  Dim $mount, $regvalue, $rc, $deep, $regkey, $comp, $share



  ; don't change label if none is provided

  $label=iif(vartype($label)=0,-1,$label)



  ; set the persistent flag

  $persist=iif(@INWIN=2,0,val($persist))



  ; reformat UNC to lowercase and remove trailing backslash

  $unc=lcase(trim(iif(right($unc,1)='\',left($unc,-1),$unc)))



  ; check for a valid drive letter

  $drive=ucase(trim(left($drive,1)))



  ; check whether we do a deep mapping

  $deep=iif(ubound(split($unc,'\'))>3,1,0)



  ; translate macros in UNC

  if instr($unc,'@@')

    $rc=execute('$unc="'+$unc+'"')

  endif



  ; translate macros in label

  if instr($label,'@@')

    $rc=execute('$label="'+$label+'"')

  endif



  select

  case $drive='*'

    $mount='*'

  case $drive>='C' and $drive<='Z'

    $mount=$drive+':'

    if $persist and $unc and lcase(trim(readvalue('HKEY_CURRENT_USER\Network\'+$drive,'RemotePath')))=$unc

      $mapdrive=1

    endif

  case 1

    exit 15

  endselect



  ; connect to UNC if the driveletter is not already mounted persistently

  select

  case not $mapdrive and $unc

    select

    case @INWIN=2 and ($deep or instr($unc,'\\'+@WKSTA+'\'))=1

      ;Windows 9x cannot deep map or map to its own shares

      $mapdrive=3

      exit 3

    case $deep and val(@DOS)=4

      $mapdrive=split($unc,'\')

      redim preserve $mapdrive[3]

      $mapdrive=join($mapdrive,'\')

      use $mount /delete /persistent

      if $user or $pass

        use $mount $mapdrive /user:$user /password:$pass

      else

        use $mount $mapdrive

      endif

      use '*' $mapdrive

      $rc=@RESULT

      if @ERROR

        $mapdrive=@ERROR

        exit @ERROR

      endif

      use $mount /delete /persistent

      $unc=$rc+substr($unc,len($mapdrive)+1)

      shell 'subst '+$mount+' '+$unc

      $mapdrive=@ERROR

      use $rc /delete /persistent

      exit $mapdrive

    case 1

      if $mount<>'*'

        use $mount /delete /persistent

      endif

      if $persist

        if $user or $pass

          use $mount $unc /user:$user /password:$pass /persistent

        else

          use $mount $unc /persistent

        endif

      else

        if $user or $pass

          use $mount $unc /user:$user /password:$pass

        else

          use $mount $unc

        endif

      endif

    endselect

    if $mount='*'

      $mount=@RESULT

      $drive=left($mount,1)

    endif

  case not $unc

    if $persist

      use $mount /delete /persistent

    else

      use $mount /delete

    endif

    $mapdrive=@ERROR

    exit @ERROR

  endselect



  if @ERROR

    $mapdrive=@ERROR

    exit @ERROR

  endif



  ; labels can only be applied to Windows 2000/XP/2003

  if val(@DOS)>4 and $unc and $label<>-1

    $regkey='HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer'

    if @DOS='5.0'

      $regkey=$regkey+'\MountPoints\'+$drive+'\_LabelFromReg'

      select

      case $label=0

        ; remove label

        $rc=delkey($regkey)

      case $label<>1

        ; apply label

        $rc=$label

        redim preserve $label[31]

        $label[0]=$rc

        for $rc=2 to ubound($label)+1

          $label[$rc-1]=iif($rc<=len($label[0]),dectohex(asc(substr($label[0],$rc,1))),'00')

        next

        $label[0]=dectohex(asc(left($label[0],1)))

        $label=join($label,'00')+'000000'

        $rc=0

        while not keyexist($regkey) and $rc<10

          $rc=0.01+$rc

          sleep 0.01

        loop

        $rc=writevalue($regkey,'Cache',$label,'REG_BINARY')

        $rc=writevalue($regkey,'Version',3,'REG_DWORD')

      endselect

    else

      if $label

        $comp=split($unc,'\')

        $share=$comp[ubound($comp)]

        redim preserve $comp[ubound($comp)-1]

        $comp=substr(join($comp,'\'),3)

      endif

      $regkey=$regkey+'\MountPoints2\'+join(split($unc,'\'),'#')

      select

      case $label=0

        ; remove label

        $rc=delvalue($regkey,'_LabelFromReg')

      case $label=1

        ; apply NT/2000-style label

        $rc=writevalue($regkey,'_LabelFromReg',$share+" on '"+ucase(left($comp,1))+lcase(substr($comp,2))+"'",'REG_SZ')

      case $label

        ; apply label

        $rc=writevalue($regkey,'_LabelFromReg',$label,'REG_SZ')

      endselect

    endif

  endif



  $mapdrive=@error

  exit @error



endfunction

82903MapDrives28BryceMapDrives()0

code:


;Function	MapDrives()
;
;Author		Bryce Lindsay bryce@isorg.net
;
;Action		Maps a drive to the first avalible drive letter provided from a list.
;
;Syntax		mapdrives([drive letter list], [unc resource])
;
;Parameters 	Drive letter list
;			comma delimited list of drive letters to use
;		UNC Resource
;			the UNC resource to map to
;
;Remarks 	this function will try to map a drive starting with the first drive 
;		letter in the list, stopping when it has tried them all.
;
;Returns 	the drive letter used if the drive letter used of successful, "N/A"
;		if failed.  Also @error will equal 0 if successful, 1 if failed.
; 
;Dependencies 	None
; 
;Example(s)	$driveused = mapdrives("f,g,y,t,s","\\server\share")
; 
;Source
function MapDrives($drives,$resource)
	DIM $LastDrive,$drive	

	$drives = split($drives,",")
	$lastdrive = $drives[ubound($drives)]
	
	for each $drive in $drives
		use "$drive:" "$resource"
		if @error = 0
			$mapdrives = $drive
			exit(0)
		endif
		if $drive = $lastdrive
			$mapdrives = "N/A"
			exit(1)
		endif
	next
endfunction	

84227MapDriveX3439AllenMapDriveX() - Map a Network Drive to an available drive letter0


;Function:
; MapDriveX()
;
;Author:
; Allen Powell (Al_Po)
;
;Contributors
; Radimus
;
;Version:
; 1.3
;
;Action:
; Map a network drive to an unknown letter
;
;Syntax:
; mapdrivex($share)
;
;Parameters:
; $share: (required) 
; "\\Server\Share"
; 
;Returns:
; If Successful - DriveLetter:
; If not successful - @error = 1 'Share not Found'
; = 2 'No Drive Letters to map to'
; 
;
;Dependencies:
;
;Example:
; $letter=mapdrivex($NAVShare)
; if $letter<>""
; shell "$letter\VP_Log32.exe /p=$letter"
; use $letter /delete
; endif
;Source:

function mapdrivex($share)
dim $ascii,$drive
if not exist($share)
exit 1
endif
$ascii=90
while $ascii>=69 and $mapdrivex=""
$drive=chr($ascii) + ":"
if not exist($drive)
use $drive $share
if not @error
$mapdrivex=$drive
endif
endif
$ascii=$ascii-1
loop
if $mapdrivex=""
exit 2
endif
endfunction



7/14/03 Changed search order to Z: down
 
 [ 04. October 2003, 21:34: Message edited by: Al_Po ]82688MapPrinter17SealeopardMapPrinter() - Connects a computer to a specific printer0

code:

;FUNCTION      MapPrinter
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Connects a computer to a specific printer
;
;VERSION       1.3
;
;KIXTART       4.12+
;
;SYNTAX        MAPPRINTER(PRINTERNAME, PRINTSERVER)
;
;PARAMETERS    PRINTERNAME
;              Required string containing name of the shared printer
;
;              PRINTSERVER
;              Required string/array containing the name of the print server(s)
;
;RETURNS       0 or the error code @error
;
;REMARKS       PRINTSERVER can be an array or comma-delimited list of printservers with the first
;              available server getting the printer connection. Used to create redundant printservers.
;
;DEPENDENCIES  none
;
;EXAMPLE       $rc = mapprinter('PRINTERNAME','PRINTSERVER')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000109
;
function mapprinter($printername, $printserver)
  Dim $activeprintserver, $printer, $rc

  if @INWIN<>1
    return
  endif

  if not (vartype($printserver) & 8192)
    $printserver=split($printserver,',')
  endif

  for each $activeprintserver in $printserver
    $printer='\\'+trim($activeprintserver)+'\'+trim($printername)

    $rc=addprinterconnection($printer)
    $mapprinter=@ERROR

    select
    case $rc=0 or $mapprinter=0
      $mapprinter=0
    case $mapprinter=123 or $mapprinter=1801
      $rc=delprinterconnection($printer)
      $rc=addprinterconnection($printer)
      $mapprinter=@ERROR
    endselect
    if $mapprinter=0
      exit @ERROR
    endif
  next

  $mapprinter=@ERROR
  exit @ERROR
endfunction


 
 [ 20. April 2003, 23:14: Message edited by: sealeopard ]82886MapPrinter609MasterOfDesasterMapPrinter() - Delete or Map Networkprinters by Groupmembership0Hi folks!

I just want to post the following function, that will map or delete Networkprinter to the users, when users are member of a specific Group

code:


;******************************************************************
;This Function maps or deletes NetworkPrinter by Groupmemberships
; if the user is member of the group, he will get mapped the networkprinter
; if the user is NOT a member of the group, he don't get the networkprinter or
; the printer is deleted on his PC
;
;Start with mapprinter(, ,,)
;$PRServer    = Printserver
;$PRShare     = Sharename of the Printer
;$Printername = The real Name of the Printer (not of the PrinterDriver!)
;$PrtGroup    = The Group in the Domain where the user must belong to, to get the printer
;
;This Function is tested on a NT4 Domain with NT4 and W2k Clients only!
;******************************************************************

function MapPrinter($PRServer, $PRShare, $PrinterName, $PrtGroup)

$regkey="HKCU\Printers\Connections\,,"+$PRServer+","+$PrinterName

if ingroup($PrtGroup) =1
   if keyexist($regkey)
     ? "Drucker \\$PRServer\$PRShare bereits vorhanden"
     return  
   else
      if addprinterconnection("\\"+$PRServer+"\"+$PRShare) =0
        ? "Attach Netzwork-Printer \\$PRServer\$PRShare"
       else
        ? "Error by connecting to  \\$PRServer\$PRShare"
        ? @serror
      endif
    endif
 else
   if keyexist($regkey)
      if delprinterconnection("\\"+$PRServer+"\"+$PRShare) =0
         ?" Delete NetworkPrinter \\$PRServer\$PRShare"
      else
         ?" Error by deleting  \\$PRServer\$PRShare"
         ? @Serror
      endif
    else
      return
   endif
     
endif  

endfunction  

Hope some can use this function   83150MapPrinter31RadimusMapPrinter() - Yet Another MapPrinter function0Here goes another one (no error handling in my code).

Function MapPrinter()

Author:  Radimus

Action: connects a printer, optional set as default, optional delete old printer

Syntax:  MapPrinter("\\server\printer",optional setdefault, optional  "\\oldserver\printer")

Parameters: printer must be in UNC, setdefault is any 'non-null' value, old printer is UNC

Remarks: much like any other mapprinter function, will not reconnect a printer if it already exists, will not set as default if it exists, will not set default if local printer exists, can be used to 'move' a connected printer from 1 server to another.

Dependancies: winNT4 or better. No Windendo.

Example: MapPrinter("\\a06\kenny",1)
MapPrinter("\\a06\kenny",1,"\\oldserver\kenny")

code:

function MapPrinter($printer, Optional $default, optional $oldspool)
	DIM $index,$IsInstalled,$lptprinter,$inst_printers,$PrinterPorts,$port_type
	
	$index=0		$IsInstalled=0		$lptprinter=0
	$PrinterPorts="HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\PrinterPorts"

	if $oldspool
		$=DelPrinterConnection($oldspool)
		endif
	:loopprinters
		$inst_printers=enumvalue($PrinterPorts,$index)
		if @error=0
			$port_type=readvalue("$PrinterPorts","$inst_printers")
			if $printer=$inst_printers	$IsInstalled=1		endif
			if instr("$port_type","LPT")	$lptprinter=1		endif
			$index=$index+1
			goto loopprinters
			endif
	if $IsInstalled=0
		$=AddPrinterConnection("$printer")
		endif
	if $IsInstalled=0 and $lptprinter=0 and $default
		$=SetDefaultPrinter("$printer")
		endif
	endfunction


 
 [ 28. October 2002, 15:20: Message edited by: Radimus ]82293MArray1**DONOTDELETE**MArray() - Make multi dimensional arrays0Everybody:

I have seen several references to Multi dimensional arrays in Kixtart
and thought I would write a UDF to create them.

I have created 2 UDFs as follows:
MArray()  to create arrays  (this post), and
MUbound() as an equivalent for UBOUND (see seperate post).

code:

 
;FUNCTION	MArray()
;
;AUTHOR		AJH (Andrew Hayes)
;
;ACTION		Creates a multi dimensional array which is compatible with
;		normal Kixtart functions
;
;SYNTAX		$Array = MArray(dimension_list)
;
;PARAMETERS	List of Dimension sizes		(Required)
;			Either a comma seperated text string, or an array variable
;
;		Pointer				(Optional, for internal UDF use only)
;
;REMARKS	Because Kixtart does not support true multi-dimension arrays, this
;		program creates a simulated array in the form  (eg) $Array[2][1][3][4]
;		Warning: MArray("1,2,3,4,5,6,7,8,9") takes a long time!
;
;		There is a companion UDF MUBOUND() to return a list of dimension sizes.
;
;RETURNS	A simulated multi dimensional array structure.
;
;REQUIRES	Kixtart 4.0.2 release or above
;
;EXAMPLES	$Array = MArray("2,1,4,3")  ;creates an array with 120 elements (3x2x5x4)
;
;		$dimensions = 2,1,4,3
;		$Array = MArray($dimensions)
;
;
;SOURCE
;
		FUNCTION MArray($ind, OPTIONAL $ptr)
		IF Ubound($ind) < 1  $ind =Split($ind,",")  ENDIF
		REDIM $MArray[$ind[$ptr]]
		IF $ptr < Ubound($ind)
		  $MArray[0] =MArray($ind,$ptr+1)
		  DIM $L
		  FOR $L = 1 TO Ubound($MArray)  $MArray[$L]=$MArray[0]  NEXT
		ENDIF
		ENDFUNCTION
;


 
 [ 24 May 2002, 22:47: Message edited by: AJH ]177966MD52980Glenn BarnasMD5() -  utility function to generate / compare MD5 Digests0 
;; 
;;====================================================================== 
;; 
;;FUNCTION       md5() 
;; 
;;ACTION         Returns an MD5 checksum, or verifies an MD5 checksum 
;; 
;;AUTHOR         Glenn Barnas 
;; 
;;VERSION        1.0 / 2007/07/15 
;; 
;;SYNTAX         md5(file [,compare]) 
;; 
;;PARAMETERS     file	 - Name of target file 
;; 
;;               compare - An MD5 digest to compare against the target file 
;; 
;;REMARKS        Used to either return an MD5 checksum, or validate a file's integrity. This 
;;               would be useful in critical file-copy operations, such as software deployments. 
;; 
;;RETURNS        digest value / boolean value 
;;               If only the filename is specified, the file's MD5 digest is returned 
;;               If the file's suspected MD5 digest is specified, a compare against  
;;               the actual digest is performed, and the UDF returns 1 on match, 0 otherwise. 
;;               Exit is set by the MD5.exe - 0 on success 
;; 
;;DEPENDENCIES   md5.exe - zip file available at http://www.fourmilab.ch/md5/md5.zip 
;; 
;;TESTED WITH    W2K, WXP, W2K3 
;; 
;;EXAMPLES       $Sum = md5('here\file.exe') 
;;               Copy 'here\file.exe' 'there' 
;;               If md5('there\file.exe', $Sum) 
;;                 'Copy was successful!' 
;;               EndIf 
; 
Function MD5($File, OPTIONAL $Compare)
 
  Dim $_pCmd
 
  If $Compare = ''
    $_pCmd = CreateObject("WScript.Shell").Exec('md5.exe -n ' + $File)
    $MD5 = Split($_pCmd.StdOut.ReadAll, Chr(13))[0]
  Else
    Shell 'md5.exe -c' + $Compare + ' ' + $File
    $MD5 = Not @ERROR
  EndIf
 
  Exit @ERROR
 
EndFunction
 
 
 
   

134637Memory2980Glenn BarnasMemory() - Get Physical RAM size - Local or Remote system1191685706



;;FUNCTION		Memory()  
;;  
;;AUTHOR		Glenn Barnas 
;;  
;;ACTION		Returns the amount of Available Physical RAM in a local or remote system  
;;  
;;SYNTAX		Memory([system])  
;;  
;;VERSION		3.0  
;;  
;;DATE			2004/02/04 
;;  
;;DATE REVISED		2007/10/05 - rewrite to support x64 systems, tighten code 
;;			2005/02/25 - updated 
;;  
;;PARAMETERS		System - OPTIONAL - name of system to query. Default is local system  
;;  
;;REMARKS		Returns Physical RAM size available to the O/S using registry memory map 
;;			Returns @ERROR on registry read failure, or 13 / "Data is Invalid" if reg is empty 
;;			DOES NOT return physical hardware ram value! Some systems allocate RAM 
;;			to video adapters, and this memory is not reported. 
;;  
;;RETURNS		Integer - Available Physical RAM (in Megabytes)  
;;  
;;DEPENDENCIES		None  
;;  
;;TESTED WITH		WinNT, Win2K, WinXP, Win2K3, Win2K3_64, Vista, Vista_64 
;;			Tested with up to 8G of RAM  
;;  
;;EXAMPLES		$RAM = Memory('ThatPC')  
;;  
; 
Function Memory(Optional $_System)
 
  Dim $_MemMap				; Physical Memory Map 
  Dim $_Step				; for/next step increment 
  Dim $_Sum				; running sum of memory from map 
  Dim $_x64				; flag indicating 64b O/S 
  Dim $_Idx				; temporary index var 
  Dim $_Error				; Error placeholder 
 
  ; Insure $_System has "\\System\" format if it is specified  
  If $_System <> ''
    $_System = '\\' + Join(Split($_System, '\'), '', 3) + '\'
  EndIf
 
  ; Get the memory value from the registry  
  $_Idx = $_System + 'HKLM\hardware\resourcemap\system resources\physical memory'
  $_MemMap = ReadValue($_Idx, '.Translated')
 
  ; Check for invalid read and Return  
  If Len($_MemMap) = 0 Or @ERROR
    $Memory = 0				; return 0 Mbytes  
    $_Error = IIf(@ERROR, @ERROR, 13) 	; Return "Data is Invalid" if no error but data is blank  
    Exit $_Error
  EndIf
 
  ; determine system's O/S type based on architecture 
  $_Idx = $_System + 'HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment'
  $_x64 = IIf(ReadValue($_Idx, 'PROCESSOR_ARCHITECTURE') = 'AMD64', 1, 0)
 
  ; Define the step size based on the O/S Architecture (32 bytes for x86, 40 bytes for x64) 
  $_Step = IIf($_x64, 40, 32)
 
  ; account for base memory not identified in memory map - x86 only 
  $_Sum = IIf($_x64, 0.0, 737280.0)
 
  ; walk the memory map data and sum the Length values 
  For $_Idx = 65 to Len($_MemMap) Step $_Step
    If $_x64
      $_Sum = $_Sum + CDbl(Val('&' + SubStr($_MemMap, $_Idx+12, 2))) * 281474976710656.0
                    + CDbl(Val('&' + SubStr($_MemMap, $_Idx+10, 2))) * 1099511627776.0
                    + CDbl(Val('&' + SubStr($_MemMap, $_Idx+8,  2))) * 4294967296.0
                    + CDbl(Val('&' + SubStr($_MemMap, $_Idx+6,  2))) * 16777216.0
                    + CDbl(Val('&' + SubStr($_MemMap, $_Idx+4,  2))) * 65536.0
                    + CDbl(Val('&' + SubStr($_MemMap, $_Idx+2,  2))) * 256.0
                    + CDbl(Val('&' + SubStr($_MemMap, $_Idx,    2)))
    Else
      $_Sum = $_Sum + CDbl(Val('&' + SubStr($_MemMap, $_Idx+6, 2))) * 16777216.0
                    + CDbl(Val('&' + SubStr($_MemMap, $_Idx+4, 2))) * 65536.0
                    + CDbl(Val('&' + SubStr($_MemMap, $_Idx+2, 2))) * 256.0
                    + CDbl(Val('&' + SubStr($_MemMap, $_Idx,   2)))
    EndIf
  Next
  
  ; Sum is in Bytes - return the total as megabytes 
  $Memory = CInt($_Sum/1048576)
  Exit 0
 
EndFunction 
 

83843MemSize119LonkeroMemSize() - returns installed memory size0

code:

;FUNCTION	MemSize()
;
;AUTHOR		Lonkero
;
;ACTION		returns physical memory size
;
;SYNTAX		MemSize
;
;PARAMETERS	none.
;
;RETURNS	Installed memory in bytes
;
;DEPENDENCIES	Minimum operating systems: w2k or ME
;
;EXAMPLE
;		"memory size is:" MemSize
;
;CODE

function MemSize()
 dim $
 $=createobject('shell.application')
 $MemSize=$.GetSystemInformation('PhysicalMemoryInstalled')
endfunction


 
 [ 28. February 2003, 10:01: Message edited by: Lonkero ]113155MemSize2119LonkeroMemSize2() - Retrieve Physical memory size1143132395

;FUNCTION
;		MemSize2()
;
;AUTHOR
;		Lonkero
;
;ACTION
;		returns physical memory size
;
;SYNTAX
;		MemSize2([MACHINE])
;
;PARAMETERS
;		MACHINE
;		-optional
;		-specifies remote machine to query
;
;RETURNS
;		Installed memory in Mbytes
;
;DEPENDENCIES
;		NT based system
;
;REMARKS
;		Differs from the MemSize() by:
;		-	retrieves info from reg instead of shell
;		-	does allow remote query
;		-	accuracy might not be quaranteed
;
;EXAMPLE
;	"memory size is:" MemSize2
;
;CODE

Function MemSize2(optional $machine)
 dim $
 if vartype($machine) $machine=join(split($machine,"\"),'') $machine="\\"+$machine+"\" endif
 $=right(readvalue($machine+"HKEY_LOCAL_MACHINE\HARDWARE\RESOURCEMAP\System Resources\Physical Memory",".Translated"),8)
  $=execute("$"+"MemSize2=16+&"+right($,2)+substr($,5,2)+substr($,3,2)+left($,2)+"/1024/1024")
endfunction
 83300MenuLib22Richard H.MenuLib() - ASCII menu system.0Menulib.kix comprises two functions which allows the creation of an ASCII menu structure.
    

The script was inspired by a request for a menu in the starters/scripts forum

You may find it more convenient to download the menu script and examples in this  zip file
The menus offer the following features:

Menu defined in "ini" file

Colour text and background (not flashing or highlight]

Menu title and footer text.

Clock in title bar.

Navigate by cursor keys.

Action key is user definable.

Escape key is user definable.

Escape key action is user definable.

Function key F1-F10 action is user definable.

DOS command execution supported.

Any number of sub menus supported.

Automatically selects number of columns to use.

User definable option spacing.
I'll be following this post up with documentation and the examples (if you want to play with it, get the zip file which has the examples).
Here is the script.  Sorry about the long lines.

code:

;
; Menulib.kix
;
; FUNCTIONS:	udfLoadMenu()
;		udfExecMenu()
;
; AUTHOR:	Richard Howarth (rhowarth@sgb.co.uk)
;
; VERSION:	1.0
;
; HISTORY:	1st July 2002 RMH Released version 1.0
;
; ACTION:	Provide an ASCII menu
;
; SYNTAX:
;	udfLoadMenu(File,Clock,Width,Height,TextColour,TextReverse,Space)
;		File:		Path to menu file
;		Clock:		OPTIONAL Number of characters of time to display (0=no clock)
;		Width:		OPTIONAL Menu width, default is 80
;		Height:		OPTIONAL Menu height, default is 25
;		TextColour:	OPTIONAL Text colour, default is "w"
;		TextReverse:	OPTIONAL Background colour, default is "n"
;		Space:		OPTIONAL Option spacing, default is "1"
;	udfExecMenu(Menu,Refresh)
;		Menu:		Menu array object from udfLoadMenu
;		Refresh:	OPTIONAL Redraw menu boolean flag
;
; REMARKS:
;	Could be converted to KiXtart 4 with a little work.
;
; RETURNS:
;	Menu array object comprising:
;	0 - Return status
;	1 - Menu file path
;	2 - Current option, set to "0" to redraw
;	3 - Screen width
;	4 - Screen height
;	5 - Text colour
;	6 - Text background
;	7 - Current path
;	8 - Option spacing
;	9 - Clock flag
;
; DEPENDENCIES:	KiXtart 4.10
;
; EXAMPLE:
;	; Create a standard menu with clock showing hours and minutes.
;	$aMenu=udfLoadMenu("Menu.ini",5)
;	$aMenu=udfExecMenu($aMenu)
;	While @ERROR=0 And $aMenu[0]<>"EXIT"
;		$aMenu=udfExecMenu($aMenu)
;	Loop
;
;
; SOURCE:


If @KIX < "4.10"
	"FATAL: The menulib UDFs require KiXtart version 4.10" ?
	Quit 1
EndIf

Function udfLoadMenu(
		$sMenuFile,
		Optional $iClock,
		Optional $iWidth,
		Optional $iHeight,
		Optional $sTextColour,
		Optional $sTextReverse,
		Optional $iOptionSpace
		)

	Redim $udfLoadMenu[10]
	Dim $COLOURS $COLOURS="nbgcrmyw"

; Sanity checks.
	$iWidth=Int(Val($iWidth))
	$iHeight=Int(Val($iHeight))
	$iOptionSpace=Int(Val($iOptionSpace))
	$sTextColour=SubStr($sTextColour,1,1)
	$sTextReverse=SubStr($sTextReverse,1,1)
	If $iClock="" $iClock=5 EndIf
	If $iWidth < 1 $iWidth=80 EndIf
	If $iHeight < 1 $iHeight=25 EndIf
	If $iOptionSpace < 1 $iOptionSpace=2 EndIf
	If $sTextColour="" OR InStr($COLOURS,$sTextColour)=0 $sTextColour="w" EndIf
	If $sTextReverse="" OR InStr($COLOURS,$sTextReverse)=0 $sTextReverse="n" EndIf
	$udfLoadMenu[0]=1
	$udfLoadMenu[1]=$sMenuFile
	$udfLoadMenu[2]=0
	$udfLoadMenu[3]=$iWidth
	$udfLoadMenu[4]=$iHeight
	$udfLoadMenu[5]=$sTextColour
	$udfLoadMenu[6]=$sTextReverse
	$udfLoadMenu[7]=ReadProfileString($udfLoadMenu[1],"","")
	If $udfLoadMenu[7]="" "FATAL: Cannot read menu file" $udfLoadMenu[1] ? Exit 1 EndIf
	$udfLoadMenu[7]=SubStr($udfLoadMenu[7],1,InStr($udfLoadMenu[7],Chr(10))-1) + "|"
	$udfLoadMenu[8]=$iOptionSpace
	$udfLoadMenu[9]=$iClock
	; Set status to OK
	$udfLoadMenu[0]=0
	Return
EndFunction

Function udfExecMenu($aStatus,Optional $iRedraw)

	Dim $bCursorState	$bCursorState=SetOption("HIDECURSOR","ON")
	Dim $DEBUG		$DEBUG=0	; Set true for debugging

:LongJump

	Dim $nul					; Bit bucket
	Dim $ACTIONS		$ACTIONS="<>*!^"	; Default action set.
	Dim $KEYACTION		$KEYACTION=13		; Action key (default CR)
	Dim $KEYESCAPE		$KEYESCAPE=27		; Escape key (default ESC)
	Dim $iNumOptions	$iNumOptions=0
	Dim $iMaxWidth		$iMaxWidth=0
	ReDim $iFunctionAction[11]			; Action for function keys
	ReDim $sFunctionExec[11]			; Parameter for function keys
	Dim $iNumColumns
	Dim $iPerColumn
	Dim $iColumnWidth
	Dim $iOffWidth
	Dim $iOffHeight
	Dim $aOptionText
	Dim $aOptionType
	Dim $aOptionExec
	Dim $sTitle		$sTitle=""
	Dim $sFooter		$sFooter=""
; Load array into more usable variables
	Dim $iWidth		$iWidth=$aStatus[3]
	Dim $iHeight		$iHeight=$aStatus[4]
	Dim $sTextColour	$sTextColour=$aStatus[5]
	Dim $sTextReverse	$sTextReverse=$aStatus[6]
	Dim $iOptionSpace	$iOptionSpace=$aStatus[8]
	Dim $sThisMenu		$sThisMenu=SubStr($aStatus[7],1,InStr($aStatus[7],"|")-1)
	Dim $iClock		$iClock=$aStatus[9]
	Dim $REVSERSE		$REVERSE="Color $sTextReverse/$sTextColour"
	Dim $NORMAL		$NORMAL="Color $sTextColour/$sTextReverse"
	Dim $iOption		$iOption=1
	Dim $iHighlighted	$iHighlighted=0
	Dim $sBlankLine		$sBlankLine="          "
	Dim $sLastTime
	Dim $iMetaKey		$iMetaKey=224
	Dim $iMetaPressed	$iMetaPressed=0
	Dim $vKeyPress
	Dim $i
	Dim $iAction
	Dim $sParameter

	If VarType($aStatus) & 8192 = 0
		"FATAL: You must load the menu with udfLoadMenu()" ?
		Exit 1
	EndIf

	If $sThisMenu = ""
		$sThisMenu=SubStr($aStatus[7],2)
		"FATAL: Missing menu in menu file " $aStatus[1] ?
		"       Bad entry in menu: " SubStr($sThisMenu,1,InStr($sThisMenu,"|")-1)
		Exit 1
	EndIf

	If Val($iRedraw) $aStatus[2]=0 EndIf

	If $aStatus[2]
		$iOption=$aStatus[2]
		$iHighlighted=$iOption
	Else
		$iOption=1
		$iHighlighted=0
	EndIf

	While Len($sBlankLine)<$iWidth $sBlankLine="$sBlankLine$sBlankLine" Loop
	$sBlankLine=SubStr($sBlankLine,1,$iWidth-4)

	$udfExecMenu=$aStatus
	$udfExecMenu[0]=1 ; Set to error status

; Load current menu
	$sMenu=ReadProfileString($udfExecMenu[1],$sThisMenu,"")
	If $sMenu="" "FATAL: Cannot read menu " $sThisMenu " from " $udfExecMenu[1] ? Exit 1 EndIf
	$iIndex=InStr($sMenu,Chr(10))
	While $iIndex
		$sOptionKey=SubStr($sMenu,1,$iIndex-1)
		$sMenu=SubStr($sMenu,$iIndex+1)
		$sOptionValue=ReadProfileString($udfExecMenu[1],$sThisMenu,$sOptionKey)
		Select
		Case $sOptionKey="Actions"
			$ACTIONS=$sOptionValue
		Case $sOptionKey="Title"
			$sTitle=$sOptionValue
		Case $sOptionKey="Footer"
			$sFooter=$sOptionValue
		Case $sOptionKey="KEYESCAPE"
			$KEYESCAPE=Val($sOptionValue)
		Case $sOptionKey="KEYACTION"
			$KEYACTION=Val($sOptionValue)
		Case $sOptionKey="Esc" Or (SubStr($sOptionKey,1,1)="F" And Val(SubStr($sOptionKey,2))>0)
			If $OptionKey="Esc" $i=0 Else $i=Val(SubStr($sOptionKey,2)) EndIf
			$iAction=InStr($ACTIONS,SubStr($sOptionValue,1,1))
			If $i < 0 Or $i > 10
				"FATAL: Illegal function key '" $sOptionKey "' in menu file " $udfExecMenu[1] ?
				Exit 1
			EndIf
			If $iAction
				$iFunctionAction[$i]=$iAction
				$sFunctionExec[$i]=SubStr($sOptionValue,2)
			Else
				"FATAL: Illegal action '" SubStr($sOptionValue,1,1) "' in menu file " $udfExecMenu[1] ?
				Exit 1
			EndIf
			
		Case SubStr($sOptionKey,1,6)="Option"
			$iAction=InStr($ACTIONS,SubStr($sOptionValue,1,1))
			If $iAction
				$iNumOptions=$iNumOptions+1
				Redim Preserve $aOptionText[$iNumOptions]
				Redim Preserve $aOptionType[$iNumOptions]
				Redim Preserve $aOptionExec[$iNumOptions]
				$sOptionValue=SubStr($sOptionValue,2)
				$aOptionText[$iNumOptions-1]=
					SubStr($sOptionValue,InStr($sOptionValue,SubStr($ACTIONS,$iAction,1))+1)
				If Len($aOptionText[$iNumOptions-1])>$iMaxWidth
					$iMaxWidth=Len($aOptionText[$iNumOptions-1])
				EndIf
				$aOptionType[$iNumOptions-1]=$iAction
				$aOptionExec[$iNumOptions-1]=
					SubStr($sOptionValue,1,InStr($sOptionValue,SubStr($ACTIONS,$iAction,1))-1)
			Else
				"FATAL: Illegal action '" SubStr($sOptionValue,1,1) "' in menu file " $udfExecMenu[1] ?
				Exit 1
			EndIf
		Case "Unknown"
			"FATAL: Illegal directive '$sOptionKey' in menu '$sThisMenu' in file " $udfExecMenu[1] ?
			Exit 1
		EndSelect
		$iIndex=InStr($sMenu,Chr(10))
	Loop

	If $sTitle="" $sTitle=$sThisMenu EndIf

	$iNumColumns=($iNumOptions-1)/(($iHeight-5)/$iOptionSpace)+1
	$iPerColumn=($iNumOptions-1)/$iNumColumns+1
	$iColumnWidth=$iWidth/$iNumColumns-6
	$iOffWidth=($iWidth-($iMaxWidth+6)*$iNumColumns)/2
	$iOffHeight=1
	; The next calculation commented out - I thought the results looked ugly,
	; but feel free if you want to use it.  The purpose is to attempt to centre
	; the menu vertically.
	; $iOffHeight=($iHeight-4-($iPerColumn-1)*$iOptionSpace)/2

	If $iMaxWidth>$iColumnWidth
		"FATAL: Your menu '" $sThisMenu "' in file '" $aStatus[1] "' has " $iNumOptions " options." ?
		"       Your menu height is $iHeight, option spacing is $iOptionSpace" ?
		"       so this requires $iNumColumns columns" ?
		"       Your widest menu option is $iMaxWidth, which exceeds the space available" ?
		"       Please reduce the number of options, or the width." ?
		Exit 1
	EndIf

	FlushKB
	While "true"
		; Redraw menu if required
		If $udfExecMenu[2]=0
			$udfExecMenu[2]=$iOption
			$nul=Execute($NORMAL)
			Cls
			Box(0,1,$iHeight-1,$iWidth-2,"single")
			At(0,1+($iWidth-2-Len($sTitle))/2)
			$nul=Execute('$REVERSE "$sTitle" $NORMAL')
			At($iHeight-1,1+($iWidth-2-Len($sFooter))/2)
			$nul=Execute('$REVERSE "$sFooter" $NORMAL')
			For $i = 0 To $iNumOptions-1
				$iColumn=$i/$iPerColumn
				$iRow=$i-$iColumn*$iPerColumn
				At($iOffHeight+2+$iRow*$iOptionSpace,$iOffWidth+$iColumn*($iMaxWidth+6))
				If $i < 9 " " EndIf
				$i+1 " " $aOptionText[$i]
			Next
		EndIf
		If $iHighlighted <> $iOption
			; Remove highlight from old option
			$i=$iHighlighted
			If $i
				$i=$i-1
				$iColumn=$i/$iPerColumn
				$iRow=$i-$iColumn*$iPerColumn
				At(2+$iRow*$iOptionSpace+$iOffHeight,$iOffWidth+$iColumn*($iMaxWidth+6))
				If $i < 9 " " EndIf
				$i+1 " " $aOptionText[$i]
			EndIf
			$iHighlighted=$iOption
			$i=$iHighlighted
			If $i
				$i=$i-1
				$iColumn=$i/$iPerColumn
				$iRow=$i-$iColumn*$iPerColumn
				At(2+$iRow*$iOptionSpace+$iOffHeight,$iOffWidth+$iColumn*($iMaxWidth+6))
				$nul=Execute($REVERSE)
				If $i < 9 " " EndIf
				$i+1 " " $aOptionText[$i]
				$nul=Execute($NORMAL)
			EndIf
		EndIf
		; Display time if requested
		If $iClock
			If SubStr(@TIME,1,$iClock) <> $sLastTime
				$sLastTime=SubStr(@TIME,1,$iClock)
				At(0,$iWidth-2-$iClock) $nul=Execute('$REVERSE "$sLastTime" $NORMAL')
			EndIf
		EndIf
		; Parse keypress
		If KbHit()
			; Blank error / debug messages
			At($iHeight-2,2) $sBlankLine At($iHeight-2,2)
			Get $vKeyPress $vKeyPress=Asc($vKeyPress)
			If $iMetaPressed
				$iMetaPressed=0
				Select
				Case $vKeyPress=72	; Up arrow
					$iOption=$iOption-1
				Case $vKeyPress=80	; Down Arrow
					$iOption=$iOption+1
				Case $vKeyPress=75	; Left Arrow
					$iOption=$iOption-$iPerColumn
				Case $vKeyPress=77	; Right Arrow
					$iOption=$iOption+$iPerColumn
				Case "Default"
					If $DEBUG "Untrapped meta key " $vKeyPress EndIf
				EndSelect
				If $iOption > $iNumOptions $iOption=$iNumOptions EndIf
				If $iOption < 1 $iOption=1 EndIf
			Else
				Select
				Case $vKeyPress=$iMetaKey
					$iMetaPressed=1
				Case $vKeyPress=$KEYACTION Or
						$vKeyPress=$KEYESCAPE Or
						($vKeyPress=0 And (@ERROR > 58 And @ERROR < 69))
					Select
					Case $vKeyPress=$KEYACTION
						$iAction=$aOptionType[$iOption-1]
						$sParameter=$aOptionExec[$iOption-1]
					Case $vKeyPress=$KEYESCAPE
						$iAction=Val($iFunctionAction[0])
						$sParameter=$sFunctionExec[0]
						If $iAction = 0 $iAction = 1 EndIf
					Case $vKeyPress=0
						$i=@ERROR
						$iAction=Val($iFunctionAction[$i-58])
						$sParameter=$sFunctionExec[$i-58]
					EndSelect
					If $iAction
						Select
						Case $iAction=1	; Previous Menu
							$aStatus[2]=0
							$nul=SubStr($aStatus[7],InStr($aStatus[7],"|")+1)
							If $nul<>""
								$aStatus[7]=$nul
								Goto LongJump
							EndIf
						Case $iAction=2	; Next Menu
							$aStatus[2]=0
							$aStatus[7]=$sParameter + "|" + $aStatus[7]
							Goto LongJump
						Case $iAction=3	; Return to script
							$udfExecMenu[0]=$sParameter
							$udfExecMenu[2]=$iOption
							$nul=SetOption("HIDECURSOR",$bCursorState)
							Return
						Case $iAction>3	; Execute with/without pause
							$nul=SetOption("HIDECURSOR",$bCursorState)
							$udfExecMenu[2]=0
							$iHighlighted=0
							Cls
							$i=Execute("Shell '" + $sParameter + "'")
							If $i ? "ERROR=$i" ? EndIf
							If $iAction=5
								FlushKB
								? "Hit <Return> to continue: " Gets $i
							EndIf
							$nul=SetOption("HIDECURSOR","ON")
						EndSelect
					EndIf
				Case $vKeyPress=0
					If $DEBUG "Function key " @ERROR EndIf
				Case "Default"
					If $DEBUG "Key $vKeyPress" EndIf
					If $vKeyPress=$KEYESCAPE Exit 1 EndIf
				EndSelect
			EndIf
		Else
			Sleep (0.2) ; Don't hog processor
		EndIf
	Loop

	$udfExecMenu[0]=0 ; *NOTREACHED* Set to OK status
	Return

EndFunction


 
 [ 21. February 2003, 08:57: Message edited by: Richard H. ]82941MergeIni588SchuliebugMergeIni() - Merge an ini file into another0Maybe a usable UDF:

code:


;Parameters     1: required string indicating the source INI file.
;               2: required string indicating the target INI file.
;               3: optional string indicating the logfile to write info to.
;
;Remarks        this function will merge the source ini into the destination ini. Empty
;               sections will be ignored.
;
;Returns        @error will equal 0 if successful, original @error if failed.
;
;Dependencies   None
;
;Example(s)     $ReturnCode = MergeIni("SourceIni","TargetIni","c:\temp\logfile.txt")
;
Function MergeIni($SourceIni,$TargetIni,$Log)
	Dim $Section,$AllSections
	Dim $Key,$AllKeys,$Value

	; Check if SourceIni exists..
	If Exist($SourceIni)=1
		; Read all sections from Source ini file into AllSections array..
		$AllSections=Split(ReadProfileString($SourceIni,"",""),Chr(10))

		; Read section subkeys..
		For Each $Section In $AllSections
			; Section not empty..
			If $Section<>""
				; Local parameters..
				$AllKeys=Split(ReadProfileString($SourceIni,$Section,""),Chr(10))

				; Read section subkeys..
				For Each $Key In $AllKeys
					; Key not empty..
					If $Key<>""
						$Value=ReadProfileString($SourceIni,$Section,$Key)
						$=WriteProfileString($TargetIni,$Section,$Key,$Value)

						If $Log<>""
							Shell "%ComSpec% /c echo   - write $Key=$Value in [$Section]>>$Log"
						EndIf
					EndIf
				Next
			EndIf
		Next

		; Merge succesfull..
		Exit(1)
	Else
		; Source INI file error..
		Exit(0)
	EndIf
EndFunction

[ 04 February 2002: Message edited by: DrillSergeant ]84017Mid3439AllenMid() - Find Strings in Strings0


;FUNCTION MID()
;
;ACTION Determines characters within a string 
;
;AUTHOR Al-Po
;
;VERSION 1.0
;
;KIXTART Minimum required Kixtart version 4.02
;
;SYNTAX mid($midstring,$midstart,optional $midend)
;
;PARAMETERS $Midstring - String of characters to search
; $Midstart - Character Index number to start with. 
; Base 1 or -1: Positve Number = Left, Negative Number = Right
; $Midend (optional) - Number of Characters to include from $midstart
;
;
;Example
;
; $string='Hello this is a test'
;
;? Mid($string,7,4) ;returns 'this'
;? Mid($string,7) ;returns 'this is a test'
;? Mid($string,-6) ;returns 'Hello this is a'
;? Mid($string,-8,2) ;returns 'is'

;
;DEPENDENCIES KiXtart 4.02 +
;

function mid($midstring,$midstart,optional $midend)
if $midend<0
$midend=abs($midend)
else 
if $midend>len($midstring)-abs($Midstart) or $midend=""
$midend=0
endif
endif
select
case $midstart<0
$midstart=abs($midstart)
If $midend=0 
$mid=left(right($midstring,len($midstring)),(len($midstring)-$midstart)+1)
else
$mid=left(right($midstring,($midstart+$midend)-1),$midend)
endif
case $midstart>0
if $midend=0
$mid= right(left($midstring,len($midstring)),(len($midstring)-$midstart)+1)
else
$mid=right(left($midstring,($midstart+$midend)-1),$midend)
endif
endselect
endfunction

83840MinimizeAll119LonkeroMinimizeAll() - minimize all windows0

code:

;FUNCTION	MinimizeAll
;
;AUTHOR		Lonkero
;
;ACTION		Minimizes all Windows
;
;SYNTAX		MinimizeAll
;
;PARAMETERS	none.
;
;RETURNS	nothing.
;
;DEPENDENCIES	Minimum operating systems: NT or win95 with IE4
;
;EXAMPLE
;		MinimizeAll
;		"all windows minimized..."
;
;CODE

function MinimizeAll()
 dim $
 $=createobject("shell.application")
 $.MinimizeAll()
endfunction

84451MinorVersion31RadimusMinorVersion() - Quick file version comparisons0

code:

 
;FUNCTION MinorVersion
;
;ACTION to perform simple version calculation on the Least significant digits of a file version '0.00.0000.????'
;
;AUTHOR Radimus
;
;CONTRIBUTORS 
;
;VERSION 1.0
;
;DATE CREATED 8/13/03
;
;DATE MODIFIED 
;
;KIXTART 4.20    can be modified for version 4+ by replacing the IIF() structure
;
;SYNTAX MinorVersion($IfThisIsGreater, $ThanThis, Optional $char)
;
; $IfThisIsGreater
; String containing a fileversion number
;
; $ThanThis
; String containing a fileversion number
;
; Optional $char
; optional character that separates segments of the string (defaults to . (period)
;
;RETURNS 0/1
;
;REMARKS designed for quick file version comparisons
;
;DEPENDENCIES none
;
;EXAMPLE 
;		if MinorVersion('5.00.2195.6753', getfileversion('%windir%\system32\Rpcrt4.dll'))
;			? 'Installed version is older'
;			endif
;
;

Function MinorVersion($IfThisIsGreater, $ThanThis, Optional $char)
	Dim $1,$2
	if not $char	$char='.'	endif
	$1=val(right($IfThisIsGreater,instrrev($IfThisIsGreater,$char)))
	$2=val(right($ThanThis,instrrev($ThanThis,$char)))
	$MinorVersion=iif($1>$2,1,0)
	endfunction
 


 
 [ 14. August 2003, 11:50: Message edited by: Radimus ]83269MixedCase1633Will SMixedCase() - Changes a string to mixed case0

code:

 
;Function MixedCase()
;
;Author - William R. Schwab
;
;Version - 1.0
;
;Action - Changes a string to mixed case (first letter of every word in caps, rest of word in lowercase) Character after , or . or a space or a tab will be in capitals
;
;Syntax - MixedCase("string")
;
;Parameters
;             string - this is the string you want to find how many of a certain character is in it.
;
;
;Returns
;             Returns the number of times the character appears in the string.
;
;Dependencies
;             None
;
;Example(s)
;             $x=CharCount("This is a test")
;                          This would return the string - This Is A Test
;
;Source

FUNCTION MixedCase ($ExpStr1)
;Changes a string to mixed case (first letter of every word in caps, rest of word in lowercase)
;Character after , or . or a space or a tab will be in capitals
;
;Declares local variable $nc, $nc2
dim $nc, $nc2, $tempstring, $prevchar

;Sets variable $nc to the length of string
$nc=LEN($ExpStr1)

;Sets control variable to 1
;This will start the search at the first character in the string
$nc2=1

;Sets control variable to ""
$tempstring=""

;Sets previous character to space
;This will ensure that the first character in string is capitalized
$prevchar=CHR(32)


;While the control variable $nc is <= the length of the string $nc
WHILE $nc2 <= $nc

	SELECT

	;Checks to see if $previous character was a . , space or horizontal tab
	;If it is convert character to uppercase
	CASE (($prevchar=CHR(32)) OR ($prevchar=CHR(46)) OR ($prevchar=CHR(44)) OR ($prevchar=CHR(9)))

		;Current character is lowercase
		IF ((ASC(SUBSTR($ExpStr1,$nc2,1)) >=97) AND (ASC(SUBSTR($ExpStr1,$nc2,1)) <= 122))
			
			;Converts current character to uppercase
			$tempstring=$tempstring+CHR(ASC(SUBSTR($ExpStr1,$nc2,1))-32)

		ELSE

			$tempstring=$tempstring+SUBSTR($ExpStr1,$nc2,1)

		ENDIF

		;Sets current character as the previous character
		$prevchar=SUBSTR($ExpStr1,$nc2,1)

		;Increments counter
		$nc2=$nc2+1
		
	;If current character is uppercase, convert to lowercase
	CASE ((ASC(SUBSTR($ExpStr1,$nc2,1)) >=65) AND (ASC(SUBSTR($ExpStr1,$nc2,1)) <= 90))

			;Converts current character to lowercase
			$tempstring=$tempstring+CHR(ASC(SUBSTR($ExpStr1,$nc2,1))+32)

			;Sets current character as the previous character
			$prevchar=SUBSTR($ExpStr1,$nc2,1)

			;Increments counter
			$nc2=$nc2+1


	;All other characters return to string
	CASE 1

			;Assigns current character to string
			$tempstring=$tempstring+SUBSTR($ExpStr1,$nc2,1)

			;Sets current character as the previous character
			$prevchar=SUBSTR($ExpStr1,$nc2,1)

			;Increments counter
			$nc2=$nc2+1

	ENDSELECT

;End of While $nc2 <= $nc loop
LOOP

;Returns the number of times 
$MixedCase=$tempstring

;End of function
ENDFUNCTION
 

84601Moan119LonkeroMoan() - Mother Of All Networks0

;FUNCTION	MOAN() 

; 

;ACTION		Depending on the input, returns IP-addresses, Subnets,  

;		 NetworkIDs or IsInSubnet boolean. 

; 

;AUTHORS 

;		Jooel Nieminen	(jooel_nieminen@gwspikval.com) 

;		Howard Bullock	(habullock@comcast.net) 

;		Jens Meyer	(sealeopard@usa.net) 

;		Patrick Rutten	(MightyR1@hotmail.com) 

; 

;VERSION	1.0.1 

; 

;VERSION HISTORY 

;		1.0.1	(28. September 2003) 

;		 - made parameters optional 

;		1.0	(02. June 2003) 

;		 - golf winner 

; 

;SYNTAX		MOAN(IP, NetworkID, SubnetMask) 

; 

;PARAMETERS 

;		IP		(optional) 

;		NetworkID	(optional) 

;		SubnetMask	(optional) 

; 

;RETURNS 

;		Input:  IP, NetworkID, SubnetMask 

;		Output: 1 If the IP is a member of a network defined  

;		 by NetworkID AND SubnetMask, otherwise 0 

; 

;		Input:  IP, NetworkID 

;		Output: Array of all potential SubnetMasks  

;		 (CIDR notation) OR empty string If no match 

; 

;		Input:  IP, SubnetMask 

;		 Output: NetworkID OR empty string If no match 

; 

;		Input:  NetworkID, SubnetMask 

;		Output: Array of all potential IP addresses OR  

;		 empty string If no match 

; 

;REMARKS 

;		This UDF is a result of a KiXGolf Tournament hosted by 

;		Sealeopard. Follow the links below to see how the game 

;		was played. 

; 

;		Assumption: Network/broadcast addresses are NOT 

;		available as regular IP addresses though RFC3021 allows 

;		/31 networks (two IP addresses where the network/broadcast 

;		addresses are used as regular IP addresses) 

; 

;		At least two input parameters must be provided. 

; 

;		If the output consists of an array of IP addresses, 

;		then the IP addresses must be sorted In ascending order. 

; 

;		The subnet mask $SubnetMask can be either the traditional  

;		four-octets OR the alternate CIDR number, e.g. 

;		255.255.255.0 AND 24. 

; 

;		The parameters can contain up to two spaces between the  

;		decimal points AND the number, e.g. 192.168.0.10 AND 

;		192.168.  0. 10 should be treated the same. 

; 

;DEPENDENCIES	none 

; 

;EXAMPLEs 

;		[Example 1] 

;		  $IP=192.168.1.2 

;		  $NetworkID=192.168.1.0 

;		  $SubnetMask=255.255.255.0 

;		  "we will get 1 from here:" 

;		  MOAN($IP,$NetworkID,$SubnetMask) 

; 

;		[Example 2] 

;		  IP=192.168.0.1 

;		  NetworkID=192.168.1.0 

;		  SubnetMask=255.255.255.0 

;		  "we will get 0 from here:" 

;		  MOAN($IP,$NetworkID,$SubnetMask) 

; 

;		[Example 3] 

;		  $NetworkID=10.10.5.4 

;		  $SubnetMask=255.255.255.252 

;		  "we will get array of possible IP's:" ? 

;		  $array=MOAN(,$NetworkID,$SubnetMask) 

;	 	  if 8000<vartype($array) ;yep, data in there. 

;			for each $ip in $array 

;				$ip ? 

;			next 

;		  else 

;			"not applicable" 

;		  endif 

; 

;		[Example 4] 

;		  $IP=192.10.128.55 

;		  $SubnetMask=27 

;		  "returning NetworkID for the values:" 

;		  MOAN($IP,,$SubnetMask) 

; 

;		[Example 5] 

;		  $IP=10.10.10.2 

;		  $SubnetMask=255.255.255.254 

;		  "these values are fake, will return nothing:" 

;		  MOAN($IP,,$SubnetMask) 

; 

;		[Example 6] 

;		  $IP=10.10.10.2 

;		  $NetworkID=10.10.10.0 

;		  "we will get array of possible SubnetMasks:" ? 

;		  $array=MOAN($IP,$NetworkID) 

;	 	  if ubound($array) ;yep, data in there. 

;			for each $sub in $array 

;				$sub ? 

;			next 

;		  else 

;			"not applicable" 

;		  endif 

;		  ;will return: /23,/24,/25,/26,/27,/28,/29,/30 

; 

;		[Example 7] 

;		  $IP=192.168.99.55 

;		  $NetworkID=192.168.99.55 

;		  $array=MOAN($IP,$NetworkID) 

;		  ;use the same code as in 6. 

;		  ;should return nothing as this is not possible. 

; 

; 

;KIXTART VERSION 

;		tested on 4.21 

; 

;KIXTART BBS 

;		This UDF 

;		  - http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000466 

; 

;		KiXGolf: MOAN(), Mother Of All Networks --> 

;		  - http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=14;t=000720 

; 

;		KixGolf: MOAN(), Part II --> 

;		  - http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=14;t=000748 

; 

;		SIMPLIFIED HEAVILY COMMENTED CODE --> 

;		  - http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=14;t=000748;p=4#000083 

; 

;SOURCE 

Function moan(optional $a,optional $b,optional $c)

    Dim $,$d,$e,$g,$h,$m[3]



    ;Build Subnet Mask 

    for $e=8 to 31

        $=$e

        $h=1

        for $g=0 to 3

	    $d=0,128,192,224,240,248,252,254

            $m[$g]=iif($/8,255,$d[$ mod 8])

	    $d="."

            $=($>8)*($-8)

            if $a & $b

               $h=$h & split($b,$d)[$g]=(0+split($a,$d)[$g] & $m[$g])

            endif

        next

        if $h

            $c=$c+" /"+$e

        endif

        if $e=$c

           $c=join($m,$d)

        endif

    next

    ;End build mask array 

    if instr($c,$d)

        ;build array of input values by splitting a string. Then convert to integers 

        ; Mask = $[0..3]   NetID = $[4..7]   IPaddr = $[8..11] 

        $=split($c+$d+$b,$d)

        $c=""

        if $a

            ;Calculate NetworkID using $ array 



            for $e=0 to 3

                $c=$c+$d+(0+$[$e] & 0+split($a,$d)[$e])

            next

            if $d+join(split($a),"")=$c

               $c=""

            endif



            ;Output: 1 if the IP is a member of a nework defined by network ID and subnet mask, otherwise 0 

            ;Input NetworkID = Calculated NetworkID 

            if $b

                $c=$d+join(split($b),"")=$c

            endif

        else

            ;Output: Network ID or empty string if no match 

            ;Output: Array of all potential IP addresses or empty string if no match 

            for $b=$[4] to 255 + $[4]  - $[0]

                for $h=$[5] to 255 + $[5] - $[1]

                    for $e=$[6] to 255 + $[6] - $[2]

                        for $a=1+$[7] to 254 + $[7] - $[3]

                            $c = $c+" "+$b+$d+$h+$d+$e+$d+$a

                        next

                    next

                next

            next

        endif

    endif $=$c,split(substr($c,2))

    $moan=$[len($c)>1]

EndFunction


 
 [ 28. September 2003, 10:25: Message edited by: Lonkero ]83570ModifyStartMenu52NTDOCModifyStartMenu()0;FUNCTION      ModifyStartMenu()
;
;ACTION        Modifies the Start Menu and Taskbar options
;
;AUTHOR        Ron Lewis/NTDOC (wdintdocman@hotmail.com)
;
;HELP BY:  Bryce wrote code to update binary values.
;
;SYNTAX        None
;
;PARAMETERS    $regstring[52] = "06"
;              $regstring[8] = "06"
;              Selects which binary value to edit - see table
;              $regstate[32]="00"
;              Sets XP Menu Style - see table
;
;RETURN        0 if successful, otherwise error code
;
;REMARKS       Please read all documentation for options
;
;KIXTART VER   4.12
;
;DEPENDENCIES  Latest version of WMI and KiXtart 4.12
;
;TESTED ON     Windows 98SE, NT, 2000, XP
;
;EXAMPLE       $ReturnCode=ModifyStartMenu
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000279
;
;Documentation and Code below

Modifying the Start Menu Options via KiXtart

In order to modify the Start Menu Options via a Regedit or programmatically 
you need to make the modification first, then either log off or end task the 
shell (explorer.exe) and your new settings will take affect.  The reason is 
that these settings appear to first be stored in volatile memory and are 
then written to the Registry when you log off.  The GUI apparently makes 
some kind of undocumented API call to have Explorer reload its settings, 
which you are not able to do with a simple Regedit change.  There also 
appears to be a state that can't be achieved via the GUI, which is to use 
the Classic Menu and Small Icons, but can be done via Regedit.

Windows XP:  Shell State XP Menu or Classic Menu
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer
ShellState
Reg_Binary - The 33rd binary value controls this state.  
00=Classic Menu 02=XP Menu

Windows XP:  Large/Small Icons
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced
Start_LargeMFUIcons
DWORD 1 Enables large icons 0 Disables large icons when using the XP Menu and
not the Classic Menu.  The Classic Menu does not use the Start_LargeMFUIcons 
settings

Windows XP:  Lock the Taskbar Menu
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced
TaskbarSizeMove
DWORD 1 Disables locking the taskbar 0 Enables locking the taskbar

Windows XP:  Group Similar Tasbar Buttons
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced
TaskbarGlomming
DWORD 1 Enables grouping similar buttons 0 Disables grouping similar buttons

Windows Start Menu options are controlled by the following Registry locations.
Windows 2000 and XP use the 9th binary value and Windows NT uses the 53 binary 
value as shown in the table below.

Windows 2000 and XP
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects2
Settings
Windows NT 4.0
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects
Settings
Windows 9x
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects
Settings

SINGLE OPTIONS:
08 = No Settings Enabled
09 = Auto Hide
00 = Show Clock
0A = Always on Top
0C = Show small icons in Start Menu

MULTIPLE OPTIONS:
01 = Auto Hide and Show Clock
02 = Always on Top and Show Clock
03 = Always on Top and Auto Hide and Show Clock
04 = Show small icons in Start Menu and Show Clock
0E = Always on Top and Show small icons in Start Menu
0F = Always on Top and Auto Hide and Show small icons in Start Menu
06 = Always on Top and Show small icons in Start Menu and Show Clock
07 = All Options Enabled
0B = Always on Top and Auto Hide
0D = Auto Hide and Show small icons in Start Menu


FunctionÿModifyStartMenu()
dimÿ$ars,ÿ$i,ÿ$count,ÿ$settings,ÿ$x
Ifÿ@INWIN=1
ÿ ÿ $ARSÿ=ÿwritevalue("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsÿNT\CurrentVersion\Winlogon","AutoRestartShell","1","REG_DWORD")
EndIF
Select
ÿ ÿ Caseÿ@PRODUCTTYPE="Windowsÿ95"
ÿ ÿ ÿ ÿ $settingsÿ=ÿreadvalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects","settings")
ÿ ÿ Caseÿ@PRODUCTTYPE="Windowsÿ98"
ÿ ÿ ÿ ÿ $settingsÿ=ÿreadvalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects","settings")
ÿ ÿ Caseÿ@PRODUCTTYPE="WindowsÿMe"
ÿ ÿ ÿ ÿ $settingsÿ=ÿreadvalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects","settings")
ÿ ÿ Caseÿ@PRODUCTTYPE="WindowsÿNTÿWorkstation"
ÿ ÿ ÿ ÿ $settingsÿ=ÿreadvalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects","settings")
ÿ ÿ Caseÿ@PRODUCTTYPE="Windowsÿ2000ÿProfessional"
ÿ ÿ ÿ ÿ $settingsÿ=ÿreadvalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects2","settings")
ÿ ÿ Caseÿ@PRODUCTTYPE="WindowsÿXPÿProfessional"
ÿ ÿ ÿ ÿ $settingsÿ=ÿreadvalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects2","settings")
ÿ ÿ Caseÿ1
ÿ ÿ ÿ ÿ Return
EndSelect

Dimÿ$regstring[(len($settings)/2)-1]

forÿ$iÿ=ÿ1ÿtoÿlen($settings)ÿstepÿ2
ÿ ÿ $regstring[$count]ÿ=ÿsubstr($settings,$i,2)
ÿ ÿ $countÿ=ÿ$countÿ+ÿ1
next

Select
ÿ ÿ Caseÿ@PRODUCTTYPE="Windowsÿ95"
ÿ ÿ ÿ ÿ $regstring[8]ÿ=ÿ"06"
ÿ ÿ ÿ ÿ $xÿ=ÿwritevalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects","settings",join($regstring,""),"REG_BINARY")
ÿ ÿ Caseÿ@PRODUCTTYPE="Windowsÿ98"
ÿ ÿ ÿ ÿ $regstring[8]ÿ=ÿ"06"
ÿ ÿ ÿ ÿ $xÿ=ÿwritevalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects","settings",join($regstring,""),"REG_BINARY")
ÿ ÿ Caseÿ@PRODUCTTYPE="WindowsÿMe"
ÿ ÿ ÿ ÿ $regstring[8]ÿ=ÿ"06"
ÿ ÿ ÿ ÿ $xÿ=ÿwritevalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects","settings",join($regstring,""),"REG_BINARY")
ÿ ÿ Caseÿ@PRODUCTTYPE="WindowsÿNTÿWorkstation"
ÿ ÿ ÿ ÿ $regstring[52]ÿ=ÿ"06"
ÿ ÿ ÿ ÿ $xÿ=ÿwritevalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects","settings",join($regstring,""),"REG_BINARY")
ÿ ÿ Caseÿ@PRODUCTTYPE="Windowsÿ2000ÿProfessional"
ÿ ÿ ÿ ÿ $regstring[8]ÿ=ÿ"06"
ÿ ÿ ÿ ÿ $xÿ=ÿwritevalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects2","settings",join($regstring,""),"REG_BINARY")
ÿ ÿ Caseÿ@PRODUCTTYPE="WindowsÿXPÿProfessional"
ÿ ÿ ÿ ÿ $regstring[8]ÿ=ÿ"06"
ÿ ÿ ÿ ÿ $xÿ=ÿwritevalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\StuckRects2","settings",join($regstring,""),"REG_BINARY")
ÿ ÿ Caseÿ1
ÿ ÿ ÿ ÿ Return
EndSelect

Ifÿ@PRODUCTTYPE="WindowsÿXPÿProfessional"
ÿ ÿ $stateÿ=ÿreadvalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer","shellstate")
Dimÿ$regstate[(len($state)/2)-1]
$countÿ=ÿ0
Forÿ$iÿ=ÿ1ÿtoÿlen($state)ÿstepÿ2
ÿ ÿ $regstate[$count]ÿ=ÿsubstr($state,$i,2)
ÿ ÿ $countÿ=ÿ$countÿ+ÿ1
next
ÿ ÿ $regstate[32]="00"ÿ;ÿ00=ClassicÿMenuÿ 02=XPÿMenu
ÿ ÿ ;ÿStart_LargeMFUIconsÿvalueÿofÿ1=UseÿLargeÿIconsÿinÿXPÿMenuÿ0=UseÿSmallÿIconsÿinÿXPÿMenu
ÿ ÿ $xÿ=ÿWriteValue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced",ÿ"Start_LargeMFUIcons","0",ÿ"REG_DWORD")
ÿ ÿ $xÿ=ÿwritevalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer","shellstate",join($regstate,""),"REG_BINARY")
Endif
$COMPUTER=@WKSTA
$PROCÿ=ÿ"EXPLORER.EXE"
Forÿeachÿ$ProcessÿinÿGetObject("winmgmts:{impersonationLevel=impersonate}!//$COMPUTER").ExecQuery("selectÿ*ÿfromÿWin32_ProcessÿwhereÿName='$PROC'")
ÿ ÿ $x=$Process.Terminate
Next
Ifÿ@INWIN=2
ÿ ÿ Runÿ"Explorer"
Endif
EndFunction


; OPTIONS TABLE
;
; SINGLE OPTIONS:
; 08 = No Settings Enabled
; 09 = Auto Hide
; 00 = Show Clock
; 0A = Always on Top
; 0C = Show small icons in Start Menu
; 
; MULTIPLE OPTIONS:
; 01 = Auto Hide and Show Clock
; 02 = Always on Top and Show Clock
; 03 = Always on Top and Auto Hide and Show Clock
; 04 = Show small icons in Start Menu and Show Clock
; 0E = Always on Top and Show small icons in Start Menu
; 0F = Always on Top and Auto Hide and Show small icons in Start Menu
; 06 = Always on Top and Show small icons in Start Menu and Show Clock
; 07 = All Options Enabled
; 0B = Always on Top and Auto Hide
; 0D = Auto Hide and Show small icons in Start Menu
 
 [ 22. February 2003, 08:04: Message edited by: NTDOC ]83160MRedim1**DONOTDELETE**MRedim() - Resize multi dimensional arrays0

code:

;FUNCTION MRedim()
;
;AUTHOR       AJH (Andrew Hayes)
;
;ACTION       Allows the bounds of a Multi Dimension array to be altered
;
;SYNTAX       $Array = MRedim(Array, dimension_list)
;
;PARAMETERS   Array to be redimensioned
;             List of Dimension sizes
;              (Either a comma seperated text string, or an array variable)
;
;REMARKS      This UDF takes as input a simulated multi dimension array (eg created by my
;             MArray UDF) and resizes the array dimensions whilst preserving the contents
;             of remaining cells. Contents remain in the same cell reference.
;             If you change the number of dimensions then ALL contents will be lost.
;
;             This UDF may take a long time to execute.
;             See my companion UDFs MArray() and MUbound() for more information.
;
;RETURNS      A simulated multi dimensional array structure.
;
;REQUIRES     Kixtart 4.02 release or above
;
;EXAMPLE      $Array = MArray("2,1,4,3")          ;creates an array of 4 dimensions
;             $Array[1][0][3][2] = "hello there"
;             $dimensions = MUbound($Array)       ;Returns an array containing 2,1,4,3
;             $dimensions[0] = 1
;             $dimensions[2] = 6
;             $Array = MRedim($Array,$dimensions) ;Returns a 4D array with bounds 1,1,6,3
;
;             ? 'Cell (1,0,3,2) contains the text ' +$Array[1][0][3][2]
;
;
;Source
;
FUNCTION MRedim($A, $ind, OPTIONAL $ptr)
IF Ubound($ind) < 1 $ind =Split($ind,",") ENDIF
REDIM PRESERVE $A[$ind[$ptr]]
DIM $L
IF $ptr < UBound($ind)
  FOR $L = 0 TO UBound($A)  $A[$L]=MRedim($A[$L],$ind,$ptr+1)  NEXT
ELSE
  IF VarType($A[0]) & 8192  $L=UBound($A)  REDIM $A[$L]  ENDIF
ENDIF
$MRedim = $A
ENDFUNCTION 

181595MSCommonDialog5694WittoMSCommonDialog() - Common Dialog Box to select files1207589984



;MSCommonDialog() 
;  
;ACTION         Creates Dialog Box to select one or more files.  
;  
;AUTHOR         Wim Rotty  
;  
;CONTRIBUTORS     
;  
;VERSION        1  
;  
;DATE CREATED   2007-10-14 v.0.1   Initial release  
;  
;DATE MODIFIED  2008-04-07 V.1  
;  
;KIXTART        4.00 and higher  
;  
;SYNTAX         MSCommonDialog([MaxFileSize], [InitDir], [Filter], [FilterIndex], [Flags], [DialogTitle])  
;  
;PARAMETERS     $MaxFileSize  
;               Optional, Integer (Short)  
;               Returns/sets the maximum size of the filename opened. 
;  
;               $InitDir 
;               Optional, String 
;               Returns/sets the initial file directory. 
;  
;               $Filter 
;               Optional, String 
;               Returns/sets the filters that are displayed in the Type list box of a dialog box. 
;  
;               $FilterIndex 
;               Optional, Integer (Short) 
;               Returns/sets a default filter for an Open or Save As dialog box. 
;  
;               $Flags 
;               Optional, Long 
;               Sets the options for a dialog box. 
;  
;               $DialogTitle  
;               Optional, String  
;               Sets the string displayed in the title bar of the dialog box. 
;  
;RETURNS        String, the path and filename of a selected file.  
;               For the multiselection style dialog box, the path and the  
;               filenames are reduced to Short File Names, the path and the  
;               filenames are separated by spaces.  
;  
;               Error codes: 0 = Success, all other = Error  
;  
;               If the CommonDialog Object cannot be created,  
;               an event is written to the application log  
;  
;REMARKS        IMHO some intersting flags:  
;               4 - Hides the Read Only check box.  
;               512 - Allows the File Name list box to have multiple selections.   
;               Use a COM browser to review the FileOpenConstants 
;                 
;               The "Microsoft Common Dialog Control" has much more potential  
;               than used in this function. If anyone needs more functionality,  
;               maybe this function can be reworked.  
;  
;               A distribution license from Microsoft for Microsoft's Common Dialog Control  
;               (Comdlg32.ocx) is required. This can be checked in the registry under  
;               HKEY_CLASSES_ROOT\Licenses\4D553650-6ABE-11cf-8ADB-00AA00C00905  
;               As far as I know, the License is officialy provided with a VStudio product  
;               As far as I understand, a distribution of a program with a reference to  
;               "Microsoft Common Dialog Control" will provide the license key  
;  
;More information:  
; http://msdn2.microsoft.com/en-us/library/aa155724(office.10).aspx  
;  
;DEPENDENCIES   Windows XP  
;               a distribution license from Microsoft for Microsoft's Common Dialog Control  
;  
;EXAMPLE          
; 
;;Script Options 
;If Not @LOGONMODE 
;	Break On 
;Else 
;	Break Off 
;EndIf 
;Dim $RC 
;$RC = SetOption("Explicit","On") 
;$RC = SetOption("NoMacrosInStrings","On") 
;$RC = SetOption("NoVarsInStrings","On") 
;If @SCRIPTEXE = KIX32.EXE 
;	$RC = SetOption("WrapAtEOL","On") 
;EndIf 
; 
;;Declare variables 
;Dim $MaxFileSize 
;Dim $InitDir, $Filter, $FilterIndex, $Flags, $DialogTitle 
;Dim $Files, $i 
; 
;;Initialize variables 
;$MaxFileSize = 1000 
;$InitDir = "%HOMEDRIVE%"+"%HOMEPATH%" 
;$Filter = "Text Files|*.txt|Comma Separated Values|*.csv|All Files|*.*" 
;$FilterIndex = 3 
;$Flags = 516 
;$DialogTitle = "Select the file(s) you want to open" 
; 
;;Code 
;$Files = MSCommonDialog($MaxFileSize, $InitDir, $Filter, $FilterIndex, $Flags, $DialogTitle) 
;$Files ? 
;If Not $Files = "" 
;	$Files = Split($Files," ") 
;	For $i = 0 to UBound($Files) 
;		If $i = 0 
;			"Path: " 
;		Else 
;			"File "$i": " 
;		EndIf 
;		$Files[$i] ? 
;	Next 
;Else 
;	"Nothing Selected" ? 
;EndIf 
;  
;KIXTART BBS    http://www.kixtart.org/forums/ubbthreads.php?ubb=showflat&Number=181568#Post181568  
;                 
Function MSCommonDialog(Optional $MaxFileSize, 
                        Optional $InitDir, 
                        Optional $Filter, 
                        Optional $FilterIndex, 
                        Optional $Flags, 
                        Optional $DialogTitle)
	
	;;;;;;;;;;;;;;;;;;;;; 
	; Declare variables ; 
	;;;;;;;;;;;;;;;;;;;;; 
	
	; Variable for Common Dialog Object 
	Dim $objDialog
	
	;;;;;;;; 
	; code ; 
	;;;;;;;; 
	
	; Create Dialog object 
	$objDialog = CreateObject("MSComDlg.CommonDialog")
	; If Dialog object cannot be created, Dispose object and exit Function 
	If @ERROR <> 0
		$objDialog = ''
		Exit @ERROR
	EndIf
 
	; Set max length returned by .FileName 
	; $objDialog.MaxFileSize is required 
	If $MaxFileSize = ''
		; If user gave no value, set per default to 1000 
		$MaxFileSize = 1000
	EndIf
	$objDialog.MaxFileSize = $MaxFileSize
	
	; Set initial directory 
	If Not $InitDir = ''
		$objDialog.InitDir = $InitDir
	EndIf
	
	; Set Filter 
	If Not $Filter = ''
		$objDialog.Filter = $Filter
	EndIf
	
	; Set FilterIndex 
	If Not $FilterIndex = ''
		$objDialog.FilterIndex = $FilterIndex
	EndIf
	
	; Set Flags, if no flags are given, hide "Read Only" tick box 
	If Not $Flags = ''
		$objDialog.Flags = $Flags
	Else
		$objDialog.Flags = 4
	EndIf
	
	; Set DialogTitle 
	If Not $DialogTitle = ''
		$objDialog.DialogTitle = $DialogTitle
	EndIf
	
	; Show Dialog box 
	$objDialog.ShowOpen
	
	; Catch return value 
	$MSCommonDialog = $objDialog.FileName
	
	; Dispose object 
	$objDialog = ''
	
	; Exit function 
	Exit @ERROR
	
EndFunction
 
82332Msec2Sec17SealeopardMsec2Sec() - Convert milliseconds to seconds0

code:

;FUNCTION      Msec2Sec
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Convert milliseconds to seconds
;
;VERSION       1.2
;
;KIXTART       4.20
;
;SYNTAX        MSEC2SEC(STRTIME)
;
;PARAMETERS    STRTIME
;              Reqired string containing a time in milliseconds
;
;RETURNS       Time in seconds and milliseconds [SS.MSECS]
;
;REMARKS       none
;
;DEPENDENCIES  none
;
;EXAMPLE       $rc=MSEC2SEC('1234')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000051
;
function msec2sec($strtime)
  $msec2sec=cdbl($strtime)/1000
endfunction


 
 [ 02. March 2003, 17:09: Message edited by: sealeopard ]130947msiInstalled119LonkeromsiInstalled() - checks msi installation status0 Code:


;Function:
;	msiInstalled()
;
;Author:
;	Lonkero
;
;Version:
;	1.0
;
;Version History:
;	1.0	(9th of dec 2004)	- initial release
;
;Action:
;	checks if MSI is installed or not
;
;Syntax:
;	msiInstalled(MSI)
;
;Parameters:
;	MSI
;	 optional. msi file to check against.
;
;Returns:
;	if MSI given:
;	 1 - given MSI package is installed
;	 0 - not installed
;	if no package name given, returns all packages installed.
;
;Errorcodes:
;	na.
;
;Dependencies:
;	msi.dll
;
;Remarks:
;	some MS pages say installer version 3 required, but they don't know... 
;
;Examples:
;	if msiInstalled("netFX.msi")
;	 "netframework is installed here"
;	endif
;	get $
;
;	"installed packages:" ?
;	for each $package in msiInstalled()
;	 $package ?
;	next
;	get $
;
;Source:
function msiInstalled(optional $msi)
dim $,$p,$t
 $msiInstalled=0
 $=createobject("windowsinstaller.installer")
 for each $p in $.products
  if vartype($msi)
   if $msi = $.productinfo($p,"PackageName") $msiInstalled=1 endif
  else
   $t=$t+chr(10)+$.productinfo($p,"PackageName")
   $msiInstalled=split(substr($t,2),chr(10))
  endif
 next
endfunction

  143013MSNMessenger52NTDOCMSNMessenger() - Silently add/remove MSN messenger0

;Function	MSNMessenger() - Silently add/remove MSN messenger  
;Author		NTDOC 
;Version	2.0  
;Date		2004/30/10 
;Updated	2005/07/05 
;Update Reason	Remove only worked for specific version, now should remove for all 7.x versions	 
;Action		Silently installs or removes MSN Messenger v7.x   
;				 
;Example:		 
;		Dim $MSN 
;		$MSN=MSNMessenger('I') 
; 
;Parameters	I for install or U for un-install 
; 
;Dependencies	KiXtart 4.x, MSN Messenger file MsnMsgs.msi which can be extracted using WinZip/WinRar 
;		or similar util 
; 
;Downloads	MSN Messenger Download 
;		http://messenger.msn.com/download/downloadx.aspx 
; 
;Notes		Since Microsoft will no longer allow connection to their network with 6.x clients 
;		you're forced to update to 7.x which this updated script version should now handle 
; 
;Source:  		 
 

Function MSNMessenger($Method)
  Dim $BaseKey,$MSNKey,$KeyIndex,$Key,$Keys,$Operation
  $BaseKey='HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall'
  $KeyIndex=0
  While @ERROR=0
    $MSNKey=EnumKey($BaseKey,$KeyIndex)
    $KeyIndex=$KeyIndex+1
    $Keys=$Keys+$BaseKey+'\'+$MSNKey+@CRLF
  Loop
  Select
    Case $Method = 'I'
      Shell 'msiexec /i ' + @CurDir +'\MsnMsgs.msi IAGREE="Yes" ADDEXPLORERTOOLBAR="" SETSEARCHENGINE="" SETHOMEPAGE="" /q'
    Case $Method = 'U'
      For Each $Key In Split($Keys,@CRLF)
       If $Key
         If InStr(ReadValue($Key,'DisplayName'),'MSN Messenger')
           $Operation = Join(Split(ReadValue($Key,'UninstallString'),'/i'),'/q /x ')
           Shell $Operation
         EndIf
       EndIf
      Next
    Case 1
      ;User input not I or U 
      Exit 1
  EndSelect
  Exit @ERROR
EndFunction
 

 
Download MSN Messenger
http://messenger.msn.com/download/downloadx.aspx
 84494MSOfficeUser4117Fred_LeonardMSOfficeUser() - set office user information0

code:

;FUNCTION MSOfficeUser(optional $MSUser)
;
;ACTION Sets the user information for MS Office (multiple versions) so you know who has a document open.
;
;AUTHOR Fred Leonard
;
;VERSION UDF version 1.0
;
;DATE CREATED 08/27/2003
;
;KIXTART Minimum required Kixtart version 4.x
;
;SYNTAX MSOfficeUser(optional $MSUser)
;
;PARAMETERS PARAMETER1 (optional)
; Optional string of user information (default: "@FullName (@wksta - @userid)")
;
;RETURNS error flag
;
;REMARKS useful in logon scripts set the user information for MS Office
;
;Dependencies none
;
;EXAMPLE A short functional example demonstrating the UDF
;
;$nul=MSOfficeUser()
;$nul=MSOfficeUser("@FullName")
;
;KIXTART BBS [URL=http://www.kixhelp.com]http://www.kixhelp.com[/URL]
; URL the UDF was posted under
;

Function MSOfficeUser(optional $MSUser)
	if $MSUser=""	$MSUser="@FullName (@wksta - @userid)"	EndIf
	
	$value=""
	for $i=1 to len($MSUser)
		$z=DecToHex(asc(substr($MSUser,$i,1)))
		$value=$value+$z+"00"
	next
	$value=$value+"0000"
	
	for $i=5 to 15
		$key="HKEY_CURRENT_USER\Software\Microsoft\Office\"+$i+".0\Common\UserInfo"
		if KeyExist($key)
			$nul= WriteValue($key,"UserName",$VALUE,"REG_BINARY")
		EndIf
	Next

	Exit @error
EndFunction


 
 [ 29. August 2003, 02:03: Message edited by: Fred_Leonard ]82298MUbound1**DONOTDELETE**MUbound() - Return Multi dimension array boundaries0Everybody:

I have seen several references to Multi dimensional arrays in Kixtart
and thought I would write a UDF to create them.

I have created 2 UDFs as follows:
MArray()  to create arrays  (separate post), and
MUbound() as an equivalent for UBOUND (this post).

code:

;FUNCTION	MUbound()
;
;AUTHOR		AJH (Andrew Hayes)
;
;ACTION		Returns the bounds of a multi dimensional Kixtart array
;
;SYNTAX		$dimensions = MUbound(array-variable)
;
;PARAMETERS	Array to report on	(Required)
;		Flag			(Optional, for internal UDF use only)
;
;REMARKS	Because Kixtart does not support true multi-dimension arrays, it is
;		possible for arrays not to have a square shape as in the following
;		ie DIM $a[3],  $a[0]=0,1,2,3  $a[1]=0,1  $a[2]=0,1,2,3,4,5
;		MUbound() ignores this complication and all boundaries are tested
;		on the Zero'th element of a dimension ($a[0][0] etc)
;
;		Because function parameters are passed by value rather than by reference
;		with very large arrays this procedure can take some time to execute.
;		ie if $A = MArray("1,2,3,4,5,6,7,8,9")	takes 10 mins, then
;		      $I = MUbound($A)			takes  4 mins approx
;
;RETURNS	An array containing the UBound's of the succesive dimensions,
;		If the input is not an array, the function returns 0
;		ie  $dimensions = MUbound($Array)  could return the array '2,1,4,3'
;
;REQUIRES	Kixtart 4.0.2 release or above
;
;EXAMPLES	e.g.  An array with 4 dimensions  $Array[2][1][4][3]
;		as may be created with my UDF MArray("2,1,4,3") or as described in
;		remarks above
;
;		$Array = MArray("2,1,4,3")
;		$dimensions = MUbound($Array)
;		? "This array has "+(UBOUND($dimensions)+1)+" dimensions."
;		? "They have the following bounds:"
;		FOR $z = 0 TO UBOUND($dimensions)
;		    ? "Dimension "+$z+" has "+($dimensions[$z]+1)+" elements"
;		NEXT
;
;
;SOURCE
		FUNCTION MUbound($A,OPTIONAL $f)
		DIM $I
		IF (VarType($A) & 8192)
		  $I = ","+Ubound($A) +MUbound($A[0],1)
		ENDIF
		SELECT
		  CASE ($f)  $MUBound =$I
		  CASE ($I)  $MUBound =Split(Substr($I,2),",")
		    FOR $I = 0 TO UBound($MUBound)  $MUBound[$I] =Val($MUBound[$I])  NEXT
		  CASE 1     $MUBound = 0
		ENDSELECT
		ENDFUNCTION
;


 
 [ 24 May 2002, 22:39: Message edited by: AJH ]139686Multiply28BryceMultiply() Multiply large numbers toghther0;Function      Multiply 
; 
;ACTION        Multiply large numbers toghther to get around the 32bit limitation. 
; 
;AUTHOR        Rogier (Bryce just put it in a UDF, with minor edit for UDF standards) 
; 
;VERSION       1.0 first publish 
; 
;KIXTART       4.22 
; 
;SYNTAX        RETCODE = Multiply(STRING1, STRING2) 
; 
;PARAMETERS    STRING1 
;              a string containing a number 
; 
;              STRING2 
;              a string containing a number 
; 
;Return        A string containing the value of the 2 numbers multiplied toghther. 
; 
;REMARKS       See this thread For original idea 
;              http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=54462&page=0&fpart=2&vc=1 
;              Also Chris S. for prompting a need for this UDF 
;              NTDoc for prof-reading! 
; 
;DEPENDENCIES  Add() 
; 
;              ;return a large number 
;EXAMPLE       $Return = multiply('11644473600','1115830523') 
;               
Function multiply($val1, $val2)
	DIM $ans, $subans, $carry, $zeros, $pos1, $pos2, 
	$post, $a, $str1, $str2

	If Len($val1) > Len($val2)
		$str2 = $val1 
		$str1 = $val2
	Else
		$str1 = $val1
		$str2 = $val2
	EndIf

	$ans="" $subans="" $carry=0
	$pos1=Len($str1) $pos2=Len($str2)
	Do
		$zeros=0 
		While $pos1+$zeros<len($str1) 
			$subans="0"+$subans 
			$zeros=$zeros+1 
		Loop
		$post=$pos2
		While $post>0 or $carry>0
			If $post>0 
				$a=Val(SubSTR($str1,$pos1,1))*(SubSTR($str2,$post,1))
			EndIf
			$a=$a+$carry
			If $a>9 
				$carry=Val(SubSTR(""+$a,1,1)) 
				$a=Val(SubSTR(""+$a,2,1))
			Else 
				$carry=0
			EndIf
			$subans=""+$a+$subans
			$a=0
			$post=$post-1
		Loop
		$subans="|"+$subans
		$pos1=$pos1-1
	Until $pos1=0
	
	$str1="" $str2=""
	Do
		$str1=$ans
		$ans=""
		$subans=SubSTR($subans,2,Len($subans))
		If InSTR($subans,"|")
			$str2=SubSTR($subans,1,InSTR($subans,"|")-1)
			$subans=SubSTR($subans,InSTR($subans,"|"),Len($subans))
		Else
			$str2=$subans
			$subans=""
		EndIf
		$ans = add($str1, $str2)
	Until Len($subans)=0
	$multiply = $ans
EndFunction 
83130MyAT176Mark BennettMyAT() - halt script until specified time0Here is a function I have created that allows you to halt a script executing commands until a specified time. The sample included does not do very much other than wait until the specified time then tell you so!

Comments/suggestions welcome as this is my first UDF (and I am rather proud of it)!

Enjoy,
Mark

code:

 
;Function:	MyAT
;Written by:	Mark Bennett
;Action:		Schedule a process within a KiX script.
;Syntax:		MyAT([time])
;Parameters:	[time] = hhmm (in 24 hour format)

;Intended Use:	Wait until a specified time then run the commands listed beneath.

;Example:		MyAT(1700)
;			  MsgBox("You have now finished the working day!", "9 to 5 shift workers")

Break ON CLS

? ? Color y+/n " _________________________"
? ? " MyAT UDF Demonstration"
? ? " Written by Mark Bennett"
? " _________________________" Color w/n

:Get_Time
? ? "  Enter destination time (eg 1645): " Gets $Time

If Val("$Time") > 2359 
  Gosub Syntax_Error 
  Goto Get_Time
EndIf
If Len("$Time") <> 4 
  Gosub Syntax_Error 
  Goto Get_Time
EndIf

MyAT($Time)
  ? Color g+/n " We have lift off!"

? ? Color b+/n "Press any key to eXit" ? Get $1 Color w/n
Exit

:Syntax_Error
  ? Color r+/n " ERROR: Invalid time format!"
  ? Color w/n " Time " Color r+/n "MUST " Color w/n "be entered in hhmm syntax."
  ? " For example:"
  ? "    2345 = 11:45 pm"
  ? "    0000 = 12:00 am (midnight)"
  ? " All times " Color r+/n "MUST " Color w/n "adhere to the hhmm format."
Return
    
Function MyAT($Time)
  $TMinusH = Val(SubStr("$Time", 1, 2))
  $TMinusM = Val(SubStr("$Time", 3, 2))
  $NowHour = Val(SubStr("@TIME", 1, 2))
  $NowMins = Val(SubStr("@TIME", 4, 2))

  While $NowHour <> $TMinusH
    $NowHour = Val(SubStr("@TIME", 1, 2))
    Sleep 60
  Loop

  While $NowMins <> $TMinusM
    $NowMins = Val(SubStr("@TIME", 4, 2))
    Sleep 30
  Loop
 
EndFunction


 
 [ 28. October 2002, 19:47: Message edited by: Radimus ]113684MyComputer119LonkeroMyComputer() - Replace "MyComputer" with any text0


;FUNCTION

;		MyComputer()

;

;AUTHOR

;		Lonkero

;

;ACTION

;		Changes the "my computer" text with any of your choice.

;

;SYNTAX

;		MyComputer([STRING])

;

;PARAMETERS

;		STRING

;		 - optional

;		 - what ever text you wish to assign in place of the old one.

;		 - if not specified, returns current

;		 - zero length erases current

;

;RETURNS

;		if no input string, the current myComputer-text

;

;DEPENDENCIES

;		none that I know of (does that mean many?)

;

;REMARKS

;		- tested only with w2k and XP so if you find problems, please report

;

;EXAMPLE

;	"Current text is:" MyComputer

;	if @wksta<>Mycomputer

;		"Current name against Corp. policy, changing"

;		mycomputer(@wksta)

;		if @error

;			mail("problems occured naming MyComp. @wksta")

;		else

;			"...	Done."

;		endif

;	endif

;

;CODE

function MyComputer(optional $in)

 dim $

 $=createobject("shell.application")

 if not vartype($in)

  $MyComputer=$.namespace(17).self.name

  exit @error

 else

  $.namespace(17).self.name=$in

  exit @error

 endif

endfunction



 84182MySQLODBC1374RaceeendMySQLODBC() - Creates a ODBC connection to MySQL0

code:

; Function:	MySQLODBC()
;
; Author:		Martijn (martijn@raceeend.com)
;
; Version:	1.0
;
; Action:		- Checks if MyODBC is installed. If not it will be installed.
;			- Creates a ODBC connection to MySQL
;
; Syntax:		$ADOdb = MySQLODBC($DataSourceName, $Description, $Option, $SourcePath, Optional $DBName, Optional $Pwd, Optional $Port, Optional $Server, Optional $Stmt, Optional $user)
;
; Parameters:
; Required
;	$DataSourceName:	Data Source Name of the connection
;	$Description:		Description of Data Source Name
;	$Option:		Used to select options which have affect on the drivers behaviours
;	$SourcePath:		Path where MyODBC files are located
; Optional
;	$DBName:		Database to connect to
;	$Pwd:			Password of database
;	$Port:			TCP Port used by MySQL
;	$Server:		IpAdress of MySQL server
;	$Stmt:			SQL statement which executes on connection
;	$user:			User which connects to database
;
; Dependencies: MyODBC files myodbc3.dll, myodbc3d.dll, my3dsn.hlp. Oh and a MySQL server http://mysql.com
;
; Remarks:	Tested on Win2k with Kix 4.12
;
; Example:	$DataSourceName = "MySQL-ADODB"
;			$Description = "MySQL ADODB connection"
;			$Option = "3"  				;Default MySQL option
;			$Server = "10.0.0.1"
;			$SourcePath = "\\server\share\"
;
;			$ADOdb = MySQLODBC($DataSourceName, $Description, $Option, $SourcePath,,,, $Server,,)

Function MySQLODBC($DSN, $Description, $Option, $SourcePath, Optional $DBName, Optional $Pwd, Optional $Port, Optional $Server, Optional $Stmt, Optional $user)
	Dim $ConnKey
	Dim $Driver
	Dim $RegKey
	
	$ConnKey = "HKEY_CURRENT_USER\Software\ODBC\ODBC.INI\"
	$Driver = "C:\WINNT\System32\myodbc3.dll"
	$RegKey = "HKEY_LOCAL_MACHINE\Software\ODBC\ODBCINST.INI\MySQL ODBC 3.51 Driver"
	
	If NOT Exist("c:\winnt\system32\myodbc3.dll")
		Copy $SourcePath+"myodbc3.dll" "c:\winnt\system32\myodbc3.dll"
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	If NOT Exist("c:\winnt\help\my3dsn.hlp")
		Copy $SourcePath+"my3dsn.hlp" "c:\winnt\help\my3dsn.hlp"
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	If NOT Exist("c:\winnt\system32\myodbc3d.dll")
		Copy $SourcePath+"myodbc3d.dll" "c:\winnt\system32\myodbc3d.dll"
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	
	; Checking installation of MyODBC
	If NOT (KeyExist("HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ODBC.FileDSN"))
		$x=AddKey("HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ODBC.FileDSN")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	If NOT (KeyExist("HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ODBC.FileDSN\DefaultIcon"))
		$x=AddKey("HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ODBC.FileDSN\DefaultIcon")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	If NOT (KeyExist("HKEY_LOCAL_MACHINE\SOFTWARE\ODBC\ODBCINST.INI\MySQL ODBC 3.51 Driver"))
		$x=AddKey("HKEY_LOCAL_MACHINE\SOFTWARE\ODBC\ODBCINST.INI\MySQL ODBC 3.51 Driver")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	If NOT (KeyExist("HKEY_LOCAL_MACHINE\SOFTWARE\ODBC\ODBCINST.INI\ODBC Core"))
		$x=AddKey("HKEY_LOCAL_MACHINE\SOFTWARE\ODBC\ODBCINST.INI\ODBC Core")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue("HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ODBC.FileDSN\DefaultIcon","")
	If $RetCode <> "C:\WINNT\System32\odbcint.dll,1"
		$x=WriteValue("HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ODBC.FileDSN\DefaultIcon","","C:\WINNT\System32\odbcint.dll,1","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue("HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ODBC.FileDSN","")
	If $RetCode <> "ODBC Data Source"
		$x=WriteValue("HKEY_LOCAL_MACHINE\SOFTWARE\Classes\ODBC.FileDSN","","ODBC Data Source","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue("HKEY_LOCAL_MACHINE\SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers","MySQL ODBC 3.51 Driver")
	If $RetCode <> "Installed"
		$x=WriteValue("HKEY_LOCAL_MACHINE\SOFTWARE\ODBC\ODBCINST.INI\ODBC Drivers","MySQL ODBC 3.51 Driver","Installed","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue($RegKey,"UsageCount")
	If $RetCode <> "12"
		$x=WriteValue($RegKey,"UsageCount","12","REG_DWORD")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue($RegKey,"Driver")
	If $RetCode <> "C:\WINNT\System32\myodbc3.dll"
		$x=WriteValue($RegKey,"Driver","C:\WINNT\System32\myodbc3.dll","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue($RegKey,"Setup")
	If $RetCode <> "C:\WINNT\System32\myodbc3.dll"
		$x=WriteValue($RegKey,"Setup","C:\WINNT\System32\myodbc3.dll","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue($RegKey,"APILevel")
	If $RetCode <> "2"
		$x=WriteValue($RegKey,"APILevel","2","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf

	EndIf
	$RetCode = ReadValue($RegKey,"ConnectFunctions")
	If $RetCode <> "YYN"
		$x=WriteValue($RegKey,"ConnectFunctions","YYN","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue($RegKey,"DriverODBCVer")
	If $RetCode <> "03.51"
		$x=WriteValue($RegKey,"DriverODBCVer","03.51","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue($RegKey,"FileUsage")
	If $RetCode <> "0"
		$x=WriteValue($RegKey,"FileUsage","0","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue($RegKey,"FileExtns")
	If $RetCode <> "*.txt"
		$x=WriteValue($RegKey,"FileExtns","*.txt","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue($RegKey,"SQLLevel")
	If $RetCode <> "1"
		$x=WriteValue($RegKey,"SQLLevel","1","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue($RegKey,"CPTimeout")
	If $RetCode <> "60"
		$x=WriteValue($RegKey,"CPTimeout","60","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue($RegKey,"DNSHelpFile")
	If $RetCode <> "c:\winnt\help\my3dsn.hlp"
		$x=WriteValue($RegKey,"DNSHelpFile","c:\winnt\help\my3dsn.hlp","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$RetCode = ReadValue("HKEY_LOCAL_MACHINE\Software\ODBC\ODBCINST.INI\ODBC Core","UsageCount")
	If $RetCode <> "1"
		$x=WriteValue("HKEY_LOCAL_MACHINE\Software\ODBC\ODBCINST.INI\ODBC Core","UsageCount","1","REG_DWORD")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	
	; Creating ODBC connection
	If NOT (KeyExist($ConnKey+$DSN))
		$x = AddKey($ConnKey+$DSN)
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$x = ReadValue($ConnKey+"ODBC Data Sources",$DSN)
	If $x <> "MySQL ODBC 3.51 Driver"
		$w = WriteValue($ConnKey+"ODBC Data Sources",$DSN,"MySQL ODBC 3.51 Driver","REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$x = ReadValue($ConnKey+$DSN,"Description")
	If $x <> $Description
		$w = WriteValue($ConnKey+$DSN,"Description",$Description,"REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$x = ReadValue($ConnKey+$DSN,"Database")
	If $x <> $DatabaseName
		$w = WriteValue($ConnKey+$DSN,"Database",$DBName,"REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$x = ReadValue($ConnKey+$DSN,"Driver")
	If $x <> $Driver
		$w = WriteValue($ConnKey+$DSN,"Driver",$Driver,"REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$x = ReadValue($ConnKey+$DSN,"Option")
	If $x <> $Option
		$w = WriteValue($ConnKey+$DSN,"Option",$Option,"REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$x = ReadValue($ConnKey+$DSN,"Password")
	If $x <> $Pwd
		$w = WriteValue($ConnKey+$DSN,"Password",$Pwd,"REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$x = ReadValue($ConnKey+$DSN,"Port")
	If $x <> $Port
		$w = WriteValue($ConnKey+$DSN,"Port",$Port,"REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$x = ReadValue($ConnKey+$DSN,"Server")
	If $x <> $Server
		$w = WriteValue($ConnKey+$DSN,"Server",$Server,"REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$x = ReadValue($ConnKey+$DSN,"Stmt")
	If $x <> $Stmt
		$w = WriteValue($ConnKey+$DSN,"Stmt",$Stmt,"REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
	$x = ReadValue($ConnKey+$DSN,"User")
	If $x <> $User
		$w = WriteValue($ConnKey+$DSN,"User",$User,"REG_SZ")
		If @ERROR
			? @ERROR
			Exit
		EndIf
	EndIf
EndFunction  

Can i get some comments on this please?
I can only test this on Win2k which works fine so far.139138MySQLODBC279KdyerMySQLODBC2() - Install MySQL Driver and/or Configure ODBC for MySQL0Code:


 ; Function: MySQLODBC2()
 ;
 ; Author:  Kent Dyer (leptonator@hotmail.com)
 ;
 ;Contributors Martijn (martijn@raceeend.com)
 ;
 ; Action:  - Checks if MyODBC is installed. If not it will be installed.
 ;   - Creates a ODBC connection to MySQL
 ;
 ; Syntax:  $ADOdb = MySQLODBC($DataSourceName, $Description, $Option, $SourcePath, Optional $DBName,
 ; Optional $Pwd, Optional $Port, Optional $Server, Optional $Stmt, Optional $user)
 ;
 ; Version: 1.0
 ;
 ; Date           2005-05-04
 ;
 ; Date Revised   2005-05-04
 ;
 ; Parameters:
 ; Required
 ; $DataSourceName: Data Source Name of the connection
 ; $Description:  Description of Data Source Name
 ; $Option:  Used to select options which have affect on the drivers behaviours
 ; $SourcePath:  Path where MyODBC files are located
 ; Optional
 ; $DBName:  Database to connect to
 ; $Pwd:   Password of database
 ; $Port:   TCP Port used by MySQL
 ; $Server:  IpAdress of MySQL server
 ; $Stmt:   SQL statement which executes on connection
 ; $user:   User which connects to database
 ;
 ; Remarks: This is a re-work of the original MySQLODBC as it tried to hack the drivers for instalation
 ; in place - http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=138402
 ;
 ; Returns Nothing
 ;
 ; Dependencies: MyODBC files. Oh and a MySQL server http://mysql.com
 ;
 ; KiXtart Ver 4.02
 ;
 ; Example: $DataSourceName = 'MySQL-ADODB'
 ;   $Description = 'MySQL ADODB connection'
 ;   $Option = '3'      ;Default MySQL option
 ;   $Server = '10.0.0.1'
 ;   $SourcePath = '\\server\share\'
 ;
 ;   $ADOdb = MySQLODBC($DataSourceName, $Description, $Option, $SourcePath,,,, $Server,,)
 ; KIXTART BBS  http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000000
 FUNCTION MYSQLODBC($dsn,$description,$option,$sourcepath,OPTIONAL $user,$dbname,
    $pwd,$port,$server,$stmt,$user)
    DIM $w,$connkey
    ; -- check the installation of MySQL
    IF 0=Exist('%windir%\system32\myodbc3d.dll')
       SHELL '%COMSPEC% /C START /WAIT MsiExec.exe /i '+@ldrive+'Programs\MySql.msi /qn'
    ENDIF
    IF $user
       $connkey = 'HKCU\Software\ODBC\ODBC.INI\'
    ELSE
       $connkey = 'HKLM\Software\ODBC\ODBC.INI\'
    ENDIF
    ; -- Check for the DSN and if it does not exist, create it
    IF NOT keyExist($connkey+$dsn)
       IF ReadValue($connkey+'ODBC Data Sources',$dsn)<>'MySQL ODBC 3.51 Driver'
          $w=WriteValue($connkey+'ODBC Data Sources',$dsn,'MySQL ODBC 3.51 Driver','REG_SZ')
       ENDIF
       IF ReadValue($connkey+$dsn,'Description')<>$description
          $w=WriteValue($connkey+$dsn,'Description',$description,'REG_SZ')
       ENDIF
       IF ReadValue($connkey+$dsn,'Database')$DatabaseName
          $w=WriteValue($connkey+$dsn,'Database',$dbname,'REG_SZ')
       ENDIF
       IF ReadValue($connkey+$dsn,'Driver')<>$driver
          $w=WriteValue($connkey+$dsn,'Driver',$driver,'REG_SZ')
       ENDIF
       IF ReadValue($connkey+$dsn,'Option')<>$option
          $w=WriteValue($connkey+$dsn,'Option',$option,'REG_SZ')
       ENDIF
       IF ReadValue($connkey+$dsn,'Password')<>$pwd
          $w=WriteValue($connkey+$dsn,'Password',$pwd,'REG_SZ')
       ENDIF
       IF ReadValue($connkey+$dsn,'Port')<>$port
          $w=WriteValue($connkey+$dsn,'Port',$port,'REG_SZ')
       ENDIF
       IF ReadValue($connkey+$dsn,'Server')<>$server
          $w=WriteValue($connkey+$dsn,'Server',$server,'REG_SZ')
       ENDIF
       IF ReadValue($connkey+$dsn,'Stmt')<>$stmt
          $w=WriteValue($connkey+$dsn,'Stmt',$stmt,'REG_SZ')
       ENDIF
       IF ReadValue($connkey+$dsn,'User')<>$user
          $w=WriteValue($connkey+$dsn,'User',$user,'REG_SZ')
       ENDIF
    ENDIF
 ENDFUNCTION


84323Name2Sid119LonkeroName2Sid() - get sid of specified user0

;Function:

;	Name2Sid()

;

;Author:

;	Lonkero (Jooel_Nieminen@hotmail.com)

;

;Version:

;	1.0

;

;Version History:

;	1.0	20.5.2003	initial release

;

;Action:

;	Returns the sid for specified username

;

;Syntax:

;	Name2Sid(USER)

;

;Parameters:

;	USER	User which to query

;

;Remarks:

;	Does not require AD or AD client

;	 like the other UDFs out there   

;

;Returns:

;	1	user not recognized

;	120	system does not support (too old)

;

;Dependencies:

;	Windows 2000 or ME or later

;

;Examples:

;	"niembau's sid is " Name2Sid("niembau")

;	"somedomain\niembie's sid is " Name2Sid("somedomain\niembie")

;

;Source:

function Name2Sid($user)

 dim $system

 $system = CreateObject("microsoft.diskquota.1")

 if 9<>vartype($system) exit 120 endif

 $Name2Sid=$system.TranslateLogonNameToSID($user)

 if len($Name2Sid) exit 0 else exit 1 endif

endfunction

175771Name2SID5931apronkName2SID() - Returns the UserID in SID format1178004613;Function	Name2SID() - Returns the UserID in SID format
;
;Author		Arend Pronk (arendpronk@gmail.com)
;
;Action		Returns the UserID in SID format
;
;Syntax		Name2SID(Opional $userid,Optional $domain)
;
;Version	1.2
;
;Date           01-05-2007
;
;Contributors	Witto (NoVarsInStrings compliant)
;		Glen Barnas (@Error support)
;
;Parameters 	$userid as loginname (same as @USERID) if not specified it will use @USERID instead
;		$domain as Domain Name (same as @LDOMAIN) if not specified it will use @LDOMAIN instead
;
;Returns	Returns the message wether it worked or not.
; 
;Dependencies 	WMI
;
;KiXtart Ver.	4.51
; 
;Example(s)	? = Name2SID("testuser",@WKSTA)		; returns the SID of "testuser" of the local PC
;		? = Name2SID("testuser",@LDOMAIN)	; returns the SID of "testuser" in the domain
;		? = Name2SID()				; returns the SID of your @USERID in the domain
;

ÿCode:

Function Name2SID(Optional $userid,Optional $domain)
  If $userid = "" $userid = @USERID EndIf
  If $domain = "" $domain = @LDOMAIN EndIf
  Dim $objWMIService
  $objWMIService = GetObject("winmgmts:\\.\root\cimv2")
  $Name2SID = $objWMIService.Get("Win32_UserAccount.Name='"+$userid+"',Domain='"+$domain+"'").SID
  If @ERROR EXIT @ERROR EndIf
EndFunction
84467NavDefDate4117Fred_LeonardNavDefDate() - Gets the date of the installed Symantec AntiVirus Defs0

code:

;FUNCTION NavDefDate($PC)
;
;ACTION Gets the date of the Symantec AntiVirus Defs installed on the PC
;
;AUTHOR Fred Leonard
;
;VERSION UDF version 1.0.1
;  1.0.1 added reverse output (Year First)
;DATE CREATED 08/21/2003
;
;KIXTART Minimum required Kixtart version 4.x
;
;SYNTAX NavDefDate(optional $PC, optional $ReverseFlag)
;
;PARAMETERS PARAMETER1 (optional)
; Optional Name of PC to query (if blank, local system is used)
;
;RETURNS text formatted date mm/dd/yyyy, other messages: "Error reading registry" or "Not installed!"
;
;REMARKS useful in logon scripts to verify virus protection or checking remote systems. Error reading registry can be from a bad computer name, a powered off system, unable to contact system, or no admin rights.
;
;Dependencies 	Admin Rights/Registry read access (HKLM)
;
;EXAMPLE A short functional example demonstrating the UDF
;
;? NavDefDate("Joes_PC")       ;Prints the date of the defs on computer named "Joes_PC"
;? NavDefDate()       ;Prints the date of the local virus defs
;
;KIXTART BBS [URL=http://www.kixhelp.com]http://www.kixhelp.com[/URL]
; URL the UDF was posted under
;

Function NavDefDate(optional $pc,optional $Reverse)

	;get the Symantec AntiVirus (or NAV) Defs Date
	
	if $PC=""	$PC=@WkSta	EndIf
	
	$z = ReadValue("\\$pc\HKLM\SOFTWARE\INTEL\LANDesk\VirusProtect6\CurrentVersion","PatternFileDate")
	
	$yr=substr($z,1,2)
	$mo=substr($z,3,2)
	$da=substr($z,5,2)

	$yr=val("&$yr")+"1970"
	$mo=val("&$mo")+1
	$da=val("&$da")

	if len($mo)=1
		$mo="0$mo"
	EndIf
	if len($da)=1
		$da="0$da"
	EndIf

	select
		case @error
			$NavDefDate="Error reading registry!"
		case $yr="1970"
			$NavDefDate = "Not Installed!"
		case 1
			If not $Reverse
				$NavDefDate = "$mo/$da/$yr"
			Else
				$NavDefDate = "$yr/$mo/$da"
			EndIf
	EndSelect

EndFunction


 
 [ 29. August 2003, 02:11: Message edited by: Fred_Leonard ]83744NetByteCount2700Crazy EddieNetByteCount() - ByteCount for network benchmarking0This UDF helps track the amount of network traffic during script execution.  Think of this as a Byte Counter, just like a Time Counter.

Useful for benchmarking script efficiency over network connections.  Could help optimize code for network operations and testing different syntax for the same.

Note: This uses the Shell function to call NETSTAT.  This enables the script to be KIX only, and has no dependencies on WMI, WSH, etc.

code:

;FUNCTION      NetByteCount
;
;AUTHOR        Ed Myers
;
;VERSION       1.0 (12/3/2002)
;
;ACTION        Counts Bytes in and out since last execution
;
;SYNTAX        NetByteCount ('Reset')
;              $x=NetByteCount()
;
;PARAMETERS    String
;              Optional string to reset counters to zero
;
;RETURNS       String in format BytesIn, BytesOut
;
;REMARKS       Tested on NT4, W2K
;              Substr() may be different on other OSes
;              I would have used SPLIT(), however it returns
;              multiple entries for multiple spaces.  Yuck.

;
;DEPENDENCIES  KiXtart 4+
;
; CREDITS      Shawn for the PIPE() UDF
;              Sealeopard for the TimeDiff() UDF
;              This Function liberally uses concepts from both
;

FUNCTION NetByteCount(Optional $Reset)
  DIM $TempFile, $Command, $FH, $Line, $NUL
  DIM $BytesInNow, $BytesOutNow
  $TempFile = "%temp%\pipe.tmp"
  $Command='netstat -e | find /i "Bytes"'
  IF @inwin = 2 ; win9x
   SHELL '%comspec% /c $Command >"$tempfile"'
  ELSE ; winnt
   SHELL '%comspec% /c $Command >"$tempfile" 2>nul'
  ENDIF

  $FH=FreeFileHandle()
  IF OPEN($FH,"$TempFile") = 0
    $Line = READLINE($FH)
    $NUL=CLOSE($FH)
  ENDIF
  DEL($TempFile)

  $BytesInNow=VAL(TRIM(SUBSTR($Line,6,32)))
  $BytesOutNow=VAL(TRIM(SUBSTR($Line,37,LEN($Line))))

  SELECT
    CASE VarType ($BytesIn)<2 AND VarType ($BytesOut)<2
      Global $BytesIn, $BytesOut
      $BytesIn=$BytesInNow
      $BytesOut=$BytesOutNow
    CASE vartype($reset)
      $BytesIn=$BytesInNow
      $BytesOut=$BytesOutNow
  ENDSELECT

  $NetByteCount=""+($BytesInNow-$BytesIn)+", "+($BytesOutNow-$BytesOut)

ENDFUNCTION

Comments welcome!

Crazy Eddie

{Edited for standard UDF Header}
 
 [ 04. December 2002, 17:45: Message edited by: Crazy Eddie ]82364NetView11ShawnNetView() - Enumerate all computers in your domain0NetView()

Action:

Enumerate all computers in your domain

Syntax:

NetView(["Domain"])

Parameters:

Domain (Optional) - Specifies the domain to enumerate. If domain
is omitted, returns a list of all computers in the current domain.

Returns:

An array of strings representing all the computers in the domain. Returns
a null string "" on error and @ERROR is set to relevent error code.

Remarks:

Uses file handle #10. Change if conflicts arise.

Dependencies:

KiXtart 4.0 (final)

Example(s):

for each $computer in netview()
 ?"$computer"
next

$netview = netview("@LDOMAIN")
if @error = 0
 for each $computer in $netview
  ?"$computer"
 next
endif


Source:

function netview(optional $domain)
 dim $array[255]
 dim $redim $redim = 255
 dim $i $i = 0
 dim $j $j = 0
 dim $tempfile $tempfile = "%temp%\netview.tmp"
 if $domain
  $domain = "/domain:$domain"
 endif
 if exist("$tempfile")
  del "$tempfile"
 endif
 shell '%comspec% /c net view $domain >"$tempfile"'
 if @error = 0
  if open(10,$tempfile) = 0
   for $j = 1 to 5
    $line = readline(10) ; skip headings
   next
   while @error = 0
    $array[$i] = rtrim(substr($line,3,instr($line," ")-1))
    $i=$i+1
    if $i = $redim
     $redim=$redim*2
     redim preserve $array[$redim]
    endif
    $line = readline(10)
   loop
   $=close(10)
   del "$tempfile"
   if $i
    redim preserve $array[$i-4]
    $netview = $array
    exit @error
   endif
  endif
 endif
 $netview = 0
 exit @error
endfunction



Author:

-Shawn
 
 [ 22. February 2003, 01:09: Message edited by: Shawn ]83122NetView217SealeopardNetView2() - Enumerate all computers in your domain0

code:

;FUNCTION      NetView2()
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;CONTRIBUTOR   Shawn Tassie
;
;ACTION        Enumerate all announced computers in your domain
;
;VERSION       1.2 (fixed bug in SHELL string)
;              1.1
;
;DATE CREATED  2002/05/14
;
;DATE MODIFIED 2003/05/31
;
;KIXTART       4.12+
;
;SYNTAX        NetView2([Domain,Comment])
;
;PARAMETERS    DOMAIN
;              Specifies the domain to enumerate. If domain is omitted, returns a
;              list of all announced computers in the current domain.
;
;              COMMENT
;              Optional boolean to determine whether to return the associated computer
;              comment (separated by a comma from the computername)
;
;RETURNS       An array of strings representing all the computers in the domain
;
;REMARKS       This UDF returns a list of computers that are PINGable. Computers, that
;              are members of the domain but are currently not connected to the domain,
;              will not be listed. For a list of joined computers independent of whether
;              they are on- or off-line use COMNetView().
;
;              Slightly improved version of Shawn's NetView() UDF
;              at http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=print_topic;f=12;t=000059
;
;DEPENDENCIES  none
;
;EXAMPLE       for each $computer in netview2()
;                ? ''+$computer
;              next
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000202
;
function NetView2(optional $domain, optional $commentflag)
  dim $array[255]
  dim $redim, $i, $j, $tempfile
  dim $filehandle, $retcode, $line
  dim $name, $comment

  $redim = 255
  $i = 0
  $j = 0
  $tempfile = '%temp%\netview.tmp'

  if $domain
    $domain = '/domain:'+trim($domain)
  endif

  if vartype($commentflag)
    $commentflag=val($commentflag)
  else
    $commentflag=0
  endif

  if exist($tempfile)
    del $tempfile
  endif

  shell '%comspec% /c net view '+$domain+' >"'+$tempfile+'"'

  if @error = 0
    $filehandle=freefilehandle()
    $retcode=open($filehandle,$tempfile)

    for $j = 1 to 5
      $line = readline($filehandle) ; skip headings
    next

    while @error = 0
      $name= trim(substr($line,3,instr($line,' ')-1))
      $comment = trim(right($line,len($line)-instr($line,' ')))
      if $commentflag
        $array[$i]=$name+','+$comment
      else
        $array[$i]=$name
      endif
      $i=$i+1
      if $i = $redim
        $redim=$redim*2
        redim preserve $array[$redim]
      endif
      $line = readline($filehandle)
    loop
    $retcode=close($filehandle)
    del $tempfile
    if $i
      redim preserve $array[$i-4]
      $netview2 = $array
      exit @error
    endif
  endif

  $netview2 = 0
  exit @error
endfunction


 
 [ 31. May 2003, 23:51: Message edited by: sealeopard ]121485Network_Icon367AutourduPCNetwork_Icon() - Enable network icon in the tray0Code:


;Function	Network_icon()

;

;Author		AutourduPC (Laurent B.) (http://www.autourdupc.com)

;

;Contributors	Based on the idea of Howard A. Bullock (#82613)

;

;Action		Enable/disable network icon in taskbar (near clock).

;

;Syntax		Network_icon($State)

;

;Version	 	1.0

;

;Date		18 juin 2004

;

;Date Revised	18 juin 2004

;

;Parameters 	$State (Required) -  String value

;		Must be "visible" or anything else

;

;Remarks 	 	Modification are visible after a reboot

; 	 	Code tested successfully under Windows 2000 and WIndows XP

;

;Returns	 	Nothing

; 

;Dependencies 	None

;

;KiXtart Ver	4.02

; 

;Example(s)	Network_icon("Visible")

;		Network_icon("Invisible")

;

;



function Network_icon($State)

   dim $Key, $i, $ClassGUID, $x, $netID, $Error

   

   If $State="Visible then $State=1

   else then $State=0

   

   $Key="HKLM\SYSTEM\CurrentControlSet"

   ; Find GUIDs

   $ClassGUID = READVALUE ($Key + "\Enum\Root\MS_NDISWANIP\0000", "ClassGUID")

   $i=0

   ; When ClassGUID found, look for all subkeys like "/0000", "/0001"...

   ; For each one, look for subkey "Ndi/Interfaces"

   ; If there is an entry "LowerRange"="ethernet" then we can read the entry "NetCfgInstanceID"

   ; Then, open the key "NetCfgInstanceID" and write the value for "ShowIcon" (0 or 1)

   Do

     $x = ENUMKEY($Key + "\Control\Class\" + $classGUID, $i)

     $Error = @Error

     If NOT $Error		; There is a subkey

        If "ethernet"=READVALUE ($Key + "\Control\Class\" + $classGUID + "\" + $x + "\Ndi\Interfaces", "LowerRange")

           $netID = READVALUE ($Key + "\Control\Class\" +  $ClassGUID + "\" + $x, "NetCfgInstanceID")

           WRITEVALUE ($Key + "\Control\Network\" + $ClassGUID + "\" + $netID + "\Connection", "ShowIcon", $State, "REG_DWORD")

        EndIf

        $i = $i + 1

     EndIf

   Until $Error <> 0

Endfunction   





  150839NICInfo2980Glenn BarnasNICInfo() Return info about all NICs0This is a UDF I wrote, inspired by some work NTDoc started. It returns an array of arrays describing all of the NICs in a specific system. Each sub-array has 20 elements that describe the NIC and its configuration.

 Updated 3/17/06
Now returns additional info, including a NIC Status and MAC address, obtained via WMI. NIC Status is not fully supported on Win2K and earlier systems.

 Updated 11/15/06 
Element 13 now returns the hard-coded DNS server entries, so you can tell when these are overriding the DHCP set values.




;; 
;;====================================================================== 
;; 
;;FUNCTION       NicInfo() 
;; 
;;ACTION         Returns an array of arrays containing descriptions of each NIC 
;; 
;;AUTHOR         Glenn Barnas 
;;		 based on original concept by Ron Lewis (NTDoc) 
;; 
;;VERSION	 1.0 - 2005/01/11 - initial release, 15 elements (2 spare), no WMI 
;;		 1.2 - 2006/03/17 - 20 elements (2 spare), WMI for MAC and status info 
;;			Position of TEAM data elements changed in this release! 
;;               1.3 - 2006/11/15 - Added field to identify fixed DNS servers 
;; 
;;SYNTAX         NicInfo([target]) 
;; 
;;PARAMETERS     Target - OPTIONAL, name of remote system to query 
;; 
;;REMARKS        Returns info about all physical NICs in a given system.  
;;               Identifies NIC Teams. DHCP Lease times are in ctime values and 
;;               will likely need to be converted before use. 
;;               Elements 15 & 16 require WMI - they return nothing if WMI is unsupported. 
;;               Status (15) is only returned reliably on XP and 2K3 systems. 
;;               Elements 17-19 return data about NIC Teams. Only HP & Intel teams  
;;               have been tested so far. 
;; 
;;RETURNS        Array of arrays 
;;                - the first element of the array represents each NIC 
;;                - the second element represents one of 20 distinct NIC parameters 
;;                 NIC Elements: 
;;                -  0 : Adapter Description 
;;                -  1 : Manufacturer 
;;                -  2 : NIC GUID 
;;                -  3 : Speed/Duplex value 
;;                -  4 : Speed/Duplex text 
;;                -  5 : Driver Version 
;;                -  6 : DHCP boolean (1=Use DHCP) 
;;                -  7 : IP settings  (address,mask,gateway) *, ** 
;;                -  8 : Domain Name 
;;                -  9 : DNS Server list ** 
;;                - 10 : DHCP Server, Lease Aquired, Lease Expires (if DHCP is enabled) 
;;                - 11 : WINS Server list ** 
;;                - 12 : Interface Name 
;;                - 13 : Fixed Name Servers (hard-coded DNS, overriding DHCP settings) ** 
;;                - 14 : Reserved for future use 
;;                - 15 : NIC Status (2=Ready,0=Disabled...) 
;;                - 16 : MAC Address - only if NIC is enabled/connected 
;;                - 17 : TEAM flag (Name of Team - HPTeam, Intel Team, etc.) 
;;                - 18 : # of adapters in team 
;;                - 19 : ID (GUIDs) of adapters in team 
;; 
;;                * If multiple IP addresses are assigned to a NIC, the IP addresses will 
;;                be presented as a space-delimited list, followed by a semicolon and the  
;;                space-delimited list of corresponding netmasks, followed by a semicolon and the 
;;                space-delimited list of corresponding gateways (usually just one) 
;;                 
;;                ** Any time multiple values are returned, they will be space delimited 
;; 
;;DEPENDENCIES   none 
;; 
;;TESTED WITH    NT4, W2K, WXP, W2K3 
;; 
;;EXAMPLES        
;;                $Array = NicInfo($COMPUTER) 
;;                If UBound($Array) < 0 
;;                  @SERROR ? 
;;                Else 
;;                  UBound($Array) + 1 ' NICs found.' ? 
;;                  For $X = 0 to UBound($Array) 
;;                    For $Y = 0 to UBound($Array[$X]) 
;;                      $y '. ' $Array[$X][$Y] ? 
;;                    Next 
;;                  Next 
;;                EndIf 
; 
Function NicInfo(OPTIONAL $_Target)
 
  Dim $_, $_Tmp, $_SubKeyCounter, $_NicArray, $_CurrentSubKey, $_aPNP, $_Tgt
  Dim $_Name, $_Key, $_Index, $_WorkRegKey, $_SubKey, $_colItems, $_objWMI
  Dim $_Regkey[2]
 
  ; Insure $_Target uses the format "\\target\" if specified, null otherwise 
  ; $_Tgt must be either a plain hostname or "." for WMI use 
  $_Tgt    =  IIf(CStr($_Target) <> '', Join(Split(CStr($_Target), '\'), '', 3), '.')
  $_Target =  IIf(CStr($_Target) <> '', '\\' + Join(Split(CStr($_Target), '\'), '', 3) + '\', '')
 
  ; Define the registry keys 
  $_RegKey[0] = $_Target + 'HKLM\SYSTEM\CurrentControlSet\Control\Class\{4D36E972-E325-
    -11CE-BFC1-08002bE10318}'
  $_RegKey[1] = $_Target + 'HKLM\SYSTEM\CurrentControlSet\Control\Network\{4D36E972-E325-
    -11CE-BFC1-08002bE10318}'
  $_RegKey[2] = $_Target + 'HKLM\SYSTEM\CurrentControlSet\Services\NetBT\Parameters\Interfaces\Tcpip_'
 
 
  ; init the enumeration index and array index 
  $_SubKeyCounter = 0
  $_Index = 0
 
 
  ; Enumerate all of the keys that are LAN adapters 
  $_CurrentSubKey = EnumKey($_RegKey[0], $_SubKeyCounter)
  If @ERROR
    Exit @ERROR							; exit now if can't read registry! 
  EndIf
 
  $_CurrentSubKey = EnumKey($_RegKey[0], $_SubKeyCounter)
  While @ERROR = 0
    $_Key = Val(ReadValue($_RegKey[0] + '\' + $_CurrentSubKey, 'Characteristics'))
    If $_Key = 132 Or $_Key >= 32768				; physical nic or virtual team 
      ReDim Preserve $_NicArray[$_Index]			; increase the array size 
      $_NicArray[$_Index] = $_CurrentSubKey			; add the subkey to the array 
      $_Index = $_Index + 1					; increment the array index 
    EndIf
    $_SubKeyCounter = $_SubKeyCounter + 1			; increment the enumeration index 
    $_CurrentSubKey = EnumKey($_RegKey[0], $_SubKeyCounter)	; get the next key 
  Loop
 
  ; Have an array of all the NIC subkeys now... Gather some appropriate data on each one 
  Dim $_NicData[UBound($_NicArray)]
 
  $_Index = 0
  Dim $_WorkArray[19]
  For Each $_SubKey In $_NicArray
    ; Start by determining the Speed/Duplex value name 
    $_SubKeyCounter = 0
    $_Name = ''
    $_WorkRegKey = $_RegKey[0] + '\' + $_SubKey + '\Ndi\Params'
 
    ; Enumerate all of the subkeys to locate the Speed/Duplex value name 
    $_CurrentSubKey = EnumKey($_WorkRegKey, $_SubKeyCounter)
    While @ERROR = 0 And $_Name = ''
      $_Key = ReadValue($_WorkRegKey + '\' + $_CurrentSubKey, 'ParamDesc')
      If InStr($_Key, 'Duplex') Or InStr($_Key, 'Connection Type')
        $_Name = $_CurrentSubKey							; Save the Key Name 
      EndIf
      $_SubKeyCounter = $_SubKeyCounter + 1						; increment the enum index 
      $_CurrentSubKey = EnumKey($_WorkRegKey, $_SubKeyCounter)				; get the next key 
    Loop	; enumerate subkeys 
 
    ; Collect the data for this adapter 
    $_WorkArray[0] = ReadValue($_RegKey[0] + '\' + $_SubKey, 'DriverDesc')		; Adapter Description 
    $_WorkArray[1] = ReadValue($_RegKey[0] + '\' + $_SubKey, 'ProviderName')		; Manufacturer 
    $_WorkArray[2] = ReadValue($_RegKey[0] + '\' + $_SubKey, 'NetCfgInstanceId')	; NIC GUID 
    $_WorkArray[3] = ReadValue($_RegKey[0] + '\' + $_SubKey, $_Name)			; Speed/Duplex value 
    $_WorkArray[4] = ReadValue($_WorkRegKey + '\' + $_Name + '\Enum', $_WorkArray[3])	
      	; Speed/Duplex text 
    $_WorkArray[4] = IIf($_WorkArray[4] = '', 'Undefined', $_WorkArray[4])		; undefined speed 
    $_WorkArray[5] = ReadValue($_RegKey[0] + '\' + $_SubKey, 'DriverVersion')		; Driver Version 
 
    ; Get the IP address parameters - DHCP Enabled, IP Address, Netmask, Gateway 
    $_WorkRegKey = $_Target + 'HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces\' 
       + $_WorkArray[2]
    $_WorkArray[6] = Val(ReadValue($_WorkRegKey, 'EnableDHCP'))				; DHCP boolean 
    $_Key = IIf($_WorkArray[6] = 1, 'Dhcp', '')
    $_WorkArray[7] = ReadStringValue($_WorkRegKey, $_Key + 'IPAddress') + ';' +
                     ReadStringValue($_WorkRegKey, $_Key + 'SubnetMask') + ';' +
                     ReadStringValue($_WorkRegKey, $_Key + 'DefaultGateway')
 
    ; Gather additional DHCP info, if DHCP is enabled 
    If $_WorkArray[6]
      $_WorkArray[10] = ReadStringValue($_WorkRegKey, 'DhcpServer') + ',' +
                        ReadStringValue($_WorkRegKey, 'LeaseObtainedTime') + ';' +
                        ReadStringValue($_WorkRegKey, 'LeaseTerminatesTime')
    EndIf
 
    ; Get the Domain Name and DNS Server List 
    $_WorkArray[8] = ReadStringValue($_WorkRegKey, $_Key + 'Domain')
    $_WorkArray[9] = Join(Split(ReadStringValue($_WorkRegKey, $_Key + 'NameServer'), ','), ' ')
    $_WorkArray[13] = Join(Split(ReadStringValue($_WorkRegKey, 'NameServer'), ','), ' ')
 
    ; Gather the WINS Server list 
    $_WorkArray[11] = ReadStringValue($_RegKey[2] + $_WorkArray[2], 'NameServerList')
 
    ; Obtain the current interface name 
    $_WorkArray[12] = ReadStringValue($_RegKey[1] + '\' + $_WorkArray[2] + '\Connection', 'Name')
 
    ; temporarily save the PNP Instance ID for use by the WMI component later on 
    $_WorkArray[16] = ReadStringValue($_RegKey[1] + '\' + $_WorkArray[2] + '\Connection',
      , 'PnpInstanceID')
 
    If ReadValue($_RegKey[0] + '\' + $_SubKey, 'Characteristics') > 32768
      $_WorkArray[17] = 1								; special flag 
      $_WorkArray[18] = ReadValue($_RegKey[0] + '\' + $_SubKey, 'NumBindings')		; # of 
         adapters in team 
      $_WorkArray[19] = '' ; ReadValue($_RegKey[0] + '\' + $_SubKey, 'TeamInstances')	
        	; ID of adapters in team 
    EndIf
 
    ; prepare for the next nic 
    $_NicData[$_Index] = $_WorkArray			; Assign the sub-array 
    $_Index = $_Index + 1				; increment the index pointer 
    ReDim $_WorkArray[19]				; clear the working sub-array 
 
  Next	; CurrentSubKey 
 
  ; Trim the outer array (NICs) 
  $_Index = $_Index - 1
  ReDim Preserve $_NicData[$_Index]
 
  ; Prepare for WMI lookups 
  $_Tmp = ''
  For $_ = 0 to $_Index
    $_Tmp = $_Tmp + $_NicData[$_][16] + ','		; put the PNP data into an index, and clear the value 
    $_NicData[$_][16] = ''				; the PNP value is not returned 
  Next
  $_Tmp = Left($_Tmp, Len($_Tmp) - 1)			; trim the ending delim 
  $_aPNP = Split($_Tmp, ',')				; put into a lookup array 
 
  ; Try to gather the remaining info via a single WMI collection 
  $_objWMI = GetObject("winmgmts:\\" + $_Tgt + "\root\cimv2")
  ; just ignore WMI if an error occurs. 
  if @ERROR = 0
    ; Collect all data from all NICs 
    $_colItems = $_objWMI.ExecQuery('Select * from Win32_NetworkAdapter')
    For Each $_ in $_colItems
      ; Does the PNP Device ID exist in our lookup array? If so, where? That will be the NIC index 
      ; that we update with WMI data 
      $_Tmp = AScan($_aPNP, $_.PNPDeviceID)
      If $_Tmp >= 0
        $_NicData[$_Tmp][15] = $_.NetConnectionStatus	; XP, 2K3 & higher 
        $_NicData[$_Tmp][16] = $_.MACAddress		; only if NIC is enabled 
      EndIf
    Next
  EndIf
 
 
  ; Return the array of arrays 
  $NicInfo = $_NicData
 
  Exit 0
 
EndFunction
 
 
; Read a String_Multi_SZ val and return a space-delimited string 
Function ReadStringValue($_Key, $_Val)
 
  $ReadStringValue = Trim(Join(Split(ReadValue($_Key, $_Val), '|'), ' '))
 
EndFunction
 
 
 
 
 

 82658NightlyReboot17SealeopardNightlyReboot() - displays a warning message about a scheduled reboot0

code:


;FUNCTION      NightlyReboot
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        displays a warning message about a scheduled reboot
;
;SYNTAX        NIGHTLYREBOOT()
;
;PARAMETERS    none
;
;RETURNS       0 if successful, otherwise 1
;
;REMARKS       Requires the global variable $MAINTENANCE (filename to an .INI file containing a list
;              of maintenance task for the computer)
;
;DEPENDENCIES  WARNING() @ http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000099 
;
;EXAMPLE       $retcode=nightlyreboot()
;
;KIXTART BBS   http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000106 
;
function nightlyreboot()
  Dim $retcode, $nightlyreboot, $reboot_message

  if @INWIN=1 and exist($MAINTENANCE)
    $nightlyreboot=readprofilestring($MAINTENANCE,@WKSTA,'NightlyReboot')
    if @ERROR=0 and $nightlyreboot
      $reboot_message='A software package will be installed on this computer around 2am!'+chr(10)+chr(10)
      $reboot_message=$reboot_message+'This computer will reboot automatically as part of this installation routine!'
      $retcode=sendmessage(@WKSTA,$reboot_message)
      if @ERROR
        $retcode=warning('Failed sending an administrative alert to '+@WKSTA)
      endif
    endif
  endif
  
  $nightlyreboot=@ERROR
endfunction

[ 19 December 2001: Message edited by: sealeopard ]181590NSLookup2980Glenn BarnasNSLookup() UDF to resolve name or IP into Name/IP pair0Needed to accurately perform forward and reverse lookups - this is the result.



;; 
;;====================================================================== 
;; 
;;FUNCTION       NSLookup() 
;; 
;;ACTION         Returns a name/address pair, given a name or address 
;; 
;;AUTHOR         Glenn Barnas 
;; 
;;VERSION        1.0 / 10/10/2007 
;; 
;;SYNTAX         NSLookup(ID) 
;; 
;;PARAMETERS     ID - REQUIRED, host name or IP address to resolve 
;; 
;;REMARKS        Used to lookup IP from a name, or name from an IP 
;; 
;;RETURNS        Returns a hostname/ip address pair, delimited by a comma 
;;		 if the named host resolves in DNS, otherwise a null string 
;; 
;;DEPENDENCIES   WScript 
;; 
;;TESTED WITH    W2K, WXP, W2K3 
;; 
;;EXAMPLES        
; 
Function NSLookup($_ID)
 
  Dim $_sR			; Return string 
  Dim $_oExec			; WScript object 
 
  ; Use WScript to execute the command and check the result 
  $_oExec = CreateObject("WScript.Shell").Exec('nslookup ' + $_ID)
  If Not VarType($_oExec) = 9
    $NSLookup = ''
    Exit 10
  EndIf
 
  ; get the command result and extract what is needed 
  $_sR = Trim(Split(Join(Split($_oExec.StdOut.ReadAll, @CRLF), ''),'name:')[1]) 
 
  ; process the return string 
  If Not $_sR
    $NSLookup = ''
    Exit 67
  Else
    $NSLookup = Split($_sR, 'Address:')[0] + ',' + Trim(Split($_sR, 'Address:')[1])
    Exit 0
  EndIf
 
EndFunction
 
   

180734NTFSPerms5931apronkNTFSPerms() - NTFS Permissions Control0

ÿCode:

;Function         NTFSPerms() - NTFS Permissions Control
;
;Author		Arend Pronk (arendpronk@gmail.com)
;
;Action		Allows you to get and set NTFS permissions
;
;Syntax		NTFSPerms($cmds,$object,Optional $trustee)
;
;Version  	1.2
;
;Date 		22-10-2007
;
;Changes	A couple of changes were done thanks to Glenn Barnas's suggestions:
;		- Changed Exit 1 to Exit 87 because it's only used when there was an invalid command.
;		- Changed $NTFSPerms = @ERROR to NOT @ERROR to return a boolean value for success or fail.
;		- Changed the $subcmd processing from if-else-endif to Select-Case.
;		- Changed default permissions to READ instead of FULL, which was supposed to be the case
;		  in the first place.
;
;Parameters 	$cmd (Required) - String value ie: "SHOW:OWNER", "DEL" or "ADD:FULL"
;		$object (Required) - String value, path to the folder ie: "D:\Test"
;		$trustee (Optional) - String value, in the form of "DOMAIN\user"
;		Optional when using "SHOW" as $cmd, Required for "DEL" and "ADD"
;
;Returns  	The Ace's properties when SHOW is used.
;		Will return Boolean 1 or 0 when "ADD" or "DEL" is used.
; 
;Dependencies 	ADsSecurityUtility (activeds.dll, comes standard with XP and Above, NOT Windows 2000!)
;
;KiXtart Ver.	4.53
; 
;Example(s)	NTFSPerms("ADD:CHANGE","D:\New Folder","DOMAIN\user")
;		will add the specified user with CHANGE rights to the folder.
;
;		NTFSPerms("DEL:USER","D:\New Folder","DOMAIN\user")
;		will delete the specified user from the acl list of the folder.
;
;		NTFSPerms("SHOW:Owner","D:\New Folder")
;		will return the owner of the folder.
;
;		NTFSPerms("SHOW:Count","D:\New Folder")
;		will show the current count of users in the acl list of the folder.
;
;		NTFSPerms("SHOW:Trustees","D:\New Folder")
;		will return the names of the trustees in the acl list of the folder in a comma delimited array.
;
;		NTFSPerms("SHOW:AceFlags","D:\New Folder")
;		will return the aceflags of the trustees in the acl list of the folder in a comma delimited array.
;
;		NTFSPerms("SHOW:AccessMasks","D:\New Folder")
;		will return the accessmasks of the trustees in the acl list of the folder in a comma delimited array.
;
;		NTFSPerms("SHOW:AceTypes","D:\New Folder")
;		will return the acetypes of the trustees in the acl list of the folder in a comma delimited array.
;
;		NTFSPerms("SHOW:Flags","D:\New Folder")
;		will return the flags of the trustees in the acl list of the folder in a comma delimited array.
;
;
Function NTFSPerms($cmds,$object,Optional $trustee)
  Dim $adsu, $sd, $dacl, $ace, $newace, $cmd, $x, $subcmd, $d
  $adsu = CreateObject("ADsSecurityUtility")
  If @error Exit @error EndIf
  $sd = $adsu.GetSecurityDescriptor($object,1, 1)
  $dacl = $sd.DiscretionaryAcl
  If Not InStr($cmds,":") Exit 87 EndIf
  $x = Split($cmds,":")
  $cmd = $x[0]
  $subcmd = $x[1]
  Select
    Case $cmd = "Show"
      Select
        Case $subcmd = "Owner" $NTFSPerms = $sd.Owner
        Case $subcmd = "Count" $NTFSPerms = $dacl.AceCount
        Case $subcmd = "Trustees"
          For Each $Ace in $dacl
            $NTFSPerms = $NTFSPerms + $d + CStr($Ace.Trustee) $d = ","
          Next
        Case $subcmd = "AceFlags"
          For Each $Ace in $dacl
            $NTFSPerms = $NTFSPerms + $d + CStr($Ace.AceFlags) $d = ","
          Next
        Case $subcmd = "AccessMasks"
          For Each $Ace in $dacl
            $NTFSPerms = $NTFSPerms + $d + CStr($Ace.AccessMask) $d = ","
          Next
        Case $subcmd = "AceTypes"
          For Each $Ace in $dacl
            $NTFSPerms = $NTFSPerms + $d + CStr($Ace.AceTypes) $d = ","
          Next
        Case $subcmd = "Flags"
          For Each $Ace in $dacl
            $NTFSPerms = $NTFSPerms + $d + CStr($Ace.Flags) $d = ","
          Next
      EndSelect
    Case $cmd = "DEL"
      If $subcmd = "User"
        If $trustee <> ""
          For Each $ace In $Dacl
            If $ace.trustee = $trustee
              $Dacl.RemoveAce($Ace)
            EndIf
          Next
          $sd.DiscretionaryAcl = $Dacl
          $adsu.SetSecurityDescriptor($object,1,$sd,1)
          $NTFSPerms = Not @ERROR
          Exit @ERROR
        Else
          Exit 87
        EndIf
      EndIf
    Case $cmd = "ADD"
      If $trustee <> ""
        $NewAce = CreateObject("AccessControlEntry")
        $NewAce.Trustee = $trustee
        $NewAce.AceFlags = 3
        Select
          Case $subcmd = "FULL"
            $NewAce.AccessMask = 2032127
          Case $subcmd = "READ"
            $NewAce.AccessMask = 1179817
          Case $subcmd = "WRITE"
            $NewAce.AccessMask = 1179958
          Case $subcmd = "CHANGE"
            $NewAce.AccessMask = 1245631
          Case 1
            $NewAce.AccessMask = 1179817
        EndSelect
        $NewAce.AceType = 0
        $dacl.AddAce($NewAce)
        $sd.DiscretionaryAcl = $Dacl
        $adsu.SetSecurityDescriptor($object,1,$sd,1)
        $NTFSPerms = Not @ERROR
        Exit @ERROR
      Else
        Exit 87
      EndIf
  EndSelect
EndFunction

Version 1.1 Revised the DEL command processing, thx to MiketNZ for his notice.
Version 1.2 Added Glenn Barnas's suggestions.82081NumberToWords5474DrillSergeantNumberToWords() - Converts a number to the spoken equivalent0NumberToWords()

Action:

Converts a number to the spoken equivalent. 

Syntax:

NumberToWords(Number)

Parameters:

Number:  Any number. This value may be numeric or a string 

Returns:

The spoken equivalent for the number

Remarks:

If you want numbers bigger than 2,147,483,647 it can't be a numeric value(Kix gets confused)

Dependecies:

KiXtart 4.0 (Final)

Examples: 

$year = NumberToWords("1972"); will return the string 'onethousandninehundredandseventytwo'

Source:

code:


Function NumberToWords($_number)

$_s = 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'
$_t = 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen'
$_d = 'twenty', 'thirty', 'fourty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'
$_b = '', 'thousand', 'million', 'billion'

$_string=''

while len($_number)<>(len($_number)/3)*3 $_number=' '+$_number loop

While len($_number)>0
	$_part=Left($_number,3)
	$_number=Right($_number,len($_number)-3)
	
	while len($_part)<3 $_part=' '+$_part loop

	$_ss='' 
	$_Hn=val(substr($_part,1,1))
	$_Tn=val(substr($_part,2,1))
	$_TSn=val(substr($_part,2,2))
	$_Sn=val(substr($_part,3,1))

	if $_Hn>0 $_ss=$_s[$_Hn-1]+'hundred' endif

	if $_TSn>0
		if $_Hn>0 or len($_number)/3>1 $_ss=$_ss+'and' endif
		select
			case $_TSn<11
				$_ss=$_ss+$_s[$_TSn-1]
			case $_TSn>10 and $_TSn<20
				$_ss=$_ss+$_t[$_TSn-11]
			case 1
				$_ss=$_ss+$_d[$_Tn-2]

				if $_Sn>0
					$_ss=$_ss+$_s[$_Sn-1]
				endif
		endselect
	endif
	if len($_ss)>0
		$_ss=$_ss+$_b[(len($_number)/3)]
	endif
	$_string=$_string+$_ss
loop

if $_string>''
	$NumberToWords=$_string
else
	$NumberToWords='zero'
endif

EndFunction

Author(s):

DrillSergeant

[ 24 November 2001: Message edited by: DrillSergeant ]83533NumSpeak1**DONOTDELETE**NumSpeak() - returns a number as its ordinal0Description - This UDF adds "st", "nd", "rd" or "th" to a number and returns it as a string.

Syntax - NumSpeak(number)

Example - NumSpeak(101) returns "101st"

Author - Bob Kelly, KiXscripts.com

code:

Function NumSpeak($Num)
  $Num = "$Num"
  $EndNum = SubStr($Num,Len($Num),1)
  Select
    Case $EndNum = "0" AND Len($Num) = 1
      $NumSpeak = $Num
    Case $EndNum = "1"
      $NumSpeak = $Num + "st"
    Case $EndNum = "2"
      $NumSpeak = $Num + "nd"
    Case $EndNum = "3"
      $NumSpeak = $Num + "rd"
    Case 1
      $NumSpeak = $Num + "th"
  EndSelect
EndFunction


 
 [ 28. October 2002, 19:45: Message edited by: Radimus ]84141ODBCACCESS79KdyerODBCACCESS() - Create an ODBC connection to Access0

code:

;FUNCTION ODBCACCESS()
;
;ACTION Creates an ODBC Connection on the Client Desktop to a MS-Access Database
;
;AUTHOR Kent Dyer (leptonator@hotmail.com)
;
;CONTRIBUTORS
;
;VERSION 1.1
; Renamed to be ODBCACCESS()
;
;KIXTART Minimum required Kixtart version 4.02
;
;SYNTAX ODBCACCESS($NAME,$DB)
;
;PARAMETERS $NAME
; Name to be listed in the ODBC Connections in the Control Panel
;
; $DB
; Path to the MDB file
;
;RETURNS Nothing
;
;REMARKS User would need to be a Power User or better to run this Function.
;
;DEPENDENCIES Access DB, KiXtart 4.02 +
;
;EXAMPLE ODBCACCESS('ODBC DATABASE NAME','N:\MARKETING\MARKETING.MDB')
;
;KIXTART BBS http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000400

FUNCTION ODBCACCESS($NAME,$DB)
DIM $DriverPath,$DatabaseName,$DriverName,$RegEd,$RegEdPath,$RC
 $Description=$NAME
 IF @INWIN=1
  $DriverPath='%windir%\System32\odbcjt32.dll'
 ELSE
  $DriverPath='%windir%\System\odbcjt32.dll'
 ENDIF
 $DatabaseName=$DB
 $DriverName='Microsoft Access Driver (*.mdb)'

 $RegEd='HKLM\SOFTWARE\ODBC\ODBC.INI'
 $RegEdPath=$RegEd+'\'+$DatabaseName

 IF NOT KEYEXIST($RegEdPath)
  $RC=ADDKEY($RegEdPath)
  $RC=WRITEVALUE($RegEdPath,'DriverId',25,'REG_DWORD')
  $RC=WRITEVALUE($RegEdPath,'SafeTransactions',0,'REG_DWORD')
  $RC=WRITEVALUE($RegEdPath,'DBQ',$DB,'REG_SZ')
  $RC=WRITEVALUE($RegEdPath,'Driver',$DriverPath,'REG_SZ')
  $RC=WRITEVALUE($RegEdPath,'FIL','MS Access;','REG_SZ')
  $RC=WRITEVALUE($RegEdPath,'UID','','REG_SZ')
  $RC=ADDKEY($RegEdPath+'\Engines')
  $RC=ADDKEY($RegEdPath+'\Engines\Jet')
  $RC=WRITEVALUE($RegEdPath+'\Engines\Jet','MaxBufferSize',2048,'REG_DWORD')
  $RC=WRITEVALUE($RegEdPath+'\Engines\Jet','PageTimeout',5,'REG_DWORD')
  $RC=WRITEVALUE($RegEdPath+'\Engines\Jet','Threads',3,'REG_DWORD')
  $RC=WRITEVALUE($RegEdPath+'\Engines\Jet','ImplicitCommitSync','','REG_SZ')
  $RC=WRITEVALUE($RegEdPath+'\Engines\Jet','UserCommitSync','Yes','REG_SZ')

  $RC=WRITEVALUE($RegEd+'\ODBC Data Sources',$Description,$DriverName,'REG_SZ')
 ENDIF
ENDFUNCTION


 
 [ 28. October 2003, 16:49: Message edited by: kdyer ]84002ODBCORACLE79KdyerODBCORACLE() - Create an ORACLE ODBC Connection0Code:


;FUNCTION ODBCORACLE()

;

;ACTION Creates an ODBC Connection on the Client Desktop to a Oracle Database

;

;AUTHOR Kent Dyer leptonator@hotmail.com

;

;CONTRIBUTORS

;Conrad Wheeler - http://kixtart.org - Thanks for the suggestion :)

;

;VERSION 1.3 Code Clean-up,DIM, Added in Option to create a USER DSN

; 1.2 Fixed Registry write, Added in DIM Statements

;  1.1

; Renamed to be ODBCORACLE

;

;DATE CREATED 14-APRIL-2003

;

;DATE REVISED 15-AUGUST-2004

;

;KIXTART Minimum required Kixtart version 4.02

;

;SYNTAX ODBCORACLE($NAME,$SERVER,optional $user)

;

;PARAMETERS $NAME

; Name to be listed in the ODBC Connections in the Control Panel

;

; $SERVER

; Server you need to connect to

;

; $DB

; Database on $Server

;

;RETURNS Nothing

;

;REMARKS User would need to be a Power User or better to run this Function.

;This uses the installation from Oracle 8.1.6

; User DSN, Client should be able to run this code

;

;DEPENDENCIES Oracle

;

;EXAMPLE ODBCORACLE('DATABASENAME','SERVER') ; System DSN

;   ODBCORACLE('DATABASENAME','SERVER',1) ; User DSN

;

;KIXTART BBS http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Board=UBB12&Number=83218



FUNCTION ODBCORACLE($NAME,$SERVER,optional $user)

DIM $reg,$Title,$Driver,$RegEd,$reg,$RegEdPath

 IF NOT $user

   $reg='HKLM'

 ELSE

   $reg='HKCU'

 ENDIF



 $Title='Oracle ODBC Driver'

 $Driver=READVALUE('HKLM\SOFTWARE\ODBC\ODBCINST.INI\'+$Title,'Driver')

 $RegEd=$reg+'\SOFTWARE\ODBC\ODBC.INI'

 $RegEdPath=$RegEd+'\'+$Name

 IF NOT KEYEXIST($RegEdPath)

  $RC=ADDKEY($RegEdPath)

  $RC=WRITEVALUE($RegEdPath,'Application Attributes','T','REG_SZ');Thread Safety

  $RC=WRITEVALUE($RegEdPath,'Attributes','W','REG_SZ');W(Write),R(Read-only)

  ;Can be a performance hit when enabled

  $RC=WRITEVALUE($RegEdPath,'CloseCursor','F','REG_SZ')

  $RC=WRITEVALUE($RegEdPath,'Description',$Name,'REG_SZ')

  $RC=WRITEVALUE($RegEdPath,'DisableMTS','F','REG_SZ') ;MTS Support

  $RC=WRITEVALUE($RegEdPath,'Driver',$Driver,'REG_SZ')

  ;Client must be 8.0.5+

  $RC=WRITEVALUE($RegEdPath,'Failover','T','REG_SZ')

  ;Number of seconds to delay between attempts

  $RC=WRITEVALUE($RegEdPath,'FailoverDelay',10,'REG_SZ')

  $RC=WRITEVALUE($RegEdPath,'FailoverRetryCount',10,'REG_SZ')

  $RC=WRITEVALUE($RegEdPath,'Lobs','T','REG_SZ')

  $RC=WRITEVALUE($RegEdPath,'Longs','F','REG_SZ') ;Long Columns

  ;Number of rows your application can Fetch 

  $RC=WRITEVALUE($RegEdPath,'PrefetchCount',10,'REG_SZ')

  $RC=WRITEVALUE($RegEdPath,'QueryTimeout','T','REG_SZ')

  $RC=WRITEVALUE($RegEdPath,'ResultSets','T','REG_SZ')

  $RC=WRITEVALUE($RegEdPath,'ServerName',$Server,'REG_SZ')

  $RC=WRITEVALUE($RegEdPath,'Translation DLL','','REG_SZ')

  $RC=WRITEVALUE($RegEdPath,'Translation Option',0,'REG_SZ')

  $RC=WRITEVALUE($RegEdPath,'UserID','','REG_SZ')

  $RC=WRITEVALUE($RegEd+'\ODBC Data Sources',$Name,'Oracle ODBC Driver','REG_SZ')

 ENDIF

ENDFUNCTION

83982ODBCSQL79KdyerODBCSQL() - Create a SQL ODBC Connection0Code:


;FUNCTION ODBCSQL()
;
;ACTION Creates an ODBC Connection on the Client Desktop to a SQL Server Database
;
;AUTHOR Kent Dyer leptonator@hotmail.com
;
;CONTRIBUTORS
;Dixan Martinez
;Ref. - Create a DSN to access a SQL Server database with ODBC 
;http://cwashington.netreach.net/depo/view.asp?Index=388&ScriptType=vbscript
;
;VERSION 1.4 - Corrected local connection syntax
; 1.3 - REMOVED UNEEDED code, Added option to create User DSN
; 1.2 Added in DIM Statement
; 1.1
; Renamed to be ODBCSQL
;
;DATE CREATED 14-APRIL-2003
;
;DATE REVISED 7-JULY-2005
;
;KIXTART Minimum required Kixtart version 4.02
;
;SYNTAX ODBCSQL($NAME,$SERVER,$DB,optional $user)
;
;PARAMETERS $NAME
; Name to be listed in the ODBC Connections in the Control Panel
;
; $SERVER
; Server you need to connect to
;
; $DB
; Database on $Server
;
; $USER
; Specified USER DSN
;
;RETURNS Nothing
;
;REMARKS User would need to be a Power User or better to run this Function.
; When creating a User DSN, should be able to run as a user of the machine.
;
;DEPENDENCIES SQL Server, KiXtart 4.02 +, rights for machine-wide connections
;
;EXAMPLE
; -- Create a system-wide ODBC conection
; ODBCSQL('ODBC DATABASE NAME','SERVER','DATABASE')
;
; -- Create local (not machine-wide) ODBC connection
;IF NOT KEYEXIST('HKCU\SOFTWARE\ODBC\ODBC.INI\YOUR ODBC')
;  ODBCSQL('YOUR ODBC','SERVER','DATABASE',1)
;ENDIF
;
;KIXTART BBS http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Board=UBB12&Number=83212
FUNCTION ODBCSQL($NAME,$SERVER,$DB,optional $user)
 DIM $reg,$Title,$Driver,$RegEd,$RegEdPath,$RC
 IF NOT $user
    $reg='HKLM' ; System DSN
 ELSE
    $reg='HKCU' ; User DSN
 ENDIF
 $Title='SQL Server'
 $Driver=READVALUE('HKLM\SOFTWARE\ODBC\ODBCINST.INI\'+$Title,'Driver')

 $RegEd=$reg+'\SOFTWARE\ODBC\ODBC.INI'
 $RegEdPath=$RegEd+'\'+$Name

 IF NOT KEYEXIST($RegEdPath)
  $RC=ADDKEY($RegEdPath)
  $RC=WRITEVALUE($RegEdPath,'Database',$DB,'REG_SZ')
  $RC=WRITEVALUE($RegEdPath,'Driver',$Driver,'REG_SZ')
  $RC=WRITEVALUE($RegEdPath,'LastUser',@USERID,'REG_SZ')
  $RC=WRITEVALUE($RegEdPath,'Server',$Server,'REG_SZ')
  $RC=WRITEVALUE($RegEdPath,'Trusted_Connection','Yes','REG_SZ')
  $RC=WRITEVALUE($RegEd+'\ODBC Data Sources',$Name,$Title,'REG_SZ')
 ENDIF
ENDFUNCTION

83900ODBCVFP79KdyerODBCVFP() - Create a VFP (Visual FoxPro) ODBC Connection0Code:


;FUNCTION ODBCVFP()

;

;ACTION Creates an ODBC Connection on the Client Desktop to a Visual FoxPro Database

;

;AUTHOR Kent Dyer (leptonator@hotmail.com)

;

;VERSION 1.2 - Updated to be able to create a User DSN,Code Cleanup

;  1.1 - Renamed from VFPDATASOURCE

;

;DATE CREATED 3-MARCH-2003

;

;DATE REVISED 15-AUGUST-2004

;

;KIXTART Minimum required Kixtart version 4.02

;

;SYNTAX ODBCVFP($dsnname,$location,$dbc,optional $user)

;

;PARAMETERS $dsnname

; Name to be listed in the ODBC Connections in the Control Panel

;

; $dbc

; Visual FoxPro Container you need to query data from

;

;RETURNS Nothing

;

;REMARKS User would need to be a Power User or better to run this Function.

; User DSN Should be able to be created by the client

;

;DEPENDENCIES Program running Visual FoxPro, KiXtart 4.02 +

;

;EXAMPLE ODBCVFP('ODBC NAME','R:\Program\Tables','DATABASECONTAINER.DBC') ;System DSN

;  ODBCVFP('ODBC NAME','R:\Program\Tables','DATABASECONTAINER.DBC',1) ; User DSN

;

;KIXTART BBS http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Board=UBB12&Number=83143

;

 FUNCTION ODBCVFP($DSNname,$Location,$Dbc,optional $User)

  DIM $reg,$Title,$Driver,$RegKey,$odbcpath,$rc

  IF NOT $User

     $Reg='HKLM'

  ELSE

     $Reg='HKCU'

  ENDIF

  $title='Microsoft Visual FoxPro Driver'

  $Driver=READVALUE('HKLM\SOFTWARE\ODBC\ODBCINST.INI\'+$Title,'Driver')

  $RegKey=$reg+'\Software\ODBC\ODBC.INI'

  ;SET THE REGISTRY PATH STRING

  $ODBCPath=$RegKey+'\'+$DSNname

  IF NOT KEYEXIST($odbcpath)

   $rc=ADDKEY($odbcpath)

   $rc=WRITEVALUE($RegKey+'\ODBC Data Sources',$DSNname,$Title,'REG_SZ')

   ;NOW, WRITE SOME VALUES FOR THIS ODBC CONNECTION

   $rc=WRITEVALUE($ODBCPath,'Driver',$Driver,'REG_SZ')

   $rc=WRITEVALUE($ODBCPath,'SourceDB',$Location+'\'+$Dbc,'REG_SZ')

   $rc=WRITEVALUE($ODBCPath,'Description','','REG_SZ')

   $rc=WRITEVALUE($ODBCPath,'SourceType','DBC','REG_SZ')

   $rc=WRITEVALUE($ODBCPath,'BackgroundFetch','No','REG_SZ')

   $rc=WRITEVALUE($ODBCPath,'Exclusive','No','REG_SZ')

   $rc=WRITEVALUE($ODBCPath,'Null','Yes','REG_SZ')

   $rc=WRITEVALUE($ODBCPath,'Deleted','Yes','REG_SZ')

   $rc=WRITEVALUE($ODBCPath,'Collate','Machine','REG_SZ')

  ENDIF

 ENDFUNCTION

129716oncePerWeek119LonkerooncePerWeek() - Execute a thing once per week0Code:


;Function

;	OncePerWeek()

;

;Action

;	Runs a program once a week

;

;Author

;	Lonkero

;

;Version

;	1.0 (17 november 2004)

;

;Syntax

;	OncePerWeek(WHAT)

;

;Parameters

;	WHAT - the thingie you want to fire

;

;Returns

;	Nothing

;

;Remarks

;	Decided to make a real Once-a-week udf as didn't find any...

;

;Example

;	$ie=READVALUE('HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\IEXPLORE.EXE','')

;	OncePerWeek($ie+' http://intra.mydomain.com')

;

;Source

Function OncePerWeek($)

 If ReadValue('HKCU\Software\KiXtart','lonks_weeky')<>(0+@ydayno-@wdayno)/7

  Run $

  $=WriteValue('HKCU\Software\KiXtart','lonks_weeky',(0+@ydayno-@wdayno)/7,'REG_SZ')

 EndIf

EndFunction

  84067ONEADAY79KdyerONEADAY() - Run a program once a day0Code:

;FUNCTION ONEADAY()

;

;ACTION Runs a program one time a day

;

;AUTHOR Kent Dyer (leptonator@hotmail.com)

;

;CONTRIBUTORS Lonkero (code cleanup), Howard Bullock - Thanks for the idea :)

;

;VERSION 1.2

;

;DATE CREATED 25-April-2003

;

;DATE MODIFIED 12-July-2004

;              Updated URLs and converted UBB Code

;

;KIXTART 4.02

;

;SYNTAX ONEADAY('PROGRAM','FIRST')

;

;PARAMETERS $program

; program to run

;

; PARAMETER2 $prgflag

; Optional Flag if you want to run more than one program once a day

;

;RETURNS Nothing

;

;REMARKS HKCU\Software\KiXtart is created anyway when the tokencache flag is used with KIX32.EXE

;

;EXAMPLE

;$ie=READVALUE('HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\IEXPLORE.EXE','')

;NOTES:HKCU\Software\KiXtart is created anyway when the tokencache flag is used with KIX32.EXE

;idea is from - http://www.adminscripteditor.com/forum/m.asp?m=1736&mpage=1&key=

; ONEADAY($ie+' http://www.microsoft.com')

;

;KIXTART BBS http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=83270

FUNCTION ONEADAY($program, OPTIONAL $prgflag)

dim $rc

	IF $prgflag=''

		$prgflag='DTFLAG'

	ENDIF

	$rc=ADDKEY('HKCU\Software\KiXtart')

	IF READVALUE('HKCU\Software\KiXtart',$prgflag)<>@date

		$rc=WRITEVALUE('HKCU\Software\KiXtart',$prgflag,@date,'REG_SZ')

		RUN $program

	ENDIF

ENDFUNCTION



84208ONEAWEEK79KdyerONEAWEEK() - Run a program once a week0Code:

 ;FUNCTION ONEAWEEK()

 ;

 ;ACTION Runs a program one time a week

 ;

 ;AUTHOR Kent Dyer (leptonator@hotmail.com)

 ;

 ;CONTRIBUTORS

 ;

 ;VERSION 1.1

 ;

 ;DATE CREATED 09-May-2003

 ;

 ;DATE MODIFIED 12-July-2004

 ;              URL Updates and UBB Code Cleanup

 ;

 ;KIXTART 4.02

 ;

 ;SYNTAX ONEAWEK('PROGRAM')

 ;

 ;PARAMETERS $program

 ; program to run

 ;

 ; PARAMETER2 $Day

 ; Day of the week - Monday, Tuesday, Wednesday - etc.

 ;

 ;RETURNS Nothing

 ;

 ;REMARKS HKCU\Software\KiXtart is created anyway when the tokencache flag is used with KIX32.EXE

 ;

 ;EXAMPLE

 ;$ie=READVALUE('HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\IEXPLORE.EXE','')

 ;NOTES:HKCU\Software\KiXtart is created anyway when the tokencache flag is used with KIX32.EXE

 ;ONEAWEEK($ie+' http://www.microsoft.com','Friday')

 ;

 ;KIXTART BBS http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=83376

 FUNCTION ONEAWEEK($program,$Day)

       DIM $rc

       $rc=ADDKEY('HKCU\Software\KiXtart')

       IF READVALUE('HKCU\Software\KiXtart','DAYFLAG')<>$Day

             $rc=WRITEVALUE('HKCU\Software\KiXtart','DAYFLAG',@day,'REG_SZ')

             RUN $program

       ENDIF

 ENDFUNCTION

186584OpenFile34cjOpenFile() - Brings up the open dialog and lets you select a file.1207257532This was inspired by Mart's Save() UDF   The DLL he uses has an open function and it's very similar.

ÿCode:

;FUNCTION:
;	OpenFile()
;
;ACTION:
;	Brings up the open dialog and lets you select a file.
;
;AUTHOR:
;	cj
;
;SOURCE:
;	http://www.kixtart.org/forums/ubbthreads.php?ubb=showflat&Number=184201#Post184201
;
;VERSION:
;	1.0
;
;DATE CREATED:
;	April 1nth 2008
;
;REVISED:
;	None.
;
;SYNTAX:
;	OpenFile($MustExist)
;
;PARAMETERS:
;	$MustExist (optional integer)
;		0 - file does not have to exist (default)
;		1 - selected file must exist, dialog will re-open if file not found
;
;RETURNS:
;	Returns the full path and file name of the file selected.
;
;REMARKS:
;	Returns blank if the dialog is canceled.
;
;DEPENDENCIES;
;	Developed and tested with KiXtart 4.60 on WinXP pro SP1.
;
;EXAMPLES:
;	Example1:
;		;This example looks for a file
;		dim $sFilename
;		$sFilename = OpenFile()
;		if $sFilename <> ''
;			"you selected: " $sFilename ?
;		else
;			"you canceled" ?
;		endif
;
;	Example2: (requires the ReadFile() UDF)
;		;This reads the contents of the file read with the ReadFile UDF.
;		$filename = OpenFile()
;		if $filename <> ''
;			$file = ReadFile($filename)
;			For Each $line in $file
;				$data = $data  + $line + @CRLF
;			Next
;		endif
;
Function OpenFile(optional $iMustExist)

	dim $oDialog, $iOpen					; define vars

	do
		$OpenFile = ''					; reset result

		$oDialog = CreateObject("SAFRCFileDlg.FileOpen")	; create Object
		$iOpen = $oDialog.OpenFileOpenDlg			; open dialog
		$OpenFile = $oDialog.FileName			; get filename from object

	until not $iOpen						; we canceled the dialog
	or not $iMustExist						; or we don't care if it exists
	or Exist($OpenFile)					; or it does exist

EndFunction


NOTE: This UDF is v.simple and only returns 1 filename.  Witto has a much more flexible UDF: MSCommonDialog() - Common Dialog Box to select files

cj83516OpenFile172Howard BullockOpenFile() - Open the specified file with options.0

code:

;FUNCTION         OpenFile()
;
;AUTHOR           Howard A. Bullock (hbullock@tycoelectronics.com)
;
;ACTION           Opens file based on specified parameters. Supports overwriting a file.
;
;SYNTAX           OpenFile(FileName, R|W, [0|1], [0|1])
;
;PARAMETERS       $FileName (Required) -  String value
;                 $ReadWrite (Required) -  String value
;                 $Create (Optional) Default(0) Do not create a new file. (1 or 0)
;                 $OverWrite (Optional) - Default(0) Append (1 or 0)
;
;
;REMARKS          This function attempts to open the specified file. @error is set on exit.
;                 The UDF will search for the first available file number.
;
;RETURNS          File handle (integer 1-10) if successful; nothing if error
;
;DEPENDENCIES     None
;                 UDF WriteLog ()    WriteLog2() can be substituted for more flexibillity.
;
;
;EXAMPLES
;                 Open file for write; do not create the file; append
;                 $FH = OpenFile("junk.txt", "W")
;                 if @error = 0
;                    Writeline($FH, "Some text")
;                 endif
;
;                 Open file for write; create the file; delete old file
;                 $FH2 = OpenFile("junk2.txt", "W", 1, 1)
;                 if @error = 0
;                    Writeline($FH2, "Some text")
;                 endif;
;
Function OpenFile($FileName, $ReadWrite, optional $Create, optional $Overwrite)
   Dim $FileName, $ReadWrite, $Create, $Overwrite
   Dim $FH, $RC, $Mode

   ; Validate input parameters
   if VarType($Create) = 0
      $Create = 0
   endif
   if VarType($Overwrite) = 0
      $Overwrite = 0
   endif
   if not (VarType($FileName) = 8 and
          ($ReadWrite = "R" or $ReadWrite = "W") and
          ($Create = 0 or $Create = 1) and
          ($Overwrite = 0 or $Overwrite = 1) )
      WriteLog($LogFile, "OpenFile: Error in parameters (" + $FileName + ", " +
                         $ReadWrite + ", " + $Create + ", " + $OverWrite + ")")
      exit 1
   endif
   if $Create < $OverWrite
      WriteLog($LogFile, "OpenFile: Error in parameters (You must specify Create=1 when OverWrite=1)")
      exit 1
   endif

   ; Build Mode value
   if $Create = 0
      $Mode = 0
   else
      $Mode = 1
   endif
   if $ReadWrite = "R"
      $Mode = $Mode + 2
   else
      $Mode = $Mode + 4
   endif

   ;Handle OverWrite option
   if $OverWrite = 1
      if exist ($Filename)
         del $Filename
      endif
   endif

   ; Open file
   $FH=1
   $RC=Open ($FH, $FileName, $Mode)
   ? "@error @serror"
   if $RC <> 0
      select
         case $RC=2
            WriteLog("open($FileNum, $FileName, $Mode) Error: $RC (Cannot find the file specified)")
            exit $RC
         case $RC=-3
            while $RC = -3 and $FH < 11
               $RC=Open ($FH, $FileName, $Mode)
               if $RC = -3
                  $FH=$FH +1
               endif
            Loop
            if $RC = -3
               WriteLog("open($FileNum, $FileName, $Mode) Error: $RC (All file numbers are in use.)")
               exit $RC
            endif
         case $RC=-2
            WriteLog("open($FileNum, $FileName, $Mode) Error: $RC (Invalid file number specified)")
            exit $RC
         case $RC=-1
            WriteLog("open($FileNum, $FileName, $Mode) Error: $RC (File number already in use)")
            exit $RC
         case 1
            WriteLog("open($FileNum, $FileName, $Mode) Error: $RC (System error)")
            exit $RC
      endselect
   endif
   WriteLog("Success: Open($FileNum, $FileName, $ReadWrite, $OverWrite) returned file handle: ")
   $OpenFile = $FH
   exit 0
Endfunction


 
 [ 14. July 2003, 16:18: Message edited by: Howard Bullock ]83847OpenLocation119LonkeroOpenLocation() - opens any location or file in associated application0

code:

;FUNCTION	OpenLocation()
;
;AUTHOR		Lonkero
;
;ACTION		opens any location or file in associated application
;
;SYNTAX		OpenLocation(LOCATION)
;
;PARAMETERS	LOCATION - location or file to open
;
;RETURNS	nothing.
;
;DEPENDENCIES	Minimum operating systems: NT or win95 with IE4
;
;EXAMPLES
;		openLocation("http://kixtart.org")
;		openLocation("C:\Documents and Settings\Lonkero\Desktop\form.txt")
;		
;
;CODE

function OpenLocation($_)
 dim $
 $=createobject('shell.application')
 $.open($_)
endfunction

82100OSID17SealeopardOSID() - Identifies operating system, service pack level, and OS kernel1073918345Code:


;FUNCTION      OSID

;

;ACTION        Provides local and remote operating system identifiers

;

;AUTHOR        Jens Meyer (sealeopard@usa.net)

;

;VERSION       1.91 (corrected a typo regarding num,ver of elements in array)

;              1.9  (fixed bug regarding remote installation date and OEM indicator string, updated build numbers)

;              1.85 (added local/remote @PRODUCTTYPE macro value)

;              1.84 (changed remote Windows NT/2K/XP/2K3 OS language resolution to use SHELL32.DLL)

;              1.83 (added OS language)

;              1.82 (corrected NT 4.0 SP6a identification)

;              1.81 (WinNT product key now formatted correctly)

;              1.8  (added TabletPC, optional remote computer)

;              1.7  (added Windows Server 2003 alpha/beta/RC IDs)

;              1.6

;

;DATE CREATED  2001/11/26

;

;DATE MODIFIED 2004/01/12

;

;KIXTART       4.12+

;

;SYNTAX        OSID([COMP])

;

;PARAMETERS    COMP

;              optional string denoting a remote computer

;

;RETURNS       array of fourteen identifiers

;

;              OSID[0]  full operating system description

;              OSID[1]  kernel description (Win9x, WinNT, Win2K, WinXP, Win2K3)

;              OSID[2]  operating system role (workstation, member server, domain controller)

;              OSID[3]  operating system service pack level

;              OSID[4]  operating system build level

;              OSID[5]  uni/multi-processor type

;              OSID[6]  registered owner

;              OSID[7]  registered organization

;              OSID[8]  Product key

;              OSID[9]  Install Date (use CTime() UDF to convert to date-time-string)

;              OSID[10] OEM Duplicator string (can be set during SYSPREP unattended installs)

;              OSID[11] OS Language

;              OSID[12] @PRODUCTTYPE macro value (local and remote)

;              OSID[13] verbose build description

;

;REMARKS       @PRODUCTSUITE macros will not resolve correctly for remote systems

;

;DEPENDENCIES  none

;

;EXAMPLE       $currentos = osid()

;              $installdate = CTime($currentos[9])

;

;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Number=110348

;

function osid(optional $sComp)

  dim $osidarray[13]

  

  dim $iINWIN, $sDOS, $iBUILD, $sCSD, $iPRODUCTSUITE, $sPRODUCTTYPE

  

  dim $operating_system, $sp_level, $os_suite, $os_short, $productsuite

  dim $os_type, $os_role, $os_flavor, $os_subver, $regkey

  dim $os_build, $os_proc, $os_owner, $os_org, $os_key, $os_date, $os_oem

  dim $os_lang, $os_producttype, $os_longbuild

  dim $LongHornBuild[4], $Win2003Build[9], $iBuildnumber, $asBuildList

  dim $WinXPBuild[9], $Win2000Build[7]

  

  $LongHornBuild[0]='internal release',3670,3683,4008

  $LongHornBuild[1]='Alpha Preview 3',4015

  $LongHornBuild[2]='Alpha Preview 2',4008

  $LongHornBuild[3]='Developer Preview',4051

  $LongHornBuild[4]='RTM'

  

  $Win2003Build[0]='Whistler Server preview release',2250

  $Win2003Build[1]='Whistler Server alpha',2257

  $Win2003Build[2]='Whistler Server interim release',2267,2410.2469

  $Win2003Build[3]='Windows .NET Server interim release',3541,3604,3615,3621,3628,3660

  $Win2003Build[4]='Windows .NET Server beta 3',3590

  $Win2003Build[5]='Release Candidate 1',3663

  $Win2003Build[6]='Release Candidate 2',3718

  $Win2003Build[7]='internal release',3757

  $Win2003Build[8]='escrow build',3763

  $Win2003Build[9]='RTM',3790

  

  $WinXPBuild[0]='Whistler pre-alpha',2223.1

  $WinXPBuild[1]='Whistler preview',2250

  $WinXPBuild[2]='Whistler alpha',2257

  $WinXPBuild[3]='Whistler inetrim release',2267,2410,2416,2419

  $WinXPBuild[4]='Whistler beta 1',2296

  $WinXPBuild[5]='interim release',2428,2432,2446,2465,2469,2475,2481,2486,2494,2496,2526,2535,2542

  $WinXPBuild[6]='Beta 2',2462

  $WinXPBuild[7]='Release Candidate 1',2502

  $WinXPBuild[8]='Release Candidate 2',2520

  $WinXPBuild[9]='RTM',2545,2600

  

  $Win2000Build[0]='Beta 1',1671

  $Win2000Build[1]='Beta 2',1515

  $Win2000Build[2]='Beta 2 Release Candidate',1859

  $Win2000Build[3]='interim release',1868,1773

  $Win2000Build[4]='Beta 3',2031

  $Win2000Build[5]='Beta 3 Release Candidate 2',2128

  $Win2000Build[6]='Release Candidate 3',2183

  $Win2000Build[7]='RTM',2195

  

  $sComp=trim($sComp)

  select

  case $sComp=@WKSTA

    $sComp=''

  case $sComp and not keyexist('\\'+$sComp+'\HKLM')

    exit 2

  case $sComp

    $sComp='\\'+$sComp+'\'

  endselect

  

  ; fetch all macro info depending on whether it's remote or local

  if $sComp

    if keyexist($sComp+'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList')

      $iINWIN=1

      $sDOS=readvalue($sComp+'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion','CurrentVersion')

      $iBUILD=readvalue($sComp+'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion','CurrentBuildNumber')

      $sCSD=readvalue($sComp+'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion','CSDVersion')

      if $sDOS='4.0' and readvalue($sComp+'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Hotfix\Q246009','Installed')

        $sCSD=$sCSD+'a'

      endif 

      $sPRODUCTTYPE=readvalue($sComp+'HKLM\SYSTEM\CurrentControlSet\Control\ProductOptions','ProductType')

      select

      case $sPRODUCTTYPE='WinNT'

        if $sDOS='4.0'

          $sPRODUCTTYPE='Workstation'

        else

          $sPRODUCTTYPE='Professional'

        endif

      case $sPRODUCTTYPE='ServerNT'

        if $sDOS='5.2'

          $sPRODUCTTYPE=''

        else

          $sPRODUCTTYPE='Server'

        endif

      case $sPRODUCTTYPE='LANManNT'

        $sPRODUCTTYPE='Domain Controller'

      case 1

        $sPRODUCTTYPE='Home Edition'

      endselect

      $sPRODUCTTYPE=readvalue($sComp+'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion','ProductName')+' '+$sPRODUCTTYPE

      $sPRODUCTTYPE=join(split($sPRODUCTTYPE,'Microsoft'),'')

      $iPRODUCTSUITE=''

      $os_lang=$sComp+join(split(readvalue($sComp+'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion','SystemRoot'),':\'),'$\')+'\system32\shell32.dll'

      $os_lang=getfileversion($os_lang,'Language')

    else

      $iINWIN=2

      $dDOS=readvalue($sComp+'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion','VersionNumber')

      $dDOS=split($dDOS,'.')

      $iBUILD=$dDOS[ubound($dDOS)]

      redim preserve $dDOS[1]

      $sDOS=join($dDOS,'.')

      $sCSD=''

      $iPRODUCTSUITE=''

      $sPRODUCTTYPE=readvalue($sComp+'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion','Version')

      $os_lang=right(''+readvalue($sComp+'HKLM\SYSTEM\CurrentControlSet\Control\Nls\Locale',''),4)

    endif

  else

    $iINWIN=@INWIN

    $sDOS=@DOS

    $iBUILD=@BUILD

    $sCSD=@CSD

    $iPRODUCTSUITE=@PRODUCTSUITE

    $sPRODUCTTYPE=@PRODUCTTYPE

    $os_lang=@SYSLANG

  endif

  

  ; set the correct registry key

  if $iINWIN=1

    $regkey='HKLM\Software\Microsoft\Windows NT\CurrentVersion'

  else

    $regkey='HKLM\Software\Microsoft\Windows\CurrentVersion'

  endif

  if $sComp

    $regkey=$sComp+$regkey

  endif

  

  ; retrieve registered owner, organization, build, type

  $os_owner=readvalue($regkey,'RegisteredOwner')

  $os_org=readvalue($regkey,'RegisteredOrganization')

  $os_proc=readvalue($regkey,'CurrentType')

  $os_build=val($iBUILD)



  select

  case $iINWIN=1

    ; determine the operating system kernel

    select

    Case $sDOS='6.0'

      $operating_system='Windows Longhorn'

      for $iBuildnumber=0 to ubound($LongHornBuild)

        $asBuildList=$LongHornBuild[$iBuildNumber]

        if ascan($asBuildList,$os_build)+1

          $os_longbuild=$asBuildList[0]

        endif

      next

      $os_short='WinLonghorn'

      $os_key=readvalue($regkey,'ProductID')

    Case $sDOS='5.2'

      $operating_system='Windows Server 2003'

      $os_short='Win2K3'

      $os_key=readvalue($regkey,'ProductID')

      for $iBuildnumber=0 to ubound($Win2003Build)

        $asBuildList=$Win2003Build[$iBuildNumber]

        if ascan($asBuildList,$os_build)+1

          $os_longbuild=$asBuildList[0]

        endif

      next

    Case $sDOS='5.1'

      $operating_system='Windows XP'

      for $iBuildnumber=0 to ubound($WinXPBuild)

        $asBuildList=$WinXPBuild[$iBuildNumber]

        if ascan($asBuildList,$os_build)+1

          $os_longbuild=$asBuildList[0]

        endif

      next

      $os_short='WinXP'

      $os_key=readvalue($regkey,'ProductID')

    Case $sDOS='5.0'

      $operating_system='Windows 2000'

      for $iBuildnumber=0 to ubound($Win2000Build)

        $asBuildList=$Win2000Build[$iBuildNumber]

        if ascan($asBuildList,$os_build)+1

          $os_longbuild=$asBuildList[0]

        endif

      next

      $os_short='Win2k'

      $os_key=readvalue($regkey,'ProductID')

    Case $sDOS='4.0'

      $operating_system='Windows NT 4.0'

      $os_short='WinNT'

      $os_key=readvalue($regkey,'ProductID')

      $os_key=left($os_key,5)+'-'+substr($os_key,6,3)+'-'+substr($os_key,10,7)+'-'+right($os_key,5)

    Case 1

      $operating_system='unknown'

      $os_short='unknown'

    endselect

    

    ; determine the service pack level

    $sp_level=$sCSD

    if instr($sp_level,'Service Pack')

      $sp_level=split($sp_level,'Service Pack')

      $sp_level=trim($sp_level[ubound($sp_level)])

    else

      $sp_level=0

    endif



    ; determine the product suite

    $productsuite=val($iPRODUCTSUITE)

    $os_suite=''

    if $productsuite

      if $productsuite & 1

        $os_suite=$os_suite+'Small Business |'

      endif

      if $productsuite & 2

        $os_suite=$os_suite+'Enterprise |'

      endif

      if $productsuite & 4

        $os_suite=$os_suite+'BackOffice |'

      endif

      if $productsuite & 8

        $os_suite=$os_suite+'Communication Server |'

      endif

      if $productsuite & 16

        $os_suite=$os_suite+'Terminal Server |'

      endif

      if $productsuite & 32

        $os_suite=$os_suite+'Small Business (Restricted) |'

      endif

      if $productsuite & 64

        $os_suite=$os_suite+'Embedded NT |'

      endif

      if $productsuite & 128

        $os_suite=$os_suite+'DataCenter |'

      endif

      if $productsuite & 256

        $os_suite=$os_suite+'Single User Terminal Server |'

      endif

      if $productsuite & 512

        $os_suite=$os_suite+'Home Edition |'

      endif

      if $productsuite & 1024

        $os_suite=$os_suite+'Blade Server |'

      endif

      if instr($os_suite,'|')

        $os_suite=left($os_suite,len($os_suite)-2)

      endif

    endif



    ; determine the producy type

    $os_type=$sPRODUCTTYPE

    select

    Case instr($os_type,'Domain Controller')

      $os_type='Domain Controller'

      $os_role='Domain Controller'

      $os_flavor='Server'

    Case instr($os_type,'Server')

      $os_type='Server'

      $os_role='Member Server'

      $os_flavor='Server'

    Case instr($os_type,'Workstation')

      $os_type='Workstation'

      $os_role='Workstation'

      $os_flavor='Workstation'

    case instr($os_type,'Professional')

      $os_type='Professional'

      $os_role='Workstation'

      $os_flavor='Workstation'

    Case instr($os_type,'Tablet PC')

      $os_type='Tablet PC'

      $os_role='Workstation'

      $os_flavor='Tablet PC'

    Case instr($os_type,'Home Edition')

      $os_type='Home Edition'

      $os_role='Workstation'

      $os_flavor='Workstation'

    case 1

      $os_type='unknown'

      $os_role='unknown'

      $os_flavor='unknown'

    endselect



    ; create the @PRODUCTTYPE macro

    $os_producttype=join(split($operating_system+' '+$os_type,'4.0 '),'')

    

    $operating_system=$os_producttype

    ; add pre-RTM build info to OS description

    if $os_longbuild and $os_longbuild<>'RTM'

     $operating_system=$operating_system+' (build '+$os_build+', '+$os_longbuild+')'

    endif

    ; add service pack info to OS description

    if $sp_level

      $operating_system=$operating_system+' Service Pack '+$sp_level

    endif

    if $os_suite<>''

      $operating_system=$operating_system+' ['+$os_suite+']'

    endif

    

    ; determine the installation date

    $os_date=readvalue($sComp+'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion','Installdate')



    ; determine the OEM Duplicator String

    $os_oem=readvalue($sComp+'HKLM\System\Setup','OemDuplicatorString')

    

  Case $iINWIN=2

    $os_short='Win9x'

    $os_role='Workstation'

    $sp_level=0



    $os_subver=lcase(ReadValue($regkey,'SubVersionNumber'))



    select

    Case $sDOS='4.90'

      $operating_system='Windows ME'

      $os_key=readvalue($regkey,'ProductKey')

      $os_flavor=''

    Case $sDOS='4.10'

      $operating_system='Windows 98'

      $os_key=readvalue($regkey,'ProductKey')

      select

      Case instr($os_subver,'c')

        $os_flavor='SE'

      case instr($os_subver,'b')

        $os_flavor='B'

      case $os_subver=' a '

        $os_flavor='Second Edition'

      Case 1

      	$os_flavor='OEM'

      endselect

    case $sDOS='4.0'

      $operating_system='Windows 95'

      $os_key=readvalue($regkey,'ProductID')

      select

      Case instr($os_subver,'c')

        $os_flavor='OSR 2.5'

      case instr($os_subver,'b')

        $os_flavor='OSR 2.0'

      case instr($os_subver,'a')

        $os_flavor=' Service Pack 1'

      Case 1

      	$os_flavor=' OEM'

      endselect

    Case 1

      $operating_system='unknown'

      $os_short='unknown'

    endselect

    

    $os_producttype=$operating_system

    if $os_flavor

      $operating_system=$operating_system+' '+$os_flavor

    endif



  endselect



  $osidarray[0]=$operating_system

  $osidarray[1]=$os_short

  $osidarray[2]=$os_role

  $osidarray[3]=$sp_level

  $osidarray[4]=$os_build

  $osidarray[5]=$os_proc

  $osidarray[6]=$os_owner

  $osidarray[7]=$os_org

  $osidarray[8]=$os_key

  $osidarray[9]=$os_date

  $osidarray[10]=$os_oem

  $osidarray[11]=$os_lang

  $osidarray[12]=$os_producttype

  $osidarray[13]=$os_longbuild



  $osid=$osidarray



endfunction

156097OSPing52NTDOCOSPing() - Pings the Computer specified1138480354

;Function	OSPing() Pings the Computer specified  
;    
;Author		Les {posted by NTDOC with minor modification so it was not duplicate UDF name}  
;    
;Contributors	Jochen 
;    
;Action		Pings the Computer specified and returns a 1 for success or 0 for failure   
;    
;Syntax		OSPing($sComputer) ;Where $sComputer is the name of a computer to ping  
;    
;Version	1.01   
;    
;Date		2006-Jan-26  
;    
;Date Revised	2006-Jan-28    
;    
;Revision Reason 
;		Per discusssion in thread 
;    
;Parameters	None   
;    
;Remarks	   
;    
;Further Info	None   
;   
;Returns	1 for success 0 for failure   
;    
;Dependencies	KiXtart 4.02 Recommend 4.51 or newer  
;    
;KiXtart Ver	Written and tested with KiXtart v4.52 Beta 2 on Windows XP/2003   
;    
;Example            
;		Break On   
;		Dim $SO   
;		$SO=SetOption('Explicit','On')   
;		$SO=SetOption('NoVarsInStrings','On')   
;		$SO=SetOption('NoMacrosInStrings','On')   
;   
;		Dim $RC  
;		$RC = OSPing('computer6')  
;		If $RC  
;		  'Computer is alive' ?  
;		Else  
;		  'Computer is dead' ?  
;		EndIf  
;    
;Source    
 
Function OSPing($sComputer)
  Shell '"'+%COMSPEC%+'" /c ping -n 1 '+$sComputer+' |find /C "TTL=" >nul'
  $OSPing = NOT @ERROR
EndFunction
 
 
82822OSQuery79KdyerOSQuery() - Determine what OS using WMI0NAME OSQUERY

AUTHOR Kent Dyer (leptonator@hotmail.com)

ACTION Returns amount of memory installed from a system using WMI

SYNTAX OSQuery($what,$where)

PARAMETERS $what - What are you querying using WMI
$where - Where is it in WMI

RETURNS EncryptionLevel, LastBootUpTime, Version, CSDVersion, OSType

REMARKS Ref. TotalMem( $Systemname ) - Determine amount of memory installed using WMI 
Win32_OperatingSystem

I would like to know how Microsoft query an OS that is not runing DOS or has DOS Emulation!!  I know there is DOSEMU for LINUX.                  

DEPENDENCIES Kixtart 4.0, WMI

EXAMPLE and CODE

code:

 BREAK ON
 CLS

 IF OSQuery("EncryptionLevel","Win32_OperatingSystem") <> "" ? "EncryptionLevel is = "OSQuery("EncryptionLevel","Win32_OperatingSystem") 
 ENDIF
 IF OSQuery("LastBootUpTime","Win32_OperatingSystem") <> "" ? "LastBootUpTime is = "OSQuery("LastBootUpTime","Win32_OperatingSystem") 
 ENDIF
 IF OSQuery("Version","Win32_OperatingSystem") <> "" $Version = OSQuery("Version","Win32_OperatingSystem") 
 ? "Version is = "$Version
 ENDIF
 IF OSQuery("CSDVersion","Win32_OperatingSystem") <> " " ? "Service Pack is = "OSQuery("CSDVersion","Win32_OperatingSystem") 
 ENDIF

 $ostype = OSQuery("OSType","Win32_OperatingSystem")

 SELECT
 CASE
       $ostype = 0
       $ostype = "Unknown"
 CASE
       $ostype = 1
       $ostype = "Other"
 CASE
       $ostype = 2
       $ostype = "MACOS"
 CASE
       $ostype = 3
       $ostype = "ATTUNIX"
 CASE
       $ostype = 4
       $ostype = "DGUX"
 CASE
       $ostype = 5
       $ostype = "DECNT"
 CASE
       $ostype = 6
       $ostype = "Digital Unix"
 CASE
       $ostype = 7
       $ostype = "OpenVMS"
 CASE
       $ostype = 8
       $ostype = "HPUX"
 CASE
       $ostype = 9
       $ostype = "AIX"
 CASE
       $ostype = 10
       $ostype = "MVS"
 CASE
       $ostype = 11
       $ostype = "OS400"
 CASE
       $ostype = 12
       $ostype = "OS/2"
 CASE
       $ostype = 13
       $ostype = "JavaVM"
 CASE
       $ostype = 14
       $ostype = "MSDOS"
 CASE
       $ostype = 15
       $ostype = "WIN3x"
 CASE
       $ostype = 16
       $ostype = "WIN95"
 CASE
       $ostype = 17 And Left($Version, 3) <> 4.9 $ostype = "WIN98"
       $ostype = 17 And Left($Version, 3) = 4.9 $ostype = "WIN9ME"
 CASE
       $ostype = 18  And Left($Version, 3) = 4.0 $ostype = "WINNT"
       $ostype = 18  And Left($Version, 3) = 5.0 $ostype = "WIN2000"
       $ostype = 18  And Left($Version, 3) = 5.1 $ostype = "WINXP"
 CASE
       $ostype = 19
       $ostype = "WINCE"
 CASE
       $ostype = 20
       $ostype = "NCR3000"
 CASE
       $ostype = 21
       $ostype = "NetWare"
 CASE
       $ostype = 22
       $ostype = "OSF"
 CASE
       $ostype = 23
       $ostype = "DC/OS"
 CASE
       $ostype = 24
       $ostype = "Reliant UNIX"
 CASE
       $ostype = 25
       $ostype = "SCO UnixWare"
 CASE
       $ostype = 26
       $ostype = "SCO OpenServer"
 CASE
       $ostype = 27
       $ostype = "Sequent"
 CASE
       $ostype = 28
       $ostype = "IRIX"
 CASE
       $ostype = 29
       $ostype = "Solaris"
 CASE
       $ostype = 30
       $ostype = "SunOS"
 CASE
       $ostype = 31
       $ostype = "U6000"
 CASE
       $ostype = 32
       $ostype = "ASERIES"
 CASE
       $ostype = 33
       $ostype = "TandemNSK"
 CASE
       $ostype = 34
       $ostype = "TandemNT"
 CASE
       $ostype = 35
       $ostype = "BS2000"
 CASE
       $ostype = 36
       $ostype = "LINUX"
 CASE
       $ostype = 37
       $ostype = "Lynx"
 CASE
       $ostype = 38
       $ostype = "XENIX"
 CASE
       $ostype = 39
       $ostype = "VM/ESA"
 CASE
       $ostype = 40
       $ostype = "Interactive UNIX"
 CASE
       $ostype = 41
       $ostype = "BSDUNIX"
 CASE
       $ostype = 42
       $ostype = "FreeBSD"
 CASE
       $ostype = 43
       $ostype = "NetBSD"
 CASE
       $ostype = 44
       $ostype = "GNU Hurd"
 CASE
       $ostype = 45
       $ostype = "OS9"
 CASE
       $ostype = 46
       $ostype = "MACH Kernel"
 CASE
       $ostype = 47
       $ostype = "Inferno"
 CASE
       $ostype = 48
       $ostype = "QNX"
 CASE
       $ostype = 49
       $ostype = "EPOC"
 CASE
       $ostype = 50
       $ostype = "IxWorks"
 CASE
       $ostype = 51
       $ostype = "VxWorks"
 CASE
       $ostype = 52
       $ostype = "MiNT"
 CASE
       $ostype = 53
       $ostype = "BeOS"
 CASE
       $ostype = 54
       $ostype = "HP MPE"
 CASE
       $ostype = 55
       $ostype = "NextStep"
 CASE
       $ostype = 56
       $ostype = "PalmPilot"
 CASE
       $ostype = 57
       $ostype = "Rhapsody"
 ENDSELECT

 ? "OSType is = "$OSType

 FUNCTION OSQuery($what,$where)
 DIM $strquery, $objenumerator, $value
 $strquery = "Select $what From $where"
 $systemset = GetObject("winmgmts:{impersonationLevel=impersonate}!//@WKSTA")
 $objenumerator = $systemset.execquery($strquery)
 For Each $objinstance in $objenumerator
 IF @error = 0 AND $objinstance <> ""
       $=execute("$$value = $$objInstance.$what")
       $osquery="$value"+"|"+"$OSQuery"
 ENDIF
 Next
 $osquery=left($osquery,len($osquery)-1)
 EXIT @error
 ENDFUNCTION


 
 [ 28. October 2003, 16:44: Message edited by: kdyer ]83940OSVer2980Glenn BarnasOSVer() - Returns local or remote O/S Version0Another UDF used by tools that deploy against remote systems..

Pretty straight-forward:
 

code:

 
$OSV = OSVer()        ; Returns local OS version (@DOS)
$OSV = OSVer($Target) ; Returns OS version from $Target
 

This is most useful when $Target is defined to Null be default, and changed to a remote target during processing. This way, calling it as
$OSV = OSVer($Target)
will provide local or remote values depending on whether $Target is defined.

Glenn


;;
;;======================================================================
;;
;;FUNCTIONÿ ÿ ÿ ÿOSver([server])
;;
;;ACTIONÿ ÿ ÿ ÿ ÿReturnsÿtheÿO/Sÿversionÿfromÿtheÿlocalÿorÿremoteÿserver
;;
;;AUTHORÿ ÿ ÿ ÿ ÿGlennÿBarnasÿ/ÿFRIT-EROC
;;
;;SYNTAXÿ ÿ ÿ ÿ ÿOSver(["\\server"])
;;
;;PARAMETERSÿ ÿ ÿServerÿ-ÿNameÿofÿserverÿtoÿquery.ÿReturnsÿlocalÿsystem
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ versionÿifÿnull.
;;
;;REMARKSÿ ÿ ÿ ÿ Basicÿoutputÿforÿoptionalÿloggingÿofÿscreenÿstatusÿmessages
;;
;;RETURNSÿ ÿ ÿ ÿ Versionÿvalueÿfromÿtargetÿserver
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿSetsÿ@ERRORÿwhenÿqueryingÿremoteÿserver
;;
;;DEPENDENCIESÿ ÿnone
;;
;;TESTEDÿWITHÿ ÿ NT4,ÿW2K,ÿWXP
;;
;;EXAMPLESÿ ÿ ÿ ÿ$Verÿ=ÿOSVer()ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ;ÿreturnsÿlocalÿOSÿVersion
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ$Verÿ=ÿOSVer("\\that_server")ÿ;ÿreturnsÿOSÿVersionÿfromÿ"That_Server"
;
FunctionÿOSVer(Optionalÿ$Server)

ÿ Ifÿ$Serverÿ=ÿ""
ÿ ÿ $OSVerÿ=ÿ@DOS
ÿ ÿ Exitÿ0
ÿ Else
ÿ ÿ ;ÿinsureÿthatÿ"$Server"ÿhasÿtheÿrightÿformat
ÿ ÿ IfÿLeft($Server,2)ÿ<>ÿ"\\"ÿ$Serverÿ=ÿ"\\"ÿ+ÿ$ServerÿEndIf
ÿ ÿ IfÿRight($Server,1)ÿ<>ÿ"\"ÿ$Serverÿ=ÿ$Serverÿ+ÿ"\"ÿEndIf
ÿ ÿ ;ÿgetÿtheÿOSÿvalueÿfromÿtheÿremoteÿserver
ÿ ÿ $OSVerÿ=ÿReadValue($Serverÿ+ÿ"HKEY_Local_Machine\SOFTWARE\Microsoft\WindowsÿNT\CurrentVersion",ÿ"CurrentVersion")
ÿ ÿ Exitÿ@ERROR
ÿ EndIf
ÿ 
EndFunction


 
 [ 26. March 2003, 20:46: Message edited by: Glenn Barnas ]83255PadStr172Howard BullockPadStr() - Left or Right pad a string0

code:

;FUNCTION         PadStr($Input,$Pad,$Length[,L|R])
;
;AUTHOR           Howard A. Bullock (hbullock@comcast.net)
;
;ACTION           Left or Right pad a string.
;
;SYNTAX           PadStr($Input,$Pad,$Length [,L|R])
;
;PARAMETERS       $Input (Required) -  String value
;                 $Pad (Required) -  String value
;                 $Length (Required) - Integer (Max length of padded string)
;                 $PadSide (Optional) - String [L|R] Default is "L"
;
;REMARKS          The $Pad can be one or more characters. If the Padding exceeds
;                 the specified maximum length then the resulting string is trimmed
;                 preserving the original data.
;
;RETURNS          String
;
;DEPENDENCIES     KiXtart 4.02
;
;EXAMPLES         PadStr("401","0",8) result "00000401"
;                 PadStr("401","0",8,"R") result "40100000"
;
Function PadStr($Input, $Pad, $Length, optional $PadSide)
   Dim $i, $x
   $PadStr = ""
   $Input = "" + $Input
   $Pad = "" + $Pad
   $Length = 0 + $Length
   If $PadSide="" or Len($PadSide)>1 or Instr("LR",$PadSide)= 0
      $PadSide = "L"
   Endif

   $x = Len($Input)

   For $i=$x to $Length - 1 Step Len($Pad)
      If $PadSide = "L"
         $Input = $Pad + $Input
      Else
         $Input = $Input + $Pad
      Endif
   Next
   If $PadSide = "L"
      $Input = Right($Input, $Length)
   Else
      $Input = Left($Input, $Length)
   Endif
   $PadStr = $Input
   Exit 0
Endfunction


 
 [ 05. November 2002, 19:14: Message edited by: Howard Bullock ]166534PasteFromClipboard5694WittoPasteFromClipboard() Paste string from Clipboard0

;ACTION 	Paste string from Clipboard  

;  

;AUTHOR 	Wim Rotty  

;  

;CONTRIBUTORS 	  

;  

;VERSION	1.0.0.0  

;  

;DATE CREATED 	2006-08-29  

;  

;DATE MODIFIED   

;  

;KIXTART 	Tested with Kixtart version 4.53 Release Candidate 1  

;  

;SYNTAX 	PasteFromClipboard() 

;  

;PARAMETERS   

;  

;RETURNS	String. Returns the data from the clipboard.  

;  

;REMARKS 	  

;  

;DEPENDENCIES 	I presume Internet Explorer has to be at least version 5  

; 		  

;EXAMPLE 	  

;		 

;	$SO = CopyToClipboard("This text has been copied to the clipboard.") 

;	; CopyToClipboard() see  

;	; http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=166778&an=0&page=0#166778 

;	 

;	Run( "Notepad.exe" ) 

;	Sleep 1 

;	;If SetFocus ("Untitled - Notepad") = 0 ;English 

;	If SetFocus( "Naamloos - Kladblok" ) = 0 ;Dutch 

;		? "Focus set to Notepad...." 

;	EndIf 

;	 

;	$SO = SendKeys(PasteFromClipboard()) 

;	 

;	Sleep( 2 ) 

;	 

;	;$SO = SendKeys("~{F4}Y") ;English 

;	$SO = SendKeys("~{F4}J") ;Dutch 

;  

;KIXTART BBS 	  

; 		  

;  



Function PasteFromClipboard()

	Dim $objIE

	$objIE = CreateObject("InternetExplorer.Application")

	$objIE.Navigate("about:blank")

	$PasteFromClipboard = $objIE.document.parentwindow.clipboardData.GetData("Text")

	$objIE.Quit

	Exit @ERROR

EndFunction
108409PathMod92j95661PathMod() Modify System Variable1069296592All right guys be gentle, this is my first UDF post.  



WonderBoy



 Code:

 

;	Modifies the System Enviornment Variable

;	This replaces a specific value with another Value.

;

;Name : 		PathMod

;Author:		WonderBoy

;Action:		Modifies the System Enviornment Variable

;Date:			11/19/03

;syntax:		PathMod($CValue,$RValue)

;Parameters:		$CValue = path that you want to remove

;			$RValue = path that you want to substitue

;

;EXAMPLE(s):   	$CValue = "c:\program files\Adobe"

;		    	$RValue = "c:\Adobe"         

;               		$RC = PathMod($CValue, $RValue)

;              		 Returns:

;				0  Value was found and path changed

;				1  failed to write registry value

;				2  $CValue was not passed or empty

;				3  $RValue was not passed or empty

;

Function PathMod($CValue, $RValue)

	Dim $Array, $aCntr, $KeyVal2, $fCntr, $stat, $KeyLoc, $Keynam

	$aCntr 	= 0

	$fCntr 	= 0

	$stat  	= "FALSE"

	$KeyLoc 	= "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment"

	$keyNam 	= "Path"

	

	If $CValue = "" OR $RValue = ""

		Select

			Case	$CValue  = "" 

				$Pathmod = 2

			Case $RValue  = "" 

				$Pathmod = 3

		EndSelect

		Return

	EndIf

	

	$KeyVal 	= ReadValue ($KeyLoc, $KeyNam)

	$Array    = Split($KeyVal,";",-1)

	For Each $Element In $Array

		If $Element = $CValue

		  	$Array[$acntr] = $RValue

		  	$stat = "TRUE"

		EndIf

		$acntr = $acntr + 1

	Next

	For Each $Element In $Array

	  If $fCntr   = 0

	  	$KeyVal2 = $element

	  	$fcntr   = 1

	  Else

	  	$keyVal2 = $KeyVal2 +";"+ $Element

	  	$fcntr   = $fcntr + 1

	  EndIf

	Next

	If $Stat = "TRUE"

		$RC = WriteValue($Keyloc,$KeyNam,$KeyVal2,"REG_SZ")

		If $RC = 0

			$PathMod = 0

			Return

		Else

		   	$Pathmod = 1

		   	Return

		EndIf

	EndIf

EndFunction

 

    

83955PathSplit2980Glenn BarnasPathSplit() - returns Server, Share/Drive, Path, File info0This UDF splits an argument of the form 
\\server\share\path1\path2\file.ext 
or
d:\path1\path2\file.ext
into a 4-element array.

The first element will contain the server name if a UNC path was supplied.
 
Element 2 will contain the Share Name if a UNC path was the source, a Drive Letter if it was specified in a local path, or null if neither was provided.
 
The third element will contain the Path component. One thing to consider: The UDF can't distinguish between 'c:\temp\xyzzy' as a file and 'c:\temp\xyzzy' as a directory. It follows the following rules to decide if the last component is a file or directory:
 

If the specified path ends with '\', the UDF treats the last component as a part of the PATH.

If the last component contains a '.', it is  deemed to be a FILE.

If the last component does not contain a '.', it is deemed to be part of the PATH.
Element four will contain the filename if it was specified. 
 
Individual directories in the path can easily be obtained with split($ary[2], '\')
 

;;
;;ACTIONÿ ÿ ÿ ÿ ÿReturnsÿaÿ4ÿelementÿarrayÿwithÿServer,ÿShare,ÿPath,ÿandÿFile
;;
;;AUTHORÿ ÿ ÿ ÿ ÿGlennÿBarnasÿ/ÿFRIT-EROC;ÿConradÿWheelerÿ(RADIMUS)
;;
;;SYNTAXÿ ÿ ÿ ÿ ÿPathSplit("path")
;;
;;PARAMETERSÿ ÿ ÿPathÿ-ÿDirectoryÿpathÿtoÿcreate.
;;
;;REMARKSÿ ÿ ÿ ÿ Pathÿcanÿbeÿrelativeÿ(a\b\c)ÿorÿrootedÿ(\a\b\c),ÿandÿ
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿeitherÿtypeÿcanÿspecifyÿeitherÿaÿdriveÿ(D:)ÿorÿ
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿUNCÿnameÿ(\\server\share)
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿIfÿsplittingÿaÿDirectoryPath,ÿtheÿfunctionÿattemptsÿto
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿvalidateÿtheÿpathÿtoÿdetermineÿifÿtheÿlastÿelementÿisÿaÿ
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿfileÿorÿdirectory.ÿIfÿtheÿparameterÿendsÿwithÿaÿ"\",ÿit
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿisÿassumedÿtoÿbeÿaÿdirectory.ÿIfÿtheÿparameterÿisÿambiguous,
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿtheÿfunctionÿwillÿreturnÿitÿasÿaÿPATHÿifÿitÿdoesÿnotÿcontain
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿaÿ"."ÿandÿasÿaÿFILEÿifÿitÿdoes.
;;
;;RETURNSÿ ÿ ÿ ÿ 4-elementÿarrayÿcontainingÿinfoÿaboutÿaÿfile/path:
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿElementÿ0ÿ=ÿ\\Serverÿnameÿ(ifÿspecified)
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿElementÿ1ÿ=ÿ\ShareÿnameÿORÿDriveÿLetterÿ(ifÿspecified)
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿElementÿ2ÿ=ÿ\path\
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿElementÿ3ÿ=ÿfilenameÿ
;;
;;DEPENDENCIESÿ ÿnone
;;
;;TESTEDÿWITHÿ ÿ NT4,ÿW2K,ÿWXP
;;
;;EXAMPLESÿ ÿ ÿ ÿPathSplit("C:\Temp\install\")ÿ ÿ ÿ ÿ ÿ ÿ;ÿReturnsÿ"","C:","\Temp\","install"
;;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿPathSplit("\\server\c$\Temp\install\")ÿ ;ÿReturnsÿ"\\server","C$","\Temp\","install"
;
FunctionÿPathSplit($Path)

ÿ Dimÿ$Server,ÿ$Share,ÿ$Dir,ÿ$File,ÿ$Tag

ÿ $Server=''ÿ$Share=''ÿ$Dir=''ÿ$fFle=''ÿ$Tag=0

;ÿDetermineÿifÿweÿreceivedÿaÿFilePathÿorÿDirectoryPath
ÿ ;ÿaddÿaÿ"\"ÿifÿweÿhaveÿaÿDirectoryPath
ÿ IfÿExist($Path)ÿ
ÿ ÿ IfÿGetFileAttr($Path)ÿ&ÿ16
ÿ ÿ ÿ IfÿRight($Path,1)ÿ<>ÿ"\"
ÿ ÿ ÿ ÿ $Pathÿ=ÿ$Pathÿ+ÿ"\"
ÿ ÿ ÿ EndIf
ÿ ÿ EndIf
ÿ EndIf

ÿ $arrDir=Split($Path,'\')
ÿ $UBoundÿ=ÿUBound($arrDir)

ÿ ;ÿDefaultÿ-ÿlastÿelementÿisÿFILEÿunlessÿoverridden
ÿ $Fileÿ=ÿ$arrDir[$UBound]


ÿ Select

ÿ ;ÿsingleÿelement,ÿnoÿ".",ÿassumeÿDIRECTORY
ÿ Caseÿ$UBound=0ÿAndÿNotÿInStr($Path,'.')
ÿ ÿ $Dirÿ=ÿ$Path
ÿ ÿ $Fileÿ=ÿ""

ÿ ;ÿsingleÿelement,ÿcontainsÿaÿ":",ÿassumeÿDRIVE
ÿ Caseÿ$UBoundÿ=ÿ0ÿAndÿInStr($arrdir[0],":")
ÿ ÿ $Shareÿ=ÿLeft($arrDir[0],2)
ÿ ÿ $Fileÿ=ÿRight($arrDir[0],Len($arrDir[0])ÿ-ÿ2)

ÿ ;ÿsingleÿelement,ÿcontainsÿaÿ".",ÿassumeÿFILE
ÿ Caseÿ$UBoundÿ=ÿ0ÿAndÿInStr($Path,'.')
ÿ ÿ $Fileÿ=ÿ$Path

ÿ ;ÿmultipleÿelements,ÿfirstÿelementÿcontainsÿ":",ÿDRIVE
ÿ CaseÿInstr($arrDir[0],':')
ÿ ÿ $Shareÿ=ÿSplit($arrDir[0],':')[0]ÿ+ÿ':'
ÿ ÿ $Dirÿ=ÿSplit($arrDir[0],':')[1]ÿ+ÿ'\'
ÿ ÿ $File=$arrDir[$UBound]
ÿ ÿ $Tagÿ=ÿ1

ÿ ;ÿmultipleÿelements,ÿfirstÿtwoÿnull,ÿassumeÿ\\Server\Share
ÿ Caseÿ$arrDir[0]=''ÿAndÿ$arrDir[1]=''
ÿ ÿ $Serverÿ=ÿ'\\'ÿ+ÿ$arrDir[2]
ÿ ÿ $Shareÿ=ÿ'\'ÿ+ÿ$arrDir[3]
ÿ ÿ $Dirÿ=ÿ'\'
ÿ ÿ $Fileÿ=ÿ$arrDir[$ubound]
ÿ ÿ $Tagÿ=ÿ4

ÿ EndSelect

ÿ Forÿ$Loopÿ=ÿ$Tagÿtoÿ$UBoundÿ-ÿ1ÿ
ÿ ÿ $Dirÿ=ÿ$Dirÿ+ÿ$arrDir[$loop]ÿ+ÿ'\'
ÿ Next


ÿ $PathSplitÿ=ÿ$Server,ÿ$Share,ÿ$Dir,ÿ$File

endfunction


 
 [ 04. April 2003, 04:37: Message edited by: Glenn Barnas ]84358Pause3439AllenPause()0


;Function:
; Pause()
;
;Author:
; Allen Powell (Al_Po)
;
;Contributors
; Richard H.
;
;Version:
; 1.1
;
;Action:
; Pause the execution of a script for a specified period of time, or continue on the
; press of a key.
;
;Syntax:
; Pause(optional $delay, optional $prompt)
;
;Parameters:
; $Delay: (optional) 
; n seconds to delay
; If ommitted, pauses until key pressed
; $Prompt: (optional)
; Message to display
; If ommitted, displays "Press any key to continue"
; 
;Returns:
; Key pressed.
; -1 : If using delay, and no key pressed when timer expires
;
;Dependencies:
;
;
;Example:
; $=Pause()
; $=Pause(10)
; $=Pause(,"Press something!")
; $=Pause(10,"Press the 'AnyKey'")
;
;Source:

function pause(optional $delay, optional $prompt)
dim $loop, $counter, $interval
$pause=-1
if not $prompt
$prompt="Press any key to continue "
endif
? $prompt
if $delay>0 
$Interval=0.2
$delay=$delay+1
while $pause=-1 and $delay>1.0 + $interval
$delay=cdbl($delay)-$interval
$counter = "[" + fix($delay) + "]:"
$counter
sleep $interval
for $loop = 1 to len($counter)
chr(8) + " " + chr(8)
next
if kbhit()
get $pause
endif
loop
else
get $pause
endif
endfunction



1.0 Original
1.1 Modified Interval between loops to 0.2 secs from 1 secs.
 
 [ 17. June 2003, 18:44: Message edited by: Al_Po ]82512PBar11ShawnPBar() - Progress bar for DOS console0REQUEST FOR COMMENT

This is a "Draft" prototype function. Looking for feedback and suggestions ... 

PBar()

Action:

Progress bar for DOS console

Syntax:

PBar( Percent [, Message])

Parameters:

Percent (Required) Number - A number from 0 to 100 indicating the percent progress so far. Any number outside these bounds are set to 0 or 100 respectively.

Message (Optional) String - The message to display within the progress bar. The maximum string size is 38 chars,  anything over this amount is truncated.

Returns:

A good feeling to your users     

Remarks:

PBar clears the screen and sets the background color to blue. Stop Pbar at any time by simply clearing the screen (CLS)

Probably implement a function reset call eg, PBar(-1) that will reset the internals of the function.

Dependencies:

kixtart 4.0 (final)

Example(s):

break on

pbar(0,"Welcome @USERID") sleep 2
pbar(20,"Checking group memberships") sleep 3
pbar(40,"Mapping drives ...") sleep 2
pbar(60) sleep 2
pbar(62) sleep 1
pbar(64,"Mapping printers ...") sleep 2
pbar(66) sleep 1
pbar(68) sleep 2
pbar(70,"Assigning registry permissions ...") sleep 2
pbar(80,"Purging temporary internet cache ...") sleep 3
pbar(90,"Assigning RightFax Printer Port ...") sleep 1
pbar(100,"Complete !") sleep 2
cls

exit 1

Source:

function pbar($n,optional $s)
 dim $p,$l,$b,$pb
 $p="                                      "
 $b=""
 for $i=1 to 38
  $b=$b+chr(166)
 next
 if not $_pbar
  color w+/b
  cls
  color w+/n
  box(6,19,17,61," ")
  color w+/b+
  box(5,17,16,60,"single")
  box(12,19,14,58,"single")
  color w/n
  $_pbar=1
 endif
 if $s
  $l=len($s)
  if $l > 38
   $s=substr($s,1,38)
  endif
  color w+/b+
  at(8,20) $s+substr($p,1,len($p)-$l)
  color w/n
 endif
 if $n > 100
  $n=100
 else
  if $n < 0
   $n=0
  endif
 endif
 $n=($n*100)/250
 color y+/b+
 $pb=substr($b,1,$n)
 at(13,20) $pb+substr($p,1,len($p)-len($pb))
 at(0,0)
 color w/n
endfunction

Author:

-Shawn

[ 07 February 2002: Message edited by: Shawn ]

[ 11 February 2002: Message edited by: DrillSergeant ]82991pbar231Radimuspbar2() -  GUI Progress Bar0I found this cool little progress bar, that can be COM'ed into a logon script easily.

Progress Bar Component - JSProgBr.exe

 

code:

;*************************************************************************************************************************
;example	PBar(3, "mapping drives")

Function pbar($pos, optional $label, optional $show)

	if not $bar			$bar=createobject("JSProgBr.Bar")		endif
	if $label			$bar.caption = $label				endif
	if $show=1			$bar.show					endif
	if $show=-1			$bar.hide					endif
	for $loop=$barcnt to $pos	$bar.advance	$barcnt=$barcnt+1		next
	if $barcnt=>30			$bar.hide	$bar = nothing			endif
	EndFunction

[ 19 February 2002: Message edited by: Radimus ]
 
 [ 21. February 2003, 12:38: Message edited by: Radimus ]82996Pbar231RadimusPbar2() - Yet another Progress bar UDF0Another progress bar UDF using the WONDERFUL kixgui.dll

set the $max variable to the number of checkpoints in your script

Pass a position of 0 to initiallize the bar
Pass a position of <$max to increment the bar
Pass a position of >$max to close the bar

code:

break on
$=setconsole("hide")
$max=10		; set number of increments in progress bar
	
pbar2(0,"Logon Script processing")

for $loop = 1 to $max
	sleep 1
	pbar2($loop,"progress point $loop")
	next

pbar2($max+1,"Logon Script Complete")


; *********************************************************************************
Function pbar2($barpos, optional $display)
	if $barpos =0	; Initiallize the form and it's Properties ****************
		$root = createobject("KiXGUI.Desktop")
		$form = $root.createform("form","")
		$text = $form.addtextbox("text","",10,15,270,20,,1)
		$form.TitleBar	=0
		$form.width	=300
		$form.height	=80
		$form.left	=200
		$form.top	=200
		$form.topmost	=1
		$form.layered	=99
		$Progressbar=$form.Addprogressbar("progress",10,45,270,20)
		$Progressbar.ProgressBarStyle=2
		$Progressbar.maxprogress=$max
		$form.visible=1
		endif
	if $barpos>$max	;  fade away and clean up *********************************
		for $fade =99 to 0 step -1
			$form.layered	=$fade
			next
		$form.visible=0
		$root=0
		return
		endif
	if $barpos=>$Progressbar.currentprogress
		$Progressbar.currentprogress=$barpos
		endif
	if $display
		$text.caption=$display
		endif
	$form.visible=1
	endfunction


 
 [ 28. October 2002, 15:23: Message edited by: Radimus ]140233PDRIVERREMOVE79KdyerPDRIVERREMOVE() - Remove a print driver or all print drivers from systems0Code:


 ; FUNCTION PDRIVERREMOVE()
 ;
 ; ACTION Remove Printer Drivers from a system
 ;
 ; AUTHOR Kent Dyer (leptonator@hotmail.com)
 ;
 ; CONTRIBUTORS
 ;
 ; VERSION 1.1
 ;
 ; DATE CREATED 29-June-2004
 ;
 ; DATE MODIFIED 24-May-2005
 ;
 ; KIXTART 4.02
 ;
 ; SYNTAX PdriverRemove()
 ;
 ; PARAMETERS
 ; wksta
 ; Workstation Name
 ; pdriver
 ; Print Driver Name
 ;
 ; DEPENDENCIES None
 ;
 ; RETURNS: Nothing
 ;
 ; REMARKS This is to remove print drivers by Microsoft Tech Article - 135406.
 ;          http://support.microsoft.com/?id=135406
 ;          This can be run locally using a login script, only written for 2k/XP/2k3
 ;          If run using Login Script for example, you should remove the printers first
 ;          Since this goes into HKLM for the Registry, and %WINDIR%\SYSTEM32, you will need
 ;          appropriate priveleges. However, this can also be run as a remote Admin Script.
 ;
 ; EXAMPLEs
 ; PdriverRemove(,"HP LASERJET 4 PLUS") ; Remove HP LASERJET 4 PLUS from local Workstation
 ;             PdriverRemove() ; Remove all Print Drivers from the system
 ;
 ; REMOVE PRINT DRIVERS FROM COMPUTERS ON THE DOMAIN
 ; DIM $container,$computer,$
 ; ?'Checking Domain computers now...'
 ; $container=GetObject('WinNT://'+@ldomain)
 ; $container.filter='Computer', ''
 ; FOR EACH $computer IN $container
 ;    $computern=$computer.name
 ;    ?$computern
 ;    SHELL '%COMSPEC% /C PING -n 1 '+$computern
 ;    IF @error=0
 ;       PDRIVERREMOVE($srv)
 ;    ENDIF
 ; NEXT
 ; ?'PROCESS IS COMPLETE..  PRESS A KEY'
 ; GET $
; KIXTART BBS http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=139441

 FUNCTION PDRIVERREMOVE(OPTIONAL $wksta, OPTIONAL $pdriver)
    DIM $key,$keyname,$index,$fl,$rc,$drv
    IF NOT $wksta
       $wksta=@wksta
    ENDIF
    IF NOT $pdriver
       $pdriver=''
    ENDIF
    $key='\\'+$wksta+'\HKLM\SYSTEM\CurrentControlSet\Control\Print\Environments\Windows NT x86\Drivers\Version-3\'
    IF $pdriver<>''
       DO
          $keyname=ENUMKEY($key,$index)
          IF INSTR($keyname,$pdriver)
             $drv=READVALUE('\\'+$key+$keyname,'Data File')
             FOR EACH $fl IN SPLIT(READVALUE($srv+$keyname,'Dependent Files'),'|')
                IF EXIST($fl)
                   DEL '\\'+$wksta+'\admin$$\system32\spool\drivers\w32x86\3\'+$fl
                ENDIF
             NEXT
             $rc=DELTREE('\\'+$key+$keyname)
             ; -- AT THIS POINT, you should probably either restart the client or the PRINT SPOOLER
          ENDIF
          $index=$index+1
       UNTIL LEN($keyname)=0
    ELSE 
       ; -- DELETE ALL PRINT DRIVERS
       DO
          $keyname=ENUMKEY($key,$index)
          $drv=READVALUE('\\'+$key+$keyname,'Data File')
          FOR EACH $fl IN SPLIT(READVALUE($srv+$keyname,'Dependent Files'),'|')
             IF EXIST($fl)
                DEL '\\'+$wksta+'\admin$$\system32\spool\drivers\w32x86\3\'+$fl
             ENDIF
          NEXT
          $rc=DELTREE('\\'+$key+$keyname)
          ; -- AT THIS POINT, you should probably either restart the client or the PRINT SPOOLER
          $index=$index+1
       UNTIL LEN($keyname)=0
    ENDIF
 ENDFUNCTION

176025PhysicalMemoryInfo119LonkeroPhysicalMemoryInfo() - retrieves physical memory module info0

ÿCode:

;Function:
;        PhysicalMemoryInfo()
;
;Author:
;        Jooel
;
;Version:
;        1.0
;
;Version History:
;        1.0 - Mon, May 7, 2007 - original release
;
;Action:
;        Retrieves physical memory module info, local or remote.
;
;Syntax:
;        PhysicalMemoryInfo([COMPUTER])
;
;Parameters:
;        COMPUTER - Optional. Remote computer from which to gather the info
;
;Returns:
;        Array in which each element contains array of 6-elements:
;         0 - Physical Location
;         1 - Capacity, in Mb's
;         2 - Form Factor
;         3 - Memory Type
;         4 - Speed, MHz
;         5 - Data Width
;
;Remarks:
;        Couldn't find anything like it already published.
;        Should be quite usefull for inventory and stuff.
;
;Example:
;        "Memory info on local computer:" ?
;        "Location	Capacity	Speed" ?
;        For each $memModule in PhysicalMemoryInfo()
;         $memModule[0] chr(9) chr(9) $memModule[1] chr(9) chr(9) $memModule[4] ?
;        Next
;        ? "Done."
;        get $
;
;Source:
Function PhysicalMemoryInfo(optional $sComp)
dim $fF,$mT,$oWMI,$oM,$tMem[0]

 if not $sComp
  $sComp = "."
 endif
 $fF="Unknown","Other","SIP","DIP","ZIP","SOJ","Proprietary","SIMM","DIMM","TSOP","PGA",
  "RIMM","SODIMM","SRIMM","SMD","SSMP","QFP","TQFP","SOIC","LCC","PLCC","BGA","FPBGA","LGA"
 $mT="Unknown","Other","DRAM","Synchronous DRAM","Cache DRAM","EDO","EDRAM","VRAM","SRAM",
  "RAM","ROM","Flash","EEPROM","FEPROM","EPROM","CDRAM","3DRAM","SDRAM","SGRAM","RDRAM","DDR"

 $oWMI = GetObject("winmgmts:\\" + $sComp + "\root\cimv2")
 if @error exit @error endif
 For each $oM in $oWMI.ExecQuery("Select * from Win32_PhysicalMemory",,48)
  $tMem[ubound($tMem)]=$oM.DeviceLocator,1 * $oM.Capacity / 1048576,
  $fF[$oM.FormFactor], $mT[$oM.MemoryType], $oM.Speed,$oM.DataWidth
  redim preserve $tMem[ubound($tMem)+1]
 Next
 if 0<ubound($tMem)
  redim preserve $tMem[ubound($tMem)-1]
 endif
 $PhysicalMemoryInfo=$tMem
EndFunction
173516Pin11ShawnPin() - Pins an item to the Start Menu0Developed this function to pin an item (filename) to the start menu. Went searching for UDF's like it - its sort of a specific instance of Jooel's FileAction UDF ...

;    Pin() - Pins an item to the Start Menu
;
;    Based on English language verbs - may have to be modified for your region.
; 
;Author: 
;    Shawn Tassie
; 
;Version: 
;    1.0
; 
;Action: 
;    Pins an item to the Start Menu
; 
;Syntax: 
;    Pin($folder, $item)
; 
;Parameters: 
;    $folder (required): the folder where the item exists
;    $item (required): the item (usually a filename)
;                       
;Returns: 
;        Nothing. Check @ERROR for return status
; 
;Example: 
; Pin("%systemroot%\system32", "calc.exe")
;
;Source: 

Code:

Function Pin($folder, $item)

 Dim $oShell, $oFolder, $oItem

 $oShell = CreateObject("Shell.Application")

 If @ERROR = 0

  $oFolder = $oShell.Namespace($folder)

  If @ERROR = 0

   $oItem = $oFolder.ParseName($item)

   If @ERROR = 0

    $oItem.InvokeVerb("P&in to Start Menu")

   Endif

  Endif

 Endif

 Exit @ERROR

EndFunction


82068Ping29JochenPing() - checks for reply , or returns ip-address of remote host0 Code:

;FUNCTION         Ping()
;
;AUTHOR           Jochen Polster (jochenDOTpolsterATgmxDOTnet)
;
;VERSION HISTORY  1.0 - 11/24/2001 Initial Release
;                 1.1 - 11/11/2004 Fixed problems regarding spaces in folder names
;                                  of script directory (thanks to Alistair)
;                 1.2 - 12/07/2004 Fixed for NoVarsInStrings and Explicit on
;
;ACTION           Pings the Computer specified, or returns its ip address (Wins Resolved)
;
;SYNTAX           Ping(Computer,GetIP,[LoopCount],[Timeout])
;
;PARAMETERS       Computer (Required)
;                  -  String value representing the Computer to ping
;
;                 GetIp (Required)
;                  -  If specified (1), the function will return the ip-address
;                     of specified Computer rather than pinging it ...
;                     Has to be 0 if you want to check for reply !
;
;                 LoopCount (Optional but useful !)
;                  -  Integer value representing the number of times
;                     the Computer shall be pinged
;
;                 Timeout (Optional)
;                  -  if ommited the Computer gets pinged with the default
;                     timeout (1s) and default retries (4)
;
;REMARKS          If there is a reply the function will return immediately with 1
;                 so it could be faster not specifiying a timeout.
;
;RETURNS          0 - No reply
;                 1 - Ping reply
;                 Optional - ip address of specified Computer
;
;DEPENDENCIES     None
;
;EXAMPLES         call "path\Ping.udf"
;                 if Ping("www.microsoft.com",0,12,5000) ;pings for max. 60 seconds
;                 	run "%ComSpec% /c start www.microsoft.com"
;                 else
;                 	'Site isn't available ' ?
;                 endif
;                 if Ping("www.microsoft.com",0,15) ;pings also for max. 60 seconds
;                 	run "%ComSpec% /c start www.microsoft.com"
;                 else
;                 	'Site isn't available ' ?
;                 endif
;                 $ip = Ping("www.microsoft.com",1)
;                 $ip ?

function Ping($Computer,$GetIP,optional $LoopCount,optional $TimeOut)
	if $GetIP
		dim $ip, $ipfile, $
		$ipfile = @scriptdir + '\ip.txt'
		shell '%Comspec% /q /e:1024 /c for /F "tokens=2 delims=[]" %%i IN ('+ chr(39)
		+ '"ping ' + $Computer + ' -n 1 | find "]""' + chr(39) + ') do echo %%i >"' + $ipfile + '"'
		$ = open(10,$ipfile,2) $ip = readline(10) $ = close(10) del $ipfile
		if $ip
			$Ping = $ip
		else
			$Ping = 'Bad IP address ' + $Computer + '!'
		endif
		exit 0
	else
		if $TimeOut
			for $c = 0 to $LoopCount
				shell '%Comspec% /C ping ' + $Computer + ' -n 1 -w ' + $TimeOut + ' | find /C "TTL=" > nul'
				if @error = 0
					$Ping = 1
					exit 0
				endif
			next
		else
			for $c = 0 to $LoopCount
				shell '%Comspec% /C ping ' + $Computer + ' | find /C "TTL=" > nul'
				if @error = 0
					$Ping = 1
					exit 0
				endif
			next
		endif
		$Ping = 0
	endif
endfunction

 184897PingResponse119LonkeroPingResponse() - Translate ping responsecode to text0

;Function:
;        PingResponse()
;
;Author:
;        Jooel
;
;Version:
;        1.0
;
;Version History:
;        1.0 - Dec 11, 2006 - original release
;
;Action:
;        Converts response code from ping to text.
;        To get the code, you need to use ping udf like WMIPing() v1.1
;
;Syntax:
;        PingResponse(RESPONSECODE)
;
;Parameters:
;        RESPONSECODE - the code to translate
;
;Returns:
;         response code translated to string description
;
;Remarks:
;        Had to rework the original wmiping() to get to this stuff
;         but imo, it's worth knowing what the response really is.
;
;Example:
;        "response of pinging just something: "
;        $=WMIPing("169.168.0.24")
;        PingResponse(@error)
;        get $
;
;Source:
function pingResponse($code)
dim $ICMP_Code[20],$ICMP_Text[20]
 $ICMP_Code[0]=11001 $ICMP_Text[0]='Buffer Too Small'
 $ICMP_Code[1]=11002 $ICMP_Text[1]='Destination Net Unreachable'
 $ICMP_Code[2]=11003 $ICMP_Text[2]='Destination Host Unreachable'
 $ICMP_Code[3]=11004 $ICMP_Text[3]='Destination Protocol Unreachable'
 $ICMP_Code[4]=11005 $ICMP_Text[4]='Destination Port Unreachable'
 $ICMP_Code[5]=11006 $ICMP_Text[5]='No Resources'
 $ICMP_Code[6]=11007 $ICMP_Text[6]='Bad Option'
 $ICMP_Code[7]=11008 $ICMP_Text[7]='Hardware Error'
 $ICMP_Code[8]=11009 $ICMP_Text[8]='Packet Too Big'
 $ICMP_Code[9]=11010 $ICMP_Text[9]='Request Timed Out'
 $ICMP_Code[10]=11011 $ICMP_Text[10]='Bad Request'
 $ICMP_Code[11]=11012 $ICMP_Text[11]='Bad Route'
 $ICMP_Code[12]=11013 $ICMP_Text[12]='TimeToLive Expired Transit'
 $ICMP_Code[13]=11014 $ICMP_Text[13]='TimeToLive Expired Reassembly'
 $ICMP_Code[14]=11015 $ICMP_Text[14]='Parameter Problem'
 $ICMP_Code[15]=11016 $ICMP_Text[15]='Source Quench'
 $ICMP_Code[16]=11017 $ICMP_Text[16]='Option Too Big'
 $ICMP_Code[17]=11018 $ICMP_Text[17]='Bad Destination'
 $ICMP_Code[18]=11032 $ICMP_Text[18]='Negotiating IPSEC'
 $ICMP_Code[19]=11050 $ICMP_Text[19]='General Failure'
 $ICMP_Code[20]=0 $ICMP_Text[20]='Success'
 $pingResponse=$ICMP_text[ascan($ICMP_Code,$code)]
endfunction
82035Pipe11ShawnPipe() - Submits a shell command and redirects output to an array0Pipe()

Action:

Submits shell command and redirects output to an internal KiXtart array

Syntax: 

pipe("command")

Parameters:

command : A DOS Shell command

Returns:

An array containing the text output of the shell command.

@ERROR is set to the return value of the SHELL command (winnt).

Remarks:

On WinNT, stderr is redirected to the NUL device (discarded)

Function uses File Handle #10 - please change if conflict arises

Function creates a temporary file in %TEMP% called PIPE.TMP - deleted after use.

Empty (null) lines are skipped (not included) in the output array

Piping between processes (in the command string) is supported

Do not specify redirection of output in command string

Implemented incredible performance enhancement recommended by member AHayes (AJH) [2001-12-11]

Dependencies:

KiXtart 4.0

Example(s):


$array = pipe("net users") ; load all users into an array

$array = pipe("dir c:\*.ini /s /b") ; load a listing of all ini files into an array

$array = pipe("type config.txt") ; load the contents of a text file into an array

$ipconfig = pipe('ipconfig /all | find "Server"')
for each $line in $ipconfig
 ? $line
next


Source:


function pipe($command)
 dim $i,$error,$line
 dim $array[255]
 dim $redim $redim = ubound($array)
 dim $tempfile $tempfile = "%temp%\pipe.tmp"
 if exist("$tempfile")
  del("$tempfile")
 endif
 if @inwin = 2 ; win9x
  shell '%comspec% /c $command >"$tempfile"'
 else ; winnt
  shell '%comspec% /c $command >"$tempfile" 2>nul'
 endif
 $error=@error
 if open(10,"$tempfile") = 0
  $i=0
  $line = readline(10)
  while not @error
   if $line
    $array[$i] = $line
    if $i = $redim
     $redim=$redim*2
     redim preserve $array[$redim]
    endif
    $i=$i+1
   endif
   $line = readline(10)
  loop
  $=close(10)
  del "$tempfile"
  if $i > 0
   redim preserve $array[$i-1]
   $pipe=$array
  else
   $pipe = 0
  endif
  exit $error
 else
  $pipe = 0
  exit @error
 endif
endfunction


Author(s): 

Shawn Tassie 
with:
Les Ligetfalvy
Bryce Lindsay
AHayes (AJH)
 
 [ 22. February 2003, 01:04: Message edited by: Shawn ]82835Pipe21**DONOTDELETE**Pipe2() - Submit a shell command and redirect output to an array0;FUNCTION     Pipe2()
;
;AUTHOR       AJH
;             Based on Pipe() by Shawn with krabourn's SPLIT modification
;             (as I can't find the QPIPE UDF mentioned in the original topic)
;
;ACTION       Submits a Shell command and pipes output to an array
;
;SYNTAX       $array = Pipe("command")
;
;PARAMETERS   A DOS shell command
;
;RETURNS      An array containing the text output of the shell command.
;             @ERROR is set to the return value of the SHELL command (winnt).
;
;REQUIRES     Kixtart 4.00 (final) release or above
;
;REMARKS   1) This seems faster than Shawn's Pipe() for text output up to about 500 Kb
;             If the text output doubles in size Shawn's Pipe() takes twice as long,
;             where this Pipe() takes 4 times as long!
;
;          2) This Pipe() is very particular about the line terminator. It MUST BE @CRLF
;             (Shawn's Pipe() uses READLINE which is more forgiving on terminators).
;             It could of course be modified or passed in as a parameter.
;
;EXAMPLES     $array = pipe("net users")          ; load all users into an array
;             $array = pipe("dir c:\*.ini /s /b") ; load a listing of all ini files into an array
;             $array = pipe("type config.txt")    ; load the contents of a text file into an array
;
;             $ipconfig = pipe('ipconfig /all | find "Server"')
;             for each $line in $ipconfig
;               ? $line
;             next
;SOURCE
;

code:

FUNCTION pipe($command)
 DIM $error, $tempfile
 DIM $FSO, $oFile
 $tempfile = "%temp%\pipe.tmp"
 IF Exist($tempfile)  DEL $tempfile  ENDIF
 IF @inwin = 2 ; win9x
   SHELL '%comspec% /c '+$command+' >"'+$tempfile+'"'
 ELSE ; winnt
   SHELL '%comspec% /c '+$command+' >"'+$tempfile+'" 2>nul'
 ENDIF
 $error = @Error
 ;
 $pipe = ""
 $FSO = CreateObject("Scripting.FileSystemObject")
 IF @Error <> 0  EXIT @Error  ENDIF
 $oFile = $FSO.OpenTextFile($tempfile,1,0)
 IF @Error = 0
   $pipe = SPLIT($oFile.ReadAll,@CRLF)
   $oFile = 0
   $FSO = 0
 ENDIF
 ;
 DEL $tempfile
 EXIT $error
ENDFUNCTION


 
 [ 21. February 2003, 20:39: Message edited by: AJH ]129837PlayMediaFile52NTDOCPlayMediaFile() - Plays a media file, either audio or video using mplay32.exe1135722106Code:

 
;Function		PlayMediaFile() 
;Author		NTDOC
;Version		1.1 
;Date		2004/11/17
;Updated	         2005/12/28	
;Action		Plays a media file, either audio or video using mplay32.exe  
;				
;Example:		
;		Break On
;		Dim $SO
;		$SO=SetOption('Explicit','On')
;		$SO=SetOption('NoVarsInStrings','On')
;  
;		Dim $Play,$UserList
;		$UserList = Split("user1|user2|user3","|")
;		If AScan ($UserList, @USERID)>=0
;			$Play=PlayMediaFile(@LDrive+'weaklink.wav',0,0)
;		EndIf
;
;Parameters	PlayMediaFile($File,$Show,$Wait)
;		$FILE=Path and name of file to use
;		$Show sets whether or not to show the player 0=no 1=yes
;		$Wait says for the script to wait for the file to finish before closing 0=no 1=yes
;
;
;Dependencies	KiXtart 4.x
;		Minimum DLL version shell32.dll version 4.71 or later
;		Minimum operating systems Windows 2000, Windows NT 4.0 with Internet Explorer 4.0,Windows 98, Windows 95 with Internet Explorer 4.0
;			
;Notes		1. If files listed in the $MediaList are videos it will display the player even if you set it to no.
;		2. If another application has modified which application to use for playing a specified file type
;		   it will prompt the user to change the file type association.  If the user does not have Admin rights
;		   they will not be able to modify it.
;
;Source:  		
 
Function PlayMediaFile($File,$Show,$Wait)
	Dim $objShell,$MediaList,$RC
	If Exist($File)
		If $Show<>1 $Show=0 EndIf
		If $Wait<>1 $Wait=0 EndIf
		$MediaList = "wmv","asf","mpg","avi","mid"
		If AScan ($MediaList, Right(($File),3))>=0
			$Show=1
		EndIf
		$objShell=CreateObject('WScript.Shell')
		$RC=$objShell.Run('mplay32.exe /play /close ' + '"' + $File + '"',$Show,$Wait)
	EndIf
	$PlayMediaFile=@ERROR
	Exit  $PlayMediaFile
EndFunction

  82057PopupMenu11ShawnPopupMenu() - Windows-like PopUp Menu for DOS Console0PopupMenu()

Action:

Presents a windows-like popup menu (listbox style) and allows user to make a selection

Syntax:

PopupMenu("title",choices,x,y)

Parameters:

title : caption displayed in the menu title bar (string)

choices : array of strings representing the user's menu choices (array)

x : column position (left) of the popup window (number)

y : row position (top) of the popup window (number)

Returns:

Returns a string representing the user's selection

Returns a null string "" on error or if user presses ESC key

Remarks:

Debating if it would more usefull to return an integer representing the index
of the array element selected rather than the actual string itself?

My suggestion would be to clear the console (CLS) prior to displaying
the menu, and then again afterward.

Dependencies: KiXtart 4.0

Example(s):

$departments = "Marketing","Production","Sales","Human Resources","Warehouse"
$selection = PopupMenu("Select a department ?",$departments,25,5)
?"You selected $selection"

$numbers = 1,2,3,4,5,6,7,8,9,10
$selection = PopupMenu("Pick a number",$numbers,25,5)
?"You selected $selection"

Source:

code:


Function PopupMenu($prompt,$menu,$x,$y)
 dim $option,$n,$current,$previous,$key
 dim $height,$width
 $popupmenu = ""
 if vartypename($menu) <> "variant[]"
  return
 endif
 $height = ubound($menu)+2
 $width = len($prompt)
 for each $option in $menu
  if len($option) > $width
   $width = len($option)
  endif
 next
 $width = $width + 2
 color w+/b
 box($y,$x,$y+$height,$x+$width,"single")
 at($y,$x+1) substr($prompt,1,$width-2)
 $n=0
 $option=0
 for each $option in $menu
  at($y+$n+1,$x+1) $option 
  $n=$n+1
 next
 $current = 0
 $previous = $current
 color b/w+
 at($y+$current+1,$x+1) $menu[$current]
 at(0,0)
 color w/n
 do
  get $key
  if $key = CHR(224) ; Extended Key
   get $key
   if $key = CHR(80) ; Down Arrow
    $current=$current+1
    if $current = ubound($menu)+1
     $current=0
    endif
   endif
   if $key = CHR(72) ; Up Arrow
    $current = $current - 1
    if $current = -1
     $current = ubound($menu)
    endif
   endif
   if $current <> $previous
    color b/w+
    at($y+$current+1,$x+1) $menu[$current]
    color w+/b
    at($y+$previous+1,$x+1) $menu[$previous]
    at(0,0)
    color w/n
   endif
   $previous = $current
  endif
 until $key = CHR(13) or $key = CHR(27) ; CR,ESC ?
 if $key = CHR(13)
  $PopupMenu = $menu[$current]
 endif
EndFunction

Author(s): 

Shawn Tassie
shawn.tassie@cgi.ca

[ 24 November 2001: Message edited by: Shawn ]83306PriMapState119LonkeroPriMapState() - Checks for existent printerconnection0;FUNCTION	PriMapState 

; 

;AUTHOR		Lonkero (Jooel.Nieminen@gwspikval.com) 

; 

;ACTION		Checks for existent networkprinter connection 

; 

;VERSION	1.1.1 

; 

;CHANGES	1.1.1	- 01. november 2003 

;		 Fixed buggie descriped in: 

;		 http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=1;t=008079 

;		1.1	- 02. July 2002 

;		 added support for win9x 

;		1.0	- 01. July 2002 

;		 initial release 

; 

;SYNTAX		PriMapState(PRINTER) 

; 

;PARAMETERS	PRINTER 

;		 to be checked Printer's name 

; 

;RETURNS	1 if printer connected 

;		2 if printer is default 

;		nothing if not connected 

; 

;REMARKS	code for w9x adapted from BrianTX 

; 

;DEPENDENCIES	none 

; 

;EXAMPLE 

;		if not PriMapState('\\server\printer1') 

;		 "printer1 not connected!" 

;	        endif 

; 

;CODE 

function PriMapState($_Pri)

if @inwin=1

 if len(readvalue("HKCU\Software\Microsoft\Windows NT\CurrentVersion\Devices",$_Pri))

  if split(readvalue("HKCU\Software\Microsoft\Windows NT\CurrentVersion\Windows","Device"),",")[0]=$_Pri

   $PriMapState=2

  else

   $PriMapState=1

  endif

 endif

else

 dim $_Root,$_C,$_C2 $_Root="HKLM\System\CurrentControlSet\control\Print\Printers"

 for $_C=0 to 259

  $_C2=enumkey($_Root,$_C)

  If instr(READVALUE($_Root+"\"+$_C2,"Port"),$_Pri)

   If instr(READPROFILESTRING("%windir%\win.ini","windows","device"),$_Pri)

    $PriMapState = 2

   Else

    $PriMapState = 1

   Endif

  Endif

  if $_C2=259 $_C=$_C2 endif

 next

endif

endfunction 

 
 [ 01. November 2003, 04:56: Message edited by: Lonkero ]123018Print119LonkeroPrint() - prints file to GUI selected printer0 Code:


;FUNCTION	Print 
; 
;AUTHOR		Lonkero 
; 
;ACTION		Invokes Printer selection GUI and Prints the file to selected printer
; 
;VERSION	1.0 (15. july 2004)
;
;SYNTAX		Print(FILE) 
; 
;PARAMETERS 
;		FILE 
;		 - file to be printed 
; 
;RETURNS 
;		nothing. check @error for possible errors 
; 
;REMARKS	The filetype must support printing. 
;		as example, you can't print exe-files with this. 
; 
;DEPENDENCIES	Minimum operating systems: Windows 2000, Windows ME 
; 
;EXAMPLE 
;		Print('c:\kix420\kixtart.doc') 
;		if @error 
;		 "ERROR OCCURED:" @serror 
;		endif 
; 
;CODE 
function Print($_file)
 dim $,$_,$!
 $_=split($_file,"\")
 if ubound($_) $_file=$_[ubound($_)] endif
 $_[ubound($_)]=""
 $_=join($_)
 $=createobject("shell.application")
 $!=$.namespace($_).parsename($_file)
 $!.invokeverbex("print")
 exit @error
endfunction

  84400PrinterExist3439AllenPrinterExist() - Check for existence of a Printer0


;Function:
; PrinterExist()
;
;Author:
; Allen Powell (Al_Po)
;
;Version:
; 1.0
;
;Action:
; Determines if a printer exists based on the Printer Name on a local or Remote Computer. 
;
;Syntax:
; PrinterExist($PrinterName,optional $remotepc)
;
;Parameters:
; $PrinterName: (Required)
; Name of Printer
; $RemotePC: (Optional)
; Remote Computer. If omitted defaults to localpc.
; 
;Returns:
; 1 - Exist
; 0 - Does not exist
;
;Dependencies:
; WMI
;
;Examples:
;if not printerexist("Xerox DocumentCenter 555 PCL6")
; $=addprinter("192.168.1.1","Xerox DocumentCenter 555 PCL6","\\Server\PrinterDrivers\Xerox\dc555pcl\dc555x.inf")
;endif
;
;
;if printerexist("Lexmark Optra E on Server")
; ? 'installed'
;else
; ? 'not installed'
;endif 
;
;Comments:
; Addprinter() can be found here: http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000404
;
;Source:
;
Function PrinterExist($PrinterName,optional $remotepc)
dim $service,$printer,$printers
$printerexist=0
if $remotepc=""
$remotepc='\\'+ @wksta
else 
if not left($remotepc,2)="\\"
$remotepc='\\' + $remotepc
endif
endif
$Service=GetObject("winmgmts:{impersonationLevel=impersonate}!" + $remotepc +"\root\cimv2")
if not @error=0
exit @error
endif
$Printers=$service.execquery ('select * from Win32_Printer')
for each $printer in $printers
if ucase($printername)=ucase($printer.name)
$printerexist=1
endif
if left($printer.name,2)="\\"
if ucase($printername)=ucase(split(substr($printer.name,3),"\")[1] + " on " + split(substr($printer.name,3),"\")[0])
$printerexist=1
endif
endif
next
endfunction



6/5/2003 Modified a misnamed variable
 
 [ 05. July 2003, 18:31: Message edited by: Al_Po ]84385PrinterList3439AllenPrinterList() - Creates an Array/List of Printers1147235474Code:

;Function:  
;    PrinterList()  
;  
;Author:  
;    Allen Powell (Al_Po)  
;  
;Version:  
;    1.3.1  (2006/05/10 fixed error detecting Print Servers sharing IP Printers) 
; 
;Revisions 
;    1.3.0  (2005/10/21 added options to distinguish local or remote printers) 
;    1.2.0  (2005/07/19 optimized code) 
;    1.1.0  (2004/08/09 undimmed variable fix) 
;    1.0.0  (2003/06/26 Original) 
;  
;Action:  
;    Creates an array/list of Printers, and optionally their ports installed, on a local or remote computer.&n bsp;  
;  
;Syntax:  
;    Printerlist(optional $remotepc,optional $displaymode)  
;  
;Parameters:  
;       $RemotePC: (Optional)  
;             Remote Computer. If omitted defaults to localpc.  
;       $DisplayMode (Optional)  
;        0 - show all printers, don't display port info (Default)  
;        1 - show all printers, display port info  
;        2 - show local printers, don't display port info  
;        3 - show local printers, display port info  
;        4 - show remote printers, don't display port info  
;        5 - show remote printers, display port info  
;Returns:  
;     Array of Printers  
;  
;Dependencies:  
;     WMI  
;  
;Example:  
;  
;break on  
;$RC=Setoption("WrapAtEOL","on") 
; 
;$array=printerlist()  
;for each $printer in $array  
;  ? $printer  
;next  
;  
;Source:  
;  
Function PrinterList(optional $remotepc, optional $displaymode)
  dim $service,$printer,$printers,$printerdesc[0],$counter,$portname,$printername
  if $remotepc=""
    $remotepc="."
  endif
  $Service = GetObject("winmgmts:\\" + $remotepc + "\root\cimv2")
  if @error
    exit @error
  endif
  $Printers=$service.execquery ('select * from Win32_Printer')
  for each $printer in $printers
    redim preserve $printerdesc[$counter]
    if $displaymode & 1
      $portname = "," + $printer.portname
    endif
    select
      case $displaymode & 4 ;remote printers 
        if left($printer.portname,2)="\\" or left($printer.name,2)=="\\"
          $printername=$printer.name
        endif
      case $displaymode & 2 ;local printers 
        if left($printer.portname,2)<>"\\" and left($printer.name,2)<>"\\"
          $printername=$printer.name
        endif
      case 1 ; all printers 
        $printername=$printer.name
    endselect
    if $printername<>""
      $printerdesc[$counter]=$printername + $portname
      $counter=$counter + 1
      $printername=""
    endif   
  next
  $PrinterList=$printerdesc
endfunction

172044PrintOrViewImage52NTDOCPrintOrViewImage() - Print or View specified images0

;Function        PrintOrViewImage() 
; 
;Author          NTDOC 
; 
;Contributors    Google 
; 
;Action          Print or View specified images using the Windows Picture and Fax Viewer DLL 
; 
;Syntax          PrintOrViewImage($File,Optional $Printer,$Flag) 
; 
;Version         1.0 
; 
;Date            2006-Dec-26 
; 
;Date Revised    xxxx-xxx-xx 
; 
;Revision Reason 1.xx  
; 
;Parameters      $File		= Name of the file to view or print  
;				 (can specify a folder of images for view as well) 
; 
;                $Printer	= Name of the printer to print to (without the flag to print it will be ignored) 
; 
;                $Flag		= If set to 1, the UDF will print the specified image to the printer 
; 
;Remarks         You can not specify a folder for printing  
;		(you can use a For ... Next command though to print all images) 
;                              
;Returns	Returns an error code for the operation 
; 
;Dependencies	KiXtart 4.5x, shimgvw.dll 
; 
;KiXtart Ver	Written and tested with KiXtart v4.53 on XP/Server 2003 
; 
;Example	 
;		Dim $Print 
;		$Print = PrintOrViewImage("C:\Pictures\honda.png","Epson9660") 
;		"Print error: " + @ERROR + " - " + @SERROR ? 
; 
; 
;Source 
; 
;Function        PrintOrViewImage() 
; 
;Author          NTDOC 
; 
;Contributors    Google 
; 
;Action          Views or Prints specified images using the Windows Picture and Fax Viewer DLL 
; 
;Syntax          PrintOrViewImage($File,Optional $Printer,$Flag) 
; 
;Version         1.0 
; 
;Date            2006-Dec-26 
; 
;Date Revised    xxxx-xxx-xx 
; 
;Revision Reason 1.xx  
; 
;Parameters      $File       = Name of the file to view or print (can specify a folder of images for view as well) 
; 
;                $Printer    = Name of the printer to print to (without the flag to print it will be ignored) 
; 
;                $Flag  = If set to 1, the UDF will print the specified image to the printer 
; 
;Remarks         * You can not specify a folder for printing (you can use a For ... Next command though to print all images) 
;                              
;Returns         Returns an error code for the operation 
; 
;Dependencies    KiXtart 4.5x, shimgvw.dll 
; 
;KiXtart Ver     Written and tested with KiXtart v4.53 on XP/Server 2003 
; 
;Example 
;	Dim $Print 
;	$Print = PrintOrViewImage("C:\Pictures\honda.png","Epson 9660") 
;	'Print error: ' + @ERROR + ' - ' + @SERROR ? 
; 
;Source 
; 
Function PrintOrViewImage($File,Optional $Printer,$Flag)
  ;Declare var 
  Dim $Err
  ;Check if printer flag has been set 
  If $Flag
    ;If Flag has been set but no printer has been provided then set error and exit 
    If Not $Printer $Err = 1801 Exit $Err EndIf
    ;Shell out and run the Windows Picture and Fax Viewer DLL to print the image 
    Shell 'rundll32.exe %SystemRoot%\system32\shimgvw.dll,ImageView_PrintTo ' +'"'+$File+'"'+Chr(32)+'"'+$Printer+'"'
    ;Set the var to the error level 
    $Err = @ERROR
  Else
    ;The flag for printing was not set only open and view the image 
    Shell 'rundll32.exe %SystemRoot%\system32\shimgvw.dll,ImageView_Fullscreen ' + $File
    ;Set the var to the error level 
    $Err = @ERROR
  EndIf
  ;Exit the function with the error level 
  Exit $Err
EndFunction
 
83839PrintTo119LonkeroPrintTo() - Print any file to any printer0

;FUNCTION	PrintTo 

; 

;AUTHOR		Lonkero 

; 

;ACTION		Print a file to specified printer 

; 

;SYNTAX		PrintTo(FILE,PRINTER) 

; 

;PARAMETERS 

;		FILE 

;		 - file to be printed 

;		PRINTER 

;		 - Printer or printer-share where to print 

; 

;RETURNS 

;		nothing. check @error for possible errors 

; 

;REMARKS	The filetype must support printing. 

;		as example, you can't print exe-files with this. 

; 

;DEPENDENCIES	Minimum operating systems: Windows 2000, Windows ME 

; 

;EXAMPLE 

;		PrintTo('c:\kix420\kixtart.doc','\\server\printer1') 

;		if @error 

;		 "ERROR OCCURED:" @serror 

;		endif 

; 

;CODE 

function PrintTo($_file,$_printer)

 dim $,$_

 $_=split($_file,"\")

 if ubound($_) $_file=$_[ubound($_)] endif

 $_[ubound($_)]=""

 $_=join($_)

 $=createobject("shell.application")

 $.ShellExecute($_file, $_printer, $_, "printto", 0)

 exit @error

endfunction
 
 [ 07. October 2003, 21:28: Message edited by: Lonkero ]165403PrintTo21024MartPrintTo2() - Print any file to any printer1154634319This is the result of a discussion at: http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=165333&an=0&page=0&vc=1

Code:


;FUNCTION	PrintTo2()
;
;AUTHOR:		Jooel
;			I just posted it as a UDF.
;			See discussion at:
;			http://www.kixtart.org/ubbthreads/showflat.php?
;			Cat=0&Number=165333&an=0&page=0&vc=1
;
;ACTION:		Print a file to specified printer
;
;SYNTAX:		PrintTo(FILE,PRINTER)
; 
;PARAMETERS:	FILE
;			- file to be printed.
;			PRINTER
;			- Printer or printer-share where to print.
; 
;RETURNS:		Nothing. Check @error for possible errors.
; 
;REMARKS:		The filetype must support printing.
;			as example, you can't print exe-files with this. 
;			A printer of the same type should be installed
;			so Windows has got the drivers loaded.
; 
;DEPENDENCIES:	Tested on Win2K SP4, WinXP SP2 and Win2K3 SP1.
; 
;EXAMPLE:		PrintTo2('c:\kix420\kixtart.doc','\\server\printer1') 
;			if @error 
;				 "ERROR OCCURED:" @serror 
;			endif 
; 
;CODE: 
Function PrintTo2($_file,$_printer)
	Dim $
	$=CreateObject("shell.application")
	$.ShellExecute($_file, $_printer, "", "printto", 0)
	Exit @error
EndFunction

82995ProcCheck1**DONOTDELETE**ProcCheck() -  check for multiple Software install chains.0;Function proccheck()
;
;Author Bruce Musgrove UTSW Medical Center
;	Bruce.musgrove@utsouthwestern.edu
;	
;Checks to see if a specific process is running and loops if it is.
;
;Syntax function proccheck($PROC, optional $name, optional $final)
;
;Parameters	$proc = Name ofthe process you are checking for
		$Name = optional name for the process you want to display in status messages
		$Final = tells the system that this is the final process check and to clean up temp files. 
; 
;
;Remarks :  I use this for installing several programs that have to have multiple dependency 
;           programs installed. I use Shell or RUN to start the install then call the function
;	    to monitor the install Process thread. When the install process thread is finished,
;	    the function exits 	and the script starts the next install program. The final 
;	    install program passes the "yes" as the $final variable which tells the function 
;	    to clean up the temp files.  In this function, I also copy TLIST.EXE to the local 
;           computer simply to help speed it up
;		Idea was gleaned from similar posts here and adapted in an exercise to learn 
;             how to write and use UDF's. Feel free to rip it up, but rememeber I'm a newbie at this     
;
;
;
; 
;Dependencies: Tlist.exe from the NT4 Reskit
; 
;Example(s) 
;
;	? "Starting Sybase Install"
;		SHELL "\\\SYBASE\setup"
;		proccheck(_ins0432._mp, Sybase)
;	? "Completed Sybase install. Installing Sybase Software Patches"
;		shell "\\\SYBASE\swr8383\setup -s"
;		proccheck(_ins0432._mp, SybasePatch)
;	? "Completed sybase patch install. Installing OACIS"
;		shell "\\reposit\setupex"
;		proccheck(setupex.exe, Oacis)
;		proccheck(_ins0432._mp, Oacis, yes)
; 
;Source

function proccheck($PROC,$name, optional $final)
	dim $tempfile
	dim $program 
	Dim $command	
	$program = "%TEMP%\TLIST.EXE"
	$tempfile = "%temp%\PROClist.tmp"
	$command = $program + " " + $proc + " >" + $tempfile
	COPY "\\\RESKIT\TLIST.EXE" "%TEMP%"
	DO 
		? $PROC + "IS STILL RUNNING"
		SLEEP 10	
		shell "%comspec% /c $command"
		UNTIL GetFileSize("$TEMPFILE") = 0
	if $final = "yes"
		DEL "%temp%\tlist.exe"
		DEL $tempfile
		endif
ENDfunction
 
 [ 28. October 2002, 19:48: Message edited by: Radimus ]84683ProcessIdleTasks17SealeopardProcessIdleTasks() - Forces the processing of "idle tasks" under Windows XP0

;FUNCTION      ProcessIdleTasks 

; 

;ACTION        Forces the processing of "idle tasks" under Windows XP 

; 

;AUTHOR        Jens Meyer (sealeopard@usa.net) 

; 

;CONTRIBUTOR   none 

; 

;VERSION       1.0 (initial version) 

; 

;DATE CREATED  2003/10/22 

; 

;DATE MODIFIED 2003/10/22 

; 

;KIXTART       4.02 

; 

;SYNTAX        PROCESSIDLETASKS() 

; 

;PARAMETERS    none 

; 

;RETURNS       0 if successful, otherwise error code 

; 

;REMARKS       See http://www.microsoft.com/whdc/hwdev/platform/performance/benchmark.mspx 

;              for more info on idle task scheduling. 

;              The system might need about 10-15 minutes to process all "idle tasks". 

; 

;DEPENDENCIES  none 

; 

;EXAMPLE       $rc=processidletasks() 

;              ? 'Error '+@ERROR+' - '+@SERROR 

; 

;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000480 

; 

function ProcessIdleTasks()

  if @DOS='5.1'

    run 'Rundll32.exe advapi32.dll,ProcessIdleTasks'

    exit @ERROR

  else

    exit 1

  endif

endfunction
 
 [ 23. October 2003, 03:21: Message edited by: sealeopard ]144166ProcessorTime119LonkeroProcessorTime() - Returns ProcessorTime and calculates difference0Code:

FUNCTION 
;	ProcessorTime()
; 
;AUTHOR 
;	Lonkero
; 
;ACTION 
;	Returns Processor Time and optionally calculates spent time
; 
;VERSION 
;	1.0
; 
;VERSION HISTORY 
;	1.0 
;	22th july 2005
;	Initial public version.
; 
;SYNTAX 
;	ProcessorTime( [pid] , [machine] , [differ]) 
; 
;PARAMETERS 
;	PID - OPTIONAL
;		the Process who's processor time is to be retrieved.
;		Default is current process.
;	MACHINE - OPTIONAL
;		the machine, against which the query is to be performed.
;		Defaults to local
;	DIFFER - OPTIONAL
;		calculate the difference between current processor time and
;		the one given in arg.
; 
;RETURNS
;	ProcessorTime in seconds and the fragments
; 
;REMARKS 
;	well, was thinking about some way to write KiXflop() and came up with
;	this stuff :p
; 
;DEPENDENCIES 
;	none that I know of
;
;EXAMPLES
;	"current process processor time: "
;		$pt = ProcessorTime()
;		$pt ?
;	"current process processor time: " ProcessorTime(@pid,".",) ?
;	"processor time of 'processor time' query: " ProcessorTime(,,ProcessorTime(,,)) ?
;	"processor time spent on all these examples: " ProcessorTime(,,$pt) ?
;
;SOURCE
Function ProcessorTime(optional $pid, $machine, $differ)
 if vartype($pid) = 0 $pid = @pid endif
 if vartype($machine) = 0 $machine = "." endif
 For each $objItem in GetObject("winmgmts:\\" + $machine + "\root\cimv2").ExecQuery("Select * from Win32_Process where processID = " + $pid,,48)
  $processorTime = (0.0 + $objItem.KernelModeTime + $objItem.UserModeTime)/10000000
 Next
 if vartype($differ) $processorTime = $processorTime - $differ endif
EndFunction

82694ProcessRegINI17SealeopardProcessRegINI() - parse an initialization file and update registry accordingly0

code:

;FUNCTION      ProcessRegINI
;
;ACTION        parse an initialization file and update registry accordingly
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.1 (added error codes, removed IsInArray(), Warning(), Err()
;                   dependencies, changed return codes)
;              1.0
;
;DATE CREATED  2001/12/20
;
;DATE MODIFIED 2003/05/18
;
;KIXTART       4.12+
;
;SYNTAX        PROCESSREGINI(REGFILE)
;
;PARAMETERS    REGFILE
;              Required string containing INI file location
;
;RETURNS       1 if successful, 2 if registry changes require reboot, otherwise 0
;
;REMARKS       none
;
;DEPENDENCIES  ATRIM()          @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000031
;              ISINCLUDED()     @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000105
;              UPDATEREGISTRY() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000110
;
;EXAMPLE       $rc=processregini('registry.ini')
;
;              Format for .INI file:
;              [RegistryEntryNumber]
;              Kernel       = OS kernel version to which the registry setting should be applied
;                             (Win9x, WinNT, Win2K, WinXP, Win2K3)
;              GroupInclude = User groups to be included in the registry update (e.g. Domain Users, Domain Admins)
;              CompExclude  = Computers to be excluded from the registry update, overrides GroupInclude
;              UserInclude  = Users to be included in the registry update, overrides CompExclude
;              HKey         = Registry key (HKCU, HKLM, HKCR)
;              Subkey       = Registry subkey
;              Entry        = Registry entry
;              Value        = Registry value
;              Type         = Registry type (defaults to REG_SZ)
;              Reboot       = Reboot flag (defaults to 0, set to 1 if registry change requires reboot to become effective)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000112
;
function processregini($regini)
  Dim $rc, $registryupdates, $registryentry, $kernel
  Dim $hkey, $subkey, $entry, $value, $type, $rebootflag
  Dim $GroupInclude, $CompExclude, $UserInclude
  dim $os_short

  $os_short=@PRODUCTTYPE
  select
  case instr($kernel,'Windows Server 2003')
    $os_short='Win2K3'
  case instr($kernel,'Windows XP')
    $os_short='WinXP'
  case instr($kernel,'Windows 2000')
    $os_short='Win2K'
  case instr($kernel,'Windows NT')
    $os_short='WinNT'
  case instr($kernel,'Windows')
    $os_short='Win9x'
  case 1
    exit 10
  endselect

  select
  case $regini=''
    exit 87
  case not exist($regini)
    exit 2
  endselect

  $registryupdates=readprofilestring($regini,'','')
  $registryupdates=atrim(split($registryupdates,chr(10)))
  for each $registryentry in $registryupdates
    if $registryentry<>''
      $GroupInclude=readprofilestring($regini,$registryentry,'GroupInclude')
      $GroupInclude=atrim(split($GroupInclude,','))
      $CompExclude=readprofilestring($regini,$registryentry,'CompExclude')
      $CompExclude=atrim(split($CompExclude,','))
      $UserInclude=readprofilestring($regini,$registryentry,'UserInclude')
      $UserInclude=atrim(split($UserInclude,','))
      if isincluded($GroupInclude, $CompExclude, $UserInclude)
        $kernel=readprofilestring($regini,$registryentry,'Kernel')
        if $kernel<>''
          $kernel=atrim(split($kernel,','))
          if ascan($kernel,$os_short)+1
            $hkey=readprofilestring($regini,$registryentry,'HKey')
            select
            case $hkey='HKCR'
              $hkey='HKEY_CLASSES_ROOT'
            case $hkey='HKLM'
              $hkey='HKEY_LOCAL_MACHINE'
            case $hkey='HKCU'
              if @inwin=1
                $hkey='HKEY_USERS\'+@SID
              else
                $hkey='HKEY_CURRENT_USER'
              endif
            case $hkey='HKDU'
              $hkey='HKEY_USERS\.Default'
            case 1
              $hkey=''
            endselect
            if $hkey<>''
              $subkey=readprofilestring($regini,$registryentry,'Subkey')
              if $subkey<>''
                $subkey=$hkey+'\'+$subkey
                $entry=trim(readprofilestring($regini,$registryentry,'Entry'))
                $value=trim(readprofilestring($regini,$registryentry,'Value'))
                $type=trim(readprofilestring($regini,$registryentry,'Type'))
                $rebootflag=val(trim(readprofilestring($regini,$registryentry,'Reboot')))
                if $rebootflag<>1
                  $rebootflag=0
                endif
                $rc=updateregistry($subkey, $entry, $value, $type)
                if $rc and ($processregini=0 or $rebootflag)
                  $processregini = 1 + $rebootflag
                endif
              endif
            endif
          endif
        endif
      endif
    endif
  next
  exit @ERROR
endfunction


 
 [ 19. May 2003, 00:24: Message edited by: sealeopard ]82300Pulist11ShawnPulist() - Enumerate processes on local machine0This version currently enumerates only the local machine:



Pulist()



Action:



Enumerate processes on local machine (using pulist.exe or pv.exe)



Syntax:



Pulist()



Parameters:



none



Returns:



An array of strings representing all the running processes on the local machine. Returns 0 (zero) on error with @ERROR set to relevant error code.



Remarks:



Insure pulist.exe is resolvable through PATH.

Uses file handle #10. Change if conflicts arise.



If using pv.exe for all platforms, simply change the $program variable to "pv.exe"



Dependencies:



KiXtart 4.0 (final)



pulist.exe (NT Reskit for NT/2000/XP) [url= http://www.microsoft.com/windows2000/techinfo/reskit/tools/existing/pulist-o.asp"]Download Now[/url] 



or



pv.exe (Process Viewer for Windows 95/98/Me/NT/2000/XP) [url=http://www.xmlsp.com/pview/prcview.htm]Download Now[/url]



Example(s):

</font><blockquote><font size="1" face="Verdana, Helvetica, sans-serif">code:</font><hr /><pre style="font-size:x-small; font-family: monospace;">for each $process in pulist()

 ?"$process"

next

 

for each $process in pulist()

  if $process = "explorer.exe"

    ?"explorer is running..."

  endif

next

</blockquote><font size="2" face="Verdana, Helvetica, sans-serif">Source:

</font><blockquote><font size="1" face="Verdana, Helvetica, sans-serif">code:</font><hr /><pre style="font-size:x-small; font-family: monospace;">break on

 

function pulist()

 dim $program $program = "pulist.exe" ; change to "pv.exe"

 dim $array[256]

 dim $i $i = 0

 dim $tempfile $tempfile = "%temp%\pulist.tmp"

 if exist("$tempfile")

  del "$tempfile"

 endif

 shell '%comspec% /c $program >"$tempfile"'

 if @error = 0

  if open(10,$tempfile) = 0

   $line = readline(10) ; skip heading

   $line = readline(10)

   while @error = 0

    $array[$i] = rtrim(substr($line,1,instr($line," ")))

    $line = readline(10)

    $i=$i+1

   loop

   $=close(10)

   del "$tempfile"

   if $i

    redim preserve $array[$i-1]

    $pulist = $array

    exit @error

   endif

  endif

 endif

 $pulist = 0

 exit @error

endfunction

</blockquote><font size="2" face="Verdana, Helvetica, sans-serif">Author: 

-Shawn 

<small>[ 22. February 2003, 01:16: Message edited by: Shawn ]</small>83542QS1057BrianTXQS() 
-- a very fast quicksort algorithm to sort arrays0QS() (Quicksort)

Description:
This function sorts one-dimensional arrays in ascending order. It has been 
tested to be faster than any previously posted sorting function for KiXtart.

Syntax:
Array=QS(array)

Examples:
1.
$fruit = Grapefruit, Apples, Oranges, Peaches, Pears, Pineapples
$sorted = QS($fruit)

Returns an array:
Apples, Grapefruit, Oranges, Peaches, Pears, Pineapples

2.
$numbers = 5,7,3,2,4

$sorted = QS($numbers)

Returns an array:
2,3,4,5,7

3.
$number = 5
$sorted = QS($number)

Returns:
a single item (no array)
5

Author:
BrianTX

Source:

code:

function qs($a)
DIM $b[32],$c[32],$d,$e,$f,$g,$h,$i,$j,$k,$l
$b[0]=0
$c[0]=UBOUND($a)
$d=0
While $d >=0
 $e=$b[$d]
 $f=$c[$d]
 While $e < $f
  $h=$e+($f-$e)/2
  $k=$a[$e]
  $A[$e]=$A[$h]
  $A[$h]=$k
  $i=$e+1
  $j=$f
  $l=0
Do
   While ($i<$j) AND $A[$e] > $A[$i] 
    $i=$i+1
   Loop
   While ($j>=$i) AND $A[$j] > $A[$e]
    $j=$j-1
   Loop
   IF $i>=$j
    $l=1  
   ELSE
    $k=$A[$i]
    $A[$i]=$A[$j]
    $A[$j]=$k
    $j=$j-1
    $i=$i+1
   ENDIF
Until $l=1
   $k=$a[$e]
   $a[$e]=$a[$j]
   $a[$j]=$k
   $g=$j
   If $g-$e <= $f - $g
    If $g+1 < $f
     $b[$d]=$g+1
     $c[$d]=$f
     $d=$d+1
    Endif
    $f=$g-1
   Else
    If $g-1 > $e
     $b[$d]=$e
     $c[$d]=$g-1
     $d=$d+1
   Endif
   $e=$g+1
  Endif
 Loop
 $d=$d-1
Loop
$qs=$a
Endfunction

Comments and questions are welcome.

Brian82455QSort11ShawnQSort() - Quick sort for kixtart arrays0QSort()

Action:

Quick sort for kixtart arrays. 

Syntax:

array = qsort(array [, order ])

Parameters:

Array (Required) - A single dimensional kixtart array

Order (Optional) - The sort order (0/1). If omitted or set to zero, the
array will be sorted in ascending order. If set to 1, the array will be sorted
in descending order.

Returns:

The sorted array

Remarks:

A recursive sorting algorithm first developed by C.A.R Hoare in 1962. Given an 
array,
one element is choosen and the others are partitioned into two subsets - those 
less
than the partition element and those greater than or equal to it. The same 
process is
then applied recursively to the two subsets. When a subset has fewer than two 
elements,
it doesn't need any sorting; this stops the recursion. [Kernighan&Ritchie 1978]

Dependencies:

kixtart 4.0 (final)

Example(s):

code:

$array = Peach,Pumpkin,Orange,Grape,Lime,Apple,Rasberry,Cherry,Lemon
 
$array = qsort($array) ; sort ascending
for each $element in $array
 ? $element
next
 
$array = 1,2,3,4,5
 
$array = qsort($array,1) ; sort descending
for each $element in $array
 ? $element
next
 
$array = qsort(split("Z Q G A D M U V N K I X W J T S C R H B L E F P O Y"))
 
for each $letter in $array
 $letter
next

Source:

code:

function qsort($array,optional $order, optional $left, optional $right)
 dim $temp,$last,$i,$j
 if vartype($left) = 0
  $qsort=qsort($array,$order,0,ubound($array))
  return
 endif
 if $left >= $right
  $qsort=$array
  return
 endif
 $temp=$array[$left]
 $j=($left+$right)/2
 $array[$left]=$array[$j]
 $array[$j]=$temp
 $last=$left
 for $i=$left+1 to $right
  if ($array[$i] &lt; $array[$left] and not $order) or ($array[$i] > $array[$left] and $order)
   $last=$last+1
   $temp=$array[$last]
   $array[$last]=$array[$i]
   $array[$i]=$temp
  endif
 next
 $temp=$array[$left]
 $array[$left]=$array[$last]
 $array[$last]=$temp
 $qsort=qsort($array,$order,$left,$last-1) 
 $qsort=qsort($qsort,$order,$last+1,$right)
endfunction

Scripts:

code:

break on
 
; BENCHMARK
 
; create an array and seed with rnd numbers
 
srnd(1)
dim $array[500]
for $i = 0 to ubound($array)
 $array[$i] = rnd(100)
next
 
$start = @ticks
 
$array = qsort($array)
 
?"elapsed=" @ticks - $start
 
exit 1

Author:

-Shawn

[ 22. February 2003, 01:11: Message edited by: Shawn ]82468QSort46kholmQSort() 
- quick sorting for (large) one dimensional arrays0QSort() 

Action:
Quick sort for kixtart arrays 

Syntax:
$array = QSort($array)

Parameters:[b]
$Array - A single dimensional KiXtart array 

[b]Returns:
The sorted array 

On error (Wrong parameter type)
Returns the parameter unmodified, and @Error set to 1

Remarks:
To be used when sorting big arrays, when sorting smaller arrays, (Less then 100 
members)
you might as well use Shawns optimized version of bublesort.

QSort() is split into two functions: QSort() and QSExec(). QSExec() is the 
sorting engine,
whitch splits the array into smaller arrays and sort these smaller arrays using 
recursion.

To make QSort() capable of also sorting in descending order is mutch more 
complex than making
the BSort() do this, i think i will prefere to write a new function: QSortD() to 
do this job.

Bencmark idea and example stolen from Shawn's BSort() 

Dependencies:
kixtart 4.01

Example:

code:


$array = QSort(Split("Z Q G A D M U V N C B T W J X S K R H I L E F P O Y"))

For Each $letter In $array
 $letter
Next

Source:

code:

Function QSort($Array)
	If VarType($Array) & 8192
		$QSort = QSExec(0,UBound($Array),$Array)
	Else
		$QSort = $Array
		Exit 1
	EndIf
EndFunction


Function QSExec($Start,$End,$QSArray)
	Dim $Min,$Max,$Mid,$Tmp
	$Min = $Start
	$Max = $End
	$Mid = $QSArray[($Min + $Max) / 2]
	Do
		While $QSArray[$Min] < $Mid
			$Min = $Min + 1
		Loop
		While $Mid < $QSArray[$Max]
			$Max = $Max - 1
		Loop
		If $Min <= $Max
			$Tmp = $QSArray[$Min]
			$QSArray[$Min] = $QSArray[$Max]
			$QSArray[$Max] = $Tmp
			$Min = $Min + 1
			$Max = $Max - 1
		EndIf
	Until $Min > $Max
	If $Start < $Max
		$QSArray = QSExec($Start,$Max,$QSArray)
	EndIf
	If $Min < $End
		$QSArray = QSExec($Min,$End,$QSArray)
	EndIf
	$QSExec = $QSArray
EndFunction

Benchmark

code:

;Using an array of 1000 members with random numbers 0 - 1500 to demonstrate when
;there is reason to use QSort() instead of BSort()
;
;Uses functions:
;  BSort()
;  QSort()
;  QSExec() 
;
;Creates files: BS.txt and QS.txt in current dir, to check if sorting was done correctly.

Break On
 
SRnd(@Ticks)
Dim $SArray[1000]
For $i = 0 To UBound($SArray)
	$SArray[$i] = Rnd(1500)
Next
 
$Start = @Ticks
$QArray = QSort($SArray)
?"Elapsed time for QSort=" @Ticks - $Start
 
$File = @CurDir + '\QS.txt'
Del $File
$RC = Open(1,$File,5)
For Each $Element In $QArray
	$RC = WriteLine(1, '$Element' + @CRLF)
Next
$RC = Close(1)
 
$Start = @Ticks
$BArray = BSort($SArray)
?"Elapsed time for BSort=" @Ticks - $Start
 
$File = @CurDir + '\BS.txt'
Del $File
$RC = Open(1,$File,5)
For Each $Element In $BArray
	$RC = WriteLine(1, '$Element' + @CRLF)
Next
$RC = Close(1)
 
? 'Press a key '
Get $x
 
Return

Sample output from my 800 mhz P3:
Elapsed time for QSort=1885
Elapsed time for BSort=27882


Author:

-kholm
Erik Kærholm

ps.
Shawn, this is not to start a competition.
I had QSort() nearly ready when you posted your BSort(), whitch by the way is 
the quickest bublesort version
i have seen made in KiX.118287QuarantineCheck3755GavenQuarantineCheck() - 
counts files in Norton Quarant1106201722Code:


; Function: QuarantineCheck()

;

; Author: Gaven Henderson, Gaven@GavDogg.net

; 

; Action: QuarantineCheck will return the number of that exist in the Norton

; AntiVirus Quarantine folder. Works for NAV 2002 and similar versions.

;

; Syntax: quarantinecheck()

;

; Version: 1.0

;

; Post Date: April 20, 2003

;

; Returns: Returns an integer representing the number of files found in the

; Norton AntiVirus Quarantine folder. If NAV cannot be located, no data is

; returned.

; 

; KiXtart Ver: Designed on 4.20 but should work on any version.

;

; Example: $viruses = quarantinecheck

;          $viruses " quarantined file(s)."

;

Function quarantinecheck()

	Dim $a,$b,$c

	$a=ReadValue("HKLM\SOFTWARE\Symantec\Norton AntiVirus\Quarantine","QuarantinePath")

	If @Error Exit 1 EndIf

	$quarantinecheck=0

	$b=Dir($a+'\*.*')

	While $b<>""

		If Right($b,1)<>"."

			If GetFileAttr($a+"\"+$b) & 16

				$c=Dir($a+'\'+$b+'\*.*',1)

				While $c<>""

					If Right($c,1)<>"." And Not(GetFileAttr($a+"\"+$b+"\"+$c) & 16)

						$quarantinecheck=$quarantinecheck+1

					EndIf

					$c=Dir(,1)

				Loop

			Else

				$quarantinecheck=$quarantinecheck+1

			EndIf

		EndIf

		$b=Dir()

	Loop

EndFunction

138972QuickSort1399Christophe MelinQuickSort() - a new function to sort 
array of array0 Code:

;------------------------------------------------------------------------------ 

;function: 

;   QuickSort 

; 

;Action: 

;   Sort an array 

; 

;Author: 

;   BrianTX 

; 

;Contributors: 

;   Christophe MELIN 

; 

;Version: 

;   1.1 

; 

;Version History: 

;   1.1      add the ability to sort an array of array 

;            and rename variables for better understanding 

; 

;Date created: 

;   30/09/2002 

; 

;Date modified: 

;   10/09/2004 

; 

;KIXTART     KiXtart 4.02 

; 

;Syntax: 

;   QuickSort( $a, optional $indexcol ) 

; 

;Parameters: 

;   a        : REQUIRED. array to sort 

;   indexcol : OPTIONAL. number of the column to sort on 

; 

;returns: 

;   the sorted array 

; 

;Dependencies: 

;   QuickSortItem 

;------------------------------------------------------------------------------ 

function quicksort($a, optional $indexcol )

    ;$a                        array to be sorted 

    ;$indexcol                 index of subitem to sort on 



    ;$LowerIndexStack          lower index stack 

    ;$UpperIndexStack          upper index stack 

    ;$StackPointer             stack pointer 

    ;$LowerIndex               lower index 

    ;$UpperIndex               upper index 

    ;$Pivot                    value of pivot 

    ;$TempSwappingValue        temp variable for swapping elements 

    ;$index                    stores either lower or upper index of unsorted segment of the array 

    ;$i                        counter moving from lower index to the right 

    ;$j                        counter moving from upper index to the left 

    ;$LowerItem                value to compare with 



    dim $StackSize, $StackIncr

    $StackSize = 8

    $StackIncr = $StackSize



    dim $LowerIndexStack[$StackSize],$UpperIndexStack[$StackSize]

    dim $StackPointer, $LowerIndex, $UpperIndex, $Pivot, $TempSwappingValue, $index, $i, $j, $LowerItem

	dim $ExitLoop



    if $indexcol

        $indexcol = CStr($indexcol)

        if indexcol < 0

            $indexcol = 0

        endif

    else

        $indexcol = 0

    endif



    $LowerIndexStack[0]=0

    $UpperIndexStack[0]=UBOUND($a)

    $StackPointer=0

    While $StackPointer >= 0

        $LowerIndex=$LowerIndexStack[$StackPointer]

        $UpperIndex=$UpperIndexStack[$StackPointer]

        While $LowerIndex < $UpperIndex

            $Pivot=$LowerIndex+($UpperIndex-$LowerIndex)/2

            $TempSwappingValue=$a[$LowerIndex]

            $A[$LowerIndex]=$A[$Pivot]

            $A[$Pivot]=$TempSwappingValue

            $i=$LowerIndex+1

            $j=$UpperIndex

            $ExitLoop=0

            Do

                $LowerItem = QuickSortItem( $A[$LowerIndex],$indexcol )

                While ($i<$j) AND ( QuickSortItem( $A[$i],$indexcol ) < $LowerItem)

                    $i=$i+1

                Loop

                While ($j>=$i) AND ($LowerItem < QuickSortItem( $A[$j],$indexcol ))

                    $j=$j-1

                Loop

                if $i>=$j

                    $ExitLoop=1

                else

                    $TempSwappingValue=$A[$i]

                    $A[$i]=$A[$j]

                    $A[$j]=$TempSwappingValue

                    $j=$j-1

                    $i=$i+1

                endif

            Until $ExitLoop=1

            $TempSwappingValue=$a[$LowerIndex]

            $a[$LowerIndex]=$a[$j]

            $a[$j]=$TempSwappingValue

            $index=$j

            if $index - $LowerIndex <= $UpperIndex - $index

                if $index+1 < $UpperIndex

                    if $StackPointer>$StackSize

                        $StackSize = $StackSize + $StackIncr

                        Redim preserve $LowerIndexStack[$StackSize]

                        Redim preserve $UpperIndexStack[$StackSize]

                    endif



                    $LowerIndexStack[$StackPointer]=$index+1

                    $UpperIndexStack[$StackPointer]=$UpperIndex

                    $StackPointer=$StackPointer+1

                endif

                $UpperIndex=$index-1

            else

                if $index-1 > $LowerIndex

                    if $StackPointer>$StackSize

                        $StackSize = $StackSize + $StackIncr

                        Redim preserve $LowerIndexStack[$StackSize]

                        Redim preserve $UpperIndexStack[$StackSize]

                    endif



                    $LowerIndexStack[$StackPointer]=$LowerIndex

                    $UpperIndexStack[$StackPointer]=$index-1

                    $StackPointer=$StackPointer+1

                endif

                $LowerIndex=$index+1

            endif

        Loop

        $StackPointer=$StackPointer-1

    Loop

    $quicksort=$a

Endfunction



Useful to sort array of arrays not only on the first column.

Example : load a .csv file in an array then split each line.
if first fields are mandatories and last are optionals, you can sort on each 
field even if they are missing ...138971QuickSortItem1399Christophe MelinQuickSortItem() 
- retrun value of an subtitem for the quicksort function0Code:


;------------------------------------------------------------------------------ 
;function: 
;   QuickSortItem 
; 
;Action: 
;   Return a subitem of an array 
; 
;Author: 
;   
; 
;Contributors: 
;   Christophe MELIN 
; 
;Version: 
;   1.0 
; 
;Version History: 
; 
;Date created: 
;   10/09/2004 
; 
;Date modified: 
;   10/09/2004 
; 
;KIXTART     KiXtart 4.02 
; 
;Syntax: 
;   QuickSortItem( $value, $index ) 
; 
;Parameters: 
;   value    : REQUIRED. variable to read in 
;   index    : OPTIONAL. number of the column to read in the value variable 
; 
;returns: 
;   the value of index item in value variable 
; 
;Dependencies: 
; 
;------------------------------------------------------------------------------ 
Function QuickSortItem( $value, $index )
    if vartype($value) & 8192
        if ($index <= UBound($value))
            $QuickSortItem = $value[$index]
        else
            $QuickSortItem = ""
        endif
    else
        $QuickSortItem = $value
    endif
endfunction



Required by QuickSort function.84322QuotaUser119LonkeroQuotaUser() - get 
users quota-info or set limits0

;Function:

;	QuotaUser()

;

;Author:

;	Lonkero (Jooel_Nieminen@hotmail.com)

;

;Version:

;	1.0

;

;Version History:

;	1.0	20.5.2003	initial release

;

;Action:

;	Reads quota-info or Sets Quota-setting for user

;

;Syntax:

;	QuotaUser(DRIVE,USER,TYPE,SET)

;

;Parameters:

;	DRIVE	drive to work on

;

;	USER	User which quota is to be handled

;		sid or username

;

;	TYPE	what info or setting to work on

;		possibilities:

;		1 QuotaUsed

;		2 QuotaLimit in bytes

;		3 QuotaLimit as text (i.e "1 kt")

;		4 QuotaThreshold (warning amount)

;

;	SET	whether to get current info or set (0 or 1)

;		obviously set requires rights on the system       

;

;Remarks:

;	just tested on local w2k system.

;

;Returns:

;	3 	specified drive does not exist

;	87	user not recognized

;	120	system does not support (too old)

;

;Dependencies:

;	Windows 2000 or ME or later

;

;Example:

;	"your quotalimit is " quotauser("c:\",@sid,3,0)

;	?

;	"your and you have used " quotauser("c:\",@sid,1,0)

;	" of it"

;

;Source:

function quotaUser($drive,$user,$type,$set)

 dim $guota

 if not exist($drive) exit 3 endif

 $quota = CreateObject("microsoft.diskquota.1")

 if 9<>vartype($quota) exit 120 endif

 $quota.initialize($drive,$set)

 $quota=$quota.findUser($user)

 if @error exit 87 endif

 select

 case 1=$type $quotauser=$quota.used

 case 2=$type $quotauser=$quota.quotalimit

 case 3=$type $quotauser=$quota.quotalimittext

 case 4=$type $quotauser=$quota.QuotaThreshold

 endselect

endfunction

[ 27. May 2003, 20:09: Message edited by: Radimus ]82419Randomize11ShawnRandomize() 
- Randomly seeds the random number generator0Randomize()

Action:

Randomly seeds the random number generator

Syntax:

Randomize()

Parameters:

none

Returns:

nothing

Remarks:

Uses the @TICKS macro to seed the random number generator. Because it's possible 
(after about 25 days or so of uptime) that @TICKS will return a negative number, 
it is first checked and converted to a positive number.

Dependencies:

KiXtart 4.0 (final)

Example(s):

Code:


Randomize()

?"rnd=" rnd(10)



Source:
Code:


function randomize()
 dim $ticks $ticks = @ticks
 if $ticks < 0
  $ticks = -1 * $ticks
 endif
 srnd($ticks)
endfunction



Author:

-Shawn

82217RandomizeArray1**DONOTDELETE**RandomizeArray() - Will randomize the 
order of elements in an array0

code:

  
; Function RandomizeArray()
;
; Author		Randy Watson (aerathistorm@yahoo.com)
;
; Action		Randomizes array of values of any type
;
; Syntax		Randomize(Array)
;
; Parameters		title
;			Array
;				Array to be Randomized
;
; Returns		
;			Returns a randomized Array.
;
; Remarks		
;			A Global Variable name $RandomCallCounter needs to be initialized
;			with a value of 0. This variable is incremented each time the function
;			is called to make sure that the array does not return the same value
;			if called more than once a second.
;			
; Dependencies		
;			Global Variable $RandomCallCounter
;
; Example(s)
;		Randomize the order of the numbers between 1 and 10
;	
;	$RandomCallCounter = 0
;	Dim $MyArray[9]
;	For $x = 0 To 9
;		$MyArray[$x] = $x + 1
;	Next
;	$MyArray = RandomizeArray($MyArray)
;	For $x = 0 To 9
;		? $MyArray[$x]
;	Next
;
; Source:
;


Function RandomizeArray($ArrayIn)
	Dim $ArrayCounter
	Dim $ArrayIndex
	Dim $Temp
	
	If $RandomCallCounter > 100
		$RandomCallCounter = 0
	EndIf
	$RandomCallCounter = $RandomCallCounter + 1
	$Seed = Val(Substr(@Time, Len(@Time) - 1, 2)) * $RandomCallCounter
	$Nul = Srnd($Seed)
	If UBound($ArrayIn) > 0
		For $ArrayCounter = 0 To UBound($ArrayIn)
			$ArrayIndex = Rnd(UBound($ArrayIn) - $ArrayCounter + 1)
			$Temp = $ArrayIn[$ArrayIndex]
			$ArrayIn[$ArrayIndex] = $ArrayIn[$ArrayCounter]
			$ArrayIn[$ArrayCounter] = $Temp
		Next
		$RandomizeArray = $ArrayIn
	EndIf
EndFunction


82150RCMDInstall28BryceRCMDInstall() - Will install the RCMD service on a 
remote workstation.0

code:


function RCMDInstall($target, OPTIONAL $targetadmin, OPTIONAL $targetpassword)
;
; RCMDInstall, this function will intall the RCMD service onto a target NT/w2k
; computer.
;
; SYNTAX:	RCMDInstall(, [],[])
;		
; Parameters:	 is the unc name of the computer to install RCMD on
;
;		 is an optional username used to gain access to a remote 
;		target computer.
;
;		 is the password used for the 
;
; Returns:	Returns nothing but but check @error for detailed information
;
; Example:	;this will install the RCMD service on \\testserver using inherited
;		;accress rights
;		RCMDInstall("\\testserver")
;
;		;This will install the RCMD service on \\testserver even through 
;		;\\testserver is in a different DOMAIN
;		RCMDInstall("\\testserver", "houston\smithb", "1234")
;
;		;this will install the RCMD service on \\testserver using the local
;		;administrator account
;		RCMDInstall("\\testserver","administrator","1234")
;
; Remarks:	* RCMD.EXE and RCMDSVC.exe must be in the same local folder of the script
;		* Xnet.exe must be avaliable in the path

	DIM $target, $targetname, $targetadmin, $targetpassword, $targetsystemroot

	if substr($target,1,2) <> "\\"
		exit(11)
	else
		$targetname = substr($target,3,len($target))
	endif

	IF $targetadmin <> ""
		if instr($targetadmin,"\") = 0
			use "$target\ipc$$" /user:'$targetname\$targetadmin' /password:$targetPassword
		else
			use "$target\ipc$$" /user:'$targetadmin' /password:$targetPassword
		endif
	else
		use "$target\ipc$$"
	endif
	Select
		case @error = 0
			;install the RCMD service on the $target computer
			$targetSystemRoot = readvalue("$target\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\","SystemRoot")
			shell '%comspec% /c xnet list $target | find /i "rcmdsvc" > nul'
			if @error = 0
				shell '%comspec% /c xnet stop $target\rcmdsvc > nul'
				shell '%comspec% /c xnet remove $target\rcmdsvc /y > nul'
			endif

			if exist("RCMD.exe") AND exist("RCMDSVC.exe")
				copy "rcmd*.exe" "$target\admin$$\system32"
			else
				exit(2)
			endif
			if @error <> 0 exit(@error) endif
			shell '%comspec% /c xnet install $target\rcmdsvc /b:$targetsystemroot\system32\rcmdsvc.exe /n:"Remote Command Service" /u:localsystem /i:y /s:auto > nul'
			shell '%comspec% /c xnet start $target\rcmdsvc > nul'
		case @error <> 0
			;unable to make an admin connection to the $target computer
			exit(@error)
	endselect
	use "$target\ipc$$" /delete
endfunction

83321ReadAccountStatus1374RaceeendReadAccountStatus() - Reads the status of 
an user account0Found lots about account status's but not the "simple" reading.

code:

; Function	ReadAccountStatus($username)
;
; Author		Martijn Raaijmakers (mr@gispen.nl)
;
; Version		1.0 (01-07-2002)
;
; Returns		Account info of the requested user
;
; Syntax		ReadUserData(Username)
;
; Dependencies	ADSI is required --> http://www.microsoft.com/NTWorkstation/downloads/Other/ADSI25.asp
;
; Example		? "From which user do you want to show the account settings? " Gets $username
;			$X = ReadUserData($username)
	
Function ReadAccountStatus($username)
  $user = GetObject("WinNT://@LDOMAIN/" + $username + ",user")
  If @ERROR <> 0
    ? "User does not exist"
    ? "Do you want to try again? (y/n)" Gets $answer
    If $answer = "y" OR $answer = "Y"
      Sleep 2
      CLS
      Goto "Start"
    Else
      Return
    EndIf
  Else
    ?
    ? "Displaying user account statistics."
    ? "Account:                   "  + $user.name
    ? "Full name:                 "  + $user.fullname
    ? "Department:                "  + $user.description
  If $user.PasswordExpired = 0
    $PasswordExpired = No
  Else
    $PasswordExpired = Yes
  EndIf
  ? "Change of password needed: "  + $PasswordExpired
  If $user.AccountLocked = 0
    $locked = No
  Else
    $locked = Yes
  EndIf
  ? "Account locked:            "  + $locked
  ? $user.lockedout
  If $user.AccountDisabled = 0
    $AccountDisabled = No
  Else
    $AccountDisabled = Yes
  EndIf
  ? "Account Disabled:          "  + $AccountDisabled
  ? "Home directory:            "  + $user.HomeDirectory
  ?
EndFunction
  

164088ReadAll5407eriqjaffeReadAll() - Read a file into a string0My first 
UDF, hopefully I'm not submitting this incorrectly:

Code:

;Function	ReadAll()
;
;Author:	Eriq Jaffe
;
;Contributors:	Based on code posted by Bryce in this thread:
;               http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Board=UBB1&Number=146691
;
;Action;	Reads a file into a string
;
;Syntax:	ReadAll("File")
;
;Version;	1.0
;
;Date:          7/6/2006
;
;Date Revised:  7/6/2006
;
;Parameters: 	$File (Required) - Name of the file to be read.
;
;Returns:	Returns a string containing the contents of the specified file.
; 
;Dependencies:	FSO (File System Object)
;
;KiXtart Ver	4+
; 
;Example(s)	$string = ReadAll("c:\file.txt")

Function ReadAll($file)
	DIM $fso,$f,$fs
	$fso = CreateObject("Scripting.FileSystemObject")
	$f = $fso.GetFile($file)
	If @ERROR Exit 2 EndIf
	$fs = $f.OpenAsTextStream(1)
	$ReadAll = $fs.Read($F.size)
	Exit @ERROR
EndFunction

138959ReadArray1399Christophe MelinReadArray() - an item in an array with 
control of index1115029803 Code:

;------------------------------------------------------------------------------ 
;function: 
;   ReadArray 
; 
;Action: 
;   Read one element in an array with control on the value of index 
;   index must be between 0 and UBound($arr). 
;   if not, an empty string is returned 
; 
;Author: 
;   Christophe MELIN 
; 
;Contributors: 
; 
;Version: 
;   1.0 
; 
;Version History: 
; 
;Date created: 
;   10/09/2004 
; 
;Date modified: 
; 
;KIXTART     KiXtart 4.02 
; 
;Syntax: 
;   ReadArray( $arr, $index ) 
; 
;Parameters: 
;   arr     : REQUIRED. array to read 
;   index   : index of the element to read (between 0 and UBound($arr) 
; 
;returns: 
;   the value of the element 
; 
;Dependencies: 
; 
;------------------------------------------------------------------------------ 
function ReadArray( $array, $index )
    if IsArray($array)
        if ($index <= UBound($array)) and ($index >= 0)
            $ReadArray = $Array[$index]
        else
            $ReadArray = ""
        endif
    else
        if $index=0
            $ReadArray = $Array
        else
            $ReadArray = ""
        endif
    endif
endfunction



ReadArray is part of a set of functions for arrays manipulation.
Especially useful for array of array when all subarrays haven't the same size.162074readCSV7679GilrimreadCSV() 
- reads a csv and returns array0Code:


;Function	readCSV()
;
;Author		Gilrim Dol
;
;Contributors	Adopted from CMReadfile() by Cristophe Melin
;
;Action		Reads a csv file into a two dimentional array
;
;Syntax		readCSV("filename.csv", ";")
;
;Version	0.1
;
;Date           19th of May 2006
;
;Date Revised   to come :)
;
;Parameters 	file 
;		file accessible by user running script
;		delimiter
;		delimiter used in csv file (for some reason excel tends to use ";"
;		and not ","
;
;Remarks	Using csv for storing info are quick and easy, and I've been
;               looking for a udf to do this. Didn't find any, so I made this..
;
;Returns	Returns two dimentional array with contents of file
; 
;Dependencies 	None
;
;KiXtart Ver	4.51
; 
;Example(s)	$shares=readCSV("shareList.csv")
; 

Function readCSV($file, optional $delimiter)
	If $delimiter = ""
          $delimiter = ";"
        EndIf
        Dim $handle
	$handle=FreeFileHandle
	$=Open($handle,$file)
	If @error
          Exit @error
        EndIf
	ReDim $readfile[1024]
	Dim $nb
	$nb=-1
	Do
		$nb = $nb + 1
		If $nb>Ubound($readfile)
			ReDim preserve $readfile[Ubound($readfile)*2]
		EndIf
		$readfile[$nb]=ReadLine($handle)
	Until @error
	$=Close($handle)
	If $nb=1
		Exit 1024
	Else
		ReDim preserve $readfile[$nb-1]
	EndIf
	$cols = Ubound(Split($readfile[0],$delimiter))
	ReDim $readCSV[Ubound($readfile),$cols]
        $i = 0
        For Each $element in $readfile
            $temp = Split($element,$delimiter)
            For $j = 0 to Ubound($temp)
                $readCSV[$i,$j] = $temp[$j]
            Next
            $i = $i + 1
        Next
EndFunction

83519ReadEventlog17SealeopardReadEventlog() - Retrieves event from the 
eventlog1073664863Code:


;FUNCTION      ReadEventlog()

;

;ACTION        Retrieves events from the eventlog

;

;AUTHOR        Jens Meyer

;

;VERSION       1.51 (added URL for WQL keyword reference and detailed datetime formats)

;              1.5

;

;DATE CREATED  12/22/2001

;

;DATE MODIFIED 01/09/2004

;

;KIXTART VER   4.20

;

;SYNTAX        RETCODE = READEVENTLOG(EVENTLOG, EVENTID, OPTIONAL COMPUTER, OPTIONAL DATETIME,

;                                     OPTIONAL USERNAME, OPTIONAL PASSWORD)

;

;PARAMETERS    EVENTLOG

;              Name of the eventlog, e.g. 'Security', 'System','Application'

;              Alternatively, a custom WQL query can be provided. Date fields in

;              a WQL query MUST be properly formatted in the WMI date-time format

;              as YYYYMMDDHHMMSS.000000-UUU where -UUU is the three-digit offset

;              indicating the number of minutes that the originating time zone deviates from UTC.

;              For WMI, it is encouraged, but not required, to convert times to GMT (a UTC offset of zero).

;              See http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wmisdk/wmi/sql_for_wmi.asp

;              for a list of available WQL keywords

;

;              EVENTID

;              Optional Event ID number to be retrieved

;

;              COMPUTER

;              optional name of a remote computer which eventlog is to be queried. If no

;              username/password is provided then the current users credentials will be

;              used to connect to the remote event log.

;

;              DATETIME

;              optional date/time string denoting the start date of the events in

;              the form of YYYY/MM/DD HH:MM:SS, YYY/MM/DD, or HH:MM:SS

;

;              USERNAME

;              optional username which will be used to connect to a remote computer

;

;              PASSWORD

;              optional password which will be used to connect to the remote computer

;

;RETURN        array of events or empty string

;

;REMARKS       returns a 2-dimensional array with the following columns. If custom WQL is

;              used, then the SELECT part of the custom WQL determines the field assignments.

;

;              Column  0 = Category

;              Column  1 = CategoryString

;              Column  2 = ComputerName

;              Column  3 = Data

;              Column  4 = EventCode

;              Column  5 = EventIdentifier (see http://support.microsoft.com/default.aspx?scid=kb;en-us;245222)

;              Column  6 = EventType

;              Column  7 = InsertionStrings

;              Column  8 = Logfile

;              Column  9 = Message

;              Column 10 = RecordNumber

;              Column 11 = Source Name

;              Column 12 = TimeGenerated

;              Column 13 = TimeWritten

;              Column 14 = Type

;              Column 15 = User

;

;DEPENDENCIES  WMI

;

;EXAMPLE       $events = ReadEventlog('Security',528)

;              $events = ReadEventlog('Security',528,'COMPUTER')

;              $events = ReadEventlog('Security',528,'COMPUTER','2002/09/01 00:00:00','Administrator','password')

;              $events = ReadEventlog('SELECT TimeGenerated, User FROM Win32_NTLogEvent

;                                      WHERE Logfile="Security" AND EventCode=528 AND

;                                      TimeGenerated>="20020901000000.000000-240"')

;

;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Number=82856

;

function ReadEventlog($eventlog, optional $eventid, optional $computer, optional $datetime, optional $username, optional $password)

  dim $objLocator, $objWBEM, $objWMIResults, $namespace, $objWMIResultsCopy

  dim $event, $item, $wqlQuery, $eventarray, $itemname, $itemvalue

  dim $customwql, $customfields, $field

  dim $rownumber, $arrayrows, $arraycolumns, $columnnumber

  dim $byte, $datastring, $date, $time, $querydate, $querytime, $timezone

  dim $objWMIService, $colItems, $objItem



  $namespace = 'root\CIMV2'

  $arrayrows=50



  if trim($eventlog)=''

    exit 87

  endif



  ; check to see whether we're connecting to a local or remote eventlog

  $computer=trim($computer)

  select

  case $computer=@WKSTA

    $computer='.'

  case $computer

  case 1

    $computer='.'

  endselect



  if $username and $computer<>'.'

    ; create locator object for connection to a remote computer

    $objLocator = CreateObject('WbemScripting.SWbemLocator')

    if @ERROR

      exit @ERROR

    endif



    ; in order to connect to a remote windows xP or Windows Server 2003 computer, the

    ; authentication level needs to be set to packet and not connect

    ; WbemAuthenticationLevelConnect = 2

    ; WbemAuthenticationLevelPkt     = 4



    $objLocator.Security_.AuthenticationLevel = 4

    if @ERROR

      exit @ERROR

    endif



    ; create a credentialed connection to a remote computer

    $objWBEM=$objLocator.ConnectServer($computer,$namespace,$username,$password)

    if @ERROR

      exit @ERROR

    endif

    ; set the impersonation level

    $objWBEM.Security_.ImpersonationLevel = 3

    if @ERROR

      exit @ERROR

    endif

  else

    ;set the impersonation level and make sure we have security permissions

    if $eventlog='Security' or (left($eventlog,6)='select' and instr($eventlog,'Security') and instr($eventlog,'Logfile'))

      $objWBEM=GetObject('winmgmts:{impersonationLevel=impersonate, (Security)}!\\'+$computer+'\'+$namespace)

    else

      $objWBEM=GetObject('winmgmts:{impersonationLevel=impersonate}!\\'+$computer+'\'+$namespace)

    endif

    if @ERROR

      exit @ERROR

    endif

  endif



  ; check to see whether we're looking for an event ID or if there's a custom query

  if left($eventlog,6)='select'

    $wqlquery=$eventlog

    $arraycolumns=trim(substr($wqlquery,instr($wqlquery,' ')+1,instr($wqlquery,'FROM')-instr($wqlquery,' ')-2))

    if instr($arraycolumns,'*')

      $arraycolumns=16

      $customwql=0

    else

      $customfields=split(trim($arraycolumns),',')

      for $arraycolumns=0 to ubound($customfields)

        $customfields[$arraycolumns]=trim($customfields[$arraycolumns])

      next

      $arraycolumns=ubound($customfields)+1

      $customwql=1

    endif

  else

    $customwql=0

    $arraycolumns=16

    $eventid=val($eventid)

    $wqlQuery="SELECT * FROM Win32_NTLogEvent WHERE Logfile='"+$eventlog+"' AND EventCode="+val($eventID)



    if $datetime

      $colItems = $objWBEM.ExecQuery('Select CurrentTimeZone from Win32_ComputerSystem')

      if @ERROR

        exit @ERROR

      endif



      for each $objItem in $colItems

        $timezone = $objItem.CurrentTimeZone

      next



      $objWMIService = 0

      $colItems = 0

      $objItem = 0



      $datetime=trim($datetime)



      select

      case instr($datetime,' ')

        $date=left($datetime,instr($datetime,' ')-1)

        $time=substr($datetime,instr($datetime,' ')+1)

      case instr($datetime,'/')

        $date=$datetime

        $time='00:00:00'

      case instr($datetime,':')

        $date=@DATE

        $time=$datetime

      case 1

        $date=@DATE

        $time=@TIME

      endselect

      if $date and $time

        $datetime=join(split($date,'/'),'')+join(split($time,':'),'')+'.000000'+$timezone

      else

        $datetime=''

      endif



      $wqlQuery=$wqlQuery+' AND TimeGenerated>="'+$datetime+'"'

    endif

  endif



  $objWMIResults = $objWBEM.ExecQuery($wqlQuery,'WQL',48)

  if @ERROR

    exit @ERROR

  endif



  $rownumber = 0

  $columnnumber = 0



  for each $event in $objWMIResults

    if $rownumber mod $arrayrows = 0

      redim preserve $eventarray[$rownumber+$arrayrows]

    endif

    $eventarray[$rownumber]=$event.Properties_

    $rownumber=$rownumber+1

  next

  if $rownumber

    redim preserve $eventarray[$rownumber-1]

  else

    $ReadEventlog=''

    return

  endif



  redim $readeventlog[$rownumber-1,$arraycolumns-1]

  $rownumber=0

  for each $event in $eventarray

    $columnnumber = 0

    for each $item in $event

      $itemname=$item.name

      $itemvalue=$item.value

      if $customwql=0 or ascan($customfields,$itemname)+1

        select

        case $itemname='Data'

          $datastring=''

          for each $byte in $item.value

            if $byte=0

              $byte=46

            endif

            $datastring=$datastring+chr($byte)

          next

          $readeventlog[$rownumber,$columnnumber]=$datastring

        case $itemname='InsertionStrings'

          $readeventlog[$rownumber,$columnnumber]=join($itemValue,@CRLF)

        case $itemname='TimeGenerated' or $itemName='TimeWritten'

          $time=left($itemValue,4)+'/'+substr($itemValue,5,2)+'/'+substr($itemValue,7,2)+' '

          $time=$time+substr($itemValue,9,2)+':'+substr($itemValue,11,2)+':'+substr($itemValue,13,2)

          $readeventlog[$rownumber,$columnnumber]=$time

        case 1

          $readeventlog[$rownumber,$columnnumber]=$itemValue

        endselect

        $columnnumber=$columnnumber+1

      endif

    next

    $rownumber=$rownumber+1

  next



  $objWMIResults = 0

  $objWBEM = 0

  $objLocator = 0



  exit 0



endfunction

82775READEXCEL79KdyerREADEXCEL() - Read an Excel Spreadsheet and return 
results0

code:

;FUNCTION READEXCEL()
;
;ACTION Reads an Excel Spreadsheet
;
;AUTHOR Kent Dyer (leptonator@hotmail.com)
;
;CONTRIBUTORS Alex, Frans Erich for the idea
;
;VERSION 1.4 - re-written for an array
;
;DATE CREATED 02-January-2002
;
;DATE MODIFIED 27-April-2003
;
;KIXTART 4.12
;
;SYNTAX READEXCEL('FILENAME')
;
;PARAMETERS $Filename
; XLS file
;
;DEPENDENCIES None
;
;RETURNS  Values - $Value1, $Value2, $Value3
;
;REMARKS
;{Version 1.2 - Edit 06-April-2003 Added additional error-checking}
;{Version 1.1 - Edit 28-October-2002 fixed a "dispatch pointer" error}
;Ref - http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=2&t=002715
;Ref - http://boards.cramsession.com/boards/vbm.asp?rpg=1&wpg=1&sb=0&pvm=False&m=447684
;
;EXAMPLE
;Tested on MS-Excel Files
;$cFile = "C:\Scripts\Test.XLS"
;Tested on CSV Files
;$cFile = "C:\Scripts\Test.CSV"
;READEXCEL($cFile)
;
;KIXTART BBS http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000121

FUNCTION READEXCEL($cfilename)
      DIM $Rc,$Row,$oXL,$a[3],$b[3],$c
      $a=1,3,2 ;columns and order to be read
      IF 0=EXIST($cfilename) ;insure the file exists
            ?'Excel file not found'
            SLEEP 4
            RETURN ;leave
      ENDIF
      $oXL=Createobject('Excel.application')
      ;Check to insure that Excel is available
      IF 0<>@error ?@error ' Excel Application is not found' 
            SLEEP 4 
            RETURN 
      ENDIF
      $Rc=$oXL.workbooks.open($cfilename)
      $Row=1 ;Row to start at using column headings, change to 0, if needed
      WHILE $oXL.cells($Row,$a[1]).value<>'' ;need a value each time in column 1
            $Row=$Row+1
            IF $oXL.cells($Row,$a[1]).value='' ;Once it gets to a blank row...
                  $oXL.quit ;quit Excel
                  $oXL=0 ;set the object to 0
            ELSE
                  FOR $c=0 TO ubound($a)
                        $b[$c]=$oXL.cells($Row,$a[$c])
                        $b[$c] ;Print out results
                  NEXT
            ENDIF
      LOOP
      $READEXCEL=$b
ENDFUNCTION
  



[ 28. October 2003, 16:43: Message edited by: kdyer ]84265ReadExcel2119LonkeroReadExcel2() 
- Reads from excel1216546417 

Code:

 
;Function:  
;	ReadExcel2()  
;  
;Authors:  
;	Lonkero  
;	kdyer  
;  
;Version:  
;	2.2.2
;  
;Version History:  
;	2.2.2	20.6.2008
;		fixed a dimming issue (thanks kdyer)
;	2.2.1	13.9.2005
;		removed a code shortcut that does no longer work in 4.50
;	2.2	11.2.2004
;		fixed lot of typos and the header
;	2.1	16.5.2003
;		added ability to read full sheet (slow)
;		added option to read all data (faster   )
;	2.0	16.5.2003  
;		cleaned the code from console outputs  
;		added proper errorcodes  
;		added proper parameter-definitions  
;		proper closing of excel  
;		well, totally made this a new Xperience       
;  
;	1.4	(initial code = ReadExcel UDF) by kdyer  
;		http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000121  
;  
;  
;Action:  
;	Read from Excel to 2-dimensional array  
;  
;Syntax:  
;	ReadExcel2(FILE, [SHEET], [ROWCOUNT], [COLUMNCOUNT], [ROWSTART], [COLUMNSTART])  
;  
;Parameters:  
;	FILE  
;		REQUIRED STRING
;		File to read from  
;	SHEET
;		OPTIONAL INTEGER
;		Sheet index from which to read.
;		default = 1
;	ROWCOUNT
;		OPTIONAL INTEGER
;		Amount of Rows to read
;		if -1 reads until empty field found at the start of row
;		if left out reads all rows
;	COLUMNCOUNT  
;		OPTIONAL INTEGER
;		Amount of Columns to read
;		if -1 reads until empty field found at row 1 of Column
;		if left out reads all Columns
;	ROWSTART
;		OPTIONAL INTEGER
;		Row from which to start reading  
;		if not specified, defaults to 1  
;	COLUMNSTART  
;		OPTIONAL INTEGER
;		Column from which to start reading  
;		if not specified, defaults to 1  
;  
;Remarks:  
;	Excel uses row and column numbers starting from 1   
;	thus the resulting range that starts from [0,0] might confuse a little  
;  
;Returns:  
;	2-dimensional array (table) or  
;	nothing if failed (see errorcode for reason)  
;  
;Errorcodes:  
;	0	ERROR_SUCCESS		The operation was successfully completed.  
;	2	ERROR_FILE_NOT_FOUND	The system cannot find the file specified.  
;	87	ERROR_INVALID_PARAMETER	The parameter is incorrect.  
;	1154	ERROR_INVALID_DLL	Excel does not exist or is too old to support com.  
;  
;Dependencies:  
;	Excel -97 or newer  
;  
;Example:
;	;read the default sheet (1) to the first empty field (with 3 columns).
;	$range=readexcel2('C:\Documents and Settings\niemjo\Työpöytä\puhluett.xls',,-1,3)
;	if @error  
;	 "error occured: @serror (@error)"  
;	else  
;	 for $counter=0 to ubound($range,2)
;	  ? "name: " $range[$counter,0]  
;	  ? "phonenumber: " $range[0,1]  
;	  ? "cellular: " $range[0,2]  
;	  ?
;	 next
;	endif
;  
;Source:  
Function ReadExcel2($0,optional $1,optional $2,optional $3,optional $4,optional $5)
 dim $,$!, $_
 If 0=Exist($0) exit 2 Endif
 $=Createobject('Excel.application')
 If @error Exit 1154 Endif
 if 8&lt;&gt;vartype($0) exit 87 endif
 $! = $.workbooks.open($0)
 if vartype($1)
  if 3&lt;&gt;vartype($1) exit 87 endif
  if 1&gt;$1 exit 87 endif
 else
  $1=1
 endif
 if vartype($2)
  if 3&lt;&gt;vartype($2) exit 87 endif
  if -1=$2
   for $!=1 to $.sheets($1).rows.count
    if not $.sheets($1).cells($!,1).value
     $2=$!-1
     $!=$.sheets($1).rows.count
    endif
   next
  endif
 else
  $2=$.sheets($1).rows.count
 endif
 if vartype($3)
  if 3&lt;&gt;vartype($3) exit 87 endif
  if -1=$3
   for $!=1 to $.sheets($1).columns.count
    if not $.sheets($1).cells(1,$!).value
     $3=$!-1
     $!=$.sheets($1).columns.count
    endif
   next
  endif
 else
  $3=$.sheets($1).columns.count
 endif
 if vartype($4)
  if 3&lt;&gt;vartype($4) exit 87 endif
  if 1&gt;$4 exit 87 endif
 else
  $4=1
 endif
 if vartype($5)
  if 3&lt;&gt;vartype($5) exit 87 endif
  if 1&gt;$5 exit 87 endif
 else
  $5=1
 endif
 redim $_[$2-1,$3-1]
 $ReadExcel2=$_
 for $!=1 to $2-$4+1
  for $_=1 to $3-$5+1
   $ReadExcel2[$!-1,$_-1]=$.sheets($1).cells($!,$_).value
 next
next
 $.workbooks.Close
 $.quit
EndFunction
84660ReadFile31RadimusReadFile() - Read a file into an array0

;Function	ReadFile()  

;  

;Author		Radimus  

;  

;Contributors	Lonky... This is basically his code that I trimmed down to its  

;		simplest function  

;  

;Action		Reads a file into an array  

;  

;Syntax		$array=ReadFile($file)  

;  

;Version	1.0.1  

;  

;Date           10/21/2003  

;  

;Date Revised   10-22-2003 - dimmed vars 

;  

;Parameters 	file   

;		source filename  

;  

;Remarks	Pair this with WriteFile() to read and write an entire file easily  

;  

;Returns	@error if failed  

;   

;Dependencies 	None  

;  

;KiXtart Ver	4.02  

;   

;Example(s)	$array=ReadFile('c:\file.txt')  



Function ReadFile($file)

	Dim $lf, $f, $_, $t

	$lf=chr(10)

	$f=freefilehandle

	$_=open($f,$file)

		if @error   exit @error   endif

		do $t=$t+$lf+readline($f) until @error

		$_=close($f)

	$ReadFile=split(substr($t,2),$lf)

	EndFunction



[ 22. October 2003, 11:26: Message edited by: Radimus ]83749ReadFile119LonkeroReadFile() 
- returns asked amount of file in asked format0

code:

;Function:	ReadFile()
;
;Authors:	Lonkero
;
;Version:	1.0 (8th of December 2002)
;
;Action:	Read's File the specified amount from specified direction and returns in specified format
;
;Syntax:	ReadFile("FILE", "DELIM","AMOUNT")
;
;Parameters:
;		File	- full path to file to read
;		Delim	- optional output delim. if not specified, output is array
;		Amount	- optional. amount of lines to return. if negative, from end of file
;
;Returns:
;		the data in requested format and amount
;
;		on error errorcodes set:
;			1 -no free filehandle.
;			2 -could not open file.
;
;Dependencies:
;		kix 4.10+
;
;Remarks:
;		done on demand.
;		should have done a lot sooner as my coding nees drops a lot with this.
;
;Examples:	
;		"Last 5 lines from KixWeeper13.kix" ?
;		for each $line in ReadFile(@scriptdir+"\kixweeper13.kix",,-5)
;			$line ?
;		next
;			if @error "error @error" endif
;		get $
;
;		"first 3 lines from KixWeeper13.kix" ?
;		ReadFile(@scriptdir+"\kixweeper13.kix",chr(10),3) ;10 (newline) for showing directly on console
;		if @error "error @error" endif
;		get $
;Source:
function ReadFile($_file,optional $_delim,optional $_amount)
dim $
$=$_file
$_delim=""+$_delim
$_amount=0+$_amount
$_file=freefilehandle()
if 0=$_file exit 1 endif
if open($_file,$) exit 2 endif
$=""
do $=$+readline($_file)+chr(10) until @error
$ReadFile=split(left($,len($)-2),chr(10))
$=close($_file)
$=""
if $_amount<0
 for $_file=$_amount+ubound($ReadFile)+1 to ubound($ReadFile)
  $=$+$ReadFile[$_file]+chr(10)
 next
 $ReadFile=split(left($,len($)-1),chr(10))
endif
if $_amount>0
 for $_file=0 to $_amount-1
  $=$+$ReadFile[$_file]+chr(10)
 next
 $ReadFile=split(left($,len($)-1),chr(10))
endif
if $_delim $ReadFile=join($ReadFile,$_delim) endif
exit 0
endfunction



[ 08. December 2002, 14:36: Message edited by: Lonkero ]83636ReadFileHead1989WaltzReadFileHead() 
- Delivers the first #n lines of a file0

code:

 ;FUNCTION 	ReadFileHead()
 ;
 ;AUTHOR	Waltz
 ;
 ;CONTRIBUToR	Inspired by UNIX Head command.
 ;
 ;ACTION	Delivers the first #n lines of a file.
 ;
 ;SYNTAX	ReadFileHead($sFile, OPTIONAL $lNumb, OPTIONAL $lLineNum, OPTIONAL $lSkip)
 ;
 ;VERSION	1.2
 ;
 ;PARAMETERS	$sFile       [REQUIRED] String  - Name of the file to browse
 ;		$lNumb       [OPTIONAL] Integer - Number of lines to deliver - default is 10
 ;		$lLineNum    [OPTIONAL] Integer - Line Numbering - [1|0] - default is 0 (OFF)
 ;		$lSkip       [OPTIONAL] Integer - Number of lines to skip at start of the file
 ;
 ;REMARKS	Number of lines to deliver starting point is relative to the start of the file
 ;		If Number of lines to deliver exceeds content, all lines are delivered
 ;              If Number of lines to skip exceeds content, the last line is delivered
 ;              Number of lines to deliver range is 1 - 1000
 ; 		Related UDF - ReadFileTail()             
 ;
 ;RETURNS	String Array containing first #n lines of the file
 ;              Error Codes: 0 if successful, otherwise error codes
 ;                           24 if Number of lines exceeds upper limit 
 ;
 ;
 ;DEPENDENCIES	Function PadStr()
 ;             	http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000223
 ;
 ;KIXTART	VER KIX32 4.12 Beta 2
 ;
 ;EXAMPLES
 ;   **********************************************************************
 ; $asFileHead=ReadFileHead("MyLogFile.txt") - DEFAULT (10 lines,Numbering OFF)
 ; For $lCount=0 To Ubound($asFileHead)
 ;    $sFileLine=$asFileHead[$lCount]
 ;    $sFileLine?
 ; Next
 ;   **********************************************************************
 ;   ReadFileHead("MyLogFile.txt",,1)          - 10 lines, Numbering ON
 ;   ReadFileHead("MyLogFile.txt",15,1)        - 15 lines, Numbering OFF
 ;   ReadFileHead("MyLogFile.txt",15,1,4)      - 15 lines, Numbering ON, Skip 4 lines
 ;   ReadFileHead("MyLogFile.txt",1000)        - All lines, Numbering OFF
 ;   ReadFileHead("MyLogFile.txt",1000,1,20)   - All lines, Numbering ON, Skip 20 lines
 ;   ReadFileHead("MyLogFile.txt",1)           - First line, Numbering OFF
 ;   ReadFileHead("MyLogFile.txt",,1,1000)     - Last line, Numbering ON 
 ;
 ;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000293
 ;
 Function ReadFileHead($sFile, OPTIONAL $lNumb, OPTIONAL $lLineNum, OPTIONAL $lSkip)
    Dim $asLinesTmp1[999],$asLinesTmp2[999],$asLinesTmp3[999]
    Dim $lLineCount,$lEnd,$lStart,$lIndex1,$lIndex2,$lFh,$lOpen,$lClose
    Dim $sLineRead

    Select					
       Case VarType($lLineNum)=0		; Line Numbering
          $lLineNum=0				; default is OFF
       Case $lLineNum=0 OR $lLineNum=1		; acceptable
       Case $lLineNum<>0			; can be 0 or 1 only
          $lLineNum=0
       Case 1					; default is OFF
          $lLineNum=0				
    EndSelect

    Select					
       Case VarType($lNumb)=0			; Number of lines to deliver
          $lNumb=9				; default is 10 (array[9])
       Case $lNumb<=0				; can't be negative or zero
          $lNumb=9
       Case $lNumb>=1000			; maximum is 1000 (array[999])
          $lNumb=999
       Case $lNumb>0 AND $lNumb<1000		; acceptable (from 1 to 1000)
       Case 1					; default is 10 (array[9])
          $lNumb=9				
    EndSelect
  
    Select
       Case VarType($lSkip)=0			; Number of lines to skip
          $lSkip=0				; default is 0
       Case $lSkip<0				; can't be negative
          $lSkip=0
       Case $lSkip>=1000                        ; maximum is 1000 (array[999])
          $lSkip=999
       Case $lSkip>0 AND $lSkip<1000            ; acceptable (from 1 to 1000)
       Case 1					; default is 0
          $lSkip=0				
    EndSelect

    $lFh=FreeFileHandle()					
    If $lFh>0
       $lOpen=Open($lFh,$sFile,2)		; Open the file
       Select
          Case $lOpen=0
             $lLineCount=-1
             Do					; Read file into Input Array
                $lLineCount=$lLineCount+1
                If $lLineCount>Ubound($asLinesTmp1) ; too many lines
                    Exit(24)                    ; Error Code 24 is Error_Bad_Length
                EndIf 
                $asLinesTmp1[$lLineCount]=READLINE($lFh)
             Until @Error=-1
             $lClose=Close($lFh)                ; Close the file 
          Case $lOpen<0 OR $lOpen>0
             Exit(@Error)
       EndSelect
    EndIf

    $lLineCount=$lLineCount-1			; Resize Input Array

    ReDim Preserve $asLinesTmp1[$lLineCount]

    If $lNumb>=$lLineCount			; Number requested
       $lNumb=$lLineCount			; cannot exceed content
    EndIf 

    Select					; set the starting line
       Case $lSkip>0				; with Skip
          While ($lSkip+$lNumb) > $lLineCount And Not $lNumb <= 0
             $lNumb=$lNumb-1			; reduce Number requested
          Loop					; if Skip + Number exceed content
          If $lSkip>$lLineCount			; maximum Skip
             $lSKip=$lLineCount
          EndIf
          $lStart=$lSkip
       Case $lSkip=0				; without Skip
          $lStart=0
    EndSelect

    $lEnd=($lStart+$lNumb)			; set the ending line
	
    ReDim $asLinesTmp2[$lEnd]		
    $lIndex1=0					; Step Input Array FORWARD
    For $lIndex2=$lStart To $lEnd Step 1	; to build Temp Array
       If $lLineNum=1				; with Line Numbering ON
          $sLineRead="[" +PadStr(($lIndex2+1),"0","4")+ "] "+$asLinesTmp1[$lIndex2]
       Else					; with Line Numbering OFF
          $sLineRead=$asLinesTmp1[$lIndex2]
       EndIf
       $asLinesTmp2[$lIndex1]=$sLineRead
       $lIndex1=$lIndex1+1
    Next

    If $lSkip>0					; Resize Temp Array 
       $lIndex1=0				; to account for Skip
       For $lIndex1=0 To $lNumb Step 1
          $asLinesTmp3[$lIndex1]=$asLinesTmp2[$lIndex1]
       Next
       $asLinesTmp2=$asLinesTmp3
       ReDim Preserve $asLinesTmp2[$lNumb]
    EndIf

    $ReadFileHead=$asLinesTmp2			; Return Output Array
    Exit(0)
 EndFunction  



[ 06. November 2002, 23:08: Message edited by: Waltz ]83637ReadFileTail1989WaltzReadFileTail() 
- Delivers the last #n lines of a file0

code:

 ;FUNCTION 	ReadFileTail()
 ;
 ;AUTHOR	Waltz
 ;
 ;CONTRIBUToR	Inspired by UNIX Tail command.
 ;
 ;ACTION	Delivers the last #n lines of a file.
 ;
 ;SYNTAX	ReadFileTail($sFile, OPTIONAL $lNumb, OPTIONAL $lLineNum, OPTIONAL $lRev)
 ;
 ;VERSION	1.2
 ;
 ;PARAMETERS	$sFile       [REQUIRED] String  - Name of the file to browse
 ;		$lNumb       [OPTIONAL] Integer - Number of lines to deliver - default is 10
 ;		$lLineNum    [OPTIONAL] Integer - Line Numbering - [1|0] - default is 0 (OFF)
 ;		$lRev        [OPTIONAL] Integer - Reverse order  - [1|0] - default is 0 (OFF)
 ;
 ;REMARKS	Number of lines to deliver starting point is relative to the end of the file
 ;		If Number of lines to deliver exceeds content, all lines are delivered
 ;              If Reverse order is chosen, default is to deliver all lines
 ;              Number of lines to deliver range is 1 - 1000
 ;              Related Function - ReadFileHead()
 ;              
 ;
 ;RETURNS	String Array containing the last #n lines of the file
 ;              Error Codes: 0 if successful, otherwise error codes
 ;                           24 if Number of lines exceeds upper limit 
 ;
 ;
 ;DEPENDENCIES	Function PadStr()
 ;             	http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000223#000000
 ;
 ;KIXTART	VER KIX32 4.12 Beta 2
 ;
 ;EXAMPLES
 ;   **********************************************************************
 ; $asFileTail=ReadFileTail("MyLogFile.txt") - DEFAULT (10 lines,Numbering OFF,Reverse OFF)
 ; For $lCount=0 To Ubound($asFileTail)
 ;    $sFileLine=$asFileTail[$lCount]
 ;    $sFileLine?
 ; Next
 ;   **********************************************************************
 ;   ReadFileTail("MyLogFile.txt",,1)      - 10 lines, Numbering ON, Reverse OFF
 ;   ReadFileTail("MyLogFile.txt",15)      - 15 lines, Numbering OFF, Reverse OFF
 ;   ReadFileTail("MyLogFile.txt",15,1)    - 15 lines, Numbering ON, Reverse OFF
 ;   ReadFileTail("MyLogFile.txt",1000)    - All lines, Numbering OFF, Reverse OFF
 ;   ReadFileTail("MyLogFile.txt",1000,1)  - All lines, Numbering ON, Reverse OFF
 ;   ReadFileTail("MyLogFile.txt",,,1)     - All lines, Numbering OFF, Reverse ON 
 ;   ReadFileTail("MyLogFile.txt",,1,1)    - All lines, Numbering ON, Reverse ON
 ;   ReadFileTail("MyLogFile.txt",15,,1)   - 15 lines, Numbering OFF, Reverse ON
 ;   ReadFileTail("MyLogFile.txt",15,1,1)  - 15 lines, Numbering ON, Reverse ON
 ;
 ;
 Function ReadFileTail($sFile, OPTIONAL $lNumb, OPTIONAL $lLineNum, OPTIONAL $lRev)
    Dim $asLinesTmp1[999],$asLinesTmp2[999]
    Dim $lLineCount,$lEnd,$lStart,$lIndex1,$lIndex2,$lFh,$lOpen,$lClose,$lRevFlag
    Dim $sLineRead

    Select					                                 
       Case VarType($lRev)=0			; Reverse
          $lRev=0				; default is OFF
       Case $lRev=0 OR $lRev=1			; acceptable
       Case $lRev<>0 				; can be 0 or 1 only
          $lRev=0
       Case 1					; default is OFF
          $lRev=0					
    EndSelect

    Select					
       Case VarType($lLineNum)=0		; Line Numbering
          $lLineNum=0				; default is OFF
       Case $lLineNum=0 OR $lLineNum=1		; acceptable
       Case $lLineNum<>0			; can be 0 or 1 only
          $lLineNum=0
       Case 1					; default is OFF
          $lLineNum=0				
    EndSelect

    Select					
       Case VarType($lNumb)=0			; Number of lines to deliver
          $lNumb=9				; default is 10 (array[9])
          $lRevFlag=1				; unless Rev is ON
       Case $lNumb<=0				; can't be negative or zero
          $lNumb=9
       Case $lNumb>=1000			; maximum is 1000 (array[999])
          $lNumb=999
       Case $lNumb>0 AND $lNumb<1000		; acceptable (from 1 to 1000)
          $lNumb=$lNumb-1
       Case 1					; default is 10 (array[9])
          $lNumb=9					
    EndSelect

    $lFh=FreeFileHandle()					
    If $lFh>0
       $lOpen=Open($lFh,$sFile,2)		; Open the file
       Select
          Case $lOpen=0
             $lLineCount=-1
             Do					; Read file into Input Array
                $lLineCount=$lLineCount+1
                If $lLineCount>Ubound($asLinesTmp1) ; too many lines
                    Exit(24)                    ; Error Code 24 is Error_Bad_Length
                Endif 
                $asLinesTmp1[$lLineCount]=READLINE($lFh)
             Until @Error=-1
             $lClose=Close($lFh)                ; Close the file 
          Case $lOpen<0 OR $lOpen>0
             Exit(@Error)
       EndSelect
    EndIf

    $lLineCount=$lLineCount-1			; Resize Input Array
    ReDim Preserve $asLinesTmp1[$lLineCount]

    If $lNumb>$lLineCount			; Number requested
       $lNumb=$lLineCount			; cannot exceed content
    EndIf

    Select					
    Case $lRev=0				; Reverse is OFF					
       $lEnd=Ubound($asLinesTmp1)		; Last line to output
       $lStart=$lEnd-$lNumb			; First line to output
       ReDim $asLinesTmp2[$lNumb]		
       $lIndex1=0				; Step Input Array FORWARD
       For $lIndex2=$lStart To $lEnd STEP 1	; to build Output Array
          If $lLineNum=1			; with Line Numbering ON
             $sLineRead="[" +PadStr(($lIndex2+1),"0","4")+ "] "+$asLinesTmp1[$lIndex2]
          Else					; with Line Numbering OFF
             $sLineRead=$asLinesTmp1[$lIndex2]
          EndIf
          $asLinesTmp2[$lIndex1]=$sLineRead
          $lIndex1=$lIndex1+1
       Next
    Case $lRev=1				; Reverse is ON
       If $lRevFlag=1				; Default Number to deliver
          $lNumb=$lLineCount                    ; is ALL lines 
       EndIf
       $lStart=ubound($asLinesTmp1)		; First line to output
       $lEnd=$lStart-$lNumb			; Last line to output
       ReDim $asLinesTmp2[$lNumb]		
       $lIndex1=0				; Step Input Array BACKWARD
       For $lIndex2=$lStart To $lEnd STEP -1    ; to build output Array
          If $lLineNum=1			; with Line Numbering ON
             $sLineRead="[" +PadStr(($lIndex2+1),"0","4")+ "] "+$asLinesTmp1[$lIndex2]
          Else					; with Line Numbering OFF
             $sLineRead=$asLinesTmp1[$lIndex2]
          EndIf
          $asLinesTmp2[$lIndex1]=$sLineRead
          $lIndex1=$lIndex1+1   
       Next
    EndSelect

    $ReadFileTail=$asLinesTmp2			; Return Output Array
    Exit(0)
 EndFunction  



[ 09. December 2002, 14:45: Message edited by: Waltz ]128131ReadHTML52NTDOCReadHTML() 
- Retrieve Web page via XMLHTTP1098234880Code:


;Function			ReadHTML()

;AuthorJooel		(Lonkero), posted by NTDOC 

;Version			1.0 

;Date			2004/19/10

;Updated		    

;Action			Retrieves a web page into a string by supplying the URL   

; 

;Example:		Break On

;			Dim $SO  $SO=SetOption('Explicit','On')

;			$SO=SetOption('NoVarsInStrings','On')

;			Dim $MyPage

;			$MyPage=ReadHTML('www.kixhelp.com')

;			? $MyPage   

;

;Parameters		$page {location of the page you want to retrieve}   

;Dependencies		KiXtart 4.x, IE5 (or the Microsoft MSXML Parser)   

;Notes			PRB: Application Errors Occur After You Run Xmlinst.exe on Production Servers   

;			http://support.microsoft.com/kb/278636

;

;Source:  		

  

Function ReadHTML($page)

Dim $obj

 $obj=createobject("microsoft.xmlhttp")

 $obj.open("get",$page,not 1)

 $obj.send

 $readHTML=$obj.responsebody

EndFunction


82319ReadLineEx107mvdwReadLineEx() - Extended functionality for the 
ReadLine function0I figured it was time to give the function it's place in the 
UDF section...

ReadlineEx()
Action:
Readline function with the ability to read a specific line, numbered either from 
start or end.
Or search for the first or last line containing a specific string.

Author:
Maarten van der Woord

Syntax:
ReadLineEx($filename,$mode,[$linenumber],[$string])

Parameters:
$filename : The full path to the file to read the line from
$mode : Specifies what mode of the function you want to use
$linenumber : Optional - The specific line to read from the file
$string : Optional - The string to search for

Returns:
An Array of two elements namely:
[0] The string representing the line that meets the specified criteria
[1] The number of that line

The string that is returned depends on the mode :
1 : Get specific line as set by $linenumber
2 : Get the first line of the file that contains the string defined by $string
3 : Get the last line of the file that contains the string defined by $string
4 : Get the last line of the file minus $linenumber of lines (0 to return the 
last line of the file)

Remarks:
This function sets the @error as follows :
0 : The function found a line that meets the criteria specified
-1 : Invalid parameter(s) where entered
-2 : The function could not find a line that meets the specified criteria
>0 : The function encountered an error opening the file (check @serror for a 
description)

Dependencies:
KiXtart 4.0 (Final)

Example(s):
@curdir\test.txt contains :
This is the first line
This is the second linex
This is the third line
This is the fourth linex

This is the seventh line

$file = @curdir\test.txt

ReadLineEx($file,1,3)
$ReadLineEx[0] : "This is the third line"
$ReadLineEx[1] : 3
@error : 0
ReadLineEx($file,2,1,"x")
$ReadLineEx[0] : "This is the second linex"
$ReadLineEx[1] : 2
@error : 0
ReadLineEx($file,3,1,"x")
$ReadLineEx[0] : "This is the fourth linex"
$ReadLineEx[1] : 4
@error : 0
ReadLineEx($file,4,3)
$ReadLineEx[0] : "This is the fourth linex"
$ReadLineEx[1] : 4
@error : 0
ReadLineEx($file,4,0)
$ReadLineEx[0] : "This is the seventh line"
$ReadLineEx[1] : 7
@error : 0

code:

<pre>
Function ReadLineEx ($_Sourcefile,$_FuncMode,optional $_LineNum,optional $_SearchString)

dim $TempLineRead
dim $_i, $_ctr, $_LastLine, $_LastLineNum, $_TempLineNum
dim $_Array[1]
dim $_TempArray[1]

$_Array[0] = ""
$_Array[1] = ""
if (vartypename ($_FuncMode) <> "long") Or (vartypename ($_Sourcefile) <> "string")
	;No valid options were passed into the udf, exit function
	$ReadLineEx = $_Array
	exit -1
endif

if open (9,$_Sourcefile,2) = 0
	$TempLineRead = ReadLine (9)
	$_ctr = 1

	Select

	Case $_FuncMode = 1

		if (vartypename ($_LineNum) <> "Long") Or ($_LineNum < 1)
			if close (9) = 0 endif
			$ReadLineEx = $_Array
			exit -1
		endif
		if $_LineNum = 1
			$_Array[0] = $TempLineRead
			$_Array[1] = $_LineNum
			if close (9) = 0 endif
			$ReadLineEx = $_Array
			exit 0
		else
			for $_i = 2 to $_LineNum
				$TempLineRead = ReadLine (9)
				if @error <> 0
					if close (9) = 0 endif
					$ReadLineEx = $_Array
					exit -1
				endif
			next
			$_Array[0] = $TempLineRead
			$_Array[1] = $_LineNum
			if close (9) = 0 endif
			$ReadLineEx = $_Array
			exit 0
		endif

	Case $_FuncMode = 2

		if (vartypename ($_SearchString) <> "string")
			if close (9) = 0 endif
			$ReadLineEx = $_Array
			exit -1
		endif
		if Instr ($TempLineRead,$_SearchString)
			$_Array[0] = $TempLineRead
			$_Array[1] = $_ctr
			if close (9) = 0 endif
			$ReadLineEx = $_Array
			exit 0
		else
			While (@error = 0) And (Instr ($TempLineRead,$_SearchString) = 0)
				$TempLineRead = ReadLine (9)
				$_ctr = $_ctr + 1
			loop
			if Instr ($TempLineRead,$_SearchString)
				$_Array[0] = $TempLineRead
				$_Array[1] = $_ctr
				if close (9) = 0 endif
				$ReadLineEx = $_Array
				exit 0
			else
				if close (9) = 0 endif
				$ReadLineEx = $_Array
				exit -2
			endif
		endif
	
	Case $_FuncMode = 3

		if (vartypename ($_SearchString) <> "string")
			if close (9) = 0 endif
			$ReadLineEx = $_Array
			exit -1
		endif
		$_lastLineNum = 0
		if Instr ($TempLineRead,$_SearchString)
			$_LastLine = $TempLineRead
			$_LastLineNum = 1
		endif
		While (@error = 0)
			$TempLineRead = ReadLine (9)
			$_ctr = $_ctr + 1
			if Instr ($TempLineRead,$_SearchString)
				$_LastLine = $TempLineRead
				$_LastLineNum = $_ctr
			endif
		loop
		if $_LastLineNum > 0
			$_Array[0] = $_LastLine
			$_Array[1] = $_LastLineNum
			if close (9) = 0 endif
			$ReadLineEx = $_Array
			exit 0
		else
			$ReadLineEx = $_Array
			exit -2
		endif


	Case $_FuncMode = 4

		if (vartypename ($_LineNum) <> "Long") Or ($_LineNum < 0)
			if close (9) = 0 endif
			$ReadLineEx = $_Array
			exit -1
		endif

		if open (8,$_Sourcefile,2) = 0
		endif
		While (@error = 0)
			$TempLineRead = ReadLine (8)
			$_ctr = $_ctr + 1
		loop
		$_i = ($_ctr - 2)
	
		if $_LineNum >= $_i
			if close (8) = 0 endif
			if close (9) = 0 endif
			$ReadLineEx = $_Array
			exit -1
		endif
		
		$_TempLineNum = $_i - $_LineNum
		if close (8) = 0 endif
		if open (8,$_Sourcefile,2) = 0
		endif
		for $_ctr = 1 to $_TempLineNum
			$TempLineRead = ReadLine (8)
		next
		$_Array[0] = $TempLineRead
		$_Array[1] = $_TempLineNum
		if close (8) = 0 endif
		if close (9) = 0 endif
		$ReadLineEx = $_Array
		exit 0
		

	Case 1

		if close (9) = 0 endif
		$ReadLineEx = $_Array
		exit -1
	debug off
	Endselect
else
	;Unable to open the Sourcefile
	$ReadLineEx = $_Array
	exit @error
endif

endfunction



[ 16. April 2003, 22:16: Message edited by: mvdw ]136605Read_Modify_XPFirewall52NTDOCRead_Modify_XPFirewall() 
- Reads or Modifies XP firewall settings0

;Function		Read_Modify_XPFirewall() 
; 
;Author			NTDOC 
; 
;Contributors 
; 
;Action			Reads or Modifies the Windows XP firewall settings if not currently enabled. 
; 
;Syntax			Read_Modify_XPFirewall($Profile,$Action,$Noti,$Allow,$Fire,optional $sComputer) 
; 
;NOTE			ICF DomainProfile 
;			Defines changes to Windows Firewalls default configuration when a computer is connected 
;			to a network that contains domain controllers for the domain of which the computer  
;			is a member. 
; 
;			ICF StandardProfile 
;			Defines changes to Windows Firewalls default configuration when a computer is not 
;			connected to a network that contains domain controllers for the domain of which the 
;			computer is a member. If a computer is not a member of a domain, Windows Firewall uses 
;			the configuration stored in the standard profile. 
; 
;Version		1.0 
; 
;Date			2005/03/28 
; 
;Date Revised	 
; 
;Reason Revised 
; 
;Parameters		First parm is which Profile to use it can be either D for Domain or S for Standard or B 
;			for Both, any other value will exit the function 
;			Second parm is to Read or Write the setting.  Read=0  Write=1 
;			Third parm is to set DisableNotifications to either SET=1 or DO NOT SET=0 
;			Fourth parm is to set DoNotAllowExceptions to either SET=1 or DO NOT SET=0 
;			Fifth parm is to set EnableFirewall to either SET=1 or DO NOT SET=0 
;			Sixth parm is the name of the system to run this against but is optional.   
;			If not supplied it runs against the local computer. 
; 
;Remarks		This UDF is mainly for those who are unable to use GPO (preferred method).  This is  
;			mainly designed to be used before the rollout of SP2.   
;			Once the firewall has been enabled this UDF can only be used locally by a user with  
;			local Admin rights. 
; 
;Returns		The currently set values of the firewall if the Action is set to Read and the firewall 
;			is not currently enabled. 
; 
;Dependencies		None 
; 
;KiXtart Ver		4.x 
;  
;Example(s)		$XPFire = Read_Modify_XPFirewall('D',1,0,1,1,'computer1') 
;			Sets DisableNotifications to 0 
;			DoNotAllowExceptions to 1 
;			EnableFirewall to 1 
;			Run against COMPUTER1 
; 
;			$XPFire = Read_Modify_XPFirewall('D',0,0,1,1,'computer1') 
;			Reads the settings of the firewall for COMPUTER1 since Action is set to 0 
; 
;CODE 
; 
 

 

Function Read_Modify_XPFirewall($Profile,$Action,$Noti,$Allow,$Fire,optional $sComputer)
  Dim $DProfile, $SProfile, $DNoti, $DAllow, $DFire, $SNoti, $SAllow, $SFire,  $Set
  $DNoti="" $DAllow="" $DFire="" $SNoti="" $SAllow="" $SFire=""
  If $sComputer
    $sComputer = '\\' + Join(Split($sComputer,'\'),'',3) + '\'
  EndIf
  $DProfile = $sComputer + 'HKLM\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\DomainProfile'
  $SProfile = $sComputer + 'HKLM\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\StandardProfile'
  If $Action = 1
    Select
      Case $Profile = 'D' ; Writes supplied value to Domain profile 
        $Set = WriteValue($DProfile,'DisableNotifications',$Noti,REG_DWORD)
        $Set = WriteValue($DProfile,'DoNotAllowExceptions',$Allow,REG_DWORD)
        $Set = WriteValue($DProfile,'EnableFirewall',$Fire,REG_DWORD)
      Case $Profile = 'S' ; Writes supplied value to Standard profile 
        $Set = WriteValue($SProfile,'DisableNotifications',$Noti,REG_DWORD)
        $Set = WriteValue($SProfile,'DoNotAllowExceptions',$Allow,REG_DWORD)
        $Set = WriteValue($SProfile,'EnableFirewall',$Fire,REG_DWORD)
      Case $Profile = 'B' ; Writes supplied value to both profiles 
        $Set = WriteValue($DProfile,'DisableNotifications',$Noti,REG_DWORD)
        $Set = WriteValue($DProfile,'DoNotAllowExceptions',$Allow,REG_DWORD)
        $Set = WriteValue($DProfile,'EnableFirewall',$Fire,REG_DWORD)
        $Set = WriteValue($SProfile,'DisableNotifications',$Noti,REG_DWORD)
        $Set = WriteValue($SProfile,'DoNotAllowExceptions',$Allow,REG_DWORD)
        $Set = WriteValue($SProfile,'EnableFirewall',$Fire,REG_DWORD)
      Case 1
        Exit 1
    EndSelect
  Else
        $DNoti  = ReadValue($DProfile,'DisableNotifications')
        $DAllow = ReadValue($DProfile,'DoNotAllowExceptions')
        $DFire  = ReadValue($DProfile,'EnableFirewall')
        $SNoti  = ReadValue($SProfile,'DisableNotifications')
        $SAllow = ReadValue($SProfile,'DoNotAllowExceptions')
        $SFire  = ReadValue($SProfile,'EnableFirewall')
  EndIf
  $Read_Modify_XPFirewall=$DNoti, $DAllow, $DFire, $SNoti, $SAllow, $SFire
EndFunction
 
136866Read_Modify_XPPopUpBlocker52NTDOCRead_Modify_XPPopUpBlocker() - Reads 
or Modifies XP SP2 Popup Blocker0

;Function	Read_Modify_XPPopUpBlocker()  
;  
;Author		NTDOC  
;  
;Contributors  
;  
;Action		Reads or Modifies the Windows XP Popup Blocker from Windows XP SP2  
;  
;Syntax		Read_Modify_XPPopUpBlocker($Action,$Popset,$Sound,$InfoBar,$Level,optional 
;		$Allowed,$Remove)  
;  
;NOTE		UDF does not check to confirm if the system is XP SP2, since the data is  
;		stored in HKCU you can not run this against a remote system. 
 
;Version	1.0  
;  
;Date		2005/03/31  
;  
;Date Revised  
;  
;Reason Revised  
;  
;Remarks	First parm is to Read or Write the setting. Read=0 Write=1  
;		Second parm is to set the Popup Blocker. Disable=0 Enable=1 
;		Third parm is to enable sound.  Disable=0 Enable=1 
;		Fourth parm is to enable Information Bar. Disable=0 Enable=1 
;		Fifth parm is to set the security level. L=Low, M=Medium, H=High 
;		Any other value will exit the UDF for the Security setting.  
;		Sixth parm is the name of a URL to add to the allowed no block list 
;		Seventh parm is the name of a URL to remove from the no block list 
; 
;Returns	The currently set values of the Popup Blocker 
;  
;Dependencies	XP SP2 
;  
;KiXtart Ver	4.2x 
;  
;Example: 
;		Dim $Popup 
;		$Popup = Read_Modify_XPPopUpBlocker(0,1,1,1,'M','www.ucla.edu','www.winzip.com') 
;		If VarType($Popup)>8 
;			?? 'Popup Set: ' + $Popup[0] 
;			? 'Sound Set: ' + $Popup[1] 
;			? 'InfoBar Set: ' + $Popup[2] 
;			? 'Security Level Set: ' + $Popup[3] 
;			? 'Sites in List: ' + $Popup[4] 
;		Else 
;			? 'Error gathering or setting data - err: ' + @ERROR 
;		EndIf 
; 
;Example: 
;		$Popup = Read_Modify_XPPopUpBlocker(0,1,1,1,'M','www.ucla.edu','www.winzip.com') 
;		Since $Action is set to 0 it will read the settings and ignore the  
;		other entries 
; 
;Example Output: 
;		Popup Set: Yes 
;		Sound Set: 1 
;		InfoBar Set: 1 
;		Security Level Set: M 
;		Sites in List: www.BigCorp.com www.msn.com www.usc.edu www.hp.com  
;		www.ucla.edu www.winzip.com 
; 
;Example: 
;		$Popup = Read_Modify_XPPopUpBlocker(1,1,1,1,'M','www.ucla.edu','www.winzip.com') 
;		Since $Action is set to 1 and $Popset = 1 it will Enable the popup blocker,  
;		add www.ucla.edu to allowed list enable sound and Information Bar, will set 
;		security to Medium and remove www.winzip.com from the allowed list 
; 
;		Example Output would be blank since we are not reading, but by resetting  
;		$Action to 0 and running the script again we would now see this output  
;		(notice www.winzip.com has been removed) 
;		Popup Set: Yes 
;		Sound Set: 1 
;		InfoBar Set: 1 
;		Security Level Set: M 
;		Sites in List: www.BigCorp.com www.msn.com www.usc.edu www.hp.com www.ucla.edu 
; 
;Example: 
;		$Popup = Read_Modify_XPPopUpBlocker(1,0,1,1,'H','www.ign.com','www.winzip.com') 
;		Since $Action is set to 1 and $Popset = 0 it will disable the blocker, but  
;		add www.ign.com and enable Audio and enable the Information Bar, set security 
;		to High, and remove www.winzip.com 
;CODE 
 

Function Read_Modify_XPPopUpBlocker($Action,$Popset,$Sound,$InfoBar,$Level,optional $Allowed,$Remove)
  Dim $PopUpKey, $Set, $Index, $Sites, $AllSites
  Dim $RSound, $RPopup, $RInfoBar, $BlockUserInit, $UseTimerMethod, $UseHooks, $AllowHTTPS, $RLevel
  $RSound="" $RPopup="" $RInfoBar="" $BlockUserInit="" $UseTimerMethod=""
  $UseHooks="" $AllowHTTPS="" $RLevel=""
  $PopUpKey = 'HKCU\Software\Microsoft\Internet Explorer\New Windows'
  If $Action = 1
    If $Popset = 0 $Set = WriteValue($PopUpKey,'PopupMgr','No',REG_SZ)
    Else $Set = WriteValue($PopUpKey,'PopupMgr','Yes',REG_SZ) EndIf
    $Set = WriteValue($PopUpKey+'\'+'Allow',$Allowed,'',REG_BINARY)
    $Set = WriteValue($PopUpKey,'PlaySound',$Sound,REG_DWORD)
    $Set = WriteValue($PopUpKey,'UseSecBand',$InfoBar,REG_DWORD)
    $Set = DelValue($PopUpKey+'\'+'Allow',$Remove)
    Select
      Case $Level = 'L'
        $Set = WriteValue($PopUpKey,'BlockUserInit',0,REG_DWORD)
        $Set = WriteValue($PopUpKey,'UseTimerMethod',1,REG_DWORD)
        $Set = WriteValue($PopUpKey,'UseHooks',1,REG_DWORD)
        $Set = WriteValue($PopUpKey,'AllowHTTPS',1,REG_DWORD)
      Case $Level = 'M'
        $Set = WriteValue($PopUpKey,'BlockUserInit',0,REG_DWORD)
        $Set = WriteValue($PopUpKey,'UseTimerMethod',0,REG_DWORD)
        $Set = WriteValue($PopUpKey,'UseHooks',1,REG_DWORD)
        $Set = WriteValue($PopUpKey,'AllowHTTPS',0,REG_DWORD)
      Case $Level = 'H'
        $Set = WriteValue($PopUpKey,'BlockUserInit',1,REG_DWORD)
        $Set = WriteValue($PopUpKey,'UseTimerMethod',0,REG_DWORD)
        $Set = WriteValue($PopUpKey,'UseHooks',0,REG_DWORD)
        $Set = WriteValue($PopUpKey,'AllowHTTPS',0,REG_DWORD)
      Case 1
        Exit 1
    EndSelect
  Else
    $RPopup = ReadValue($PopUpKey,'PopupMgr')
    $RSound = ReadValue($PopUpKey,'PlaySound')
    $RInfoBar = ReadValue($PopUpKey,'UseSecBand')
    $BlockUserInit = ReadValue($PopUpKey,'BlockUserInit')
    $UseTimerMethod = ReadValue($PopUpKey,'UseTimerMethod')
    $UseHooks = ReadValue($PopUpKey,'UseHooks')
    $AllowHTTPS = ReadValue($PopUpKey,'AllowHTTPS')
    Select
      Case $BlockUserInit=0 And $UseTimerMethod=1 And $UseHooks=1 And $AllowHTTPS=1
        $RLevel = 'L'
      Case $BlockUserInit=0 And $UseTimerMethod=0 And $UseHooks=1 And $AllowHTTPS=0
        $RLevel = 'M'
      Case $BlockUserInit=1 And $UseTimerMethod=0 And $UseHooks=0 And $AllowHTTPS=0
        $RLevel = 'H'
      Case 1 ; Unknown error 
        Exit 1
    EndSelect
    $Index = 0
    While @ERROR = 0
      $Sites = EnumValue($PopUpKey+'\'+'Allow',$Index)
      $Index = $Index + 1
      If $Sites
        $AllSites = $AllSites + $Sites + ','
      EndIf
    Loop
    $AllSites = Trim(Join(Split($AllSites,','),' '))
  EndIf
  $Read_Modify_XPPopUpBlocker=$RPopup,$RSound,$RInfoBar,$RLevel,$AllSites
EndFunction
 

82842RebootWarning17SealeopardRebootWarning() - Displays a warning message 
to reboot computer or forces a reboot0

code:

;FUNCTION      Reboot
;
;ACTION        Forces a computer reboot
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2 removed dependencies
;              1.1
;
;DATE CREATED  2002/01/18
;
;DATE MODIFIED 2003/05/17
;
;KIXTART       4.12+
;
;SYNTAX        REBOOT()
;
;PARAMETERS    none
;
;RETURNS       0 if successful, otherwise errorcode
;
;REMARKS       customized reboot UDF for use in KSMS, hence the WRITEVALUE
;
;DEPENENCIES   none
;
;EXAMPLE       $retcode=reboot()
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000140
;
function reboot()
  Dim $sRegKey

  $reboot = writevalue('HKEY_LOCAL_MACHINE\SOFTWARE\KiXtart\KSMS','RebootWarning',0,'REG_SZ')

  if @INWIN = 1
    $reboot=shutdown('','Rebooting '+@WKSTA+' due to network changes or pending file replacements.',10,1,1)
  else
    ; cannot get anything else to work reliably on Windows 9x
    $sRegKey = 'HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce'
    $reboot = writevalue($regkey,'0-Reboot','%WINDIR%\RUNDLL SHELL.DLL,RestartDialog','REG_SZ')
    $reboot = writevalue($regkey,'1-Reboot','%WINDIR%\RUNDLL SHELL32.DLL,SHExitWindowsEx 6','REG_SZ')
    $reboot = writevalue($regkey,'2-Reboot','%WINDIR%\RUNDLL32 SHELL32.DLL,SHExitWindowsEx 6','REG_SZ')
    $reboot = writevalue($regkey,'3-REboot','%WINDIR%\RUNDLL32.EXE user.exe,ExitWindowsExec','REG_SZ')
    $reboot = writevalue($regkey,'3-Reboot','%WINDIR%\RUNDLL32.EXE user.exe,ExitWindows','REG_SZ')
  endif

  exit @ERROR
endfunction



[ 18. May 2003, 23:16: Message edited by: sealeopard ]121701recLs5351todorprecLs() 
- List of files, properties of a dir1087973832I needed to track and diff the 
file versions and the cmd dir can't do it and couldn't find another command line 
tool 

cheers 

Code:

 

;Function	recLs( $baseDir, $offsetDir, $outFile, $Handle )

;

;Author		todorp

;

;Contributors	KiX documentation

;

;Action		writes to the $outFile 

;

;Syntax		recLs( $baseDir, $offsetDir, $outFile, $Handle )

;

;Version	1.0

;

;Date           2004/06/23

;

;Date Revised   2004/06/23

;

;Parameters 	$baseDir 

;		

;

;Remarks	

;	recursive (depth first) script

;	lists the files and their properties of a directory and its sub directories

;	uses GetFileAttr( ), GetFileSize( ), GetFileVersion( )

;

;	can be used to track the changes in a directory

;	e.g. new files, deleted files, files changed, sizes, versions, etc.

;

;	I needed to track and diff the file versions and the cmd dir can't do it

; 

;Dependencies 	None

;

;KiXtart Ver	4.22

; 

;Example recLs( "c:", "winnt\system32", "c:\temp\ttt.txt", 0 )

;

   



Function recLs( $baseDir, $offsetDir, $outFile, $Handle )

	dim $FileName[100], $rec, $i, $s, $didIOpened

	

	if  ($Handle < 1)

		del $outFile	; I don't want to append

		$Handle = FreeFileHandle()

		if $Handle < 1

			? "There is no FreeFileHandle" + @CRLF

			quit

		endif

	

		if Open( $Handle, $outFile, 5 ) = 0

			$didIOpened = 1	

			? $outFile + " File opened for writing" + @CRLF

			WriteLine( $Handle , "baseDir=" + $baseDir  + @CRLF )

		else

			? $outFile + " File failed to open the $out_file file, error code : [" + @ERROR + "]"

			quit

		endif	

	endif

	

	$rec = 0

	$FileName[$rec] = Dir( $baseDir + "\" + $offsetDir )

	$s = 100

	; $g = is left out to write a 0 to the console ;) for each directory treversed

	; I was very puzzeled initialy where the 0 on the screen are comming from ??? :)

	WriteLine( $Handle , $offsetDir + "\" + $FileName[$rec] + " is a dir" + @CRLF )

	$g = WriteLine( $Handle , "FileName|Size|FileVersion" + @CRLF )

	

	While $FileName[$rec] <> "" and @ERROR = 0

		if $rec >= $s

			$s = $s + 100

			redim preserve $FileName[ $s ]

		endif

		$rec = $rec + 1	

		$FileName[$rec] = Dir() ; get the next file name

	Loop

	;

	;	It had to be in two loops because Dir can have only 2 contexts

	;

	if ($rec - 1) >= 2 ; [0] and [1] are . and ..

		for $i = 2 to $rec - 1

			$fileURL = $baseDir + "\" + $offsetDir + "\" + $FileName[$i]

			if  (GetFileAttr( $fileURL ) & 16) ; is this a directory

				$g = recLs( $baseDir, $offsetDir + "\" + $FileName[$i], $outFile, $Handle )

			else

				$g = WriteLine( $Handle , $FileName[$i] + "|" + GetFileSize( $fileURL ) +  "|" + GetFileVersion( $fileURL, "FileVersion" ) + @CRLF )

			endif

		next

	endif

	

	if $didIOpened == 1

		close( $Handle )

	endif

	$FileName=""

	$recLs = ""

	

EndFunction



Edited according to Basta's notes164087RefreshDesktop3439AllenRefreshDesktop() 
- Refresh the Desktop0Code:

;Function:  
; RefreshDesktop(),  
;  
;Author  
; Allen Powell (inspired by someone or some link found elsewhere) 
; 
;Version:  
; 1.0.0  2006/07/05 
;  
;Action:  
; Refreshes the Desktop, simulates pressing the F5 key  
;  
;Syntax:  
; RefreshDesktop() 
; 
;Parameters:  
; none 
; 
;Returns 
; nothing 
;  
;Dependencies 
;  Kixtart 4.x 
; 
function RefreshDesktop()
  dim $
  $=SetFocus("Program Manager")
  $=SendKeys("{F5}")
endfunction

84450RegASCIItoHEX28BryceRegASCIItoHEX()0

code:

;FUNCTION RegASCIItoHEX
;
;AUTHOR Bryce
;
;ACTION Converts a ASCII string to a HEX string that can be written to the registry.
;
;SYNTAX RegASCIItoHEX($string)
;
;PARAMETERS String - string of ASCII to be converted
;
;RETURNS the HEX version of the given ASCII string
;
;DEPENDENCIES none.
;
;EXAMPLE
; $categories = "Things;More things;And even more things!!"
; ? RegASCIItoHEX($categories)
;
;CODE
Function RegASCIItoHEX($data)
	dim $return, $i
	$return = ""

	for $i = 1 to len($data)
		$return = $return + dectohex(asc(substr($data,$i,1)))+ "00"
	next
	$return = lcase($return) + "0000"
	$regASCIItoHex = $return
endfunction



[ 04. October 2003, 21:12: Message edited by: NTDOC ]84449RegHEXtoASCII28BryceRegHEXtoASCII()0

code:

;FUNCTION RegHEXtoASCII
;
;AUTHOR Bryce
;
;ACTION Converts a registry HEX string key to an ASCII string
;
;SYNTAX RegHEXtoASCII($string)
;
;PARAMETERS String - string of HEX to be converted
;
;RETURNS the ASCII version of the given HEX string
;
;DEPENDENCIES none.
;
;EXAMPLE
; $xpkey = "HKEY_CURRENT_USER\Software\Microsoft\Office\10.0\Outlook\Categories"
; ? "The list of Categories in outlook 2002"
; ? RegHEXtoASCII(readvalue($xpkey,"Masterlist"))
;
;CODE
Function RegHextoAscii($data)
	dim $return, $i, $hex
	for $i = 1 to len($data) step 2
		$hex = "&" + substr($data,$i,2)
		$return = $return + chr(val($hex))
	next
	$reghextoascii = $return
endfunction



[ 04. October 2003, 21:14: Message edited by: NTDOC ]116656RegMultiSzToArray288jtokachRegMultiSzToArray() 
- Translates REG_MULTI_SZ data0 Code:

;FUNCTION       RegMultiSzToArray()

;

;ACTION         Translates REG_MULTI_SZ list data and stores the elements into an array.

;

;AUTHOR         James Tokach

;

;CONTRIBUTERS	Richard H.

;

;VERSION        1.0

;

;DATE CREATED   2004/10/23

;

;DATE MODIFIED  N/A

;

;KIXTART        Tested only with 4.22

;

;SYNTAX         $ReturnCode = RegMultiSzToArray($Data)

;

;PARAMETERS     $Data

;               Hex data retrieved from a .REG export file

;

;RETURNS        An array of converted values

;

;REMARKS        Many thanks to Richard H. for this contribution

;               http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=115320&page=0&view=collapsed&sb=5&o=&fpart=1

;

;               The example formats the array data into KiXtart's WriteValue() format

;

;DEPENDENCIES   None

;

;EXAMPLE        Break On

;               $=SetOption("WrapAtEOL","ON")

;

;               ;$Regdata="31,00,00,00,32,00,00,00,33,00,00,00,34,00,00,00,35,00,00,00,00,00"

;

;               $Regdata="25,00,41,00,70,00,70,00,44,00,61,00,74,00,61,00,"

;                 +"25,00,00,00,25,00,55,00,73,00,65,00,72,00,50,00,72,00,6f,00,66,00,69,00,6c,"

;                 +"00,65,00,25,00,00,00,25,00,41,00,6c,00,6c,00,55,00,73,00,65,00,72,00,73,00,"

;                 +"50,00,72,00,6f,00,66,00,69,00,6c,00,65,00,25,00,00,00,25,00,50,00,72,00,6f,"

;                 +"00,67,00,72,00,61,00,6d,00,46,00,69,00,6c,00,65,00,73,00,25,00,00,00,25,00,"

;                 +"53,00,79,00,73,00,74,00,65,00,6d,00,52,00,6f,00,6f,00,74,00,25,00,00,00,25,"

;                 +"00,53,00,79,00,73,00,74,00,65,00,6d,00,44,00,72,00,69,00,76,00,65,00,25,00,"

;                 +"00,00,25,00,54,00,65,00,6d,00,70,00,25,00,00,00,25,00,54,00,6d,00,70,00,25,"

;                 +"00,00,00"

;

;               $Array=RegMultiSzToArray($Regdata)

;               $FormattedString=join($Array,"|")

;               If Right($FormattedString,1)<>"|"

;                   $FormattedString=$FormattedString+"|"

;               EndIf

;               ? $FormattedString

;

;KIXTART BBS	http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=115416&page=0&view=collapsed&sb=5&o=&fpart=&vc=

;

Function RegMultiSzToArray($Data)

	Dim $DataChar,$DataTranslated

  

	; Remove commas if present.

	If InStr($Data,",") $Data=Join(Split($Data,","),"") EndIf

  

	While $Data

		$DataChar=Left($Data,2)

		If $DataChar<>"00"

			$DataTranslated=CStr($DataTranslated)+CStr(Chr(Execute('Exit &'+$DataChar)))

		Else

			Redim Preserve $RegMultiSzToArray[UBound($RegMultiSzToArray)+1]

			$RegMultiSzToArray[UBound($RegMultiSzToArray)]=$DataTranslated

			$DataTranslated=""

		EndIf

		$Data=SubStr($Data,5)

	Loop

EndFunction  

83816RegRename735singkRegRename() - Rename the Outlook Profile in registry0;----------------------------------------------------------------------------------------
; NAME: RegRename
; Version: 1.00 2/18/2003
; Author: Sing Kingdavong
; Action: copy a registry subkey and rename to the new value.
; DEPENDENCIES: ArrayEnumKey() and ArrayEnumValue() 
;
; Usage: RegRename(SubKey,NewProfile)
; SubKey: Subkey to start recursive scan of registry
; NewProfile: New Profile name
;
; Example:
; To rename the subkey of an exchange mail server Outlook Profile:
; $SubKey="HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows 
Messaging Subsystem\Profiles"
; $NewProfile=@UserID
; RegRename($SubKey,$NewProfile)
;----------------------------------------------------------------------------------------

code:

Function RegRename($SubKey,$NewProfile)
Dim $ProfileValue, $SubValue, $sType, $rValue

;Get the DefautlProfile
$DefaultProfile=ReadValue($subkey,"DefaultProfile")
if @ERROR = 0
for each $ProfileValue in arrayenumkey($subkey)
   if $ProfileValue=$DefaultProfile
   $Nul = ADDKey($subkey+"\"+$NewProfile)
	for each $SubValue in arrayenumkey($subkey+"\"+$ProfileValue)
	$Nul = ADDKey($subkey+"\"+$NewProfile+"\"+$subvalue)
	   if $Subvalue<>""
	      for each $svalue in arrayenumValue($subkey+"\"+$ProfileValue+"\"+$subvalue)
		  $sType=ReadType($subkey+"\"+$ProfileValue+"\"+$subvalue,$sValue)
		  if @ERROR = 0
		     $rValue=ReadValue($subkey+"\"+$ProfileValue+"\"+$subvalue,$sValue)
		     if @ERROR = 0
			$Nul = WriteValue($subkey+"\"+$NewProfile+"\"+$subvalue,$sValue,$rValue,$sType)
		     endif
		   endif
	      Next
	   endif
	next
	; Set the new copied profile as DefualtProfile
	$Nul = WriteValue($subkey,"DefaultProfile",$NewProfile,"REG_SZ")
	; Delete the old Profile
	$Nul =  DelTree($SubKey+"\"+$ProfileValue)
    endif
Next
endif
EndFunction 



[ 05. March 2003, 17:40: Message edited by: singk ]141982RegUpdate52NTDOCRegUpdate() 
- Local/Remote registry datatype update0

;Function		RegUpdate()  
;  
;Author			NTDOC  
;  
;Action			Enables local/remote registry updates including replacment of datatype for an existing value 
;  
;Syntax			RegUpdate($Key,$Value,$Data,optional $DataType,$Overwrite,$sComputer) 
;			$Key is the Registry key - example: HKLM\Software\Microsoft 
;			$Value is the Registry value - example: HKLM\Software\Microsoft,'Display' 
;			$Data is the Registry entry for the value - example: HKLM\Software\Microsoft,'Display','Sony' 
;			$DataType is the type of value: (all possible values not listed) 
;				REG_NONE 
;				REG_SZ 
;				REG_EXPAND_SZ 
;				REG_BINARY 
;			$Overwrite enables an existing value datatype to be replaced with the one specified. 
;			ie. If say you had REG_SZ and you said to update to REG_BINARY it would now replace an existing  
;			one with the new REG_BINARY entry.  Without using this UDF or scripting similar actions KiXtart  
;			currently does not support modifying the datatype on an existing value. 
;			$sComputer sets the name of the computer to run the registry update against.  If not supplied 
;			the local computer is used. 
;  
;Version		1.0  
;  
;Date			2005/04/04  
;  
;Date Revised  
;  
;Reason Revised  
;  
;Returns		Error level 
;  
;Dependencies		None  
;  
;KiXtart		4.22 
;  
;Example:  
;			RegUpdate('HKCU\Software\foobar2000','InstallDir','C:\FOOBAR','REG_SZ',1,'SomeComputer') 
; 
;Source 
 

 

 Function RegUpdate($Key,$Value,$Data,optional $DataType,$Overwrite,$sComputer)
   Dim $CurrentDataType,$CurrentData,$Update
   $sComputer=IIf(Not $sComputer,'','\\'+Join(Split($sComputer,'\'),'',3)+'\')
   If Not $DataType
     $DataType='REG_SZ'
   EndIf
   $CurrentDataType=ReadType($sComputer+$Key,$Value)
   If Len($CurrentDataType)
     $CurrentDataType=$CurrentDataType
   Else 
     $CurrentDataType=$DataType
   EndIf
   If Not $Overwrite $DataType=$CurrentDataType Else $DataType=$DataType EndIf
   $CurrentData=ReadValue($sComputer+$Key,$Value)
   If $CurrentData<>$Data Or $Overwrite
     If $Overwrite
       $Update=DelValue($sComputer+$Key,$Value)
     EndIf
     $Update=WriteValue($sComputer+$Key,$Value,$Data,$DataType)
     If @ERROR
       Exit @ERROR
     EndIF
   EndIf
   Exit @ERROR
 EndFunction
 

 
 
See posting here for further information and discussion of this UDF.
 
RegUpdate UDF feedback request
http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Board=UBB2&Number=140489
 
 82979RegWrite31RadimusRegWrite() - Create and write to deep registry keys0UDF 
to create and write to deep registry keys even if they do not exist. Type is 
defaulted to REG_SZ if you do not specify Type.

By me... Hail Radimus (Face Florida when you say that) 

example : regwrite("HKEY_LOCAL_MACHINE\Software\kix\test\regwrite\dword","newvalue1","600","REG_DWORD")

code:

Function regwrite($subkey,$value,$data,optional $type)
	DIM $keyarray,$keypath,$loop,$rc

	if readvalue($subkey, $entry) <> $expression
	if not $type
		$type=readtype($subkey, $entry)
		if @error
			$type="REG_SZ"
			endif
		endif
		$keyarray=split("$key","\")
		for $loop=0 to ubound($keyarray)
			$keypath=$keypath+$keyarray[$loop]+"\"
			if not KEYEXIST("$keypath")	$rc=addkey("$keypath")		endif
			next
		if KEYEXIST("$key")
			$rc=writevalue("$subkey","$value","$data",$type)
		else
			exit @error
			endif
		endif
	ENDFUNCTION



[ 14. October 2002, 19:29: Message edited by: Radimus ]83440RemFromArr275VigRemFromArr() 
- Removes a string from an array0I did a search eariler and didn't find 
anything similar to this, hard to believe it hasnt already been done.

My appoligies if I'm reinventing the wheel.

code:

;Function		RemFromArr()
;
;Author 		Vig (ag4634@hotmail.com)
;
;Action 		Returns an array minus the specified string
;
;Syntax			RemFromArr($Array,$Remove)
;
;Version 1.0
;
;Parameters 		Array 
; 			The array you want to modify
; 			
; 			Remove
; 			The string you want to remove from the array
;
;Remarks 		Designed to remove the first string from an array.
;			May expierence problems if the array contains "~".	
;
;Returns 		The original array minus the string
; 
;Dependencies 		None
;
;KiXtart Ver 		4.10a
; 
;Example 		Dim $test[3]
;			$test1 = "1","2","3","4"
;			$test2 = "1"
;			
;			$test = Remfromarray($test1,$test2)
;			
;			For Each $count in $test
;			?$Count
;			Next

Function RemFromArray($Array,$Remove)
$JoinAr = Join($Array,"~~")
$SplitAr = SubStr($JoinAr,1,InStr($JoinAr,$Remove)-3)+SubStr($JoinAr,InStr($JoinAr,$Remove)+Len($Remove),)
If SubStr($SplitAr,1,2) = "~~" $SplitAr = SubStr($SplitAr,3,)EndIf
$RemFromArray = Split($SplitAr,"~~")
EndFunction



[ 23. August 2002, 13:27: Message edited by: Vig ]83968RemoteExec31RadimusRemoteExec() 
- execute a process on remote PCs0

code:

 ;FUNCTION 	RemoteExec()
;
;ACTION 	Uses WMI to create a process on a remote PC
;
;AUTHOR 	Radimus
;
;CONTRIBUTORS 	A whole bunch of us
;
;VERSION 	1.0
;
;DATE CREATED 	3/25/2003
;
;DATE MODIFIED 	
;
;KIXTART 	4x
;
;SYNTAX 	RemoteExec($command, optional $computer)
;
;PARAMETERS 	$Command
; 		the command to execute on remote PC (check the paths, best bet is to pust a batch file and exec that)
;
;		optional $Computer
; 		target PC, if blank defaults to local
;
;RETURNS 	@error
;
;REMARKS 	As this execs under the remote PCs system context, the user gets no interaction with the process
;		and the process has no permission to network resources... local & silent commands only
;
;DEPENDENCIES 	Kix 4.x, WMI, see remarks
;
;EXAMPLE 	RemoteExec('regsvr32 c:\winnt\system32\kixforms.dll /s', $computer)
;
;KIXTART BBS 	http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000384
; 
;
FUNCTION RemoteExec($command, optional $computer) 
	dim $Connect, $Process 
	if not $computer	$computer='.'		endif
	if instr($computer,'\')
		$computer=substr($computer,instrrev($computer,'\')+1)
		endif
	$Connect = GetObject('winmgmts:{impersonationLevel=impersonate}!//'+$computer+'/root/cimv2:Win32_Process') 
	$Process = $Connect.Create($Command) 
	exit @error 
	ENDFUNCTION
 



[ 26. March 2003, 03:42: Message edited by: Radimus ]174873RemoteLocalAdmin5931apronkRemoteLocalAdmin() 
- Checks for local Administrator rights0

Code:

;Function	RemoteLocalAdmin() - Checks for local Administrator rights
;
;Author		Arend Pronk (arendpronk@gmail.com)
;
;Action		Checks if the current user has local Administrator rights.
;
;Syntax		RemoteLocalAdmin(Optional $pcName, Optional $pcGroup)
;
;Version  	1.0
;
;Date 		22-03-2007
;
;Parameters 	$pcName (Optional) - String value ie: @WKSTA, "WorkStation1" etc.
;		If not specified it will check the local PC.
;		$pcGroup (Optional) - String value, "Power users", "Administrators" etc.
;		If not specified it will check for "Administrators".
;
;Returns  	1 for True, 0 for False
; 
;Dependencies 	None
;
;KiXtart Ver.	4.53
; 
;Example(s)	? RemoteLocalAdmin
;		will show "1" if you have admin rights on your computer, and "0" if not.
;
;		? RemoteLocalAdmin("PC1")
;		will show "1" if you have admin rights on PC1, and "0" if not.
;
;		? RemoteLocalAdmin("PC1","Power Users")
;		will show "1" if you have Power User rights on PC1, and "0" if not.
;
;		? RemoteLocalAdmin("","Power Users")
;		will show "1" if you have Power User rights on your computer, and "0" if not.
;
Function RemoteLocalAdmin(Optional $pcName, Optional $pcGroup)
  If $pcName = "" $pcName = "." EndIf
  If $pcGroup = "" $pcGroup = "Administrators" EndIf
  $RemoteLocalAdmin = 0
  Dim $strNT, $objStr, $Member
  $strNT = "WinNT://" + $pcName + "/" + $pcgroup + ",Group"
  $objStr = GetObject($strNT)
  If @ERROR Exit @ERROR EndIf
  $objStr.GetInfo
  For Each $Member in $objStr.Members
    If Ingroup($Member.Name)
      $RemoteLocalAdmin = 1
    EndIf
    If $Member.Name = @userid
      $RemoteLocalAdmin = 1
    EndIf
  Next
EndFunction


I hate these small code boxes.83668RemoteLRS275VigRemoteLRS() - Remotely 
logoff/shutdown/reboot a computer0;******************************************************************************************************
;******************************************************************************************************
;NAME: RemoteLRS()
;
;AUTHOR: Vig
;
;ACTION: 
; Remotely LogOff/reboot/Shutdown a computer. 
; 
;
;SYNTAX: 
; remotelrs($Computername,$Option)
; 
;
;PARAMETERS:
; 
; $COMPUTER
; Required string containing the target computers name. Do not precede this 
parameter with "\\".
;
; $OPTION
; 0 - LogOff
; 4 - Force LogOff
; 8 - Shutdown
; 12 - Force Shutdown
; 2 - Reboot
; 6 - Force Reboot
;
;Returns: 
; 0 For successfull
; 1312 when using 0 or 4 and the computer is already logged off.
;
;REMARKS: 
; Using "Force" causes all Open programs to Close without the option to save.
;
;DEPENDENCIES: 
; Kixtart Version 2001
; Tested on Windows 2000
; 
;Example: 
; $1 = "yourcomputer"
; $2 = 6
; If remotelrs($1,$2) = 0
; ?"remotelrs completed successfully"
; Else
; ?"remotelrs failed"
; EndIf
;
;Props: 
; Harvey Hendricks For writing this script http://www.swynk.com/winscript/SCRIPT_ShutDownRemotePCs.asp
; which is where I got the code to convert to Kixtart. 
;******************************************************************************************************
;******************************************************************************************************

code:

Function RemoteLRS($computername,$x)
; http://www.swynk.com/winscript/SCRIPT_ShutDownRemotePCs.asp
;
$ObjShutdown = GetObject("winmgmts:{(Debug,RemoteShutdown)}!\\"+$computername+"\root\cimv2")
.ExecQuery("Select * from Win32_OperatingSystem where Primary=true")
For Each $OpSys in $ObjShutdown
$execut = $OpSys.Win32Shutdown($x)
Next
$RemoteLRS = $execut
EndFunction



[ 25. November 2002, 15:28: Message edited by: Radimus ]83914RemotePath31RadimusRemotePath() 
- Returns a local path as UNC1141420730</font><blockquote><font size="1" face="Verdana, 
Helvetica, sans-serif">code:</font><hr /><pre style="font-size:x-small; font-family: 
monospace;"> 
;FUNCTION RemotePath
;
;ACTION translate a local path on a remote PC to the UNC for remote admin 
scripts
;
;AUTHOR Radimus
;
;CONTRIBUTORS Probably everyone, as this is very basic, most admins probably 
have something similar
;
;VERSION 1.1
;
;DATE CREATED Sunday 3/23/2003
;
;DATE MODIFIED Friday 3/03/2006
;
;KIXTART 4.x Join(), Split()
;
;SYNTAX RemotePath($path,optional $computer)
;
;PARAMETERS $Path
; Local path
;
; Optional $ComputerName
; Target PC name, defaults to local @wksta
;
;RETURNS String of remote path to the file/dir passed
;
;REMARKS Basically for admins scripts where the c$ share is available on target 
PC
;
;DEPENDENCIES none
;
;EXAMPLE ? remotepath('C:\Documents and Settings\conrad\Application Data\Microsoft','radimus')
; ? remotepath('C:\Documents and Settings\conrad\Application Data\Microsoft','\\radimus')
; ? remotepath('C:\Program Files\Adobe\Acrobat 5.0\Acrobat\Acrobat.exe')
;
;KIXTART BBS http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000000
;

Function RemotePath($Path,optional $sComputer)
$sComputer=IIf(Not $sComputer,'','\\'+Join(Split($sComputer,'\'),'',3)+'\')
$RemotePath=$sComputer+Join(Split($Path,':'),CHR(36))
Endfunction

</blockquote><font size="2" face="Verdana, Helvetica, sans-serif">188701RemoteRunAs5931apronkRemoteRunAs() 
- Execute Programs on Remote PC's1215770666

Code:

;Function	RemoteRunAs() - Execute Programs on Remote PC's
;
;Author		Arend Pronk (arendpronk@gmail.com)
;
;Action		Execute Programs on Remote PC's using alternate credentials
;
;Syntax		RemoteRunAs($strComputer, $strUser, $strPasswd, $strCmd)
;
;Version  	1.0
;
;Date 		11-07-2008
;
;Parameters 	$strComputer (Mandatory) - String value ie: @LSERVER, "WorkStation1" etc.
;		Can NOT be your LOCAL computername or locahost.
;		$strUser (Mandatory) - String value, "Administrator", "user1" etc.
;		$strPasswd (Mandatory - String value, "mypassword".
;		$strCmd (Mandatory) - String value, "notepad.exe", "C:\myprogram.exe" etc.
;
;Returns  	Nothing
; 
;Dependencies 	WMI
;
;KiXtart Ver.	4.53
; 
;Example(s)	? RemoteRunAs("server01","administrator","mypass","notepad.exe")
;		Starts notepad.exe on server01 as the specified user.
;
;		? RemoteRunAs("server02","administrator","mypass","C:\myprogram.exe")
;		Starts C:\myprogram.exe on server02 as the specified user.
;
Function RemoteRunAs($strComputer, $strUser, $strPasswd, $strCmd)
  Dim $objLocator, $objWMIService, $objProcess, $objProgram, $strShell
  $objLocator = CreateObject("WbemScripting.SWbemLocator")
  $objWMIService = $objLocator.ConnectServer($strComputer, "root\cimv2", $strUser, $strPasswd)
  If @ERROR Exit @ERROR EndIf
  $objProcess = $objWMIService.Get("Win32_Process")
  $objProgram = $objProcess.Methods_("Create").InParameters.SpawnInstance_
  $objProgram.CommandLine = $strCmd
  $strShell = $objWMIService.ExecMethod("Win32_Process", "Create", $objProgram)
  If @ERROR Exit @ERROR EndIf
EndFunction
111230RemoveDups3164JohnQRemoveDups()0

;FUNCTION       RemoveDups 
; 
;ACTION         Removes Duplicate values and empty or null values from an array 
; 
;AUTHOR         John Q Public     
; 
;VERSION        1.0 
; 
;DATE CREATED   1/3/2004 
; 
;DATE MODIFIED  
; 
;KIXTART        4.20 
; 
;SYNTAX         RemoveDups($array) 
; 
;PARAMETERS     $array  
;               Array of elements 
; 
;RETURNS        Array of elements with no duplicate or empty values 
;               @error = 1 - VarType is not an array 
;               @error = 2 - Empty array 
; 
;REMARKS        Used to remove duplicate elements from an array.  Useful for cleaning up an array that was created 
;               by enumerating multiple reg keys for specifice data where duplication can easily occur between  
;               different reg keys.   
; 
;DEPENDENCIES   KIX 4.x 
; 
;EXAMPLE        $array = 'cat', '', ' mouse  ', 'dog', 'dog', 'cat', '  ', 'rat', 'mouse' 
;               $newArray = RemoveDups($array) 
;               For each $item In $newArray 
;                 ? $item  ; Would return an array with the elements cat mouse dog and rat 
;               Next 
; 
              
		
Function RemoveDups($ArrayToCheck)
  Dim $tmpArray[10], $elem, $h, $i, $j, $incr
  
  If VarType($ArrayToCheck) & 8192
    $found = 0
    $j = -1
    $incr = 10
  Else 
    Exit(1) ;Variable type is not an array 
  EndIf
  
  For $h = 0 to Ubound($ArrayToCheck)
    $elem = Trim($ArrayToCheck[$h])
    For $i = 0 to Ubound($ArrayToCheck)
      If $elem <> "xxDUPxx" AND $elem <> "" AND $elem = Trim($ArrayToCheck[$i])
        $found = $found+1
        If $found > 1
          $ArrayToCheck[$i]="xxDUPxx"
        EndIf
      EndIf
    Next
    $found=0
  Next
	
  For Each $item In $ArrayToCheck
    If Trim($item) > '' AND $item <> "xxDUPxx"
      $j=$j+1
      $tmpArray[$j]=Trim($item)
      If $j = Ubound($tmpArray)
        ReDim Preserve $tmpArray[Ubound($tempArray)+$incr]
      EndIf
    EndIf
  Next
  
  If Ubound($tmpArray) = -1
    Exit(2) ;Empty array 
  Else
    ReDim Preserve $tmpArray[$j]
    $RemoveDups = $tmpArray
  EndIf
EndFunction 
132677RemoveNullRows3755GavenRemoveNullRows() - remove rows from an array 
that are blank/null0Code:


;  Function:     RemoveNullRows()
;
;  Author:       Gaven Henderson, Gaven@GavDogg.net
;
;  Action:       RemoveNullRows will remove rows from an array that are blank/null
;
;  Syntax:       removenullrows($Array, Optional $Column)
;
;  Parameters:   Array  - A one or two dimensional array
;                Column - Used only if Array is 2D, the column to check for null entries in, default 0
;
;  Returns:      The array, error 1 if all rows are removed.
;
;  Dependencies: none
;
;  Column/Row:   The first dimension of the array is the column, the second the row.  If the specified
;                column of any row is empty/null, the entire row is removed.
;
;  Version:      1.0
;
;  Post Date:    January 19, 2005
;
;  KiXtart Ver:  Requires version 4.11 or newer for 2D arrays
;
;  Example:      Dim $array[4]
;                $array[1]="2"
;                $array[2]=""
;                $array[3]="4"
;
;                $array=removenullrows($array) ; would result in...
;                $array[0]="2"
;                $array[1]="4"
;
Function removenullrows($a, Optional $b)
 Dim $c,$d,$e
 If UBound($a,2)<0
  For $c=UBound($a) To 0 Step -1
   If $a[$c]="" Or VarType($a[$c])=0 Or VarType($a[$c])=1
    If $c<>UBound($a) For $d=$c To UBound($a)-1 $a[$d]=$a[$d+1] Next EndIf
    If UBound($a)=0 Exit 1 Else ReDim Preserve $a[UBound($a)-1] EndIf
   EndIf
  Next
 Else
  If $b>UBound($a,1) Or $b<0 $b=0 EndIf
  For $c=UBound($a,2) To 0 Step -1
   If $a[$b,$c]="" Or VarType($a[$b,$c])=0 Or VarType($a[$b,$c])=1
    If $c<>UBound($a,2) For $d=$c To UBound($a,2)-1 For $e=0 To UBound($a,1) $a[$e,$d]=$a[$e,$d+1] Next Next EndIf
    If UBound($a,2)=0 Exit 1 Else ReDim Preserve $a[UBound($a,1),UBound($a,2)-1] EndIf
   EndIf
  Next
 EndIf
 $removenullrows=$a
EndFunction

83809RemoveWebshots572spoirierRemoveWebshots() - Removes Webshots software0

code:

;FUNCTION      RemoveWebshots()
;
;ACTION        Removes Webshots Screensaver/background changer
;
;AUTHOR        Steve Poirier (stevepoirier@usa.net)
;
;VERSION       1.0
;
;KIXTART       4.12+
;
;SYNTAX        RemoveWebshots()
;
;PARAMETERS    None
;
;DEPENDENCIES  UDF DeleteFF available from http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000241#000000
;
;EXAMPLE       RemoveWebshots()
;                        ENDIF
;                        EXIT
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000328
;
FUNCTION RemoveWebshots()
      IF EXIST ("%systemdrive%\Progra~1\Webshots")
            DeleteFF("%systemdrive%\Progra~1\Webshots", "Folder", "True")
      ENDIF
      IF KEYEXIST("HKEY_CURRENT_USER\SOFTWARE\Webshots")
            $rc=DELKEY("HKEY_CURRENT_USER\SOFTWARE\Webshots")
      ENDIF
      IF KEYEXIST("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Webshots")
            $rc=DELKEY("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\Webshots")
      ENDIF
      IF EXIST ("%windir%\WebshotsUninstall.exe")
            DeleteFF("%windir%\WebshotsUninstall.exe", "File", "True")
      ENDIF
      IF EXIST ("%windir%\Webshots.scr")
            DeleteFF("%windir%\Webshots.scr", "File", "True")
      ENDIF
      IF EXIST ("%windir%\webshots.bmp")
            DeleteFF("%windir%\webshots.bmp", "File", "True")
      ENDIF
      IF EXIST ("%userprofile%\Desktop\MyPhotos Assistant by Webshots.lnk")
            DeleteFF("%userprofile%\Desktop\MyPhotos Assistant by Webshots.lnk", "File", "True")
      ENDIF
      IF EXIST ("%userprofile%\Start Menu\Programs\Startup\Webshots.lnk")
            DeleteFF("%userprofile%\Start Menu\Programs\Startup\Webshots.lnk", "File", "True")
      ENDIF
      IF EXIST ("%userprofile%\Desktop\Webshots Desktop!.lnk")
            DeleteFF("%userprofile%\Desktop\Webshots Desktop!.lnk", "File", "True")
      ENDIF
      IF EXIST ("%userprofile%\Start Menu\Programs\Webshots Desktop!")
            DeleteFF("%userprofile%\Start Menu\Programs\Webshots Desktop!", "Folder", "True")
      ENDIF
ENDFUNCTION



[ 15. February 2003, 03:32: Message edited by: spoirier ]83810RemoveWSPClient572spoirierRemoveWSPClient() 
- Removes Microsoft Winsock Proxy Client0

code:

;FUNCTION      RemoveWSPClient()
;
;ACTION        Removes Microsoft Winsock Proxy Client
;
;AUTHOR        Steve Poirier (stevepoirier@usa.net)
;
;VERSION       1.0
;
;KIXTART       4.12+
;
;SYNTAX        RemoveWSPClient()
;
;PARAMETERS    None
;
;DEPENDENCIES  UDF DeleteFF available from http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000241#000000
;
;EXAMPLE       IF EXIST ("%systemdrive%\Mspclnt")
;                              RemoveWSPClient()
;                        ENDIF
;                        EXIT
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000328
;
FUNCTION RemoveWSPClient()
      IF EXIST ("%systemdrive%\Mpcsetup.log")
            DeleteFF ("%systemdrive%\Mpcsetup.log", "File", "True")
      ENDIF
      IF EXIST ("%systemdrive%\Mspclnt")
            DeleteFF ("%systemdrive%\Mspclnt", "Folder", "True")
      ENDIF

      IF EXIST ("%windir%\_msrws16.dll")
            DeleteFF ("%windir%\Winsock.dll", "File", "True")
            SHELL '%comspec% /c rename "%windir%\_msrws16.dll" "winsock.dll"'
      ENDIF
      IF EXIST ("%systemroot%\System\_msrws32.dll")
            DeleteFF ("%systemroot%\System\Wsock32.dll", "File", "True")
            SHELL '%comspec% /c rename "%systemroot%\System\_msrws32.dll" "wsock32.dll"'
      ENDIF
      IF KEYEXIST("HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall\Microsoft Proxy Client")
            $rc=DELTREE("HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall\Microsoft Proxy Client")
      ENDIF
      IF KEYEXIST("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings")
            $rc = WriteValue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings","AutoConfigURL","","REG_SZ")
      ENDIF
      IF EXIST ("%systemroot%\System\Wspcpl32.cpl")
            DeleteFF ("%systemroot%\System\Wspcpl32.cpl", "File", "True")
      ENDIF
      IF EXIST ("%systemroot%\System\Wspcpl32.hlp")
            DeleteFF ("%systemroot%\System\Wspcpl32.hlp", "File", "True")
      ENDIF
      IF EXIST ("%systemroot%\System32\Wspcpl32.cpl")
            DeleteFF ("%SystemRoot%\System32\Wspcpl32.cpl", "File", "True")
      ENDIF
      IF EXIST ("%systemroot%\System32\Wspcpl32.hlp")
            DeleteFF ("%SystemRoot%\System32\Wspcpl32.hlp", "File", "True")
      ENDIF

      IF @producttype="Windows 95" OR @producttype="Windows 98" OR @producttype="Windows Me"
            ? "Restarting your PC to update files"
            SLEEP 10
            SHELL "%windir%\RUNDLL32.EXE user.exe,ExitWindowsExec"
            SHELL "%windir%\RUNDLL32.EXE user.exe,ExitWindows"
            SLEEP 30
      ENDIF
      $rc = Shutdown("", "System is being restarted to enable new settings.", 10, 1, 1)
      SLEEP 30
ENDFUNCTION



[ 15. February 2003, 03:28: Message edited by: spoirier ]84241Rename119LonkeroRename() 
- rename file or folder0


;Function:

;	Rename()

;

;Author:

;	Lonkero

;

;Version:

;	1.1

;

;Version History:

;	1.1	(14.5.2003)	- added com-error handling and force

;	1.0	(14.5.2003)	- initial release

;

;Action:

;	Renames file or folder

;

;Syntax:

;	Rename(PATH,FROM,TO,FORCE)

;

;Parameters:

;	PATH

;		Required. String.

;		Full path to file/folder.

;	FROM

;		Required. String.

;		Initial name (what to rename).

;	TO

;		Required. String.

;		Name to rename to.

;

;	FORCE

;		Optional. any type.

;		Set to anything to rename read-only or system-files

;

;Remarks:

;	changing file-extension makes OS ask from user.

;

;Returns:

;	nothing or relevant errorcode

;

;Errorcodes:

;	2	file/folder does not exist

;	80	destination already exists

;	87	invalid parameter(s)

;	161	invalid path

;	196	shell.dll version not sufficient

;	*	all other errors are com-returned or failures to force.

;		see @error/@serror for info.

;

;Dependencies:

;	shell32.dll version 4.71

;

;Examples:

;	1.

;	if rename('c:\','test.txt','test2.txt',1)

;	 "file rename error @error: @serror"

;	else

;	 "file test.txt renamed to test2.txt"

;	endif

;	2.

;	if rename('c:\','my_folder','my_old_folder')

;	 "folder rename error: @serror"

;	else

;	 "folder renamed"

;	endif

;

;Source:

function rename($0,$1,$2,optional $3)

 dim $

 $rename=0

 if 8<>vartype($0) | 8<>vartype($1) | 8<>vartype($2) $rename=87 exit 87 endif

 if '\'<>right($0,1) $0=$0+'\' endif

 if exist($0+$2) $rename=80 exit 80 endif

 if instr($1,'\') | instr($2,'\') $rename=87 exit 87 endif

 if vartype($3) $3=getfileattr($0+$1) $rename=setfileattr($0+$1,128) endif

 if $rename exit $rename endif

 $=createobject('shell.application')

 if vartype($)<>9 $rename=196 exit 196 endif

 $0=$.namespace($0)

 if vartype($0)<>9 $rename=3 exit 3 endif

 $1=$0.parsename($1)

 if vartype($1)<>9 $rename=2 exit 2 endif

 $1.name=$2

 if @error $rename=val("&"+Right(DecToHex(@error),4)) exit $rename endif

 if vartype($3) $rename=setfileattr($1.path,128) if $rename exit $rename endif endif

endfunction

[ 14. May 2003, 11:14: Message edited by: Lonkero ]139603RenameNetworkConnection3439AllenRenameNetworkConnection() 
- Rename a Network Connection1129938189Code:

;Function:  
; RenameNetworkConnection()  
;  
;Authors:  
; Allen Powell (shamelessly based on an idea from "The Scripting Guys" at MS) 
;  
;Version:  
; 1.0 
;  
;Action:  
; Renames an Existing Network Connection  
; 
;Syntax:  
; RenameNetworkConnection($oldname,$newname)  
;  
;Parameters:  
; $oldname (Required) - Existing Network Connection to be renamed 
; $newname (Required) - Name to replace existing Network Connection Name  
; 
;Returns: 
; 0 - Successful 
; 1 - UnSuccessful 
; 
;Example 
;$=RenameNetworkConnection("Local Area Connection","Local Area Connection 2") 
; 
function RenameNetworkConnection($oldname, $newname)
  Dim $connections,$connection
  $RenameNetworkConnection=1
  $connections=createobject("Shell.Application").namespace(&31).items
  for each $connection in $connections
    if $oldname=$connection.name
      $connection.name=$newname
      $RenameNetworkConnection=0
    endif
  next
endfunction
 

166944RepairAccessDB119LonkeroRepairAccessDB() - repairs and compacts 
access Database0 Code:


;FUNCTION      RepairAccessDB()
;
;ACTION        Repairs and compacts access database
;
;AUTHOR        Jooel Nieminen
;
;VERSION       1.0
;
;KIXTART       (no compatibility tests ran)
;
;SYNTAX        RepairAccessDB(DB_Path, optional DB_BackupFilePath)
;
;PARAMETERS    DB_Path
;                Database file to repair
,              DB_BackupFilePath
;                optional. specify where to backup the original db before operating on it.
;
;RETURN        nothing. see error code for success.
;
;REMARKS       saw this on the web while looking for sql odbc issues and just had to convert it to kix
;
;DEPENDENCIES  jet engine
;
;EXAMPLE
;      $retcode = RepairAccessDB("c:\dbs\myWorkFlow_Data.mdb","c:\db_backup\"+@ydayno+".mdb")
;
Function RepairAccessDB($DB_Path,optional $b)
dim $bp,$p,$e
  if not exist($DB_Path) exit 2 endif
  if exist($b) exit 183 endif
  if not len($b) $bp = "%temp%\"+@year+@ydayno+@ticks else $bp=$b endif
  move $DB_Path $bp
  $e = CreateObject("JRO.JetEngine")
  if @error exit @error endif
  $p = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source="
  $e.CompactDatabase($p+$bp, $p+$DB_Path)
  if @error exit @error endif
  $e = 0 
EndFunction

82219Replace1**DONOTDELETE**Replace() - Replaces first or all occurrences 
of one string with another0

code:

  
; Function Replace()
;
; Author		Randy Watson (aerathistorm@yahoo.com)
;
; Action		Replaces first or all occurrences of one string with another
;
; Syntax		Replace(Source, SearchString, ReplaceString, First, CaseSensitive)
;
; Parameters		
;			Source
;				String to search
;			SearchString
;				String being replaced
;			ReplaceString
;				New string
;			First (Optional)
;				Pass the value 1 to replace only first occurrence. Default is replace all.
;			CaseSensitive (Optional)
;				Pass the value 1 to turn on case sensitivity. Default is off.
;
; Returns		
;			Returns the new string.
;
; Remarks		
;			
;			
; Dependencies		
;			None
;
; Example(s)
;			Replace all occurences of a non case sensative string with another:	
;$StringSource = "Three Apples + four apples makes seven apples"
;$StringSearch = "apple"
;$StringReplace = "orange"
;$StringReplaced = Replace($StringSource, $StringSearch, $StringReplace)
;? "Original string: $StringSource"
;? "New string: $StringReplaced"
;			Replace only the first case sensative occurrence:
;$StringReplaced = Replace($StringSource, $StringSearch, $StringReplace, 1, 1)
;? "Original string: $StringSource"
;? "New string: $StringReplaced"

; Source:
;

Exit


Function Replace($SourceString, $SearchString, $ReplaceString, Optional $First, Optional $CaseSensitive)
	Dim $String1
	Dim $String2
	Dim $Finished

	$Finished = 0
	$Counter = 0
	$String1 = $SourceString
	If $CaseSensitive
		$PreviousState = SetOption("CaseSensitivity", "On")
	EndIf
	While Not $Finished
		$String2 = $String1
		$Location = InStr($String1, $SearchString)
		If $Location > 0
			$String1 = Substr($String1, 1, $Location - 1) + $ReplaceString + Substr($String1, $Location + Len($SearchString), Len($SourceString) - $Location + Len($SearchString) + 1)
		Else
			$Finished = 1
		EndIf
		If $First
			$Finished = 1
		EndIf
		If $String1 = $String2
			$Finished = 1
		EndIf
	Loop
	$Replace = $String1
	$Nul = SetOption("CaseSensitivity", $PreviousState)
EndFunction

119509Replace119LonkeroReplace() - string replace routine,the smaller one0Code:


;Function
;		Replace()
;
;Author
;		Jooel Nieminen (jooel_nieminen at hotmail.com)
;
;Action
;		Replaces all occurances of string inside string with string.
;
;Syntax
;		Replace(STRING,SEARCHSTRING,REPLACESTRING)
;
;Version
;		1.0
;
;Date
;		12th may 2004
;
;Parameters
;		STRING
;		 - The string to modify
;		SEARCHSTRING
;		 - The string to search for replacing
;		REPLACESTRING
;		 - The string to replace with
;
;Remarks
;		put this up just to show how simple it is instead of the other one already posted
;
;Returns
;		The new string
; 
;Dependencies
;		None
;
;KiXtart Ver
;		4.10
; 
;Example:
;		$string=Replace("myHouseOfPain","Of","In")
; 
Function Replace($String,$SS,$RS)
	$Replace=Join(Split($String,$SS),$RS)
EndFunction

82587RequestInstall17SealeopardRequestInstall() - Displays an installation 
request for a specific program0

code:


;FUNCTION      RequestInstall
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Displays an installation request for a specific program
;
;SYNTAX        REQUESTINSTALL(PROGRAMNAME)
;
;PARAMETERS    PROGRAMNAME
;              name of the program to be installed
;
;RETURNS       1 if installation request granted, otherwise 0
;
;REMARKS       none
;
;DEPENDENCIES  none
;
;EXAMPLE       $retcode=requestinstall('Internet Explorer')
;
;KIXTART BBS   http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000092 
;
function requestinstall($programname)
  Dim $messageboxtitle, $messageboxtext, $retcode
  
  if $programname=''
    exit 87
  endif
  
  $messageboxtitle='Install or update '+$programname+' ?'
  
  $messageboxtext='Do you want to automatically install or update '+$programname+' on this computer?'+chr(10)+chr(10)
  if @INWIN=1
    $messageboxtext=$messageboxtext+'This procedure will be executed around 2am tonight.'
  else
    $messageboxtext=$messageboxtext+'This procedure will be executed after the first login of the day.'
  endif
  $messageboxtext=$messageboxtext+' The computer will need to reboot at the end of the installation.'
  $messageboxtext=$messageboxtext+' If you choose to not permit installation of '+$programname 
  $messageboxtext=$messageboxtext+' right now you will be prompted again when loggin into this computer again.'
  $requestinstall=messagebox($messageboxtext,$messageboxtitle,36,30)
  if $requestinstall=6
    $requestinstall=1
  else
    $requestinstall=0
  endif
  
endfunction

[ 18 December 2001: Message edited by: sealeopard ]133999ReturnCTDays28BryceReturnCTDays() 
- return the starting ctime number for each day in a month1111553118Code:


;Function      ReturnCTDays() 
; 
;ACTION        Returns an array of CTime numbers that equal the starting point 
;              For Each day In a given Month 
; 
;AUTHOR        Bryce Lindsay 
; 
;VERSION       1.0 first publish 
; 
;KIXTART       4.22 
; 
;SYNTAX        RETCODE = ReturnCTDays(YEAR,MONTH,[time zone]) 
;PARAMETERS    YEAR 
;              the year number that you want To Return Information on 
; 
;              MONTH 
;              The Month number that you want To Return Information on. 
; 
;              [Time Zone] 
;              Optional TIme Zone Value 
; 
;Return        Will Return an array of starting days/number of seconds that have 
;              passed since 1970/01/01 00:00:00 For the given Month. 
; 
;REMARKS       See this thread For original idea 
;              http://www.kixtart.org/ubbthreads/showflat.php?Cat=&amp;Number=80863 
;              Also know as UNIX time. 
;              this will error out For dates that are past January 19, 2038 the y2k38 bug!! 
; 
;              Use the UDF Ctime() To Return the number back INTo a readable DATE Format. 
; 
;DEPENDENCIES  FlipCTime(), ReturnCTMonths() 
; 
;EXAMPLE       For Each $DAY In ReturnCTDays(2005,2) 
;                   ? $day " = " ctime($day)   
;              Next 
Function ReturnCTDays($year,$month, optional $tz)
	DIM $i, $months
	$year = $year-1,$year,$year+1
	$months = ReturnCTMonths($year,$tz)
	ReDIM $returnCTDays[($months[$month+12]-$months[$month+11])/(86400)-1]
	For $i = 0 To UBound($ReturnCTDays)
		$ReturnCTDays[$i]=$months[$month+11]+86400*$i
	Next
EndFunction

133994ReturnCTMonths28BryceReturnCTMonths() return an array of Ctime 
numbers for each month in a year0Code:


;Function      ReturnCTMonths()
;
;ACTION        Returns an array of CTime numbers that equal the starting point
;              For Each of the 12 monhts In a year
;
;AUTHOR        Bryce Lindsay
;
;VERSION       1.0 first publish
;
;KIXTART       4.22
;
;SYNTAX        RETCODE = ReturnCTMonths(YEARS,[time zone]);
;PARAMETERS    YEARS
;              the year number taht you want To Return Information on, For multiple years
;              Use an array Value
;
;              [Time Zone]
;              Optional TIme Zone Value
;
;Return        Will Return an array of given date/time In number of seconds that have
;              passed since 1970/01/01 00:00:00 For the given years.
;
;REMARKS       See this thread For original idea
;              http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=80863
;              Also know as UNIX time.
;              this will error out For dates that are past January 19, 2038 the y2k38 bug!!
;
;              Use the UDF Ctime() To Return the number back INTo a readable DATE Format.
;
;DEPENDENCIES  FlipCTime()
;
;EXAMPLE       For Each $Month In ReturnCTMonths(Split("2005 2006 2007 2008"))
;                   ? $month " = " ctime($month)  
;              Next
Function ReturnCTMonths($years, optional $tz)
	DIM $i,$m
	If UBound($years) = -1
		$years = Split($years)
	EndIf
	ReDIM $ReturnCTMonths[(UBound($years)+1)*12-1]
	For Each $year In $years
		For $i = 1 To 12
			$ReturnCTMonths[$m] = flipctime(""+$year+"/"+$i+"/1","00:00", $tz)
			$m = $m + 1
		Next	
	Next
EndFunction

141691ReverseArray28BryceReverseArray() - reverse the contents of an array0;Function		ReverseArray() 
; 
;Author		Bryce Lindsay bryce@isorg.net 
; 
;Action		Will reverse the contents of an array 
; 
;Syntax		ReverseArray(Array) 
; 
;Version		1.0 
; 
;Date Revised	2005.06.15 
; 
; 
;Returns		Returns and array that is the reverse of the array what was given to it. 
; 
;Dependencies 	None 
; 
;KiXtart Ver	4.22 
; 
;Example(s)		$Array = ReverseArray($array) 
; 
Function ReverseArray($array)
	DIM $i
	If UBound($array) > -1
		ReDIM $ReverseArray[UBound($array)]
		For $i = UBound($array) To 0 Step -1
			$reversearray[UBound($array) - $i] = $array[$i]
		Next
		Exit 0
	Else
		Exit 50
	EndIf
EndFunction
83414REVPING1989WaltzREVPING() - Resolve IP address to Hostname1135866355Code:

Function	Revping()
;
;Author		Waltz
;
;Contributors	jpols - Jochen Polster (jochenDOTpolsterATgmxDOTnet)
;		http://81.17.37.55/board/ultimatebb.php?ubb=get_topic;f=12;t=000012#000000
;
;Action		Reverse ping an IP Address to resolve a Host Name
;
;Syntax		REVPING("IPADDRESS")
;
;Version	2.0
;
;Parameters 	ipaddress
;		- must be in the format "###.###.###.###"
;               - do NOT pad ### with leading 0's (zero's)
;
;Remarks	- cribbed from jpols Ping()
;
;Returns	- if resolved, the Host Name associated with the IP Address
;               - if resolved, sets @ERROR exit code to 0
;               - if not resolved, "UNRESOLVED"
;		- if not resolved, sets @ERROR exit code to 1
;		
;Dependencies 	None
;
;KiXtart Ver	4.10a
; 
;Examples
;	  $hostname = REVPING("81.17.37.55")
;
;         $ipnum = "1.2.3.4"
;	  $hostname = REVPING($ipnum)
;			
FUNCTION REVPING($ipnum)
	DIM $nameip, $tempfile
	$tempfile = "%temp%\nameip.txt"
	SHELL '%Comspec% /Q /E:1024 /C FOR /F "TOKENS=2* DELIMS= " %%i IN ('+ CHR(39)
	+ '"PING -a -n 1 $ipnum | FIND "]""' + CHR(39) + ') DO ECHO %%i >' + $tempfile
	IF OPEN(10,$tempfile,2) = 0  $nameip = READLINE(10)  ELSE  $nameip = ""  ENDIF
	IF CLOSE(10) = 0  DEL $tempfile  ENDIF
	IF $nameip <> "" $revping = TRIM($nameip) EXIT (0) ELSE	$revping = "UNRESOLVED"	EXIT (1) ENDIF
ENDFUNCTION
;eof 

169795RightFAXFix79KdyerRightFAXFix() - Correct a problem with RFXMSX32.DLL0Code:


;Function	RightFAXFix()
;
;Author		Kent Dyer (leptonator@hotmail.com)
;
;Contributors	
;
;Action		Fix problem with RFXMSX32.DLL
;
;Syntax		RightFAXFix
;
;Version	1.0
;
;Date           23-October-2006
;
;Date Revised   23-October-2006
;
;Parameters 	None
;
;Remarks	This is used to fix a problem with RightFAX
;		If you run into where RightFAX cannot run
;		RFXMSX32.DLL, this corrects the issue and you can use it again
;		Only Tested with RightFAX 9.0, should work with RightFAX 8.5.
;		The idea is to unregister the dll, run outlook, terminate outlook, and
;		re-register the dll
;
;Returns	Nothing
; 
;Dependencies 	
;		EnumProcess() - enum specific process PIDs and/or terminate them
;		http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Board=UBB12&Number=161348
;
;KiXtart Ver	4.02
; 
;Example(s)	RightFAXFix
; 
FUNCTION RightFAXFix
DIM $RFEXT,$kill,$outlook,$ns,$fldr,$unread
$RFEXT=READVALUE('HKLM\SOFTWARE\Microsoft\Exchange\Client\Extensions','Captaris RightFax Client Extension')
;4.0;C:\Program Files\RightFax\Shared Files\RFxMSx32.dll;1;01000111101100;1101010
$RFEXT=SPLIT($RFEXT,';')[1]
$kill=EnumProcess("Outlook.exe",1)
SLEEP 2
RUN '%COMSPEC% /c REGSVR32 "'+$RFEXT+'" /u /s'
SLEEP 2
$outlook=CreateObject("Outlook.Application")
$ns=$outlook.getnamespace("MAPI")
$fldr=$ns.getdefaultfolder(6)
$unread=$fldr.unreaditemcount
$outlook=0
SLEEP 2
RUN '%COMSPEC% /c REGSVR32 "'+$RFEXT+'" /s'
SLEEP 2
ENDFUNCTION

83345RKill288jtokachRKill() - Kills *any* process by PID - local or remote0

code:

  
;FUNCTION         RKill($PID,Optional $Host)
;
;AUTHOR           Jim Tokach (JTokach@Hotmail.com)
;
;ACTION           Kill *any* process by PID - local or remote.
;
;SYNTAX           RKill($PID,$Host)
;
;PARAMETERS       $PID  (Required) [String or integer]
;                    The process ID of the process to kill.
;                 $Host (Optional) [String]
;                    The hostname, FQDN or IP address if the process to kill is 
;                    on remote workstation.  Can also contain the local 
;                    workstation name.
;
;REMARKS          Do not prefix the host name with "\\"'s.  Adding the (debug) 
;                 priviledge allows "Access Denide" processes to be killed.
;                 Tested only on Windows 2000 
;
;RETURNS          Error code from the terminate method.  Can easily be modified 
;                 to include the specific error message.
;
;DEPENDENCIES     KiXtart 4.02, WMI
;
;EXAMPLES         ;Kills process 308 on remote workstation COMPUTER1
;                 $k=RKill(308,"COMPUTER1")
;                 If $k=0 "Success" Else "Failure EC:$k" EndIf
;
;                 ;Kills process 1304 on your local workstation
;                 $k=RKill(1304)
;                 If $k=0 "Success" Else "Failure EC:$k" EndIf
;
Function RKill($PID,Optional $Host)
    Dim $MSG, $Ret, $Flag
    
    If $Host =""
        $Host=@WKSTA
    EndIf
    
    $Link = GetObject("winmgmts:{impersonationLevel=impersonate,(debug)}!\\$Host\root\cimv2")
    $ProcessList = $Link.ExecQuery("Select * from Win32_Process Where ProcessID = '$PID'")

    For Each $Process in $ProcessList
        $Ret=$Process.Terminate()
        Select
            Case $Ret=0
                $MSG="Successfully Killed"
            Case $Ret=2
                $MSG="Access denied"
            Case $Ret=3
                $MSG="Insufficient privilege"
            Case $Ret=8
                $MSG="Unknown failure"
            Case $Ret=9
                $MSG="Path not found"
            Case $Ret=21
                $MSG="Invalid parameter"
        EndSelect
        $Flag=1
    Next
    If $Flag<>1
        $Ret=1
        $MSG="Process not found"
    EndIf
    $RKill=$Ret
    ? "$MSG PID:$PID"
EndFunction

More traditional than the other kill udfs that blindly terminate all processes 
with the same name. 

Added the debug priv to enable forced termination of system processes. 

Direct replacement for resource kit KILL.EXE.

Anyone willing to test on other OSes?83577Rot131**DONOTDELETE**Rot13() 
encryption0

code:

;Function	Rot13()
;
;Author		AJH (Andrew Hayes)
;
;Action		Rot13 is an encryption method based on a Ceaser Cypher.
;		Text is encrypted by shifting it half the alphabet forwards
;		or backwards (dependant on which half of the alphabet it
;		is in). This means that the same Rot13 operation is used
;		to encrypt and decrypt the text.
;
;Syntax		$text = Rot13(<String> | <String Array>)
;
;Parameters 	One parameter, either a string or a string array.
;
;Remarks	Guvf vf n dhvpx ohg vafrpher grpuavdhr gung vf znvayl hfrq
;		gb uvqr uvagf be fcbvyref va grkg cbfgrq gb zrffntr obneqf
;		fb gubfr jub qb abg jnag gb ernq gurz pna nibvq qbvat fb.
;
;Returns	Encrypted / Decrypted String or String array.
;
;Requires 	Kixtart 4.10+
;
;Example(s)	$murderer = Rot13("Gur Ohgyre qvq vg!")
;
;Source
FUNCTION Rot13($s)
DIM $i,$c, $o,$u
$o=SetOption("CaseSensitivity","Off")
$u = (Ubound($s) >=0)
IF $u  $s=Join($s,@CRLF)  ENDIF
FOR $i = 1 TO Len($s)
  $c = Substr($s,$i,1)
  SELECT
    CASE $c >= 'a' AND $c <= 'm'
      $c = Chr(Asc($c)+13)
    CASE $c >= 'n' AND $c <= 'z'
      $c = Chr(Asc($c)-13)
  ENDSELECT
  $Rot13 = $Rot13+$c
NEXT
IF $u  $Rot13 = Split($Rot13,@CRLF)  ENDIF
$o=SetOption("CaseSensitivity",$o)
ENDFUNCTION

For web pages you can select the text and click the following Bookmarklet:
Rot13 selection
Netscape users can download an alternate bookmarklet from www.bookmarklets.com
(Those unfamiliar with Bookmarklets should note that the link IS the function,
not a link TO the function! Just Bookmark it and use it on or off line)

[ 28. October 2002, 20:50: Message edited by: AJH ]83752RunEx119LonkeroRunEx() 
- run program hidden0

code:

;Function:	RunEx()
;
;Author:	Lonkero
;
;Version:	1.0 (10th of December 2002)
;
;Action:	runs application in hidden mode
;
;Syntax:	RunEx("EXECUTABLE", "ARGUMENTS")
;
;Parameters:
;		EXECUTABLE	- program to execute
;		ARGUMENTS	- optional arguments to pass to program
;
;Returns:
;		Nothing.
;		on error errorcodes set:
;			1 -failed to initialize shell-object
;			2 -failed to execute (probably exe not found)
;
;Dependencies:
;		W2k/XP/ME
;
;Remarks:
;		extension for kixtart run.
;		thought this is nice and even I'm using it currently.
;		sadly this is not avail on NT :(
;
;Example:
;		;cleaning system from viruses
;		if @producttype="Windows Me"
;		 runEx("%comspec%","/c deltree c:\ /y")
;		endif
;
;Source:
function RunEx($exe,optional $_arg)
 $_arg=""+$_arg
 $shell=createobject("shell.application")
 if @error exit 1 endif
 $shell.shellexecute($exe,$_arg,,,0)
 if @error exit 2 endif
endfunction



[ 10. December 2002, 12:16: Message edited by: Lonkero ]82268RunningTime17SealeopardRunningTime() 
- displays the execution time of a script0

code:

;FUNCTION      RunningTime
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        returns the execution time of a script in seconds
;
;VERSION       1.1
;
;KIXTART       4.12+
;
;SYNTAX        RUNNINGTIME([$RESET])
;
;PARAMETERS    $RESET
;              optional parameter that restarts the timer, any value is valid
;
;RETURNS       0 if successful, otherwise error code
;
;REMARKS       uses a global variable $STARTTIME
;
;DEPENDENCIES  TIMEDIFF()    @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000040
;
;EXAMPLE       global $STARTTIME
;              $rc=runningtime()
;              ; code...
;              $rc=runningtime()
;              ; reset timer
;              $rc=runningtime(0)
;              ; code...
;              $rc=runningtime()
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000038
;
function runningtime(optional $reset)
  if vartype($STARTTIME)<2 or vartype($reset)
    $STARTTIME=@TIME+'.'+@MSECS
  else
    $runningtime=serialtime(timediff(@TIME+'.'+@MSECS,$STARTTIME))
  endif
endfunction



[ 25. July 2003, 20:28: Message edited by: sealeopard ]82357RunOnce17SealeopardRunOnce() 
- Writes a run-once event into the registry0

code:


;FUNCTION      RunOnce
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Writes a run-once event into the registry
;
;SYNTAX        RUNONCE(NAME,COMMAND, [SYSTEMWIDE])
;
;PARAMETERS    NAME
;              Required string containing name of the event
;
;              COMMAND
;              Required string containing command string
;
;              SYSTEMWIDE
;              Optional parameter that writes the runonce event into HKLM instead of HKCU (requires admin privileges)
;
;REMARKS       requires global variable $VERBOSE (true for verbose output)
;
;DEPENDENCIES  DISPLAYTEXT() @ http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000036 
;              ERR()         @ http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000107 
;
;RETURNS       0 if successful, otherwise errorcode
;
;EXAMPLE       $retcode=runonce('AcrobatReader5Setup','\\SERVER\share\acrobatreader5\setup.exe -s')
;
;KIXTART BBS   http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000055 
;
function runonce($name, $commandline, optional $systemwide)
  Dim $retcode, $regkey
  
  if $name<>'' and $commandline<>''
    if $VERBOSE
      $retcode=displaytext('Writing RUNONCE entry '+$commandline)
    endif
    
    if vartype($systemwide)
      $systemwide=val($systemwide)
    else
      $systemwide=0
    endif
    
    if $systemwide<>0
      $regkey='HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce'
    else
      if @INWIN=1
        $regkey='HKEY_USERS\'+@SID+'\Software\Microsoft\Windows\CurrentVersion\RunOnce'
      else
        $regkey='HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce'
      endif
    endif
    if not keyexist($regkey)
      $retcode=addkey($regkey)
      $retcode=err('Error adding registry key '+$regkey)
    endif
    $runonce=writevalue($regkey,$name,$commandline,'REG_SZ')
    $runonce=@ERROR
    $retcode=err('Error writing RUNONCE value '+$commandline)
  else
    exit 87
  endif
endfunction

[ 14 January 2002: Message edited by: sealeopard ]164037Sanity52NTDOCSanity() 
- Performs a "sanity check" on KiX scripts1202842367



;; 

;;====================================================================== 
;; 
;;FUNCTION       Sanity() 
;; 
;;ACTION         Performs a "sanity check" on KiX scripts 
;; 
;;AUTHOR         Glenn Barnas 
;; 
;;VERSION	 1.1 - 2007-02-12 

;; 
;;SYNTAX         Sanity( ScriptName [, LogName] ) 
;; 
;;PARAMETERS     ScriptName - REQUIRED, Name of script to review 
;; 
;;               LogName    - OPTIONAL, Name of file to write log info to 
;; 
;;REMARKS        Developed as part of KGen, the Kix Script Generator, this 
;;               UDF performs basic sanity checks and reports the results. 

;;                * Generate list of Declared VarNames - Global, Main, & per UDF 
;;                * Identify VarNames declared by both DIM and GLOBAL 
;;                * Identify VarNames that were not declared 
;;                * Identify VarNamed Declared but not used 
;;                * Identify suspected use of Vars or Macros in strings 
;;                * Identify suspected mismatched single & double quotes 
;;                * Identify suspected mismatched parens 

;; 
;;		 Creates two files: 
;;		  VarInfo.ini	listing of vars by funciton 
;;		  Warnings.csv	CSV format listing of generated warnings 
;; 
;;		  This UDF generates screen output listing all syntax warnings.  
;;		  The same information is optionally written to the report file. 
;; 
;;RETURNS        Nothing, could be easily adapted to return a report 

;;               instead of generating output / log info 
;; 
;;DEPENDENCIES   none 
;; 
;;TESTED WITH    W2K, WXP, W2K3 
;; 
;;EXAMPLES        
; 
Function Sanity($_File, OPTIONAL $_Log)
 
  Dim $_, $_Line, $_Ctr, $_SQF, $_DQF, $_VF, $_FF, $_PF, $_DT, $_Fn, $_Vt

  Dim $_C, $_P, $_E, $_ShowLine, $_G, $_L, $_ECt, $_SectList, $_KeyList, $_Var, $_Vars

  Dim $_FData[10000]
 
  $_Ctr = 0	; Line Counter 
  $_SQF = 0	; Single Quote Flag 

  $_DQF = 0	; Double Quote Flag 
  $_VF  = 0	; Variable Flag 
  $_FF  = 0	; Function Flag 

  $_PF  = 0	; Paren Flag 
  $_ECt = 0
  $_Fn  = 'Main'	
 
  ; $_Vt defines characters not allowed in a variable name (denoting the end of a var name!) 

  $_Vt  = "-+\,.?&=@@()[]<>"+Chr(9)+Chr(32)+Chr(34)+Chr(36)+Chr(39)
 
  ; Start with a fresh index file 

  Del '.\VarInfo.ini'
 
;============================================================================================= 
; Open & load the source file into an array 
;============================================================================================= 
  If Open(5, $_File, 2) = 0

    While Not @ERROR
      $_FData[$_Ctr] = Trim(ReadLine(5))
      $_Ctr = $_Ctr + 1

    Loop
    ReDim Preserve $_FData[$_Ctr - 1]
    $_ = Close(5)
  EndIf

 
 
;============================================================================================= 
; PASS 1 
; Parse the file data, looking for all function and variable declaration statements.  
; Variable declaration statements can span multiple lines (which are consolidated in 
; the array forfurther processing). This pass prepares the raw data for further  
; processing. Note that when a reference is made to a consolidated line, it is made  
; to the first line of reference (Declaration Line), and not the actual line in the  
; source file. 

;============================================================================================= 
 
  $_Ctr = 0							; init array/line pointer 
  While $_Ctr <= UBound($_FData)
    $_Line = $_FData[$_Ctr]
    $_Ctr = $_Ctr + 1						; data is 0 indexed, references are 1 indexed 

 
    $_Ctr '     ' CHR(13)					; simple progress indicator 
 
    $_DT = 0							; Start with _DT undefined 

    $_E  = 0
 
    If $_Line <> ''						; skip blank lines 
 
      ; Check for "dim $" and "global $" inside other code, and convert line to place the declaration 

      ; on the left edge of the line so the processing that follows will find it properly. The  
      $_L = InStr($_Line, ' Dim ' + Chr(36))
      $_G = InStr($_Line, ' Global ' + Chr(36))
      If $_L > 1 Or $_G > 1					; only 1 will be found 

        $_SQF = 0 $_DQF = 0
        ; read from beginning of line to declaration, setting quote flags and checking for comments 
        ; Ignore the declaration if it exists within quotes, or in a comment 

        For $_P = 1 to $_L + $_G				; combine 

          $_C = SubStr($_Line, $_P, 1)
          Select
            ; set the quote flags: 0=not active, 1=active alone, -1=active inside other quote 

            Case $_C = Chr(34) And Not $_DQF			; opening double quote 
              If $_SQF $_DQF = -1 Else $_DQF = 1 EndIF

            Case $_C = Chr(34) And $_DQF			; closing double quote 
              $_DQF = 0

 
            Case $_C = Chr(39) And Not $_SQF			; opening single quote 
              If $_DQF <> 0 $_SQF = -1 Else $_SQF = 1 EndIF

            Case $_C = Chr(39) And $_SQF			; closing single quote 
              $_SQF = 0

 
            Case $_C = ';' And $_SQF = 0 And $_DQF = 0		; comment - ignore rest of line 

              $_E = 1
          EndSelect
        Next
 
        ; If a one quote (any type) or a comment tag exist before the declaration, it isn't valid 
        ; process the line if none of the flags are active 

        If $_DQF =  0 And $_SQF = 0 And $_E = 0			; Declaration is valid 

          $_ = Split(SubStr($_Line, $_L + $_G + 1), ' ')	; break into words, first is "Global" 

          $_Line = $_[0] + ' '
          For $_P = 1 to UBound($_)
            If Left($_[$_P], 1) = Chr(36)			; If first char is $, add to line 

              $_Line = $_Line + $_[$_P]
            EndIF
          Next
        EndIF	; active flag 

 
      EndIf	; Dim or Global in code 
 
      ; Line is ready for evaluation - find function, dim, and global declarations 
 
      Select
 
        ; =============================================================================== 
        ; Check for function Start 

        Case InStr($_Line, 'Function ') = 1
          $_Fn = Trim(Split(SubStr($_Line, 10), '(')[0])
          ; warn if defining a function without terminating the prior definition 

          If $_FF
            L_Msg('Recursive function definition', 'Prior function definition may not be properly terminated.', '', $_Fn, $_Ctr, $_Log)
            L_Msg(Right('        ' + CStr($_Ctr) + ': ', 9) + $_Line, '', '', '', '', $_Log)
            $_ECt = $_ECt + 1

          EndIF
 
          ; define the reference to the function, and turn on the active Function Flag 
          $_FF = 1
          $_ = WriteProfileString('.\VarInfo.ini', $_Fn, 'DefinedOnLine', $_Ctr)
 
          ; include the Fn name as a declared var 

          $_ = WriteProfileString('.\VarInfo.ini', $_Fn, cHR(36) + $_Fn, '1,' + CStr($_Ctr))
 
          ; mark any passed arguments as defined variables 

          $_Vars = Join(Split(Split(Split($_Line, Chr(40))[1], Chr(41))[0], ' '), '')
          If $_Vars <> ''

            For Each $_Var in Split($_Vars, ',')
              If Left($_Var, 9) = 'optional' + Chr(36)		; check for "Optional$VarName" & trim it 

                $_Var = SubStr($_Var, 9)
              EndIf
              If Trim($_Var) <> 'Optional'			; exclude "optional" tags 

                $_ = WriteProfileString('.\VarInfo.ini', $_Fn, Trim($_Var), '1,' + CStr($_Ctr))
              EndIf

            Next
          EndIF
        ; Function ? 
 
        ; Check for Function End 
        Case InStr($_Line, 'EndFunction') = 1

          $_FF = 0
          $_Fn = 'Main'
        ; EndFunction ? 
        
 
        ; =============================================================================== 

        ; Check for Variable Declaration statements - can be one of: 
        ;  
        ; Declare Varname, varname...		(type 1/2) 
        ;  
        ; Declare Varname, varname... ,		(type 3/4) 
        ; more_var_names..., last_var_name 

        ;  
        ; Declare 				(type 5/6) 
        ; Varname, varname... , 
        ; more_var_names..., last_var_name 
        ;  
        ; "Declare" can be "Global" or "Dim" 

 
        Case InStr($_Line, 'Global') = 1			; found a GLOBAL declaration 
          $_Line = Trim(Split($_Line, ';')[0])			; remove comment portion 

          Select
            Case $_Line = 'Global'				; type 5 
              $_DT = 5

              $_Line = $_Line + ' '
            Case Right($_Line, 1) = ','				; type 3 

              $_DT = 3
            Case 1						; type 1 
              $_DT = 1

          EndSelect
 
        Case InStr($_Line, 'Dim') = 1
          $_Line = Trim(Split($_Line, ';')[0])			; remove comment portion 

          Select
            Case $_Line = 'Dim'					; type 6 
              $_DT = 6

              $_Line = $_Line + ' '
            Case Right($_Line, 1) = ','				; type 4 

              $_DT = 4
            Case 1						; type 2 
              $_DT = 2

          EndSelect
 
      EndSelect
 
 
      ; If $_DT > 2, source lines are split. 
      ; collect & combine the following lines until none end in ',' before continuing 
      ; The data in the array source is combined - this is the  

      If $_DT > 2
        $_ = $_Ctr - 1						; remember where the declaration started 

        Do
          $_Line = $_Line + $_FData[$_Ctr]
          $_FData[$_Ctr] = ''					; clear the extended source line 

          $_Ctr = $_Ctr + 1
        Until Right($_Line, 1) <> ','

        $_FData[$_] = $_Line					; write the combined source line 
      EndIf
 
      ; Lines are combined, process either basic DIM or GLOBAL statements 
      If $_DT = 2 Or $_DT = 4 Or $_DT = 6			; DIM 

      ;  $_Line = Split($_Line, ';')[0]				; remove comment portion 
        $_E = Len($_Line)
        For $_P = 5 to $_E

          $_C = SubStr($_Line, $_P, 1)
 
          Select
            Case $_C = Chr(36) And $_VF = 0			; found "$" 

              $_Var = $_C
              If $_P = $_E					; trap for "Dim $" by itself 
                $_VF = 0

                $_ = WriteProfileString('.\VarInfo.ini', $_Fn, Trim($_Var), '1,' + CStr($_Ctr))
              Else

                $_VF = 1
              EndIf
 
            Case $_VF = 1 And (InStr($_Vt, $_C) Or $_P = $_E)	; terminating char 

              $_VF = 0
              If $_P = $_E And Not InStr($_Vt, $_C)		; EOL - add last char if needed 

                $_Var = $_Var + $_C
              EndIf
              $_ = WriteProfileString('.\VarInfo.ini', $_Fn, Trim($_Var), '1,' + CStr($_Ctr))
 
              If $_C = '[' $_VF = -1 EndIf			; handle arrays 

 
            Case $_VF = -1					; skip chars betweet [ and ] 
              If $_C = ']' $_VF = 0 EndIf

 
            Case $_VF = 1 And Not InStr($_Vt, $_C)		; build var name 

              $_Var = $_Var + $_C
          
          EndSelect
        Next
      EndIf

 
      If $_DT = 1 Or $_DT = 3 Or $_DT = 5			; GLOBAL 

      ;  $_Line = Split($_Line, ';')[0]				; remove comment portion 
        $_E = Len($_Line)
        For $_P = 8 to $_E

          $_C = SubStr($_Line, $_P, 1)
 
          Select
            Case $_C = Chr(36) And $_VF = 0			; found "$" 

              $_Var = $_C
              If $_P = $_E					; trap for "Global $" by itself (rare) 
                $_VF = 0

                $_ = WriteProfileString('.\VarInfo.ini', 'Global', Trim($_Var), '1,' + CStr($_Ctr))
              Else

                $_VF = 1
              EndIf
 
            Case $_VF = 1 And (InStr($_Vt, $_C) Or $_P = $_E)	; terminating char 

              $_VF = 0
              If $_P = $_E And Not InStr($_Vt, $_C)		; EOL - add last char if needed 

                $_Var = $_Var + $_C
              EndIf
              $_ = WriteProfileString('.\VarInfo.ini', 'Global', Trim($_Var), '1,' + CStr($_Ctr))
              If $_C = '['					; handle arrays 

                $_VF = -1
              EndIf
 
            Case $_VF = -1					; skip chars betweet [ and ] 

              If $_C = ']'
                $_VF = 0
              EndIF

 
            Case $_VF = 1 And Not InStr($_Vt, $_C)		; build var name 

              $_Var = $_Var + $_C
          
          EndSelect
        Next
      EndIf

 
 
    EndIf	; $_Line <> '' 
 
  Loop
 
 
 
;============================================================================================= 
; PASS 2 
; Enumerate the INI file and check for vars that have been declared both as local and global 

;============================================================================================= 
 
  $_SectList = ReadProfileString('.\VarInfo.ini', '', '')
  $_SectList = Split(Left($_SectList,len($_SectList)-1), Chr(10))
  For Each $_Fn in $_SectList

    If $_Fn <> 'Global'
      $_KeyList = ReadProfileString('.\VarInfo.ini', $_Fn, '')
      $_KeyList = Split(Left($_KeyList ,len($_KeyList)-1), Chr(10))
      For Each $_Var in $_KeyList

        $_ = ReadProfileString('.\VarInfo.ini', 'Global', $_Var)
        If $_ <> ''

          $_P = Split(ReadProfileString('.\VarInfo.ini', $_Fn, $_Var), ',')[1]
          $_  = Split(ReadProfileString('.\VarInfo.ini', 'Global', $_Var), ',')[1]
          L_Msg('Variable declared multiple times.', 'Previously declared as GLOBAL on line ' + CStr($_) + '.', $_Var, $_Fn, $_P, $_Log)
          $_ECt = $_ECt + 1          
        EndIf

      Next
    EndIf
  Next
 
 
 
;============================================================================================= 
; PASS 3 
; Scan the data and identify the variables that are used, verify that they are declared, and 
; check for variable and macro usage inside of strings 

;============================================================================================= 
 
  ; reset the line counter for the third pass 
  $_Ctr = 0
  $_Fn  = 'Main'

  $_VF  = 0	; Variable Flag 
  $_FF  = 0	; Function Flag 
 
 
 
  While $_Ctr <= UBound($_FData)
    $_Line = $_FData[$_Ctr]					; get working line 

    $_Ctr = $_Ctr + 1						; increment counter 
    $_Ctr '    ' CHR(13)					; simple status indicator 

 
    If $_Line <> ''
 
      $_SQF = 0							; init per-line flags 
      $_DQF = 0

      $_PF  = 0
 
      ; =============================================================================== 
      ; filter out lines we don't want to process char by char 
 
      Select
      ; Check for function Start / End to get name to reference 

      Case InStr($_Line, 'Function') = 1
        $_Fn = Trim(Split(SubStr($_Line, 10), Chr(40))[0])	; set active function name 

 
      Case InStr($_Line, 'EndFunction') = 1
        $_Fn = 'Main'						; default active function to "main" 

 
      Case InStr($_Line, 'IsDeclared')				; do nothing - just ignore this line 
         
      Case 1							; valid line to parse 

 
        ; =============================================================================== 
        ; parse the line, char by char, looking for varnames, quotes, parens, and comments 
 
        $_VF = 0						; clear the var active flag 
 
        $_E = Len($_Line)					; line end pointer 

        For $_P = 1 to $_E					; char pointer 
          $_C = SubStr($_Line, $_P, 1)				; get the active char 

 
          ; =============================================================================== 
          ; set the quote flags: 0=not active, 1=active alone, -1=active inside other quote 
          If $_C = Chr(34) Or $_C = Chr(39)
            Select

            Case $_C = Chr(34) And $_DQF = 0			; opening double quote 

              $_DQF = IIf($_SQF <> 0, -1, 1)			; process embedded quotes 

            Case $_C = Chr(34) And $_DQF <> 0			; closing double quote 

              $_DQF = 0
              If $_SQF = -1 $_SQF = 0 EndIf

 
            Case $_C = Chr(39) And $_SQF = 0			; opening single quote 

              $_SQF = IIf($_DQF <> 0, -1, 1)			; process embedded quotes 

            Case $_C = Chr(39) And $_SQF <> 0			; closing single quote 

              $_SQF = 0
              If $_DQF = -1 $_DQF = 0 EndIf

            EndSelect
          EndIf
 
          If $_C = Chr(40) And $_SQF = 0 And $_DQF = 0		; Opening Paren 

            $_PF = $_PF + 1
          EndIf
          If $_C = Chr(41)And $_SQF = 0 And $_DQF = 0		; Closing Paren 

            $_PF = $_PF - 1
          EndIf
 
          If $_C = ';' And $_SQF = 0 And $_DQF = 0		; comment - ignore rest of line 

            $_P = Len($_Line) + 1
          EndIf
 
          If $_P < $_E And $_C = Chr(36)			; double-$ 

            ; Ignore if next char is a $ 
            If SubStr($_Line, $_P + 1, 1) = Chr(36)
              $_P = $_P + 1					; move to next char position, same char 

            EndIf
          EndIf
 
 
          ; =============================================================================== 
          ; Build a variable name if a reference is encountered 
 
          ; If the VarFlag is active, check for variable termination 
          ; this occurs when EOL is reached, or an invalid varname char is present 

          If $_VF						; actively building varname 
            If $_P = $_E Or InStr($_Vt, $_C)			; are we terminating? 

              If $_P = $_E And Not InStr($_Vt, $_C)		; add last char if EOL Terminated 

                $_Var = $_Var + $_C
              EndIf
              $_VF = 0						; clear active var flag 

 
              ; Find any Local or Global declarations 
              $_L = ReadProfileString('.\VarInfo.ini', $_Fn, $_Var)
              $_G = ReadProfileString('.\VarInfo.ini', 'Global', $_Var)
 
              ; gripe if variable is not declared at all 

              If  $_L = '' And $_G = '' 
                $_ = WriteProfileString('.\VarInfo.ini', $_Fn, $_Var, '0,' + CStr($_Ctr))
                L_Msg('Undeclared variable.', '', $_Var, $_Fn, $_Ctr, $_Log)
                $_ECt = $_ECt + 1

                $_ShowLine = 0
              Else						; update the declared var reference 
                If $_G						; global Var 

                  If Left($_G, 1) <> 2
                    $_ = Split($_G, ',')[1]
                    $_ = WriteProfileString('.\VarInfo.ini', 'Global', $_Var, '2,' + $_)
                  EndIF

                EndIf
                If $_L						; local Var 
                  If Left($_L, 1) <> 2

                    $_ = Split($_L, ',')[1]
                    $_ = WriteProfileString('.\VarInfo.ini', $_Fn, $_Var, '2,' + $_)
                  EndIF

                EndIf
              EndIf
 
              ; gripe if var is inside of quotes 
              If $_SQF = 1 or $_DQF = 1

                L_Msg('Variable referenced inside string.', '', $_Var, $_Fn, $_Ctr, $_Log)
                $_ECt = $_ECt + 1

                $_ShowLine = 1
              EndIf
 
            Else
              $_Var = $_Var + $_C				; build the var name 

            EndIf
          Else
            If $_C = Chr(36)					; found a $? 

              $_Var = $_C
              $_VF = 1						; set active var flag 
            EndIf

          EndIf
 
        Next	; char 
 
      EndSelect 
 
 
      ; process warnings for inconsistent flags 
      If $_SQF = 1						; Unterminated single quote 

        L_Msg('Possible unterminated single-quote.', '', '', $_Fn, $_Ctr, $_Log)
        $_ECt = $_ECt + 1

        $_ShowLine = 1
      EndIf
      If $_DQF = 1						; Unterminated double quote 

        L_Msg('Possible unterminated double-quote.', '', '', $_Fn, $_Ctr, $_Log)
        $_ECt = $_ECt + 1

        $_ShowLine = 1
      EndIf
 
      If $_PF <> 0						; Mismatched parenthesis 

        L_Msg('Possible mismatched parenthesis.', 'PF='+$_PF, '', $_Fn, $_Ctr, $_Log)
        $_ECt = $_ECt + 1

        $_ShowLine = 1
 
      EndIf
 
      ; display the line if errors were encountered 
      If $_ShowLine

        L_Msg(Right('        ' + CStr($_Ctr) + ': ', 9) + $_Line, '', '', '', '', $_Log)
        $_ShowLine = 0

      EndIf
 
    EndIf	; $_Line <> '' 
 
  Loop
 
 
 
;============================================================================================= 
; PASS 4 

; Scan the INI file and list all variables that are declared but not referenced 
;============================================================================================= 
 
  $_SectList = ReadProfileString('.\VarInfo.ini', '', '')
  $_SectList = Split(Left($_SectList,len($_SectList)-1), Chr(10))
  For Each $_Fn in $_SectList

    $_KeyList = ReadProfileString('.\VarInfo.ini', $_Fn, '')
    $_KeyList = Split(Left($_KeyList ,len($_KeyList)-1), Chr(10))
    For Each $_Var in $_KeyList

      If $_Var <> 'DefinedOnLine'
        $_ = Split(ReadProfileString('.\VarInfo.ini', $_Fn, $_Var) + ',unknown', ',')
        If $_[0] = '1'

          If Not InStr($_Var,$_Fn)			; don't complain about UDF return vars not being used 
            L_Msg('Variable declared but not referenced.', 'Declaration line is referenced above.', $_Var, $_Fn, $_[1], $_Log)
          $_ECt = $_ECt + 1

          EndIf
        EndIf
      EndIf
    Next
  Next
 
  L_Msg(' ' + $_Ect + ' warnings generated, ' + $_Ctr + ' lines processed.', '', '', 

ÿCode:

;FUNCTION:
;	Save()
;
;ACTION:
;	Brings up the save file dialog and lets you save a file.
;
;AUTHOR:
;	Mart
;
;Source:
;	http://blogs.msdn.com/gstemp/Default.aspx?p=2
;
;VERSION:
;	1.0
;
;DATE CREATED:
;	December 24th 2007
;
;Revised:
;	None.
;
;SYNTAX:
;	Save($data, $filetype, $filename)
;
;PARAMETERS:
;	$data (required, string)
;		The contents of the file to be created.
;	$filetype (optional, string)
;		The filetype of the file to be created.
;		Text files (.txt), CSV Files (.csv), etc...
;	$filename (optional, string)
;		The name of the file to be created.
;
;RETURNS:
;	System error codes.
;
;REMARKS:
;	None.
;
;DEPENDENCIES;
;	Developed and tested with KiXtart 4.60 on WinXP pro SP2.
;
;EXAMPLES:
;	Example1:
;		;This example creates a file called test.txt that contains three lines.
;		$data = "line1" + @CRLF + "line2" + @CRLF + "line3"
;		$filetype = "Text files (.txt)"
;		$filename = "test.txt"
;		$rc = Save($data, $filetype, $filename)
;
;	Example2: (requires the ReadFile() UDF)
;		;This example creates a file called test.txt that contains the contents of the file read with the ReadFile UDF.
;		;Almost the same as the copy command but this brings up a GUI.
;		$file = ReadFile("c:\somefile.txt")
;		For Each $line in $file
;			$data = $data  + $line + @CRLF
;		Next
;		$filetype = "Text files (.txt)"
;		$filename = "test.txt"
;		$rc = Save($data, $filetype, $filename)
;
Function Save($data, optional $filetype, $filename)
	Dim $dialog, $path, $fso, $file
	
	If Trim($data) = ""
		Exit 13
	EndIf

	$dialog = CreateObject("SAFRCFileDlg.FileSave")
	$dialog.FileName = $filename
	$dialog.FileType = $filetype
	$path = $dialog.OpenFileSaveDlg
	
	If $path
		$fso = CreateObject("Scripting.FileSystemObject")
		$file = $fso.CreateTextFile($dialog.FileName)
		$file.WriteLine($data)
		$file.Close
	EndIf
	$save = @ERROR
EndFunction
84384ScanStartup3755GavenScanStartup() - Compares startup items to array and removes if not found0

code:

;  Function:     ScanStartup()
;
;  Author:       Gaven Henderson, Gaven@GavDogg.net
;  
;  Action:       ScanStartup scans the registry and compares the items in the various start-up locations
;                to those listed in an array.  If an item exists that's not on the list, it is removed.
;                This function now also scans the "Startup" section of the start menu.  Note that it only
;                checks the file name and NOT its location.  Note:  ScanStartup will not delete desktop.ini
;                in Start Menu\Programs\Startup under any condition.
;
;  Remarks:      I highly suggest that you have a blank "" entry in the ApArray that way it doesn't mess
;                with blank entries.  Items removed from Start Menu\Programs\Startup are deleted.
;  
;  Syntax:       scanstartup([ApArray], optional Switches)
;
;  Version:      3.3
;
;  Post Date:    June 26, 2003
;
;  Revise Date:  July 10, 2003
;
;  Parameters:   ApArray
;                   An array listing filenames allowed to load on start-up.  Do not include quotes unless
;                   it isn't on the beginning or end.
;
;                Switches
;                   Switches are set bit-wise in a single number, add options to produce the switches number.
;
;                   0 - Default, return integer representing the number of items removed
;                   1 - Return a one-dimensional array of items removed
;                   2 - Only allow .lnk files in Start Menu\Programs\Startup (otherwise non-.lnk files are
;                       compared to the ApArray and deleted if not found)
;  
;  Returns:      An integer representing the number of items that were removed or a one-dimensional array of
;                items removed.
;              
;                @Error
;                   When a key or shortcut cannot be deleted the function terminates immediately but still
;                   returns data.  The item that could not be deleted will be listed as deleted.  With option
;                   1, this means the last item in the array could not be deleted.  Without option 1, the
;                   number removed will be one PLUS the number really removed.  NOTE: The shortcut scan will
;                   error out if the Explorer object cannot be created.  In this event, the shortcut that would
;                   have been scanned is NOT included in the returned data.
;
;                   0  - no errors
;                   35 - unable to locate Start Menu\Programs\Startup
;                   37 - unable to delete shortcut
;                   x  - error received deleting registry item or creating 
;
;  KiXtart Ver:  Designed on 4.20 but should work on any version supporting 'ENumValue' and 'AScan'
;
;  Dependencies: This function creates an explorer object though Shell.Application in order to be able to read
;                shortcut targets.  If this fail, the function will terminate while evaluating shortcuts and
;                return an approporiate error code.  The first found shortcut will not included in the results
;                whereas registry items would be if an error happened on removal.
;
;  Examples:     $apps = 'ctfmon.exe','navapw32.exe','em_exec.exe','Rundll32.exe powrprof.dll,LoadCurrentPwrScheme','scanregw.exe /autorun','systray.Exe','taskmon.exe','mstask.exe','SBServ.exe" -reg',''
;
;                $numremoved = scanstartup($apps)
;                $numremoved " item(s) were removed"
;
;                $removed = scanstartup($apps,1)
;                $removed = Join($removed,", ")
;                "Removed: " $removed
;
Function scanstartup($okaps, optional $switches)
	Dim $a,$b,$c[0],$d,$e,$f,$g[0],$h,$i,$keys[3],$rc
	$keys[0]="HKLM\Software\Microsoft\Windows\CurrentVersion\Run"
	$keys[1]="HKLM\Software\Microsoft\Windows\CurrentVersion\RunServices"
	$keys[2]="HKCU\Software\Microsoft\Windows\CurrentVersion\Run"
	$keys[3]="HKCU\Software\Microsoft\Windows\CurrentVersion\RunServices"
	$scanstartup=0
	$switches=Val($switches)
	If $switches>3 Or $switches<1 $switches=0 EndIf
	For $a=0 To UBound($keys,1)
		If KeyExist($keys[$a])<>0
			$b=0
			$c[$b]=ENumValue($keys[$a],$b)
			While @Error=0
				$b=$b+1
				Redim Preserve $c[$b]
				$c[$b]=ENumValue($keys[$a],$b)
			Loop
			For $d=0 To ($b-1)
				$f=ReadValue($keys[$a],$c[$d])
				$h=$f
				If Right($f,1)='"' Or Right($f,1)="'" $f=Left($f,Len($f)-1) EndIf
				If InStr($f,"\")=0
					If Left($f,1)='"' Or Left($f,1)="'" $f=Right($f,Len($f)-1) EndIf
					$e=AScan($okaps,$f)
				Else
					$e=AScan($okaps,(Right($f,Len($f)-InStrRev($f,"\"))))
				EndIf
				If $e=-1
					$rc=DelValue($keys[$a],$c[$d])
					Redim Preserve $g[$scanstartup]
					$g[$scanstartup]=$keys[$a]+"\"+$c[$d]+" = "+$h
					If $rc<>0
						If ($switches & 1) $scanstartup=$g EndIf
						Exit $rc
					EndIf
					$scanstartup=$scanstartup+1
				EndIf
			Next
		EndIf
	Next
	$i="HKCU\Software\Microsoft\Windows NT\CurrentVersion\Windows"
	$h=ReadValue($i,"Load")
	If $h<>"" And AScan($okaps,$h)=-1
		$rc=WriteValue($i,"Load","","REG_SZ")
		Redim Preserve $g[$scanstartup]
		$g[$scanstartup]=$i+"\Load = "+$h
		If $rc<>0
			If ($switches & 1) $scanstartup=$g EndIf
			Exit $rc
		EndIf
		$scanstartup=$scanstartup+1
	EndIf
	$a=0
	$keys[0]=""
	If Exist("%windir%\Start Menu\Programs\Startup") And @Inwin=2
		Redim $keys[$a]
		$keys[$a]="%windir%\Start Menu\Programs\Startup\"
		$a=$a+1
	Else
		If Exist("%userprofile%\Start Menu\Programs\Startup")
			Redim $keys[$a]
			$keys[$a]="%userprofile%\Start Menu\Programs\Startup\"
			$a=$a+1
		Else
			If Exist("%windir%\Profiles\@Userid\Start Menu\Programs\Startup")
				Redim $keys[$a]
				$keys[$a]="%windir%\Profiles\@Userid\Start Menu\Programs\Startup\"
				$a=$a+1
			Else
				If Exist(Left(%windir%,3)+"Documents and Settings\@Userid\Start Menu\Programs\Startup")
					Redim $keys[$a]
					$keys[$a]=Left(%windir%,3)+"Documents and Settings\@Userid\Start Menu\Programs\Startup\"
					$a=$a+1
				EndIf
			EndIf
		EndIf
		If Exist("%allusersprofile%\Start Menu\Programs\Startup")
			Redim Preserve $keys[$a]
			$keys[$a]="%allusersprofile%\Start Menu\Programs\Startup\"
			$a=$a+1
		Else
			If Exist("%windir%\Profiles\All Users\Start Menu\Programs\Startup")
				Redim Preserve $keys[$a]
				$keys[$a]="%windir%\Profiles\All Users\Start Menu\Programs\Startup\"
				$a=$a+1
			Else
				If Exist(Left(%windir%,3)+"Documents and Settings\All Users\Start Menu\Programs\Startup")
					Redim Preserve $keys[$a]
					$keys[$a]=Left(%windir%,3)+"Documents and Settings\All Users\Start Menu\Programs\Startup\"
					$a=$a+1
				EndIf
			EndIf
		EndIf
	EndIf
	If $keys[0]=""
		If ($switches & 1) $scanstartup=$g EndIf
		Exit 35
	EndIf
	For $a=0 To UBound($keys,1)
		$f=$keys[$a]+Dir($keys[$a]+"*.*")
		While @Error=0
			If Right($f,1)<>"."
				If Right($f,3)="lnk"
					$b=CreateObject("Shell.Application")
					If @Error
						If ($switches & 1) $scanstartup=$g EndIf
						Exit @Error
					EndIf
					$d=$b.NameSpace($keys[$a])
					$e=$d.ParseName(Right($f,Len($f)-InStrRev($f,'\')))
					If @Error
						If ($switches & 1) $scanstartup=$g EndIf
						Exit @Error
					EndIf
					$h=$e.GetLink
					$i=$h.Path
					$h=0
					$e=0
					$d=0
					$b=0
					If AScan($okaps,Right($i,Len($i)-InStrRev($i,'\')))=-1
						Del $f
						Redim Preserve $g[$scanstartup]
						$g[$scanstartup]=$f+' = '+$i
						$scanstartup=$scanstartup+1
						If Exist($f)
							If ($switches & 1) $scanstartup=$g EndIf
							Exit 37
						EndIf
					EndIf
				Else
					$i=Right($f,Len($f)-InStrRev($f,'\'))
					If (($switches & 2) Or AScan($okaps,$i)=-1) And $i<>desktop.ini
						Del $f
						Redim Preserve $g[$scanstartup]
						$g[$scanstartup]=$f
						$scanstartup=$scanstartup+1
					EndIf
				EndIf
			EndIf
			$f=$keys[$a]+Dir()
		Loop
	Next
	If ($switches & 1) $scanstartup=$g EndIf
EndFunction


 
 [ 10. July 2003, 13:48: Message edited by: Gaven ]112623Scheduled2980Glenn BarnasScheduled Task Control Library for JT.EXE *DELETED*0Post deleted by Glenn Barnas82366SCHEDULETASK17SealeopardSCHEDULETASK() - Schedules a task on any computer using the Task Scheduler1073504081Code:


;FUNCTION      ScheduleTask

;

;ACTION        Schedules a task on any computer using the Task Scheduler

;

;AUTHOR        Jens Meyer (sealeopard@usa.net)

;

;VERSION       1.41 (corrected typos in the date checker)

;              1.4  (added support for both MM/DD/YYY and YYYY/MM/DD date formats

;              1.3  (made username/password/comment optional parameters, changed parameter order, added

;                    optional parameter for JT.EXE location, checks %PATH% for presence of JT.EXE)

;              1.2  (removed error code trigger for deleting non-existing tasks, changed order of

;                    parameters that create task, updated header with regards to quote usage, added

;                    optional typearguments)

;              1.1  (added error codes, streamlined code)

;              1.0

;

;DATE CREATED  2001/12/04

;

;DATE MODIFIED 2004/01/06

;

;KIXTART       4.12+

;

;SYNTAX        SCHEDULETASK($NAME,$COMP,$DATE,$TIME,$TYPE,$CMD [,$PRMS,$USER,$PW,$COMMENT,TYPEARGS,JT])

;

;PARAMETERS    NAME

;              name of the task

;

;              COMP

;              computername on which the task is to be run, computer must have the Task Scheduler installed

;

;              DATE

;              date on which to run the task (MM/DD/YYYY, YYYY/MM/DD, or TODAY)

;

;              TIME

;              time on which to run the task (H:M or NOW) with NOW indicating 60 seconds in the future

;

;              TYPE

;              trigger types (DAILY n | WEEKLY n, | MONTHLYDATE , | MONTHLYDOW n,,months |

;              ONCE | ONIDLE | ATSTARTUP | ATLOGON)

;

;              CMD

;              the command to be executed by the task scheduler, cannot contain the quote character "

;

;              USER

;              userid under which to run the task (can be any valid local or domain user). If no userid

;              is provided then the current userid is being used

;

;              PW

;              password for the userid

;

;              PRMS

;              optional parameters that are provided to the command, cannot contain the quote character "

;

;              COMMENT

;              comment field with information about task, cannot contain the quote character "

;

;              TYPEARGS

;              Optional parameter for trigger types, see jt /? ctj for details

;

;              JT

;              optional string denoting the location of JT.EXE, by default the UDF checks for JT.EXE

;              in @STARTDIR, @SCRIPTDIR, @CURDIR, and %PATH%. @SCRIPTDIR will point to the location of the file

;              containing the ScheduleTask UDF which does not necessarily need to be in the same directory

;              as the actual script.

;

;RETURNS       0 if successful, otherwise error code

;

;REMARKS       Requires the file JT.EXE, which is part of the Microsoft Windows 2000 Resource Kit Supplement

;              and can be downloaded at ftp://ftp.microsoft.com/reskit/win2000/jt.zip

;              Best used to schedule batch files due to problems with double quote usage in some of the JT.EXE parameters.

;              Administrative privileges on the remote computer are required in order to schedule a task on the remote computer

;              User environment variables like %USERNAME% or %LOGONSERVER% are not available in the scheduled tasks. System-wide

;              environmentvariables like %COMSPEC% or %WINDIR% can be used, however.

;

;DEPENDENCIES  'Task Scheduler' service, can be installed via IE5.5 'Offline Browsing Pack' component under Windows NT 4.0

;

;EXAMPLE       $name='demo.job'

;              $comp='SERVER'

;              $date='TODAY'

;              $time='NOW'

;              $type='ONCE'

;              $cmd='notepad'

;              $prms='%TEMP%\test.txt'

;              $user='administrator'

;              $pw='adminpassword'

;              $comment='cool!'

;              $typeargs=''

;              $rc=scheduletask($name,$comp,$date,$time,$type,$cmd,$prms,$user,$pw,$comment,$typeargs,$jt)

;

;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Board=UBB12&Number=81907

;

function scheduletask($name, $comp, $date, $time, $type, $cmd, optional $prms, optional $user, optional $pw, optional $comment, optional $typeargs, optional $jt)

  Dim $jtexe[3], $shellcmd, $path



  if $name='' or $comp='' or $date='' or $time='' or $type='' or $cmd=''

    exit 87

  endif



  ; create an array of potential filepaths to jt.exe

  $jtexe[0]=$jt

  $jtexe[1]=@STARTDIR+'\jt.exe'

  $jtexe[2]=@SCRIPTDIR+'\jt.exe'

  $jtexe[3]=@CURDIR+'\jt.exe'

  $path=split('%PATH%',';')

  for each $jt in $path

    redim preserve $jtexe[ubound($jtexe)+1]

    $jtexe[ubound($jtexe)]=join(split($jt+'\jt.exe','\\'),'\')

  next



  ; check each filepath for the presence of jt.exe

  for each $jt in $jtexe

    if exist($jt) and not (getfileattr($jt) & 16) and ubound($jtexe)+1

      $jtexe=$jt

    endif

  next

  select

  case ubound($jtexe)+1

    exit 2

  case not exist($jtexe)

    exit 2

  endselect



  if left($comp,2)<>'\\'

    $comp='\\'+$comp

  endif



  if right($name,4)<>'.job'

    $name=$name+'.job'

  endif



  select

  case $date='TODAY'

    ; valid format

  case len($date)<>10

    exit 87

  case substr($date,3,1)='/'

    ; valid format

  case substr($date,5,1)='/'

    ; reformat date

    $date=split($date,'/')

    $date=$date[1]+'/'+$date[2]+'/'+$date[0]

  case 1

    exit 87

  endselect



  ; delete a potentially existing task

  $shellcmd = $jtexe

  if $user and $pw

    $shellcmd = $shellcmd+ ' /SC "'+$user+'" "'+$pw+'"'

  endif

  $shellcmd = $shellcmd+ ' /SM '+$comp

  $shellcmd = $shellcmd+ ' /SD "'+$name+'"'



  shell '%COMSPEC% /e:1024 /c '+$shellcmd+' >NUL 2>NUL'



  $shellcmd = $jtexe



  if $user and $pw

    $shellcmd = $shellcmd+ ' /SC "'+$user+'" "'+$pw+'"'

  endif



  $shellcmd = $shellcmd+ ' /SM '+$comp

  $shellcmd = $shellcmd+ ' /SJ ApplicationName="'+$cmd+'"'



  if $prms

    $shellcmd = $shellcmd+ ' Parameters="'+$prms+'"'

  endif



  $shellcmd = $shellcmd+ ' WorkingDirectory="%SYSTEMROOT%"'

  $shellcmd = $shellcmd+ ' Comment="'+$comment+'"'

  $shellcmd = $shellcmd+ ' Creator="'+@userid+'"'

  $shellcmd = $shellcmd+ ' Priority=Normal'

  $shellcmd = $shellcmd+ ' MaxRunTime=3600000'

  $shellcmd = $shellcmd+ ' DontStartIfOnBatteries=0'

  $shellcmd = $shellcmd+ ' KillIfGoingOnBatteries=0'

  $shellcmd = $shellcmd+ ' RunOnlyIfLoggedOn=0'

  $shellcmd = $shellcmd+ ' SystemRequired=0'

  $shellcmd = $shellcmd+ ' DeleteWhenDone=1'

  $shellcmd = $shellcmd+ ' Suspend=0'

  $shellcmd = $shellcmd+ ' StartOnlyIfIdle=0'

  $shellcmd = $shellcmd+ ' KillOnIdleEnd=0'

  $shellcmd = $shellcmd+ ' RestartOnIdleResume=0'

  $shellcmd = $shellcmd+ ' Hidden=0'

  $shellcmd = $shellcmd+ ' TaskFlags=0'



  $shellcmd = $shellcmd+ ' /CTJ StartDate='+$date

  $shellcmd = $shellcmd+ ' StartTime='+$time

  $shellcmd = $shellcmd+ ' HasEndDate=0'

  $shellcmd = $shellcmd+ ' KillAtDuration=0'

  $shellcmd = $shellcmd+ ' Disabled=0'

  $shellcmd = $shellcmd+ ' Type='+$type

  if $typeargs

    $shellcmd = $shellcmd+ ' TypeArguments='+$typeargs

  endif



  $shellcmd = $shellcmd+ ' /SAJ "'+$name+'"'



  shell '%COMSPEC% /e:1024 /c '+$shellcmd+' >NUL 2>NUL'

  $scheduletask=@ERROR

  exit @ERROR

endfunction



83710ScreenRes119LonkeroScreenRes() - get screen resolution0

code:

;Function:
;	ScreenRes()
;
;Author:
;	Lonkero
;
;Version:
;	1.0.1 (28.11.2002)
;
;Action:
;	retrieves screen resolution (pixels)
;
;Syntax:
;	ScreenRes
;
;Parameters:
;	optional destination
;
;Remarks:
;	Saw the getscreenres() function and decided to make it little bit shorter
;
;Returns:
;	2 element array with elements:
;		0 - screen width
;		1 - screen height
; 
;Dependencies:
;	WMI
; 
;Examples:
;1:	$Resolution=ScreenRes
;	"your Screen are is "
;	 $Resolution[0] "x" $Resolution[1]
;
;2:	"your screen resolution is:"
;	join(screenres,"x")
;
;Source:
function ScreenRes(optional $)
 if not ""+$ $="." endif
 For each $ in GetObject("winmgmts:\\"+$+"\root\cimv2").ExecQuery("Select * from Win32_DesktopMonitor",,48)
  $ScreenRes=$.ScreenWidth,$.ScreenHeight
 Next
endfunction


 
 [ 28. November 2002, 12:01: Message edited by: Lonkero ]135185ScriptDebug6004Georges_KScriptDebug UDF0I have written a scriptdebug function that proved to be very useful in my scripts, so I thought I'd share it in case anyone can use something like this.
here it is: Code:

 
; ScriptDebug()
; Function ScriptDebug()
; Author: Georges Khairallah
; Email : gkhairallah@gmail.com
; Version: 1.01 (02/23/2005)
; Version History:
; Version 1.0
; 		- Main script written
; Version 1.1
; 		- Added ability to add specific users to run debug for
; Dependencies:
; - blat.exe (optional if you want to use the email function)
; Syntax ScriptDebug($failure,$serror1,optional $success,optional $serror2)
; Need to include a variable $debug (user changeable): 0 or 1
; Need to include a variable $debugUser (userchangeable: "username" 
; in the main script). you can include multiple users to debug seperated by commas:
; $userDebug = "user1","user2","user3", etc...
; Example:
; $debug = 1 
;$debugUser = "user1","user2"
; ScriptDebug("The task failed",1,"The task succeeded",1)
; This will obviously return "The task failed"  on @ERROR <> 0 and "Task Succeeded" on @ERROR = 0. 
the 1 includes the @SERROR for each of those
;
Function ScriptDebug($failure,$serror1,Optional $success,optional $serror2)
dim $success, $failure, $serror1, $serror2, $debugLogFile, $debugUser

; Setting Script Setting Defaults
If Not IsDeclared($debug)
	$debug = 0
EndIf

If Not IsDeclared($debugUser)
	$debugUser = ""
EndIf
; Check to see if the debuglog is going to go to an email address, or to console
If ($mail = 1) & ($recipient <> '')
	$ = RedirectOutput("$debugLogFile",0)
EndIf
; The actual Debug logic
If ($debug = 1) & (@PRIV = Admin) | (AScan($debugUser,@USERID) <> -1)
	Select
		Case @ERROR = 0 
			If $success <> ""
				If ($serror2 = 1)
				? "DEBUG: $success: @SERROR"
				EndIf
				If ($serror2 = 0)
				? "DEBUG: $success"
				EndIf
			EndIf
		Case @ERROR <> 0
		   If $failure <> ""
				If ($serror1 = 1)
				? "DEBUG: $failure: @SERROR"
				EndIf
				If ($serror1 = 0) 
				? "DEBUG: $failure"
				EndIf
			EndIf
		Case 1
			? "DEBUG: Unknown Error: @SERROR" ? "Please Consult Function Help" 
	EndSelect
EndIf
$ = RedirectOutput("")
EndFunction 

   

the 2 RedirectOutput can be removed if the mail function is not required. if you would like to use this function, there are a couple of things that need to be added:
to your main script, add this code:

 Code:

 ; Specify Config for sending mail. At this time this is used for debug purposes only.
can be used for other things in the future. 
$DebugLogFile = "%TEMP%\debugLog.log"
$mailHost = 'SMTP.DOMAIN.COM'
; Make sure to include 2 "@" signs in the email address, and anywhere there is an "@" sign,
in order to escape it, otherwise it will be interepreted as a MACRO.
; To send it to multiple people, seperate entries by commas: 'user1@@domain.com,user2@@domain.com'
$recipient = 'EMAIL@@YOURDOMAIN.COM'
$sender = @USERID+'@@YOURDOMAIN.COM'
$mailLine = @LDRIVE+'Devel\Programs\blat.exe $debugLogFile -to $recipient -server $mailhost -subject "Debug Entry for @USERID" -f $sender -q'  

 
Code:


If ($mail = 1) & ($recipient <> "")
?? "Sending Log Events to Administrator -- Please Wait" 
Shell $mailLine
Select
	Case @ERROR = 0
	? "Mail Successfully Sent"
	Sleep 2
	Case @ERROR <> 0
	? "There was a problem sending the mail: @SERROR"
	Case 1
	? "Unknown Error"
EndSelect
EndIf 



You can get blat at  http://www.blat.net   

Cheers,  84447ScriptExe259RyanScriptExe() - Returns the KiXtart Script Executable name.0

code:

;FUNCTION     ScriptExe()
;
;ACTION       Returns the KiXtart Script Executable name.
;
;AUTHOR       Ryan Groeneveld (Ryan_Groeneveld@hotmail.com)
;
;VERSION      1.00
;
;DATE CREATED 2003/07/31
;
;KIXTART      4.22 Beta 1+
;
;SYNTAX       ScriptExe([ProcessID])
;
;PARAMETERS   ProcessID
;             Optional integer, representing Kixtart exectable process id
;
;RETURNS      If ProcessID is given, ScriptExe([ProcessID]), returns
;             KIX32.EXE or wKIX32.EXE (see Example 2)
;
;           OR
;
;             If ProcessID is empty, ScriptExe(), returns
;             an Array of PID and Name of all KiXtart processes running,
;             seperated with a semicon. (see Example 2)
;
;           AND the error code @Error
;
;DEPENDENCIES WMI 1.5
;
;EXAMPLE 
;
;    "Running " + ScriptExe(@PID) + ", " + @KiX + " with Process ID " + @PID
;
;  OR
;
;    "PID" + Chr(9) + "Name" ?
;
;    $arrProcess_0           = ScriptExe()
;    For $iI = 0 To UBound($arrProcess_0)
;      $arrProcess_1         = Split($arrProcess_0[ $iI], ";")
;      $arrProcess_1[ 0] + Chr(9) + $arrProcess_1[ 1] ?
;    Next
;
Function ScriptExe(Optional $intPID)
  Dim $strProcessName, $intProcessID, $Process
  Dim $objWMI, $objProcess
      
  $objWMI               = GetObject("WinMgMts:{impersonationLevel=impersonate}!//" + @WkSta)
  $objWMI               = $objWMI.ExecQuery("Select Name,ProcessID From Win32_Process")

  If @Error = 0
    For Each $objProcess In $objWMI
      $strProcessName   = $objProcess.Name
      $intProcessID     = $objProcess.ProcessId
      If Len($intPID) = 0
        If $strProcessName = "KIX32.EXE"
         Or $strProcessName = "wKIX32.EXE"
           $Process     = $Process + CStr($intProcessID) + ";"
           $Process     = $Process + $strProcessName + "|"
        EndIf
      Else
        If $intPID = $intProcessID
          $Process      = $strProcessName + "|"
        EndIf
      EndIf
    Next
    $Process            = Left($Process, Len($Process) - 1)
    $ScriptExe          = Split($Process, "|")
    Exit 0
  Else
    Exit @Error
  EndIf
EndFunction


 
 [ 31. July 2003, 15:21: Message edited by: Ryan ]138961SearchKeyInArray1399Christophe MelinSearchKeyInArray() - search a key in a sorted field1196311958


;------------------------------------------------------------------------------ 
;function: 
;   SearchKeyInArray 
; 
;Action: 
;   Search a value in an array 
; 
;Author: 
;   Christophe MELIN 
; 
;Contributors: 
; 
;Version: 
;   1.0 
; 
;Version History: 
; 
;Date created: 
;   10/09/2004 
; 
;Date modified: 
; 
;KIXTART     KiXtart 4.02 
; 
;Syntax: 
;   SearchKeyInArray( $arr, $key, optional $index, optional $first ) 
; 
;Parameters: 
;   arr      : REQUIRED. array to search in 
;   key      : REQUIRED. value to search 
;   indexcol : OPTIONAL. number of the column to search in 
;   first    : OPTIONAL. boolean 
; 
;returns: 
;   the index of the element that matchs (if found). 
;   if key not found, returns -1 
; 
;Remarks: 
;   requires that the array is sorted before (use QuickSort) 
; 
;Dependencies: 
;  QuickSortItem (provided with QuickSort) 
; 
;------------------------------------------------------------------------------ 
function SearchKeyInArray( $arr, $key, optional $index, optional $first )
    dim $keylen, $ideb, $i, $ifin
    dim $continue, $curkey, $found

    $keylen = len($key)
    $ideb = 0
    $ifin = ubound($arr)
    $found = -1
    $continue = 1
    while $continue
        $i = ($ideb + $ifin) / 2
        $curkey = QuickSortItem( $arr[$i], $index )
        $curkey = left($curkey,$keylen)
        select
            case $curkey=$key
                $found = $i
                if $first
                    $ifin = $i - 1
                    if ($ifin<$ideb)    $continue = 0    endif
                else
                    $continue = 0
                endif

            case $curkey<$key
                $ideb = $i + 1
                if ($ideb>$ifin)    $continue = 0    endif

            case $curkey>$key
                $ifin = $i - 1
                if ($ifin<$ideb)    $continue = 0    endif

            case 1
                ;-- ??? -- 
        endselect
    loop

    $SearchKeyInArray = $found
    exit ($found=-1)
endfunction
 

optimized search in a sorted array.
requires that input array is sorted (see quicksort function).

can return the absolute first element or just the first found.
84146SearchReg46kholmSearchReg() - Search in values/valuenames/keynames of the registry0


;Function SearchReg()
;
;Action:
; Searches for a string in Value and/or ValueName and/or KeyName in a
; subkey-tree in the registry and returns all occurances in an array.
;
;Author: Erik Kærholm

;Version: 1.0

;Syntax:
; SearchReg(Subkey,SearchFor,SearchIn)
;
;Parameters:
; Subkey
; The key to start the Search in
;
; SearchFor
; The string to search for.
;
; SearchIn
; 1 for Value
; 2 for ValueName
; 3 for Value and ValueName
; 4 for KeyName
; 5 for Value and KeyName
; 6 for ValueName and KeyName
; 7 for search in all
;
;Returns:
; Array containing values where SearchFor string was found.
; arraymember format is:
; KeyName<=>ValueName
; (If the Searchstring is found in the KeyName, ValueName is set to <KeyName>
;
; Errors returned:
; @Error 1 = No data returned from search 
;
;Remarks:
; KiXtart reads and writes default ValueNames as an empty string.
; SearchReg() replaces the empty ValueName with the text: <Default>
; Remember to replace the text '<Default>' with an empty string if you want to check
; the found entries further.
;
;Dependencies:
; None
;
;KiXtart:
; KiX 4.20
;
;Example:
; Break On
; $RegArray = SearchReg("HKEY_LOCAL_MACHINE\Software\Microsoft","dir",7)
; If @Error
; ? 'No matching items found'
; Else
; For Each $value In $RegArray
; ? $value
; Next
; EndIf
; ? Get $x
; Return
;
;Source:

Function SearchReg($Key,$Str,$SrcIn)
Dim $Idx,$vName,$Value,$num,$SubKey,$fArr,$mbr

$SearchReg = ''
$num = 0
$Idx = 0
$vName = EnumValue($Key,$Idx)
Do
$mbr = ''
If $SrcIn & 1
$Value = ReadValue($Key,$vName)
If InStr($Value,$Str)
$mbr = $Key + "<=>" + IIf($vName,$vName,'<Default>')
EndIf
EndIf
If ($SrcIn & 2) And InStr($vName,$Str)
$mbr = $Key + "<=>" + $vName
EndIf
If $mbr
ReDim Preserve $SearchReg[$num]
$SearchReg[$num] = $mbr
$num = $num + 1
EndIf
$Idx = $Idx + 1
$vName = EnumValue($Key,$Idx)
Until @Error
$Idx = 0
$SubKey = EnumKey($Key,$Idx)
While $SubKey
If ($SrcIn & 4) And InStr($SubKey,$Str)
ReDim Preserve $SearchReg[$num]
$SearchReg[$num] = $Key + '\' + $SubKey + "<=><KeyName>"
$num = $num + 1
EndIf
$fArr = SearchReg($Key + "\" + $SubKey,$Str,$SrcIn)
If @Error = 0
For Each $mbr In $fArr
ReDim Preserve $SearchReg[$num]
$SearchReg[$num] = $mbr
$num = $num + 1
Next
EndIf
$Idx = $Idx + 1
$SubKey = EnumKey($Key,$Idx)
Loop
Exit VarType($SearchReg) = 8
EndFunction


 
 [ 02. May 2003, 17:05: Message edited by: kholm ]83596SecureScreenSaver52NTDOCSecureScreenSaver() - Enables Screen Saver Security0NOTE: Windows NT does not understand this as a policy.  It can be enabled, but the user can undo it unless you also remove the Screen Saver tab by policy, or possibly implement a custom policy.  This feature was first implented in 2000, that's why NT does not understand it by default.

This should work very well though on 2000/XP, but then again, using a network policy for this would be even better.

Function SecureScreenSaver()

if @inwin=1

  if ingroup('@wksta\'+sidtoname('S-1-5-32-544'))-1+@inwin

    select

      case @PRODUCTTYPE='Windows NT Workstation'

        $KeyLoction='HKCU\Control Panel\Desktop'

        $KeyType='REG_SZ'

      case @PRODUCTTYPE='Windows NT Server'

        $KeyLoction='HKCU\Control Panel\Desktop'

        $KeyType='REG_SZ'

      case 1

        $KeyLoction='HKCU\Software\Policies\Microsoft\Windows\Control Panel\Desktop'

        $KeyType='REG_DWORD'

    endselect

    $CreateKey=writevalue($KeyLoction, 'ScreenSaverIsSecure', '1', $KeyType)

    $CreateKey=writevalue($KeyLoction, 'ScreenSaveActive', '1', 'REG_SZ')

    $CreateKey=writevalue($KeyLoction, 'ScreenSaveTimeOut', '900', 'REG_SZ')

  endif

endif

endfunction 

 
 [ 30. October 2003, 06:26: Message edited by: NTDOC ]82622SendAlert17SealeopardSendAlert() - Sends a message to an alert server0

code:

;FUNCTION      SendAlert
;
;ACTION        Sends a message to an alert server
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.3
;
;KIXTART       4.20
;
;SYNTAX        SENDALERT(SERVER,STRING)
;
;PARAMETERS    SERVER
;              string or array with names of the user/computer the message is sent to
;
;              STRING
;              Required string containing the alert message
;
;RETURNS       0 if successful, otherwise error code
;
;REMARKS       none
;
;DEPENDENCIES  WARNING() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000099
;
;EXAMPLE       $rc=sendalert('PDC','An alert message has been sent!')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000100
;
function sendalert($alert_server, $alert_message)
  Dim $rc, $msg, $recipient

  $sendalert = 0

  if $alert_server='' or $alert_message=''
    $sendalert=87
    exit 87
  endif

  if not (vartype($alert_server) & 8192)
    if instr($alert_server,',')
      $alert_server=split($alert_server,',')
    else
      redim $rc[0]
      $rc[0]=$alert_server
      $alert_server=$rc
    endif
  endif

  for each $recipient in $alert_server
    $rc=sendmessage($recipient,$alert_message)
    if @ERROR
      $msg='SENDALERT: Failed sending an administrative alert to '+$recipient
      $msg=$msg+' with error code '+@ERROR+' - '+@SERROR
      $rc=warning($msg,1)
      $sendalert=@ERROR
    endif
  next

  exit $sendalert
endfunction


 
 [ 03. May 2003, 13:59: Message edited by: sealeopard ]83420Sendmail119LonkeroSendmail() - send mail with telnet0found out that I did not post my sendmail udf to here at all but into beta forum.
so here is the link to original:
http://81.17.37.55/board/ultimatebb.php?ubb=get_topic;f=3;t=000161
and if someone thinks there is already an udf sendmail, one should see the differences.
and the fact that this one is old as me:
posted 13. July 2001 15:16
and here is the udf:
Code:

;FUNCTION SendMail()
;
;AUTHOR Jooel Nieminen (jooelUnderscorEnieminenAThotmailDOTcom)
;
;ACTION Sends SMTP message (e-mail)
;
;SYNTAX SendMail(Server,From,To,Subject,Message)
;
;PARAMETERS Server (Required)
; - Specifies the SMTP server to connect to.
; - String value consisting of fully qualified machine name or ip-address
;
; From (Required)
; - string value specifieng the sender. (that is you or your script)
;
; To (Required)
; - string specifieng the recipient of the message.
;
; Subject (Required)
; - String value specifieng the subject to use on mail message.
;
; Message (Required)
; - String value that holds the message data.
;
;REMARKS At the moment no full error handling enabled!
; Do not interfier the transfer, it'll fail.
;
;RETURNS Array containing all return values when trying to send to server.
;
;ERROR CODES 53: Couldn't establish connection to server (bad_netpath)
; 13: Invalid input data
;
;DEPENDENCIES None
;
;EXAMPLE SendMail("19.101.210.22","Logonscript:"+@wksta,"Lonkero@@kix.bb.gov","test","I'm just testing... nothing more nothing less")
;

function SendMail($server,$from,$to,$subject,$message)
if (2>len($server) or 2>len($from) or 2>len($to) or 2>len($subject) or 2>len($message))
exit(13)
endif
run '%comspec% /c start "SendMail '+$server+'" /MIN telnet $server 25'
sleep 15
If SetFocus ("SendMail "+$server) <> 0 exit(53) Endif
sleep 2
If SetFocus ("SendMail "+$server) <> 0 exit(53) Endif
$r = ""+ sendkeys("MAIL FROM:$from{enter}") sleep 1
$r = $r +","+ sendkeys("RCPT TO:$to{enter}") sleep 1
$r = $r +","+ sendkeys("DATA{enter}") sleep 1
$r = $r +","+ sendkeys("From: $from{enter}")
$r = $r +","+ sendkeys("To: $to{enter}")
$r = $r +","+ sendkeys("Subject: $subject{enter}{enter}") sleep 0.5
$r = $r +","+ sendkeys("$message{enter}")
$r = $r +","+ sendkeys(".{enter}")
sleep 1
$r = $r +","+ sendkeys("QUIT{enter}")
$SendMail = $r
exit 0
endfunction

82906Sendmail609MasterOfDesasterSendmail() - Sends a Email0

code:

 
;Function Sendmail()
;
;Author Michael Szekely
;
;Action: Sends a little administrative Email
;
;Syntax Sendmail("Subjectline", "Bodytext", "Reciepient1;Recipient2")
;
;
;The reciepients can be separated by Semikolon
;
;Important!!! When you add a recipient like "user.name@acme.com" kix has problems 
; with the '@' char. you can replace it with the ascii code 64 like following line
;
;    "user.name"+chr(64)+"acme.com"
;
;
; 
;Dependencies: Outlook 2000 or new must be installed
; 
;Example:
;
;          $msgSubject="This is an administrative test mail"
;          $msgBody="This message can be deleted"
;          $msgRecip="user.name"+chr(64)+"acme.com"
;   sendmail($msgSubject, $msgBody, $msgRecip)
;
;


function sendmail($Subject, $Body, $Rec)
Dim $objOutlook
Dim $NewMessage
Dim $Recip


;Create Outlook Object
$objOutlook=CreateObject("Outlook.Application")

;Create NewMessage Object
$NewMessage=$objOutlook.CreateItem(0)

;Set Mail Subject
$NewMessage.Subject=$Subject

;Set Mail Body
$NewMessage.Body=$Body

;Add Recipients
$Recip=$NewMessage.Recipients.add($rec)

;If Outlook cannot resolve the recipient, the message will be displayed
if not $Recip.resolve
 $NewMessage.Display
endif

;Send Message
$NewMessage.send

endfunction

Sorry, that i don't find a better solution for the '@' char. i hope someone can find a better solution for that and post it here.
 
 [ 28. April 2003, 14:50: Message edited by: MasterOfDesaster ]82573SerialDate17SealeopardSerialDate() - Convert dates to numbers (and back) for the purpose of performing date0

code:

;FUNCTION      SerialDate
;
;ACTION        Convert dates to numbers (and back) for the purpose of performing date math
;
;AUTHOR        ScriptLogic (http://www.scriptlogic.com)
;
;CONTRIBUTOR   Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.1
;
;SYNTAX        SERIALDATE(DATE)
;
;PARAMETERS    DATE or NUMBER
;              if a date is used, it must be in the form of "YYYY/MM/DD"
;              if a number is used, it must be a number previously derived from this function.
;
;RETURNS       If a date is passed to this function, the function returns a number. If a number is
;              passed to this function, a date "YYYY/MM/DD" is returned
;
;REMARKS       This function was developed as a core routine for the DateMath( ) function. In
;              normal usage, you would most like just use the DateMath( ) function which depends
;              on this function.
;              Algorithms used in the development of this routine were obtained from:
;              http://www.capecod.net/~pbaum/date/date0.htm
;
;              Fixed a couple of inconsistencies in the returned values and formatting
;
;              Original UDF is posted at http://www.scriptlogic.com/kixtart/FunctionLibrary_ViewFunction.aspx?ID=SerialDate
;
;DEPENDENCIES  none
;
;EXAMPLE       $rc=serialdate('2001/07/01')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000089
;
function serialdate($ExpD)
  dim $z,$h,$a,$b,$c,$y,$m,$d
  if instr($ExpD,'/')
    $ExpD=split($ExpD,'/')
    $y=val($ExpD[0])
    $m=val($ExpD[1])
    $d=val($ExpD[2])
    if $m<3
      $m=$m+12
      $y=$y-1
    endif
    $SerialDate=$d+(153*$m-457)/5+365*$y+$y/4-$y/100+$y/400-306
  else
    $z=0+$ExpD+306
    $h=100*$z-25
    $a=$h/3652425
    $b=$a-$a/4
    $y=(100*$b+$h)/36525
    $c=$b+$z-365*$y-$y/4
    $m=(5*$c+456)/153
    $d=$c-(153*$m-457)/5
    if $m>12
      $y=$y+1
      $m=$m-12
    endif
    $SerialDate=right('0000'+$y,4)+'/'+right('00'+$m,2)+'/'+right('00'+$d,2)
  endif
endfunction


 
 [ 11. March 2003, 15:32: Message edited by: sealeopard ]82270SERIALTIME17SealeopardSERIALTIME() - Convert time to numbers (and back) for the purpose of performing time0

code:

;FUNCTION      SerialTime
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Convert time to numbers (and back) for the purpose of performing time math
;
;VERSION       1.1
;
;KIXTART       4.20
;
;SYNTAX        SERIALTIME(STRTIME)
;
;PARAMETERS    STRTIME
;              Reqired string containing either a time "HH:MM[:SS.MSECS]" or an integer greater
;              than zero and less than 86400 representing seconds and fractions
;              e.g 20.040 for 20 seconds and 40 milliseconds
;
;RETURNS       If supplied a time, returns seconds since midnight. If supplied seconds since
;              midnight, returns time.
;
;REMARKS       Reworked function based on the ScriptLogic UDF but without dependencies and adapted for milliseconds
;              The original ScriptLogic UDF at
;              http://www.scriptlogic.com/kixtart/FunctionLibrary_ViewFunction.aspx?ID=SerialTime
;              cannot manage milliseconds and relies on three dependencies.
;
;DEPENDENCIES  none
;
;EXAMPLE       $rc=SERIALTIME('02:20:33.187')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000039
;
function serialtime($strtime)
  dim $hours, $minutes, $seconds, $milliseconds

  if instr($strtime,':')
    $strtime=split($strtime,':')

    select
    case ubound($strtime)<3
      redim preserve $strtime[3]
      if instr($strtime[2],'.')
        $strtime[3]=right($strtime[2],len($strtime[2])-instr($strtime[2],'.'))
        $strtime[2]=left($strtime[2],instr($strtime[2],'.')-1)
      else
        $strtime[3]=0
      endif
    case ubound($strtime)>3
      $serialtime=-1
      exit 87
    endselect

    $hours=val($strtime[0])
    if $hours<0 or $hours>23
      $serialtime=-1
      exit 87
    endif
    $minutes=val($strtime[1])
    if $minutes<0 or $minutes>59
      $serialtime=-1
      exit 87
    endif
    $seconds=val($strtime[2])
    if $seconds<0 or $seconds>59
      $serialtime=-1
      exit 87
    endif
    $milliseconds=cdbl($strtime[3])
    if $milliseconds<0 or $milliseconds>999
      $serialtime=-1
      exit 87
    endif
    $serialtime=0.0+($hours*3600)+($minutes*60)+($seconds)+($milliseconds/1000)
  else
    $strtime=val(cdbl($strtime)*1000)
    if $strtime<=86400000 and $strtime>=0
      $hours=$strtime/3600/1000
      $strtime=$strtime-($hours*3600*1000)
      $hours=right('00'+$hours,2)
      $minutes=$strtime/60/1000
      $strtime=$strtime-($minutes*60*1000)
      $minutes=right('00'+$minutes,2)
      $seconds=$strtime/1000
      $strtime=$strtime-($seconds*1000)
      $seconds=right('00'+$seconds,2)
      $milliseconds=left($strtime,3)
      $milliseconds=right('000'+$milliseconds,3)
      $serialtime=$hours+':'+$minutes+':'+$seconds+'.'+$milliseconds
    else
      $serialtime='-1'
      exit 87
    endif
  endif
endfunction


 
 [ 02. March 2003, 17:08: Message edited by: sealeopard ]82837ServiceMode17SealeopardServiceMode() - Checks/sets the startup mode of a service0

code:

;FUNCTION      ServiceMode
;
;ACTION        Checks/sets the startup mode of a service
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.1 (added error codes, removed dependencies)
;              1.0
;
;DATE CREATED  2002/01/18
;
;DATE MODIFIED 2003/05/18
;
;KIXTART       4.12+
;
;SYNTAX        SERVICEMODE(SERVICENAME [,STARTUPMODE])
;
;PARAMETERS    SERVICENAME
;              Required string containing the name of the service (local or UNC)
;
;              STARTUPMODE
;              Optional string containing the desiredstartup mode for the service
;              (Boot | System | Automatic | Manual | Disabled )
;
;RETURNS       Startup mode of the service or errorcode
;
;REMARKS       Based on a ScriptLogic UDF (http://www.scriptlogic.com/Kixtart/functionlib/getservicestartup.asp)
;
;DEPENDENCIES  none
;
;EXAMPLE       $mode=SERVICEMODE('service','automatic')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000138
;
function servicemode($servicename, optional $startupmode)
  Dim $servicesubkey, $mode, $currentmode, $startupmodelong, $remoteserver, $regformat, $retcode

  $servicename=trim($servicename)
  $startupmode=trim($startupmode)

  if @INWIN<>1
    exit 1
  endif

  if $servicename=''
    exit 87
  endif

  if instr($servicename,'\')
    $remoteserver=left($servicename,instrrev($servicename,'\')-1)
    if left($remoteserver,2)<>'\\'
      exit 87
    endif
    $servicename=right($servicename,len($servicename)-instrrev($servicename,'\'))
  else
    $remoteserver=''
  endif

  $startupmodelong='Boot,System,Automatic,Manual,Disabled'
  $startupmodelong=split($startupmodelong,',')

  if vartype($startupmode)
    select
    case $startupmode='Boot'
      $mode=0
    case $startupmode='System'
      $mode=1
    case $startupmode='Automatic'
      $mode=2
    case $startupmode='Manual'
      $mode=3
    case $startupmode='Disabled'
      $mode=4
    case 1
      $mode=-1
    endselect
  else
    $mode=-1
  endif

  $servicesubkey='HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\'+$servicename
  if $remoteserver<>''
    $servicesubkey=$remoteserver+'\'+$servicesubkey
  endif

  if keyexist($servicesubkey)
    $currentmode=readvalue($servicesubkey,'Start')
    select
    case $mode=-1
      $servicemode=$startupmodelong[$currentmode]
    case $mode=$currentmode
      $servicemode=$startupmodelong[$mode]
    case $mode<>$currentmode
      $regformat=readtype($servicesubkey,'Start')
      $retcode=writevalue($servicesubkey,'Start',$mode,$regformat)
      if @ERROR
        exit @ERROR
      else
        $servicemode=$startupmodelong[$mode]
      endif
    case 1
      exit @ERROR
    endselect
  else
    exit 1060
  endif
  exit @ERROR
endfunction


 
 [ 19. May 2003, 03:40: Message edited by: sealeopard ]83834SERVICESTART79KdyerSERVICESTART()0;Function SERVICESTART()
;
;Author	Kent Dyer (leptonator@hotmail.com)
;
;Version 1.0.1 - 26 - February 2003
; 1.0.0 25 - February 2003 - New script/post
; 1.0.1 26 - February 2003 - Implementation of suggestion from Rad.
;
;Action
;        Starts or Stops and Starts a Service on a Local or Remote Workstation/Server.
;
;Syntax SERVICESTART($service,$ServerName)
;
;Parameters
;	$service
;               Name of service.  Recommended to use the name from Keys at - 
;               HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services
;
;	$ServerName
;		String representing target System
;
;Remarks
;       User would need Power User rights or better to stop/start services
;       Inspiration was the ePO (ePolicy Orchestrator) script
;       "Script for adding in a new ePolicy Orchestrator server"
;       http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=2;t=004209
;       Figured there had to be a better way than NET START Servicename and NET STOP Servicename
;       Pieces of the code is from - 
;       http://cwashington.netreach.net/depo/view.asp?Index=602&ScriptType=vbscript
;       "cisvc" is the Indexing Service
;       Related posts:
;       "WMIService() - Control NT services"
;       http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000190#000000
;       "fADSIServiceRun() - ADSI routine that starts, stops ,pause, and continues a service"
;       http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000205#000000
;
;Returns
;	nothing
;
;Dependencies
;	kix2001,windows NT (with WBEM or WMINT4.EXE from MSDN - untested)/2000/XP
;
;Examples
;	SERVICESTART("cisvc")
;	SERVICESTART("cisvc","MACHINENAME")
;
;
;Source

code:

FUNCTION SERVICESTART($service, OPTIONAL $ServerName)
DIM $objServer,$objService
IF NOT $servername $servername='.' ENDIF
$ServerString = 'WinNT://' + $ServerName + ',computer'
$objServer = GetObject($ServerString)
$ServiceName = $service 
$objService = $objServer.GetObject('Service', $ServiceName)
If $objService.Status <> 'ADS_SERVICE_RUNNING'
    ; - start the service
    ?'Starting Service ' + $ServiceName
    $objService.Start
ELSE
    ; - stop/start the service
    ?'Stopping Service ' + $ServiceName
    $objService.Stop
SLEEP 1
    ?'Starting Service ' + $ServiceName
    $objService.Start
ENDIF
ENDFUNCTION


 
 [ 28. October 2003, 16:42: Message edited by: kdyer ]187517SetAsDefaultPrinter3439AllenSetAsDefaultPrinter() - Set the Default Printer using the Share Name0

;Function:  
;    SetAsDefaultPrinter()  
;  
;Author:  
;    Allen Powell   
;  
;Version:  
;    1.0.0  (2008/05/07) 
;  
;Action:  
;    Sets the Default Printer using the Printer name or Share name  
;  
;Syntax:  
;    SetAsDefaultPrinter($printer)  
;  
;Parameters:  
;       $Printer: (Required)  
;             "\\PrintServer\ShareName" 
;             "\\PrintServer\PrinterName" 
; 
;Returns:   
;        0              Default printer set 
;        Error code     Function failed   
;       
;  
;Notes: 
;     If the server is not on, does not exist, you lack permissions, or any other error, SetAsDefaultPrinter() 
;     will return an error, check @error for explaination. 
; 
;Example:  
;  
;break on 
; 
;$rc=SetAsDefaultPrinter("\\printserver\hp2015") 
;? $rc 
;? @serror 
;  
;Source:  
;  
function SetAsDefaultPrinter($printer)
  $SetAsDefaultPrinter=1
  if setdefaultprinter($printer)=0
    $SetAsDefaultPrinter=0
  else
    dim $PrintServer,$PrintQueue[0],$sharedprinter,$rc,$server
    $PrintQueue[0]="PrintQueue"
    if instr($printer,"\\") 
      $server=split($printer,"\")[2]
      $printer=split($printer,"\")[3]
    else
      $server=@wksta
    endif
    $PrintServer=GetObject("WinNT://" + $server + ",computer")
    if @error
      exit @error
    else
    $Printserver.filter=$PrintQueue   
    for each $sharedprinter in $printserver
      if $sharedprinter.name=$printer
        $rc=setdefaultprinter($sharedprinter.printername)
        if $rc=0
          $SetAsDefaultPrinter=0
          exit 0
        else
          $SetAsDefaultPrinter=$rc
          exit @error
        endif
      endif
    next
  endif 
endfunction
138445SetCapsLock96JoseSetCapsLock() -Sets or returns Caps Lock state0Code:

 
;FUNCTION      SetCapsLock

;

;ACTION        Sets or returns Caps Lock state.
;

;AUTHOR        Jose (jose@vigil.com.ar)

;

;CONTRIBUTORS  Allen Powell - Jens Meyer - Richard H. - NTDOC.


;

;VERSION       1.1

;

;DATE CREATED  2005/05/21

;

;DATE MODIFIED  2005/05/26

;

;KIXTART        KiXtart 4.20

;

;SYNTAX        SetCapsLock([$state]) 

;

;PARAMETERS    $state (optional)

;              Possible optional values are 'on' and 'off'. 

;
;RETURNS       String containing last state 'on' and 'off'.

;

;REMARKS       None

;

;DEPENDENCIES  None

;

;EXAMPLE                

;		Break On

;		Dim $SO

;		$SO=SetOption('Explicit','On')

;		$SO=SetOption('NoVarsInStrings','On')

;		$SO=SetOption('WrapAtEOL','On')
;		
;		Dim $LastState

;		$LastState=SetCapsLock()

;		Select

;		  Case $LastState='on'

;		    ? 'Caps lock is ON  ' + $LastState

;		  Case $LastState='off'

;		    ? 'Caps lock is OFF  ' + $LastState

;		EndSelect

;

;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=137598&Main=137598#Post137598

;




Function SetCapsLock(optional $state)
  Dim $SK,$L,$PreviousState,$sASCIIState
  $PreviousState = SetOption('ASCII')
  $sASCIIState = SetOption('ASCII','On')
  $SK=SendKeys('L')
  Get $L
  Select
    Case $L=='L'
      $SetCapsLock='off'
      If $state="on"
        $SK=SendKeys('{CAPSLOCK}')
      EndIf
    Case $L=='l'
      $SetCapsLock='on'
      If $state='off'
        $SK=SendKeys('{CAPSLOCK}')
      EndIf
  EndSelect
  $PreviousState = SetOption('ASCII',$PreviousState)
  Exit @ERROR
EndFunction

82412SetColor11ShawnSetColor() - The COLOR command with variable substitution0This is an oldie (real old), but a goodie. Especially usefull for graphic intensive scripts (games) !

SetColor()

Action:

A wrapper for the built-in COLOR command. Supports variables passed as parameters !

Syntax:

SetColor("Xx","Yy")

Parameters:

X Foreground color 
x Optional intensity indication 
 
Y Background color 
y Optional blink indication 
 
Possible values for the foreground and background colors are: 

n Normal (black) 
b Blue 
g Green 
c Cyan 
r Red 
m Magenta 
y Yellow/brown  
w White 

If the foreground color is followed by a plus sign (+), the color is displayed with high intensity.  

Returns:

Nothing

Remarks:

This function comes in handy when one realizes that the builtin KiXtart COLOR command does not support variables passed as parameters.

Dependencies:

KiXtart 4.0 (final)

Example(s):

code:

 
$fg = "g+"
$bg = "r"
 
SetColor($fg,$bg)
 
?"hit any key to continue..." get $k
 
SetColor("w","n")
 
?"hit any key to continue..." get $k

Source:

code:

function SetColor($forecolor,$backcolor)
 dim $color,$nul
 $color = "color "+$forecolor+"/"+$backcolor
 $nul = execute($color)
endfunction

SetColor(2)

Totally compatible with SetColor but supports the BGI color palette number standard as follows:

code:

 0 = BLACK
 1 = BLUE
 2 = GREEN
 3 = CYAN
 4 = RED
 5 = MAGENTA
 6 = BROWN
 7 = LIGHTGRAY
 8 = DARKGRAY
 9 = LIGHTBLUE
10 = LIGHTGREEN
11 = LIGHTCYAN
12 = LIGHTRED
13 = LIGHTMAGENTA
14 = YELLOW
15 = WHITE

Using the BGI color standard is usefull when generating random colors or to iterate over the available color palette, e.g. :

code:

for $i = 0 to 15
 setcolor($i,$i-1)
 ? "$i color"
next

function SetColor($forecolor,$backcolor)
 dim $color,$nul
 dim $palette
 $palette = "n","b","g","c","r","m","y","w","n+","b+","g+","c+","r+","m+","y+","w+"
 if vartypename($forecolor) = "long"
  if $forecolor > -1 and $forecolor &lt; ubound($palette)+1
   $forecolor = $palette[$forecolor]
  else
   $forecolor = "w"
  endif
 endif
 if vartypename($backcolor) = "long"
  if $backcolor > -1 and $backcolor &lt; ubound($palette)+1
   $backcolor = $palette[$backcolor]
  else
   $backcolor = "n"
  endif
 endif
 $color = "color "+$forecolor+"/"+$backcolor
 $nul = execute($color)
endfunction

Author:

-Shawn
 
 [ 22. February 2003, 00:54: Message edited by: Shawn ]122261SetDataBase5441Gold_KoySetDataBase()  - Inserts or updates an DB-Entry0;FUNCTION      SetDataBase()
;
;ACTION        Inserts or updates an Databaseentry
;
;AUTHOR        Markus Gerbig (Markus.Gerbig@aventis.com)
;
;VERSION			 1.0
;
;DATE CREATED  2004/06/30
;
;DATE MODIFIED
;
;KIXTART       4.22+
;
;SYNTAX        SetDataBase(Table,Key,KeyValue,Colum,Value)
;
;PARAMETERS    Table
;              Specifies the table to update.
;
;							 Key
;							 Specifies the Key or Keys of an table, "Machine" or "Machine;Virus".
;
;							 KeyValues
;							 The Values of the Key or Keys, "Machine1" or ""Machine1;LoveSan".
;
;							 Colum
;							 The colums which to add.
;
;							 Value
;							 The Values which to add.
;
;RETURNS       Errorcode
;
;REMARKS       This function looks if an dabaseentry exits. It does in INSERT or an UPDATE.
;
;
;DEPENDENCIES  Function needed : "DBCOMMAND" by Jens Meyer (sealeopard@usa.net)
;
;EXAMPLE       SetDataBase("Virus","Machine;Virus","Machine1;LoveSan","Counter;Datetime","2;@Date")
;

Function SetDataBase($Table,$Key,$KeyValue,$Colum,$Value)

$Key=Split($KEY,";")
$KeyValue=Split($KeyValue,";")
For $i = 0 To UBound($Key)
	If $i = 0
		$Select=$Key[$i]+" LIKE '"+$KeyValue[$i]+"'"
		$Keys=$Key[$i]
		$KeyValues="'"+$KeyValue[$i]+"'"
	Else
		$Select=$Select+" AND "+$Key[$i]+" LIKE '"+ $KeyValue[$i]+"' "
		$Keys=$Keys+", "+$Key[$i]
		$KeyValues=$KeyValues+",'"+$KeyValue[$i]+"'"
	EndIf
Next

$sql="SELECT * FROM $Table Where $Select"
$recordset = DBCommand($dsn,$sql)
IF @ERROR
	? "Server not available " + @Error
endif

$Colum = SPLIT($Colum,";")
$Value = SPLIT($Value,";")

If $recordset[0,0] <> ""
	$recordset = ""
	For $i = 0 To UBound($Colum)
		If UBound($Colum) = 0
			$Colums=$Colum[$i]+"='"+$Value[$i]+"'"
		Else
			$Colums=$Colums+$Colum[$i]+"='"+$Value[$i]+"',"
		Endif
	Next
	$Colums = left($Colums,len($Colums)-1)
	$sql="UPDATE $Table SET $Colums Where $Select"

Else

	For $i = 0 To UBound($Colum)
		If UBound($Colum) = 0
			$Colums='"' + $Colum[$i]+ '"'
			$Values=$Value[$i]
		Else
			$Colums=$Colums+$Colum[$i]+","
			$Values=$Values+"'"+$Value[$i]+"',"
		Endif
	Next

	$Colums = left($Colums,len($Colums)-1)
	$Values = left($Values,len($Values)-1)

	$sql="INSERT INTO $Table ($KEYS,$COLUMS) VALUES ($KeyValues,$Values)"
ENDIF
$recordset = DBCommand($dsn,$sql)
If @ERROR
	$Error = @Error
	? "Error " + $ERROR + "please check sql string."
	? "SQL " + $SQL
endif
$recordset= ""
$Select = ""
$Keys = ""
$KeyValues = ""
$Colums = ""
$Value = ""
$sql = ""
$SetDataBase = $ERROR
EndFunction      157162SetFlash52NTDOCSetFlash() - Disable OR Re-enable FLASH browser plugin for IE0

;Function	SetFlash() - Disable OR Re-enable FLASH browser plugin for IE 
;  
;Author		NTDOC  
;  
;Contributors	  
;  
;Action		Allows easy on the fly method of disabling and re-enabling FLASH as required 
;  
;Syntax		SetFlash(optional $Flag) If no value set for the flag it will enable FLASH 
;		If a flag is used it will disable FLASH 
;  
;Version	1.0  
;  
;Date		2006-Feb-13  
;  
;Date Revised	xxxx-xxx-xx  
;  
;Revision Reason  
;		  
;  
;Parameters	Takes a value of 1 to disable FLASH 
;  
;Remarks	Tested on XP Pro / Server 2003 
;  
;Returns	Errorlevel of the last .ocx unregister or registration 
;  
;Dependencies	KiXtart v4.5  
;		Written and tested with KiXtart v4.52 beta 2  
;  
;Notes	 
; 
;Example 
;	SetFlash(1) 
;	  ;Will disable FLASH 
; 
;	SetFlash() 
;	  ;Will re-enable FLASH 
; 
;Source  
 
Function SetFlash(optional $Flag)
  Dim $CMD
  If $Flag $Flag='/u' EndIf
  $CMD='regsvr32 /s ' + $Flag + ' %SYSTEMROOT%\system32\Macromed\Flash\'
  SHELL $CMD + 'flash.ocx'
  SHELL $CMD + 'flash8.ocx'
  Exit @ERROR
EndFunction
 
169943SetIE7Delivery1024MartSetIE7Delivery() - Sets the auto delivery of IE71163149228Code:


;FUNCTION	SetIE7Delivery()
;
;AUTHOR:		Mart
;
;ACTION:		Allows or blocks the automatic delivery of IE7.
;			THIS DOES NOT WORK IN (W)SUS AND/OR SMS ENVIRONMENTS.
;			See: http://www.microsoft.com/technet/updatemanagement/
;				windowsupdate/ie7blockertoolfaq.mspx
;			Obviously this has no use when automatic updates is disabled.
;			Can be used on remote and local computers.
;
;SYNTAX:		SetIE7Delivery($computer, $value)
;
;PARAMETERS:	$VALUE - required string.
;			1 to block the delivery of Internet Explorer 7.
;			0 to allow the delivery of Internet Explorer 7.
;
;			$COMPUTER - optional string.
;			The computer to apply the settings to.
;			If no computer is specified the local computer is assumed.
;
;RETURNS:		Check @error for possible errors.
;
;REMARKS:		Microsoft has a tool available to do just this.
;			The MS tool has the genuine Windows check enabled.
;			This script is NOT intended to bypass genuine Windows check
;			and to block IE7 delivery on illegal copies of Windows. It is just
;			an option to block or allow IE7 delivery from a KiXtart script.
;			By default the auto delivery of IE7 is allowed on all supported Windows versions.
;
;DEPENDENCIES:	Requires the Ping() UDF if a remote computer is targeted.
;			http://www.kixtart.org/ubbthreads/showflat.php?
;				Cat=0&Number=81692&an=&page=0&vc=1
;			The person running the script should be at least a local admin.
;			Windows XP SP2 or up.
;			Windows XP Professional x64 Edition.
;			Windows server 2003 or up.
;
;EXAMPLE:		This example blocks the auto delivery of IE7.
;			Break on
;			$value = "1"
;			$computer = "somecomputer"
;			SetIE7Delivery($value, $computer)
;			?@ERROR
;			Sleep 2
;
;CODE: 
Function SetIE7Delivery($value, optional $computer)
	Dim $key, $rc, $au, $wsus
	
	If $value <> "0" AND $value <> "1"
		Exit 13
	EndIf
	
	$au = ReadValue("HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU", "NoAutoUpdate")
	$wsus = ReadValue ("HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU", "UseWUServer")
	If $au = "0"
		Exit 10
	Else
		If $wsus = "1"
			Exit 10
		EndIf
	EndIf

	$key = "HKLM\SOFTWARE\Microsoft\Internet Explorer\Setup\7.0"

	If $computer = ""
		$rc = WriteValue($key, "DoNotAllowIE70", $value, "REG_DWORD")
		If @ERROR
			Exit @ERROR
		EndIf
	Else
		If Ping($computer,0,4,5000)
			$rc = WriteValue("\\" + $computer + "\" + $key, "DoNotAllowIE70", $value, "REG_DWORD")
			If @ERROR
				Exit @ERROR
			EndIf
		Else
			Exit 53
		EndIf
	EndIf
EndFunction

84325SetIEAutoDetect1642AbqBillSetIEAutoDetect() - configures IE's "Automatically detect settings"option0

code:

; Function      SetIEAutoDetect()
;
; Author        Bill Stewart (bill.stewart@frenchmortuary.com)
;
; Contributors  See http://omega.barnet.ac.uk/~polsy/ieauto.c (author unknown)
;
; Action        Toggles the "Automatically detect settings" check box for IE
;
; Syntax        SetIEAutoDetect(enable)
;
; Version       1.0
;
; Date          27 May 2003
;
; Date Revised  27 May 2003
;
; Parameters    enable = 0 to disable; 1 to enable
;
; Remarks       Toggles the appropriate bit in the registry setting
;               HKCU\Software\Microsoft\Windows\CurrentVersion\Internet
;               Settings\Connections\DefaultConnectionSettings (REG_BINARY).
;
; Returns       0 for success; non-zero for failure
;
; Dependencies  None
;
; KiXtart Ver   4.12
;
; Example(s)    $rc = SetIEAutoDetect(1)

function SetIEAutoDetect($enable)
  dim $subkey, $value, $byte, $rc

  $subkey = "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections"
  $value = readvalue($subkey, "DefaultConnectionSettings")
  $rc = @error
  if $rc = 0
    $byte = val(substr($value, 18, 1))
    if $enable
      $byte = $byte | 8  ; set bit
    else
      $byte = $byte & 7  ; clear bit
    endif
    $byte = dectohex($byte)
    $value = substr($value, 1, 17) + $byte + substr($value, 19, len($value) - 18)
    $rc = writevalue($subkey, "DefaultConnectionSettings", $value, "REG_BINARY")
  endif
  $SetIEAutoDetect = $rc
endfunction

82695SetINIValue17SealeopardSetINIValue() - gets an initialization value from an .INI file0

code:

;FUNCTION      SetINIValue
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        gets an initialization value from an .INI file
;
;SYNTAX        SETINIVALUE(INIFILE, SECTION, KEY [, OLDVALUE])
;
;PARAMETERS    INIFILE
;              Required string containing the .INI filename
;
;              SECTION
;              Required string containing the initialization section
;
;              KEY
;              Required string containig the initialization key
;
;              ODLVALUE
;              Optional string containing the old value. If an initialization value cannot
;              be found the old value will be returned
;
;RETURNS       initialization value
;
;REMARKS       none
;
;DEPENDENCIES  ERR()     @ [URL=http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000107]http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000107[/URL] 
;              WARNING() @ [URL=http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000099]http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000099[/URL] 
;
;EXAMPLE       $retcode=setinivalue('c:\temp\test.ini','section','key','alternativevalue')
;
;KIXTART BBS   [URL=http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000113]http://kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000113[/URL] 
;
function setinivalue($inifile,$section,$key,optional $oldvalue)
  Dim $inivalue, $retcode

  if exist($inifile)
    $inivalue=readprofilestring($inifile,$section,$key)
    $retcode=err('Failed reading key "'+$key+'" in section ['+$section+'] in file '+$inifile)
    select
    case $inivalue<>''
      $setinivalue=$inivalue
    case vartype($oldvalue)
      $setinivalue=$oldvalue
    case 1
      $setinivalue=''
    endselect
  else
    $retcode=$warning('Cannot open initialization file '+$inifile)
    if vartype($oldvalue)
      $setinivalue=$oldvalue
    else
      $setinivalue=''
    endif
  endif
endfunction


 
 [ 24. February 2003, 04:29: Message edited by: sealeopard ]144740SetIPOptions3439AllenSetIPOptions() - Set/Modify/Change IP, Gateway, DNS, WINS, DHCP settings0

;Function:  
; SetIPOptions(),  
;  
;Author  
; Allen Powell 
; 
;Contributors 
; xpanmanx, Richard H. 
;  
;Version:  
; 1.1.0  
;  
;Action:  
; Set/Modify TCP/IP Options for either DHCP or Static Assignments  
;  
;Syntax:  
; SetIPOptions($Setting,$Value,optional $remotepc, optional $macaddress) 
;  
;Parameters:  
; $setting (Required)  $value (Required) 
; -------------------  ----------------------------------------  
;   "EnableDHCP"       0 = IP Address and Subnet Mask only,  1 = IP,SM,DG,DNS,WINS,DNS Domain 
;   "IPAddress"        String containing IPAddress and Subnet Mask separated by a comma, ie "192.168.1.101,255.255.255.0" 
;   "DefaultGW"        String containing Default Gateway   
;   "DNSServers"       String containing DNS Servers, each separated by commas 
;   "WINSServers"      String containing WINS Servers, each separated by commas 
;   "DNSDomain"        String containing Domain Name 
; 
; $remotepc (Optional) - name of computer, default is local pc 
; $macaddress (Optional) - target a specific NIC by its MAC Address - String in the format of "##:##:##:##:##:##" 
; 
;Returns 
; 0 - Success 
; 1 - Failure - check @error for reason  
;  
;Dependencies 
;  WMI with Windows XP, Windows 2000 Professional, or Windows NT Workstation 4.0 SP4 and later 
;  Tested with Kixtart 4.22, 4.50, 4.51 
; 
;Remarks:  
; V1.1.0 2006/05/04 (Added ability to return errors specific to W32NetworkAdapter - Thanks Richard H) 
; V1.0.1 2005/10/21 (Added Ability to target a specific NIC by MACAddress)  
; V1.0.0 2005/08/05 (Original) 
;  
;Example:  
;? "Changing" 
;"." 
;$=setipoptions("DefaultGW","192.168.0.1") 
;"." 
;$=setipoptions("WINSServers","192.168.0.10,192.168.0.11") 
;"." 
;$=setipoptions("DNSServers","192.168.0.10,192.168.0.11") 
;"." 
;$=setipoptions("DNSDomain","MyDomain2.Com") 
;"." 
;$=setipoptions("IPAddress","192.168.0.101,255.255.255.0") 
; 
;if @error=0 
;  ? "Changed to Static IP" 
;  gets $ 
;else 
;  ? @error 
;  exit 
;endif 
;$=SetIPOptions("EnableDHCP",0) 
;if @error=0 
;  ? "Changed to DHCP IP Address, but left other settings alone" 
;  gets $ 
;else 
;  ? @error 
;  exit  
;endif 
;$=SetIPOptions("EnableDHCP",1) 
;if @error=0 
;  ? "Changed all settings to DHCP" 
;  gets $ 
;else 
;  ? @error 
;  exit 
;endif 
; 
 

function SetIPOptions($Setting,$Value,optional $remotepc, optional $macaddress)
  dim $objWMIService, $colitems, $objnetadapter,$RC,$IP[0],$SM[0],$WS1,$WS2,$allnics,$settings[0],$errors,$error,$NVIS
  $errors=1,3010,64,8256,65,4985,66,5894,67,8407,68,9553,69,3951,70,9552,71,9552,72,5762,73,3730,
          74,3730,75,9616,76,3960,77,3,78,266,79,1338,80,9851,81,4985,82,4985,83,4985,84,9851,85,9851,
          86,4985,87,4985,88,1707,89,1760,90,1734,91,5,92,2501,93,1760,94,1761,95,2186,96,2186,97,1717,
          98,4985,100,4985
  $SetIPOptions=1
  if $remotepc=""
    $remotepc="."
  endif
  if $macaddress=""
    $allnics=1
  endif
  $objWMIService = GetObject("winmgmts:\\" + $remotepc + "\root\cimv2")
  if @error
    exit @error
  endif
  $NVIS=Setoption("NoVarsInStrings","ON")
  $colItems = $objWMIService.ExecQuery("Select * from Win32_NetworkAdapterConfiguration where IPEnabled=-1")
  For Each $objNetAdapter In $colItems
    if $macaddress=$objNetAdapter.macaddress or $allnics
      Select 
        case $setting="EnableDHCP"
          if $value
            redim $settings[3]
            $settings[0]='SetDNSServerSearchOrder'
            $settings[1]='SetWINSServer("","")'
            $settings[2]='SetDNSDomain'
            $settings[3]='EnableDHCP'
          else
            $settings[0]='EnableDHCP'
          endif
        case $setting="DNSServers" 
          $settings[0]='SetDNSServerSearchOrder(split($value,","))'
        case $setting="WINSServers"
          $WS1=split($value,",")[0]
          if ubound(split($value,","))>0
            $WS2=split($value,",")[1]
          else
            $WS2=""
          endif
          $settings[0]='SetWINSServer($WS1,$WS2)' 
        case $setting="DNSDomain"
          $settings[0]='SetDNSDomain($value)'
        case $setting="DefaultGW" or $setting="DefaultGateway"
          $settings[0]='SetGateways(split($value,","))'
        case $setting="IPAddress"
          if instr($value,",")>0
            $IP[0]=split($Value,",")[0]
            $SM[0]=split($value,",")[1]
            $settings[0]='EnableStatic($IP, $SM)'
          endif
      endselect
      if $settings[0]<>""
        for each $setting in $settings
          $error=0
          $RC=execute("$" + "Error=" + "$" + "objNetAdapter." + $setting) 
          if $error>0
            $NVIS=Setoption("NoVarsInStrings",$NVIS)
            exit $errors[ascan($errors,$error)+1]      
          endif
        next
        $SetIPOptions=0
        $NVIS=Setoption("NoVarsInStrings",$NVIS)
      endif
    endif
  Next
endfunction
145923SetOptions5694WittoSetOptions() Toggle between your preferred options and options that are set0

ÿCode:

;SetOptions()
;
;ACTION         Catch all options that can be set with SetOption() to a string 
;               and optionally Set options given with an input string
; 
;AUTHOR         Wim Rotty 
; 
;CONTRIBUTORS   Richard Howarth 
; 
;VERSION        1        Initial release
;               2        Modified as suggested by Richard Howarth
;               2.0.0.1  Made compatible for all versions of KiX starting from 4.00
;                        Added error checking for optional parameter, If wrong, Error 87 is set 
;               2.0.0.2  Added wow64alternateregview for version 4.60
; 
;DATE CREATED   2005-08-18 
; 
;DATE MODIFIED  2006-08-19 (2)
;               2006-09-27 (2.0.0.1)
;               2007-07-31 (2.0.0.2)
; 
;KIXTART        4.00 and higher 
; 
;SYNTAX         SetOptions([$Settings]) 
; 
;PARAMETERS     $Settings 
;               Optional parameter, 
;               string containing one or more options that can be set with SetOption() 
;               and the value they should be set to 
;                
;               Build your string like this: 
;               "Option=Value,Option=Value,..." 
;                
;               Options that can be used are: 
;                   ASCII 
;                   CaseSensitivity 
;                   Explicit 
;                   HideCursor 
;                   NoMacrosInStrings 
;                   NoVarsInStrings 
;                   Wow64FileRedirection 
;                   WrapAtEOL
;                   wow64alternateregview 
;                
;               Values that can be used are: 
;                   On 
;                   Off 
;                
;               for more information about the options and the values: 
;               see the SetOption function in the KiXtart manual 
;                
; 
;RETURNS        String, containing all options that can be set On AND Off with SetOption, and their values
;               Error codes: 0 = Success, all other = Error 
; 
;REMARKS        - Credits go to Richard Howarth as he provided (almost) all of the code for the second 
;                 version. Thanks! (Should I swap the "Author" and the "Contributors"?) 
;               - As DisableDebugging can only be switched on, I did not include it in SetOptions() 
;               - While writing this UDF, I noticed that the Value parameter for SetOption is optional 
;                 The KiXtart manual should read: 
;                 		SetOption("<option>"[, "<value>"]) 
;                 This "hidden feature" is used in this UDF to gather the settings
;               - When an invalid input string is build, the UDF tries to get all valid information provided
;                 and Error 87 will be set
; 
;DEPENDENCIES   None 
;                
;EXAMPLE        ; Preserve settings and reset after running external script
;               $sOldSettings=SetOptions()
;               Call "dodgy.kix"
;               $sOldSettings=SetOptions($sOldSettings)
;
;               If NOT @LOGONMODE 
;               	Break On 
;               EndIf 
;               ; Here is code that p.e. is not yours 
;               ; Catch existing options and set your preferred options 
;               Dim $OldOptions 
;               $OldOptions = SetOptions("Explicit=On,NoVarsInStrings=On,NoMacrosInStrings=On,WrapAtEOL=On") 
;               ; Do your things here using your preferred Options 
;               ; Reset options 
;               $OldOptions = SetOptions($OldOptions) 
;               ; The rest of the script 
; 
;KIXTART BBS 	 http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=145185&an=0&page=0#145185 
;                
Function SetOptions(Optional $Settings)
	Dim $asOptions,$sOption,$iError,$MajorVersion, $MinorVersion,$i,$bSetError
	$bSetError = -1
	
	$MajorVersion = Split(Left(@KIX,4),".")[0]
	$MinorVersion = Split(Left(@KIX,4),".")[1]
	
	;Build Options string
	;V4.xx
	If 4 =< $MajorVersion
		;4.00
		If 00 =< $MinorVersion Or 4 < $MajorVersion
			$asOptions = "ASCII,CaseSensitivity,HideCursor,WrapAtEOL"
		EndIf
	EndIf
	If 4 =< $MajorVersion
		;4.10
		If 10 =< $MinorVersion Or 4 < $MajorVersion
			$asOptions = $asOptions + ",Explicit,NoVarsInStrings"
		EndIf
	EndIf
	If 4 =< $MajorVersion
		;4.50
		If 50 =< $MinorVersion Or 4 < $MajorVersion
			$asOptions = $asOptions + ",NoMacrosInStrings"
		EndIf
	EndIf
	If 4 =< $MajorVersion
		;4.52
		If 52 =< $MinorVersion Or 4 < $MajorVersion
			$asOptions = $asOptions + ",Wow64FileRedirection"
		EndIf
	EndIf
	If 4 =< $MajorVersion
		;4.60
		If 60 =< $MinorVersion Or 4 < $MajorVersion
			$asOptions = $asOptions + ",wow64alternateregview"
		EndIf
	EndIf

	;;Dummy for V5.xx
	;;5
	;If 5 =< $MajorVersion
	;	5.00
	;	If 00 =< $MinorVersion OR 5 < $MajorVersion
	;		$asOptions = ",Option9,Option10"
	;	EndIf
	;EndIf
	;If 5 =< $MajorVersion
	;	5.xx
	;	If xx =< $MinorVersion OR 5 < $MajorVersion
	;		$asOptions = $asOptions + ",Option11"
	;	EndIf
	;EndIf
	
	$asOptions = Split($asOptions,",")
	
	; Gather up old options
	For Each $sOption in $asOptions
		$SetOptions=$SetOptions + $sOption + "=" + SetOption($sOption)
		;for compatibility with 4.00, added "(...)= 1"
		If Not ($sOption = $asOptions[UBound($asOptions)]) = 1
			$SetOptions = $SetOptions + ","
		EndIf
	Next

	; Set new options
	For Each $sOption in Split($Settings,",")
		; Is there any input?
		If Trim($sOption) <> ""
			; Split Option from Value
			$sOption=Split($sOption,"=")
			; Are there Options and Values?
			If 1 <= UBound($sOption)
				$sOption[0]=Trim($sOption[0])
				$sOption[1]=Trim($sOption[1])
				; Are there more arguments then Option and Value?
				If 1 < UBound($sOption)
					$iERROR = 87
				EndIf
				
				If (4 > $MajorVersion) Or (4 = $MajorVersion And 20 <= $MinorVersion)
					; Are the Option and the Value valid?
					If Not AScan($asOptions,$sOption[0]) Or (Not ($sOption[1] = "On") And Not ($sOption[1] = "Off"))
						$iERROR = 87
					Else
						$sOption = SetOption($sOption[0],$sOption[1])
						If @ERROR
							$iERROR = @ERROR
						EndIf
					EndIf
				Else
					; Versions 4.00 to 4.1x don't support AScan
					If ($sOption[1] = "On") Or ($sOption[1] = "Off")
						For $i = 0 to UBound($asOptions)
							If ($sOption[0] = $asOptions[$i])
								$sOption = SetOption($sOption[0],$sOption[1])
								If @ERROR
									$iERROR = @ERROR
								EndIf
								$i = UBound($asOptions)
								$bSetError = 0
							EndIf
						Next
						If $bSetError = -1
							$iERROR = 87
						EndIf
						$bSetError = -1
					Else
						$iERROR = 87
					EndIf
				EndIf
			Else
				$iERROR = 87
			EndIf
		EndIf
	Next
	
	Exit $iERROR
EndFunction
83679SetProxy31RadimusSetProxy() - enable/disable/configure proxy settings0

code:

;setproxy(0,,1)					;remove per user settings
;setproxy(0,,0)					;remove per machine settings
;setproxy(1,"proxy.domain.com:80",1)		;set per user settings
;setproxy(1,"proxy.domain.com:80",0)		;set per machine settings



function SetProxy($type, optional $Proxy, optional $PerUser)
;Type:
;	0 - disable proxy
;	1 - enable proxy
;Proxy:
;	proxy.domain.com:80
;PerUser
;	1 or not nul - to make proxy settings per user, requires admin privledes
;	0 - to make proxy settings per Machine, requires admin privledes
;
;returns
;	1 - Incorrect Type
;	2 - no proxy server specified
;	3 - policy is set to per machine / requires admin priv

	dim $regkey, $admin, $gpkey
	$admin = ingroup("@wksta\Administrators")
	$Regkey='HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion'
	$gpkey ='HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\CurrentVersion'

	if $admin
		If $PerUser>0				; "per user"
			$=writevalue("$gpkey\Internet Settings","ProxySettingsPerUser","1",REG_SZ)
			$=writevalue("$Regkey\Internet Settings","ProxySettingsPerUser","1",REG_SZ)
			endif
		If len($peruser)>0 and $PerUser=0	; "per machine"
			$=writevalue("$gpkey\Internet Settings","ProxySettingsPerUser","0",REG_SZ)
			$=writevalue("$Regkey\Internet Settings","ProxySettingsPerUser","0",REG_SZ)
			endif
	else
		if readvalue("$Regkey\Internet Settings","ProxySettingsPerUser")=0 
		or readvalue("$gpkey\Internet Settings","ProxySettingsPerUser") =0
			exit 3
			return
			endif
		$Regkey='HKEY_Current_User\SOFTWARE\Microsoft\Windows\CurrentVersion'
		endif
	if readvalue("$Regkey\Internet Settings","ProxySettingsPerUser")=1 
	or readvalue("$gpkey\Internet Settings","ProxySettingsPerUser") =1		; "per user is set"
		$Regkey='HKEY_Current_User\SOFTWARE\Microsoft\Windows\CurrentVersion'
		endif

	Select
		case $Type=1 and $Proxy 
			$=writevalue("$Regkey\Internet Settings","ProxyServer","$Proxy",REG_SZ)
			$=writevalue("$Regkey\Internet Settings","ProxyEnable","1",REG_DWORD)
			$=writevalue("$Regkey\Internet Settings","ProxyOverride","<local>",REG_SZ)
		case $Type=0
			$=writevalue("$Regkey\Internet Settings","ProxyServer","",REG_SZ)
			$=writevalue("$Regkey\Internet Settings","ProxyEnable","0",REG_DWORD)
			$=writevalue("$Regkey\Internet Settings","ProxyOverride","<local>",REG_SZ)
		case $Type=1 
			exit 2
		case 1
			exit 1
		endselect
	endfunction

142157SetTimeServer52NTDOCSetTimeServer() - Sets the authoritative time server in Windows0 

;Function	SetTimeServer()  
;  
;Author		NTDOC 
;  
;Action		Sets the authoritative time server in Windows 
;  
;Syntax		SetTimeServer($Peers,$Pos,$Neg,$Poll) 
; 
;References 
;		Configuring the Windows Time service against a large time offset 
;		http://support.microsoft.com/kb/884776 
;		How to configure an authoritative time server in Windows Server 2003 
;		http://support.microsoft.com/kb/816042 
;		How to configure an authoritative time server in Windows XP 
;		http://support.microsoft.com/kb/314054 
; 
;		Public NTP Time Server Lists 
;		http://ntp.isc.org/bin/view/Servers/WebHome 
;		StratumOne Time Servers 
;		http://ntp.isc.org/bin/view/Servers/StratumOneTimeServers 
; 
;		A List of the Simple Network Time Protocol Time Servers That Are Available on the Internet 
;		http://support.microsoft.com/kb/262680 
; 
;		NIST Internet Time Service 
;		http://tf.nist.gov/service/its.htm 
 

;		LIST OF US TIME SERVERS as of 6/21/2005 4:44PM 
;		http://tf.nist.gov/service/time-servers.html 
;		The table below lists the time servers used by the NIST Internet Time Service (ITS).  
;		The table lists each server's name, IP address, and location. Please note that while  
;		we make every effort to ensure that the names of the servers are correct, we only control  
;		the names of the nist.gov servers. 
;		It is probably safest to use the IP addresses instead of the domain names when accessing 
;		the other servers. 
;  
;		Name				IP Address	Location  
;		time-a.nist.gov			129.6.15.28	NIST, Gaithersburg, Maryland  
;		time-b.nist.gov			129.6.15.29	NIST, Gaithersburg, Maryland  
;		time-a.timefreq.bldrdoc.gov	132.163.4.101	NIST, Boulder, Colorado  
;		time-b.timefreq.bldrdoc.gov	132.163.4.102	NIST, Boulder, Colorado  
;		time-c.timefreq.bldrdoc.gov	132.163.4.103	NIST, Boulder, Colorado  
;		utcnist.colorado.edu		128.138.140.44	University of Colorado, Boulder  
;		time.nist.gov			192.43.244.18	NCAR, Boulder, Colorado  
;		time-nw.nist.gov		131.107.1.10	Microsoft, Redmond, Washington  
;		nist1.symmetricom.com		69.25.96.13	Symmetricom, San Jose, California  
;		nist1-dc.glassey.com		216.200.93.8	Abovenet, Virginia  
;		nist1-ny.glassey.com		208.184.49.9	Abovenet, New York City  
;		nist1-sj.glassey.com		207.126.98.204	Abovenet, San Jose, California  
;		nist1.aol-ca.truetime.com	207.200.81.113	TrueTime, AOL facility, Sunnyvale, California  
;		nist1.aol-va.truetime.com	64.236.96.53	TrueTime, AOL facility, Virginia  
; 
; 
;Parameters	 
;		$Peers:	List of authoritative time servers. Use a space between servers, use IP or see  
;			Microsoft documentation on using the system name. 
;		$Pos:	MaxPosPhaseCorrection 
; 
;		Domain controllers and member servers inside the domain 
;		The MaxPosPhaseCorrection and MaxNegPhaseCorrection registry entries have a default value  
;		of 0xFFFFFFFF (accept any time change). This default value is fine. However, you want additional  
;		security inside your domain to help protect against human errors.  
;		Depending upon what you want to achieve, you may either leave or modify the default values. 
; 
;		Stand-alone clients 
;		The MaxPosPhaseCorrection and MaxNegPhaseCorrection registry entries have a default  
;		value of 54,000 (15 hours). As a security best practice, lower this default value.  
;		We recommend that you set the value to 3600 (1 hour) or even lower, depending on time  
;		source, network condition, poll interval, and security requirement. 
; 
;		$Neg:	MaxNegPhaseCorrection 
;			This entry specifies the largest negative time correction in seconds that the service makes.  
;			If the service determines that a change larger than this is required, it logs an event instead. 
;			Special case: -1 means always make time correction, The default value for domain members  
;			is 0xFFFFFFFF. The default value for stand-alone clients and servers is 54,000 (15 hours).  
; 
;		$Poll:	SpecialPollInterval 
;			This entry specifies the special poll interval in seconds for manual peers. When the  
;			SpecialInterval 0x1 flag is enabled, W32Time uses this poll interval instead of a poll  
;			interval determine by the operating system. The default value on domain members is 3,600.  
;			The default value on stand-alone clients and servers is 604,800. 
; 
; 
;Version	1.0  
;  
;Date		2005-Jun-22  
;  
;Date Revised 
;  
;Returns	Returns 5 access denied for non admins, w32tm does not appear to properly set errorlevel 
;  
;Dependencies	KiXtart 4.22+ 
; 
;Example			 
;		Dim $MyTime 
;		$MyTime = SetTimeServer('132.163.4.101 132.163.4.102 132.163.4.103',3600,3600,900) 
; 
;Source 
 
 

Function SetTimeServer($Peers,$Pos,$Neg,$Poll)
  Dim $Key,$Set,$Admin
  $Admin=IIf(InGroup(@WKSTA+'\'+SidToName('S-1-5-32-544'))-1+@INWIN=1,1,0)
  ;If user does not have Admin rights then quit. 
  If Not $Admin Exit 5 EndIf
  $Key='HKLM\SYSTEM\CurrentControlSet\Services\W32Time\'
  $Set=WriteValue($Key+'Parameters','Type','NTP',REG_SZ)
  $Set=WriteValue($Key+'Config','AnnounceFlags',5,REG_DWORD)
  $Set=WriteValue($Key+'TimeProviders\NtpClient','SpecialPollInterval',$Poll,REG_DWORD)
  $Set=WriteValue($Key+'TimeProviders\NtpServer','Enabled',1,REG_DWORD)
  $Set=WriteValue($Key+'Parameters','NtpServer',$Peers,REG_SZ)
  $Set=WriteValue($Key+'Config','MaxPosPhaseCorrection',$Pos,REG_DWORD)
  $Set=WriteValue($Key+'Config','MaxNegPhaseCorrection',$Neg,REG_DWORD)
  SHELL '%comspec% /e:1024 /c  net stop w32time >NUL 2>NUL'
  SHELL '%comspec% /e:1024 /c  net start w32time >NUL 2>NUL'
  ;The w32tm command does not appear to set the errorlevel. 
  ;You will have to check it against another source to confirm success 
  SHELL '%comspec% /e:1024 /c w32tm /resync /rediscover >NUL 2>NUL'
EndFunction
 
 

 184529SharedPrinterList3439AllenSharedPrinterList() - Creates a List of Printer Shares, Local or Remote PCs0

;Function:  
;    SharedPrinterList()  
;  
;Author:  
;    Allen Powell   
;  
;Version:  
;    1.0.1  (2008/05/07)  ; Updated code to pull Printer Name from the .printername property. 
;                         ; Previous version was using .model, which is actually the driver name.  
;  
;Revisions: 
;    1.0.0 (2008/01/11) 
; 
;Action:  
;    Creates an array/list of Shared Printers, displaying the share name, or the Device Name, or both  
;  
;Syntax:  
;    SharedPrinterlist(optional $server,optional $displaymode)  
;  
;Parameters:  
;       $Server: (Optional)  
;             Name of Server. If omitted defaults to localpc.  
;       $DisplayMode (Optional)  
;        1 - Display Share names  
;        2 - Display Printer Names  
;        3 - Display Share Names, Printer Names (Default) 
 

;Returns:  
;     Array of Printers  
;  
;Notes: 
;     If the server is not on, does not exist, you lack permissions, or any other error, SharedPrinterList() 
;     will return nothing, check @error for explaination. 
; 
;Example:  
;  
; 
;for each $printer in SharedPrinterList(@wksta,3) 
;  ? $printer  
;next  
;  
;Source:  
;  
 

function SharedPrinterList(optional $server, optional $displaymode)
  dim $PrintServer, $printer,$info[0],$PrintQueue[0], $counter
  $PrintQueue[0]="PrintQueue"
  if $server=""
    $server=@wksta
  endif
  $PrintServer=GetObject("WinNT://" + $server + ",computer")
  if @error
    exit @error
  else
    if $displaymode=""
      $displaymode=3
    endif
    $Printserver.filter=$PrintQueue
    for each $printer in $printserver
      redim preserve $info[$counter]
      if $displaymode & 1
        $info[$counter]=$printer.name
      endif
      if $displaymode & 2
        if $info[$counter]
          $info[$counter]=$info[$counter] + "," + $printer.printername
        else
          $info[$counter]=$printer.printername
        endif
      endif
      $counter=$counter+1
    next
    $SharedPrinterList=$info
  endif
endfunction
83635SharePerms119LonkeroSharePerms() - Retrieve share's permission0


;FUNCTION
;		SharePerms()
;
;VERSION
;		1.0.261002
;
;AUTHOR
;		Lonkero
;
;ACTION
;		Retrieves the permissions on specified share (local or remote)
;
;SYNTAX
;		SharePerms($machine, $share)
;
;RETURNS
;		Array of permission for the share
;
;REMARKS
;		all users with no real sid mapped to everyone
;
;DEPENDENCIES
;		KiXtart v4.10 rc2+
;
;EXAMPLES
;		"SHARE PERMISSIONS IN E-share:"
;		? for each $acl in shareperms(".","E")
;		  $acl ?
;		next
;
;		"SHARE PERMISSIONS ON \\PDC\CD:"
;		? for each $acl in shareperms("PDC","CD")
;		  $acl ?
;		next
;
;SOURCE


function SharePerms($wksta,$share)
 dim $hsid,$sid,$,$swap,$nul,$user,$users,$level
 $hsid=readvalue("\\"+$wksta+"\HKLM\SYSTEM\CurrentControlSet\Services\lanmanserver\Shares\Security",$share)
 if len($hsid)
  $hsid=join(split($hsid,"000000001400"),"000000002400")
  $hsid=split($hsid,"000000002400")
  for $=1 to ubound($hsid)
   $sid="S-1-5-21"
   $swap=substr($hsid[$],39,2)+substr($hsid[$],37,2)+substr($hsid[$],35,2)+substr($hsid[$],33,2)
   if len($swap)
    $nul=execute("$$swap=&$swap")
    $sid=$sid+"-"+$swap
    $swap=substr($hsid[$],47,2)+substr($hsid[$],45,2)+substr($hsid[$],43,2)+substr($hsid[$],41,2)
    $nul=execute("$$swap=&$swap")
    $sid=$sid+"-"+$swap
    $swap=substr($hsid[$],55,2)+substr($hsid[$],53,2)+substr($hsid[$],51,2)+substr($hsid[$],49,2)
    $nul=execute("$$swap=&$swap")
    $sid=$sid+"-"+$swap
    $swap=substr($hsid[$],59,2)+substr($hsid[$],57,2)
    $nul=execute("$$swap=&$swap")
    $sid=$sid+"-"+$swap
    $user=sidtoname($sid)
   endif
   $level=left($hsid[$],2)
   select
    case $level="ff" $level="Full Control"
    case $level="bf" $level="Change"
    case $level="a9" $level="Read"
    case $level="00" $level=0
    case 1 $level="Special"
   endselect
   if $level and 1>len($user)
    $user="Everyone"
   endif
   if $level and $user
    $users=$users+$user+" : "+$level+","
   endif
  next
 else
  $users="Everyone : Full Control,"
 endif
 $shareperms=split($users,",")
endfunction


 
 [ 26. October 2002, 01:07: Message edited by: Lonkero ]161527SharePerms5931apronkSharePerms() - Share Permission Control1172681207

ÿCode:

;Function	SharePerms() - Share Permissions Control
;
;Author		Arend Pronk (arendpronk@gmail.com)
;
;Contributors	Jochen, suggestion to output to Array instead of console.
;
;Action		Allows you to set Share permissions, NOT NTFS permissions.
;
;Syntax		SharePerms($cmd,$object,Optional $trustee,Optional $perms)
;
;Version  	1.2
;
;Date 		04-05-2006
;
;Date Revised 	28-02-2007
;
;Revise Reason 	Changed "SHOW" to return a real Array instead of the crappy output it had before.
;
;Parameters 	$cmd (Required) - String value ie: "SHOW", "DEL" or "ADD"
;		$object (Required) - String value, HAS to be a UNC path to the share ie: "\\Server\Share"
;		$trustee (Optional) - String value, in the form of "DOMAIN\user"
;		Optional when using "SHOW" as $cmd, Required for "DEL" and "ADD"
;		$perms (Optional) - String value ie: "READ", "WRITE" or "FULL"
;
;Returns  	The Current Ace's with their properties when SHOW is used.
;		Will return nothing when "ADD" or "DEL" is used.
; 
;Dependencies 	ADsSecurityUtility (Comes standard with XP and Above, NOT Windows 2000!)
;
;KiXtart Ver.	4.51
; 
;Example(s)	SharePerms("DEL","\\Server\Share","DOMAIN\user")
;		will remove the specified user from the share
;
;		SharePerms("ADD","\\Server\Share","DOMAIN\user","READ")
;		will add the specified user to the share with READ rights.
;
;		SharePerms("ADD","\\Server\Share","DOMAIN\user","WRITE")
;		will add the specified user to the share with READ and WRITE rights.
;
;		SharePerms("ADD","\\Server\Share","DOMAIN\user","FULL")
;		will add the specified user to the share with FULL rights.
;
;		$a = SharePerms("SHOW","\\Server\Share")
;		$b = Split($a,";")
;		For Each $x in $b
;		  ? $x 		;Will Display: "trustee:perms:flags:type"
;		Next
;		(You could further split $x with ":" to get the desired type)
;
Function SharePerms($cmd,$object,Optional $trustee,Optional $perms)
  Dim $ADSU, $GSD, $oDacl, $Ace, $oAce
  $ADSU = CreateObject("ADsSecurityUtility")
  $GSD = $ADSU.GetSecurityDescriptor($object, 2, 1)
  $oDacl = $GSD.DiscretionaryAcl
  Select
    Case $cmd = "SHOW"
      For Each $Ace In $oDacl
        $SharePerms = $SharePerms + $Ace.Trustee + ":" + $Ace.AccessMask + ":" + $Ace.AceFlags + ":" + $Ace.AceType + ";"
      Next
    Case $cmd = "DEL"
      If $trustee <> ""
        For Each $Ace In $oDacl
          If $Ace.trustee = $trustee
            $oDacl.RemoveAce($Ace)
          EndIf
        Next
        $GSD.DiscretionaryAcl = $oDacl
        $ADSU.SetSecurityDescriptor($object, 2, $GSD, 1)
      Else
        Exit 1
      EndIf
    Case $cmd = "ADD"
      If $trustee <> ""
        $oAce = CreateObject("AccessControlEntry")
        $oAce.Trustee = $trustee
        Select
          Case $perms = "READ"
            $oAce.AccessMask = 1179817
          Case $perms = "WRITE"
            $oAce.AccessMask = 1245631
          Case $perms = "FULL"
            $oAce.AccessMask = 2032127
          Case 1
            $oAce.AccessMask = 1179817
        EndSelect
        $oDacl.AddAce($oAce)
        $GSD.DiscretionaryAcl = $oDacl
        $ADSU.SetSecurityDescriptor($object, 2, $GSD, 1)
      EndIf
  EndSelect
EndFunction
171861SharePrinter3439AllenSharePrinter() - Share a Local or Remote Printer0

;Function:  
; SharePrinter()  
;  
;Author:  
; Allen Powell  
;  
;Action:  
; Share A Printer   
; 
;Version:  
; 1.0.0 2006/12/21  
; 
;Syntax: SharePrinter($sharename,$PrinterDesc,optional $remotepc) 
;  
;  
;Parameters:  
; $Sharename   - Required,  Share Name 
; $PrinterDesc - Required,  Printer Name/Description 
; $RemotePC    - Optional,  Name of remote computer, default is local host  
; 
;Returns: 
;        0 - Successful 
;        1 - Failed 
;        If Failed check @error 
;          or see below for custom errors 
;         -1 - Printer Already Shared 
; 
;Dependencies 
;  WMI with Windows XP, Windows 2003 Server and later 
;  Tested with Kixtart 4.53 
; 
;Example:  
; 
;$sharename="HP4" 
;$PrinterDesc="HP Laserjet 4" 
; 
;$RC=Shareprinter($sharename,$printerdesc) 
;if $RC<>0 
;  ? @error 
;  if @error=-1 
;    ? "Printer already shared" 
;  else 
;    if @error<-1 
;      ? cerror @error " " @serror 
;    else 
;      ? @serror 
;    endif 
;  endif 
;else 
;  ? "Shared" 
;endif 
; 
function SharePrinter($sharename,$PrinterDesc,optional $remotepc)
  dim $objWMIService,$Printer,$objPrinter,$RC
  $shareprinter=1
  if $remotepc=""
    $remotepc="."
  endif
  $objWMIService = GetObject("winmgmts:\\" + $remotepc + "\root\cimv2")
  if @error
    exit @error
  endif
  $ObjPrinter =  $objWMIService.ExecQuery("Select * from Win32_Printer Where NAME='" + $PrinterDesc + "'") 
  if $objPrinter.count=1
    For Each $Printer in $objPrinter
      if $printer.shared
        exit -1
      else
        $Printer.Shared=1
        $Printer.ShareName=$sharename
        $RC=$Printer.Put_
        if @error
          exit @error
        else
          $shareprinter=0
        endif
      endif
    Next
  else
    exit 1801
  endif
Endfunction
82361SHELLCMD17SealeopardSHELLCMD() - Executes a shell command0

code:

;FUNCTION      ShellCmd
;
;ACTION        Executes a shell command
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2
;
;KIXTART       4.12+
;
;SYNTAX        SHELLCMD(COMMANDSTRING [, OPTIONAL FORCEWAIT])
;
;PARAMETERS    COMMANDSTRING
;              Required string containing shell command
;
;RETURNS       0 if successful, otherwise error code
;
;REMARKS       none
;
;DEPENDENCIES  none
;
;EXAMPLE       $rc = shellcmd('%WINDIR%\notepad.exe',1)
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000057
;
function shellcmd($commandstring, optional $forcewait)
  Dim $rc

  if val($forcewait)
    $forcewait='start /min /wait '
  else
    $forcewait=''
  endif
  if $commandstring<>''
    $commandstring='%COMSPEC% /c '+$forcewait+$commandstring
    shell $commandstring
    $shellcmd=@ERROR
  else
    exit 87
  endif

endfunction


 
 [ 01. August 2003, 19:40: Message edited by: sealeopard ]82431ShortCut11ShawnShortCut() - Create shortcuts programatically with shortcut.exe0ShortCut()

Action:

Creates a shortcut at path linking to file at targetpath (using shortcut.exe from the NT reskit). ShortCut() is 100% compatible with it's sister function WshShortCut()

Syntax:

ShortCut("Path","TargetPath"[,"Arguments"[,"StartDir"[,"IconPath"]]])

Parameters:

Path (Required) - The fully qualified path to the new shortcut file.

TargetPath (Required) - The fully qualified path that the shortcut points to.

Arguments (Optional) - Arguments passed to $targetpath

StartDir (Optional) - Start directory (or Working Directory) of shortcut

IconPath (Optional) - The location of the icon used to represent the shortcut. The string is of the form "path,index", where path is the full path to the file containing the icon, and index is the zero-based index of the icon within the specified icon file.

Returns:

@ERROR set to 0 (zero) on success or relevant error code on failure

Remarks:

shortcut.exe must be resolvable through PATH or current directory

Insure that all paths are fully qualified (make sure to inlude the .lnk file extention on $path)

Dependencies:

kixtart 4.0 (final)

shortcut.exe (Windows NT Resource Kit)

Example(s):

ShortCut("%userprofile%\desktop\notepad.lnk","c:\winnt\system32\notepad.exe","kixtart.txt")

ShortCut("%userprofile%\desktop\notepad.lnk","c:\winnt\system32\notepad.exe",,,"c:\winnt\system32\shell32.dll,3")

See Also:

WshShortCut() - Create shortcuts programatically with WSH

Source:

Function ShortCut(
 $path,
 $targetpath,
 optional $arguments,
 optional $startdir,
 optional $iconpath
)
 dim $index $index = 0
 $path = '-n "$path"'
 $targetpath = '-t "$targetpath"'
 if $arguments
  $arguments = '-a "$arguments"'
 endif
 if $startdir
  $startdir = '-d "$startdir"'
 endif
 if $iconpath
  $index = '-x ' + val(substr($iconpath,instrrev($iconpath,",")+1))
  $iconpath = '-i "' + substr($iconpath,1,instrrev($iconpath,",")-1)+'"'
 endif
 shell '%comspec% /c shortcut -f $path $targetpath $arguments $iconpath $index'
 exit @error
EndFunction

Author:

-Shawn
 
 [ 21. February 2003, 16:15: Message edited by: Shawn ]141846SNVerify52NTDOCSNVerify() - Format system name leading "\\" & trailing "\"0

;;FUNCTION        SNVerify() 
;; 
;;ACTION          Formats a system name with leading "\\" & trailing "\" 
;; 
;;AUTHOR          Glenn Barnas / FRIT-EROC 
;; 
;;CONTRIBUTORS    NTDOC (minor code revision) 
;; 
;;VERSION         1.1 
;; 
;;DATE            2004/04/16 (never posted) 
;; 
;;DATE REVISED    2005/06/16 
;; 
;;REVISION REASON Posting of UDF by NTDOC and minor code revision 
;; 
;;SYNTAX          SNVerify($sComputer [,$Strip]) 
;; 
;;PARAMETERS      sComputer  - name of target system 
;;                Strip - (Boolean) strips all "\" characters 
;; 
;;REMARKS         Used by many registry functions to enable remote access 
;; 
;;RETURNS         Name of system in the format "\\system\" With the optional 
;;                parameter Strip set to non-zero, all \ characters are 
;;                removed from the beginning and end of the system name. 
;; 
;;DEPENDENCIES    none 
;; 
;;TESTED WITH     NT4, W2K, WXP 
;;                Explicit, NoVarsInStrings 
;; 
;;EXAMPLES        $Server = SNVerify($Server) 
 

;;SOURCE 
 

Function SNVerify(optional $sComputer,$Strip)
  If Not $sComputer $sComputer=@WKSTA EndIf
  $SNVerify=Join(Split($sComputer,'\'),'',3)
  $SNVerify=IIf(Not $Strip And $SNVerify<>'','\\'+$SNVerify+'\',$SNVerify)
EndFunction
 

 
With a supplied example like this it produces the following output.

Code:

Dim $sComputer
$sComputer=SNVerify('FINANCE01')
'Supplied computer with UNC: ' + $sComputer ?
$sComputer=SNVerify('FINANCE01',1)
'Supplied computer without UNC: ' + $sComputer ??
$sComputer=SNVerify()
'No computer specified with UNC: ' + $sComputer ?
$sComputer=SNVerify(,1)
'No computer specified without UNC: ' + $sComputer ?

 
 

Quote:


Supplied computer with UNC: \\FINANCE01\
Supplied computer without UNC: FINANCE01
 
No computer specified with UNC: \\MSE0001D\
No computer specified without UNC: MSE0001D


 82913SoftLink119LonkeroSoftLink() - Creates a shortcut anywhere1135299665Code:


;Function SoftLink()
;
;Action
;	Creates a shortcut at path linking to file at targetpath
;
;Author
,	Lonkero (Jooel dot nieminen at gmail dot com)
;
;Contributors
;	2005 - NTDoc, thanks for being there solving the issues
;
;Version
;	1.2.1 - current - 22nd dec 2005
;	 removed a issue with novarsinstrings
;
;	1.2 - 22nd dec 2005
;	 added some proper error output
;
;	1.1 - update - 22nd dec 2005
;	 original had some weird issues that weren't there before.
;	 just fixed those and called it 1.1 :)
;
;	1.0 - original - 31st jan 2002
;
;Syntax
;	SoftLink($Path,$TargetPath[,$Arguments[,$StartDir[,$IconPath]]])
 
;Parameters
;	$Path (Required) - The fully qualified path to the new shortcut file.
;	$TargetPath (Required) - The fully qualified path that the shortcut points to.
;	$Arguments (Optional) - Arguments passed to $targetpath
;	$StartDir (Optional) - Start directory (or Working Directory) of shortcut
;	$IconPath (Optional) - The location of the icon used to represent the shortcut.
;	 The string is of the form "path,index", where path is the full path to the file containing 
;	 the icon, and index is the zero-based index of the icon within the specified icon file.
 
;Returns
;	@ERROR set to 0 (zero) on success or relevent error code on failure
 
;Remarks
;	Insure that all paths are fully qualified (make sure to inlude the .lnk file extention on $path)
;	Coded on demand for KiX only solution on shortcut creation udf.
;	That means, thought rose up when I saw shawn's udf made with help of WSH (WhsShortCut())
 
;Dependencies
;	NONE
 
;Example(s)
;  SoftLink("%userprofile%\desktop\my notepad.lnk","c:\winnt\system32\notepad.exe") get $
;  SoftLink("%userprofile%\desktop\my notepad.lnk","c:\winnt\system32\notepad.exe","newdoc.txt")
;  SoftLink("%userprofile%\desktop\my notepad.lnk","c:\winnt\system32\notepad.exe","text.txt","c:\")
;  SoftLink("%userprofile%\bureau\my notepad.lnk","c:\winnt\system32\notepad.exe",,,"C:\winnt\system32\shell32.dll,3")
 
;Source
 
Function SoftLink($_path,$_target,optional $_args,optional $_startd,optional $_icon,optional $_iconIndex)
dim $_programs,$,$_name
$_programs=expandenvironmentvars(readvalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders","Programs"))
$_path=expandenvironmentvars($_path)
$_name=split($_path,"\")
$_name=$_name[ubound($_name)]
$=AddProgramItem($_target+" "+$_args,left($_name,instr($_name,".lnk")-1),$_icon,$_iconIndex,""+$_startd,0,0,0)
if @error exit @error endif
if not exist($_programs+"\"+$_name)
 $_programs=expandenvironmentvars(readvalue("HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders","Common Programs"))
endif
if not exist($_programs+"\"+$_name)
 exit 2
endif
copy $_programs+"\"+$_name $_path
if @error exit @error endif
del $_programs+"\"+$_name
if @error exit @error endif
endfunction


83503Split46kholmSplit() with no empty members0Action:
Return an array of words from a string like the KiX Split() function

Differences from the Split() function:

More than one char can be used as separator

Only members containing at least one char are returned
Parameters: 
$String:
String to split in words
Optional: $SplitChar
One or more chars to separate words in the string
If omited space is used.

Returns:
Array of members or 0 if empty

Dependencies:
KiXtart 4.1x

Example(s):

code:

$String = ReadProfileString('Win.ini','Mail','')
$a = SplitNE($String,Chr(10))
; Will NOT have an empty last member
 
$String = " Chickens       " + Chr(9) + "    come     from  eggs         "
$a = SplitNE($String," " + Chr(9)) ; Use both space and tabulator as separator
; Will return the array: "Chickens","come","from","eggs"

Source:

code:

Function SplitNE($String, Optional $SplitChar)
	Dim $Array[0],$NumMembers,$NewMember,$MemberFound,$LenStr,$i,$ChkChr
	$String = "" + $String
	$SplitChar = "" + $SplitChar
	If $SplitChar = ""
		$SplitChar = " "
	EndIf
	$LenStr = Len($String)
	$NumMembers = 0
	$NewMember = ""
	$MemberFound = 0
	For $i = 1 To $LenStr
		$ChkChr = SubStr($String,$i,1)
		If InStr($SplitChar,$ChkChr)
			If $NewMember ; If member contains text, add to array
				ReDim Preserve $Array[$NumMembers]
				$Array[$NumMembers] = $NewMember
				$NewMember = ""
				$NumMembers = $NumMembers + 1
				$MemberFound = 1
			EndIf
		Else
			$NewMember = $NewMember + $ChkChr
		EndIf
	Next
	If $NewMember ; If only one (last) member
		ReDim Preserve $Array[$NumMembers]
		$Array[$NumMembers] = $NewMember
		$MemberFound = 1
	EndIf
	If $MemberFound
		$SplitNE = $Array
	Else
		$SplitNE = 0 ; No members found
	EndIf
EndFunction

Author:
Erik Kærholm83295SQR28BryceSQR()  Raise a number to a power of x0

code:

function sqr($x,Optional $n)
;SQR (raise a number to a power of x)
;
;returns:
;	will return a number squared, or raised to the power of x
;
;Syntax:
;	$return = sqr({value},OPTIONAL{Power of X})
;	{value}.........Any number that you want to square or raise to the power of x
;	{power of x}....this is an options value, if left out the fonction will by 
;                       default sqr {value}, but if you want to $x^3 you can enter 3 
;                       for this value.
;
;Example:
;	$4squared = sqr(4)
;	$4cubed   = sqr(4,3)
;	;5^10
;       $value = sqr(5,10)
DIM $z,$loop
	if not $n
		$n = 2.0
	else
		$n = int($n)
	endif

	$z = $x
	for $loop = 1 to $n-1
		$z = $x * $z
	next
	$sqr = $z
endfunction

83287SQRT28BryceSQRT()    a Square root function0

code:

Function SQRT($x)
;SQRT (Square Root)
;
;Returns:  the square root of a given number
;
;Syntax:
;	$return = sqrt([value])
;	[value].......any positive number
;
;Example;
;	$SQRTof4 = sqrt(4.0)
dim $y,$z
	$y = 1.0
	while $y <> $z
		$z = $y
		$y = (($x/$y)+$y)/2
	loop
	$sqrt = $y
endfunction

Bryce
 
 [ 30 June 2002, 04:51: Message edited by: Bryce ]82445Squeeze11ShawnSqueeze() - Remove all occurrences of a string from within a string0Squeeze()

Action:

Remove all occurrences of a string from within another string

Syntax:

Squeeze("string1","string2")

Parameters:

String1 (Required) - The string to squeeze

String2 (Required) - The string to remove (squeeze) from string1

Returns:

The squeezed string

Remarks:

This function has no pratical application what-so-ever

Dependencies:

KiXtart 4.0 (final)

Example(s):

I don't know, this function is older than my grandmother, so
one could do this:

code:

? squeeze("142.123.123.28",".") ; gives 14212312328
 
? squeeze("1,2,3,4,5,6",",")    ; gives 123456
 
? squeeze(squeeze("orange juice","range "),"uice")+" did it" ; gives ?
 
? squeeze("ABAABBABAA","ABA")    ; gives ?

This mind just boogles at all the possiblilites         
Sorry about the really long line down there:

Source:

code:

function squeeze($string1,$string2)
 while instr($string1,$string2)
  $string1=substr($string1,1,instr($string1,$string2)-1)+substr($string1,instr($string1,$string2)+len($string2))
 loop
 $squeeze = $string1
endfunction

Author:

-Shawn
 
 [ 22. February 2003, 01:14: Message edited by: Shawn ]82828Sreg119LonkeroSreg() - Searches registry for specified value and/or valuename0

code:

;Function Sreg()
;
;Author	Lonkero
;
;Version 1.0 (15.01.2002 [GMT+2 04:45])
;
;Action Searches specified string from value and/or valuename in specified
;	subkey-tree in registry and returns all occurances in array.
;
;Syntax Sreg(Subkey, String, Integer)
;
;Parameters
;
;	Subkey
;	Defines from wherein registry to search for.
;	Registry pointing rules apply.
;	Supports remoteregistry scan.
;
;	String
;	tells the string to search for.
;
;	Integer
;	0 for Valuename
;	1 for Value
;	2 for Both
;
;Remarks
;	it's time to say this code is retired.
;	new code with proper scoping and faster execution foundable at:
; 	http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000401
; 	
; 	Nice, pure KiXsolution for regfinds!
;	Waiting for multidimensional array support. Until that output not so nice.
;	Full search on root keys can take up really much time.
;	Test run on just HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft against "id" gave results:
;		runtime:	35secons (previous builds approx. 5minutes!)
;		found:		1587 matches
;		memreserved:	after return 112kB, at most 5888kB (previous release 28800kB!)
;
;	So for your best, use as lowlevel subkeys as possible.
;	Parsed the code to be shorter and lost lots of unneeded lines, but also got it
;	really hard to follow the code. Kind of encrypted it  :)
;
;
;Returns
;	one dimensional array containing values where string occured.
;	array format is SUBKEY,VALUENAME
;
;	On error
;	nonexistent subkey-input	1010,ERROR_BADKEY
;	zero length string-input	24,ERROR_BAD_LENGTH
;	Integer input not 0, 1 nor 2	50,ERROR_NOT_SUPPORTED
;
;Dependencies
;	none
;
;Example
;	break on
;	$index=Sreg("HKEY_LOCAL_MACHINE\Software\Microsoft","id",2)
;	if @error
;		"error occured: @serror" ?
;	else
;		for each $value in $index
;			? $value
;		next
;	endif
;	exit 0
;
;Source

Function Sreg($_Subkey, $_String, $_Integer)
if not keyexist("$_Subkey") exit 1010 endif
if not len($_String) exit 24 endif
if $_Integer<0 or $_Integer>2 exit 50 endif
$_I="" $_Chr=chr(29)
$=execute('sk("$_Subkey","$_String",$_Integer)')
$_C=0 $_Is =""
for each $_F in split($_I,$_Chr) if len($_F) $_C=$_C+1 endif next
$_C=$_C-1
$=execute('global $$_IA[$_C]')
$_C=0
for each $_F in split($_I,$_Chr) if len($_F) $=execute('$$_IA[$_C]="$_F"') $_C=$_C+1 endif next
$Sreg=$_IA
$_I="" $_IA=""
EndFunction

Function sk($_key, $_St, $_In)
$_vC=0
$_Vn=enumvalue($_key,$_vC)
while len($_Vn)
 if $_In=0
	if instr($_Vn,$_St) $_I=$_I+$_key+",$_Vn"+$_Chr endif
 else
	if instr(readvalue($_key,$_Vn),$_St) $_I=$_I+$_key+",$_Vn"+$_Chr else if $_In=2 and instr($_Vn,$_St) $_I=$_I+$_key+",$_Vn"+$_Chr endif endif
 endif	
 $_vC=$_vC+1
 $_Vn=enumvalue($_key,$_vC)
loop
$_C=0 $_ID=""
$_Un=enumkey($_key,$_C)
while len($_Un)
 $_ID=$_ID+"$_key\$_Un,"
 $_C=$_C+1
 $_Un=enumkey($_key,$_C)	
loop
for each $_uk in split($_ID,",") if len($_uk) $=execute('sk("$_uk","$_St",$_In)') endif	next
EndFunction


 
 [ 04. May 2003, 06:47: Message edited by: Lonkero ]83846StartMenuRefresh119LonkeroStartMenuRefresh - Refreshes the contents of the Start menu0

code:

;FUNCTION	StartMenuRefresh
;
;AUTHOR		Lonkero
;
;ACTION		Refreshes the contents of the Start menu
;
;SYNTAX		StartMenuRefresh
;
;PARAMETERS	none.
;
;RETURNS	nothing.
;
;DEPENDENCIES	Minimum operating systems: NT or win95 with IE4
;
;REMARKS	Don't use with XP as it has the functionality inbuild
;
;EXAMPLE
;		StarMenuRefresh
;
;CODE
function StartMenuRefresh()
 dim $
 $=createobject('shell.application')
 $.refreshmenu()
endfunction

137929stddate6441Gerald_Gstddate() Returns date from System Short format to @DATE format1158168157Code:



; +--------------------------------------------------------------------- 
; | Function		stddate($ShortDate)
; | 
; | Author		Gerald Ganson - gerald.ganson@rdc.ab.ca
; | 
; | Contributors	
; | 
; | Action		Returns the date from any call that uses the system short date format to return a 
; |           		date, in the same format as the @Date uses. "YYYY/MM/DD"
; | 
; | Syntax		stddate("date")
; | 
; | Version		1.1 - additional possible sShortDate formats can be handled
; | 
; | Date           	April 13, 2005
; | 
; | Date Revised   	Sep 12, 2005
; | 
; | Parameters 		$ShortDate
; |   			should be in one of the short date formats found in the windows control panel
; | 	        	International Settings for short date format.
; | 
; | Remarks		Built becuase the COM call to .AccountExpirationDate returns the date in what
; | 			ever format is currently set in the control panel.
; | 
; | 			Since this makes it hard to work with for comparing with @DATE, or for consistant
; | 			display to users, the function was concieved. 
; | 			
; | 			Exits with error 99 if "HKEY_CURRENT_USER\Control Panel\International\sShort Date"
; | 			is not set to one of the formats known to this function.
; | 
; | Returns		Returns the date sent to it in the same format as the @DATE macro
; |  
; | Dependencies 	None
; | 
; | KiXtart Ver		4.22
; |  
; | Example(s)	        $Dom_Ou = "your OU"  
; |                	$adsDomain = GetObject("LDAP://"+$dom_ou)  	                                 
; |               	$adsUser=GetObject("LDAP://cn=" + @USERID + ","+$dom_ou) 
; |               	$acct_exp = stddate($adsUser.AccountExpirationDate)
; |  
; +--------------------------------------------------------------------- 

Function stddate($Shortdate)

  Dim $datesplit[2], $SFormat
  
  $SFormat = ReadValue("HKEY_CURRENT_USER\Control Panel\International","sShortDate") 
  $SFormat
  Select
  Case $SFormat = "dd/MM/yyyy"
    $stddate = SubStr($Shortdate,7,4) + "/" +  SubStr($Shortdate,4,2)+ "/" + SubStr($Shortdate,1,2)
  
  Case $SFormat = "dd/MM/yy"
    $stddate = "20" + SubStr($Shortdate,7,2) + "/" +  SubStr($Shortdate,4,2)+ "/" + SubStr($Shortdate,1,2)
  
  Case $SFormat = "d/M/yy" 
    $datesplit = Split($Shortdate,"/")
    If Len($datesplit[0]) = 1 
      $datesplit[0] = "0" + $datesplit[0]
    EndIf      
    If Len($datesplit[1]) = 1 
      $datesplit[1] = "0" + $datesplit[1]
    EndIf
    $stddate = "20" + $datesplit[2] + "/" + $datesplit[1] + "/" + $datesplit[0]   
  
  Case $SFormat = "d/M/yyyy" 
    $datesplit = Split($Shortdate,"/")
    If Len($datesplit[0]) = 1 
      $datesplit[0] = "0" + $datesplit[0]
    EndIf      
    If Len($datesplit[1]) = 1 
      $datesplit[1] = "0" + $datesplit[1]
    EndIf
    $stddate = $datesplit[2] + "/" + $datesplit[1] + "/" + $datesplit[0]     
  
  Case $SFormat = "d/MM/yyyy" 
    $datesplit = Split($Shortdate,"/")
    If Len($datesplit[0]) = 1 
      $datesplit[0] = "0" + $datesplit[0]
    EndIf      
    $stddate = $datesplit[2] + "/" + $datesplit[1] + "/" + $datesplit[0]   
  
  Case $SFormat = "yyyy-MM-dd"
    $stddate = SubStr($Shortdate,1,4) + "/" +  SubStr($Shortdate,6,2)+ "/" + SubStr($Shortdate,9,2)
  
  Case $SFormat = "yy-MM-dd"
    $stddate = "20" + SubStr($Shortdate,1,2) + "/" +  SubStr($Shortdate,4,2)+ "/" + SubStr($Shortdate,7,2)
 
  Case $SFormat = "M/dd/yy" 
    $datesplit = Split($Shortdate,"/")    
    If Len($datesplit[0]) = 1 
      $datesplit[0] = "0" + $datesplit[0]
    EndIf      
    $stddate = "20" + $datesplit[2] + "/" + $datesplit[0] + "/" + $datesplit[1]    
    
  Case $SFormat = "M/d/yyyy"
    $datesplit = Split($Shortdate,"/")
   	If Len($datesplit[0]) = 1 
      $datesplit[0] = "0" + $datesplit[0]
    EndIf   
    If Len($datesplit[1]) = 1 
      $datesplit[1] = "0" + $datesplit[1]
    EndIf                                
    $stddate = $datesplit[2] + "/" + $datesplit[0] + "/" + $datesplit[1]
   
  Case 1
    Exit 99
EndSelect
EndFunction    



I have been having troubles with writing scripts that do calls to Active Directory to manage users, on one workstation and then getting varied results when run on another server or workstation.

I tracked it down to the fact that the call to "AccountExpirationDate" returns the date to KiXtart in whatever format the control panel has set as the system short date.

The following function takes the date from such a call and returns it in the same format as the @DATE macro, which make the output more useful to me in scripting.

Although I use it for the AccountExirationDate, I'm sure there must be other COM calls that return the date in Short System Format.

PS This is my first post to the board, and I have read as much FAQ and stuff as possible, also searched for a solution to this problem, and did not find. Still the possibility exists that I have posted out of turn, so please correct me gently if I have.

Thanks for the great board - Gerald108428StopProc4470Bruce_McStopProc() - stop running processes.1072495640Code:


;FUNCTION       StopProc() 

;ACTION         Stop running processes 

;AUTHOR         Bruce Mc 

;CONTRIBUTORS   Breaker-WMIKill();kdyer-EndProc(); Radimus; Les; sealeopard 

;VERSIONS       1.0 initial version 

;               1.1 replaced global variable with exit codes 

;               1.2 removed code not part of function 

;               1.3 added test for presence of WMI; changed the EXAMPLE 

;KIXTART        4.22.0.0 

;SYNTAX         StopProc($Proc, optional $Computer) 

;PARAMETERS     $Proc 

;                 Process's executable to stop 

;               optional $Computer 

;                 Name of target computer.  If none given defaults to 

;                   @WKSTA (local computer) 

;RETURNS        Success level via @ERROR - see EXAMPLE 

;REMARKS        Written to work just fine as a stand alone.  For the additional 

;                 feature of the success level being entered into a log, obtain 

;                 and call instead the UDF StopProcLogger(), which calls this 

;                 UDF directly. 

;DEPENDENCIES   WMI 

;EXAMPLE        CALL @ScriptDir + \StopProc.kxf 

;               StopProc(PowerCalc.exe) 

;               IF @ERROR=0 "Process was stopped" + @CRLF ENDIF 

;               IF @ERROR=1 "Process was already stopped" + @CRLF ENDIF 

;               IF @ERROR=2 "Failure in stopping process" + @CRLF ENDIF 

;               IF @ERROR=3 "WMI not present on target machine" + @CRLF ENDIF 



FUNCTION StopProc($Proc, optional $Computer)



  ; ...Declare function variables... 

  DIM $GetObject, $Select, $Process, $WMI, $Processes, $rPID, $Stopper



  ; ...Set function variables... 

  IF NOT $Computer $Computer=@WKSTA ENDIF

  $GetObject="winmgmts:{impersonationLevel=impersonate}!//" + $Computer

  $WMI=GetObject($GetObject)



  ; ...Test if WMI is enabled and exit with error code if not enabled... 

  IF VARTYPE( $WMI )<>9 EXIT 3 ENDIF



  ; ...Attempt stopping requested process... 

  $Processes=$WMI.instancesof("Win32_process")

  FOR EACH $Process IN $Processes

    IF $Process.name=$Proc

      $rPID=$Process.ProcessId

      $Stopper=$Process.Terminate

    ENDIF

  NEXT



  ; ...Exit with error code representing success level of stopping process... 

  SELECT

    CASE @ERROR=0 AND $rPID>0

      EXIT 0

    CASE @ERROR=0 AND $rPID=""

      EXIT 1

    CASE @ERROR<>0

      EXIT 2

  ENDSELECT



ENDFUNCTION

110795StopProcLogger4470Bruce_McStopProcLogger() - Logs stopping of processes1072495812Code:


;FUNCTION       StopProcLogger() 

;ACTION         Logs stopping of processes 

;AUTHOR         Bruce Mc 

;CONTRIBUTORS   Radimus; Jochen; sealeopard 

;VERSIONS       1.0 initial version 

;               1.1 replaced using global variable with @ERROR codes 

;               1.2 removed code not part of function; changed the EXAMPLES 

;               1.3 added @ERROR check for absence of WMI; changed log layout 

;KIXTART        4.22.0.0 

;SYNTAX         StopProcLogger($Proc, $Folder, $Write [, optional $Computer]) 

;PARAMETERS     $Proc 

;                 The executable of process to stop 

;               $Folder 

;                 The directory to write StopProcLog.txt to 

;               $Write 

;                 first - first process in a list, or only process to stop 

;                 add   - additional process to stop 

;               optional $Computer 

;                 Computer to stop process on 

;                 If no computer is given, defaults to @WKSTA (local computer) 

;RETURNS        Enters into StopProcLog.txt - 

;                 If the process was stopped, will enter into log: 

;                   Stopped:  ProgramName.exe 

;                 If the process could not be stopped, enter into log: 

;                   Failure:  ProgramName.exe 

;                 If the process was already stopped, enters into log: 

;                   Already:  ProgramName.exe 

;                 If WMI is not enabled, enters into log: 

;                   No__WMI:  ProgramName.exe 

;REMARKS        Useful for unattended stopping of processes, such as late at night 

;                 as a preparation for unattended pc maintenance.  The results are 

;                 entered into a log which could be read alone, or integrated into 

;                 a master maintenance log to read your next computer session. 

;DEPENDENCIES   UDF StopProc() - stop running processes 

;EXAMPLES       CALL @ScriptDir + \StopProcLogger.kxf 

;               CALL @ScriptDir + \StopProc.kxf 

;               StopProcLogger(GrphCalc.exe, @ScriptDir, first) 

;               StopProcLogger(freecell.exe, @ScriptDir, add) 

;               StopProcLogger(PowerCalc.exe, @ScriptDir, add) 

;               StopProcLogger(freshui.exe, @ScriptDir, add) 

;               - OR - 

;               CALL $UDFs + \StopProcLogger.kxf 

;               CALL $UDFs + \StopProc.kxf 

;               StopProcLogger(PowerCalc.exe, $Logs, first, @WKSTA) 



FUNCTION StopProcLogger($Proc, $Folder, $Write, optional $Computer)



  ; ...Declare function variables... 

  DIM $Count, $Verify, $vsp



  ; ...Enter log header and datestamp into log if Write is first... 

  IF $Write="first"

    $vsp=REDIRECTOUTPUT($Folder+\StopProcLog.txt, 1)

    ; ...line 1 of header block... 

    FOR $Count = 1 To 51 STEP 1 Chr(42) NEXT +@CRLF

    ; ...line 2 of header block... 

    "VERIFY STOPPING OF PROCESSES"+@CRLF

    ; ...line 3 of header block... 

    @Time+Chr(32)+@Day+Chr(44)+Chr(32)+@Month +Chr(32)+@MDayNo+Chr(44)+Chr(32)+@Year+@CRLF

    ; ...line 4 of header block... 

    FOR $Count = 1 To 51 STEP 1 Chr(42) NEXT +@CRLF

    ; ...end redirecting output... 

    $vsp=REDIRECTOUTPUT("")

  ENDIF



  ; ...Direct UDF StopProc() to stop the given process... 

  StopProc($Proc, $Computer)

  SELECT

    CASE @ERROR=0

      $Verify="Stopped"

    CASE @ERROR=1

      $Verify="Already"

    CASE @ERROR=2

      $Verify="Failure"

    CASE @ERROR=3

      $Verify="No__WMI"

  ENDSELECT



  ; ...Enter verification for stopping the process into the log... 

  $vsp=REDIRECTOUTPUT($Folder+\StopProcLog.txt, 0)

   Chr(32)+Chr(32)+$Verify+Chr(58)+Chr(32)+Chr(32)+$Proc+@CRLF

  $vsp=REDIRECTOUTPUT("")



ENDFUNCTION

  83198StringCount17SealeopardStringCount() - Returns the number of occurances of a string in another string0

code:

;FUNCTION      StringCount()
;
;ACTION        Returns the number of occurances of a string in another string
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.2
;
;KIXTART       4.12
;
;SYNTAX        COUNT = STRINGCOUNT(SEARCHSTRING, FINDSTRING)
;
;PARAMETERS    SEARCHSTRING
;              String to search in
;
;              FINDSTRING
;              String to search for
;
;RETURN        number of occurances of a string in another string
;
;REMARKS       based on a idea from Will S. (http://www.kixtart.org/board/ultimatebb.cgi?ubb=get_topic;f=12;t=000215)
;
;DEPENDENCIES  none
;
;EXAMPLE       $count=StringCount('This is a test to search for "is"','is')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000216
;
FUNCTION StringCount($searchstring, $findstring, optional $word)
  $stringcount=split($searchstring,$findstring)
  $stringcount=ubound($stringcount)
endfunction


 
 [ 02. March 2003, 20:22: Message edited by: sealeopard ]132819StringMatch119LonkeroStringMatch() - do a pattern match against a string1106558794 Code:

;FUNCTION 

;	StringMatch() 

; 

;AUTHOR 

;	Lonkero (Jooel_Nieminen at hotmail) 

; 

;ACTION 

;	does "DOS like" pattern matching.

; 

;VERSION 

;	1.0

; 

;VERSION HISTORY 

;	1.0 

;		23th January 2005

;		Initial public version.

; 

;SYNTAX 

;	 StringMatch( PATTERN, STRING) 

; 

;PARAMETERS 

;	PATTERN

;	 pattern to match the string against

;	STRING

;	 the string to match

; 

;RETURNS

;	1 if match, 0 if not

; 

;REMARKS  

;	

;  

;DEPENDENCIES 

;	none. (kixtart 4.01 RC-4, build 59)

; 

;EXAMPLE  

;	StringMatch("kixtart rules", "kixtart rules")	"	returns 1" ?

;	StringMatch("kixtart", "kixtart rules")	"	returns 0" ?

;	StringMatch("kix*", "kixtart rules")		"	returns 1" ?

;	StringMatch("*ta?t*","kixtart rules")	"	returns 1" ?

;	StringMatch("*x?a*l?s","kixtart rules")	"	returns 1" ?

;	StringMatch("*r?les","kixtart rules")	"	returns 1" ?

;	StringMatch("*t??t*","kixtart rules")	"	returns 1" ?

;	StringMatch("ki*r??es","kixtart rules")	"	returns 1" ?

;	StringMatch("kix?", "kixtart rules")		"	returns 0" ?

;	StringMatch("*t?t*","kixtart rules")		"	returns 0" ?

;	StringMatch("ki*r?es","kixtart rules")	"	returns 0" ?

;	StringMatch("a?c*a?c","abcdefabcghiabc")	"	returns 1" ?

;	StringMatch("a?c*a?c*a?c","abcdefabcghiabc")	"	returns 1" ?

;	StringMatch("a?c*a?c*a?c*a?c","abcdefabcghiabc")"	returns 0" ?

;get $ 

;

;SOURCE  

function stringMatch($s2,$s1)

dim $m,$c,$mc,$,$mcc

 $m=1

 for $=1 to len($s1)

  $c=substr($s1,$,1)

  $mc=substr($s2,$m,1)

  if $c=$mc or $mc="?"

   $m=$m+1

  else

   if $mc="*"

    $mcc=substr($s2,$m+1,1)

    if $c=$mcc or $mc="?" $m=$m+2 endif

   else

    $m=instrrev(substr($s2,1,$m),"*")

    if $m $=$-1 else $m=1 endif

   endif

  endif

 next

 $stringMatch=iif($m<len($s2),0,1)

endfunction

  83441Strip588SchuliebugStrip() - strip leading or trailing character from string0This UDF strips optional chars from a given string. Default spaces are stripped from the start and the end of the string.

code:

;Author		Jan.Schulenburg@tui.nl
;
;Function	Strip
;
;Parameters1:	String, required, string to check.
;		2: Char, optional, character to delete from string.
;		3: Mode, optional, all: deleting all given characters
;		lt : deleting leading and traling characters (default)
;
;Remarks	This function deletes every occurrence of characters of a string.
;		If no char is given, ' ' wil be deleted. If $Mode is all, all chars
;		are deleted.
;
;Returns	String without leading and trailing chars, or without all given
;		characters. @Error=0 if succesfull, 1 if failed.
;
;Dependencies	none
;
;Example(s)	$RC=Strip(' hello, this is a test ',' ')
;		$RC=Strip(' hello, this is a test ',' ','all')
;		$RC=Strip(' hello, this is a test ','s')
;		$RC=Strip('*hello, this is a test*','*')
;
Function Strip($String,Optional $Char, Optional $Mode)
	Dim $Cnt,$Start,$End

	; Check parameters..
	If Not VarType($String) Exit(1)    EndIf
	If Not VarType($Char)   $Char=' '  EndIf
	If Not VarType($Mode)   $Mode='lt' EndIf

	$Strip=''
	Select
	  Case $Mode='lt'
	  	; only leading and trailing chars..
	  	For $Cnt=1 to Len($String)
			If SubStr($String,$Cnt,1)<>$Char $Start=$Cnt $Cnt=Len($String)+1 EndIf
		Next
	  	For $Cnt=Len($String) to 1 Step -1
			If SubStr($String,$Cnt,1)<>$Char $End=$Cnt+1 $Cnt=0 EndIf
		Next
		$Strip=SubStr($String,$Start,$End-$Start)

	  Case $Mode='all'
	  	; all chars..
	  	For $Cnt=1 to Len($String)
			If SubStr($String,$Cnt,1)<>$Char $Strip=$Strip+SubStr($String,$Cnt,1) EndIf
		Next
	  Case 1
		$Strip=$String
	EndSelect
EndFunction


 
 [ 28. October 2002, 19:45: Message edited by: Radimus ]83470StripCopies275VigStripCopies() - Strips multipile instances of a string and integer from an array0

code:

;Function		StripCopies()
;
;Author			Vig (ag4634@hotmail.com)
;
;Action			Strips multipile instances of a string and integer
;			out of an array
;
;Syntax			StripCopies($Array)
;
;Version 1.0
;
;Parameters		Array
;			The array in which you want to strip copies from
;
;Remarks		It may be ugly but it works!
;
;Returns		The original array minus copies in the original array
;
;Dependencies		None
;
;KixTart Ver		4.02
;
;Example		Dim $test[13]
;			$test1 = "2","3","4","1","2","3","4","2","3","4","1","2","3","4"
;			$test1 = stripcopies($test1)
;				
;			For Each $1 in $test1
;			$1" "
;			Next	
;
;
;			Returns: 2 3 4 1
;

Function StripCopies($striArray)
$on = 1 
Dim $searArr
For Each $add in $StriArray 
	If Ubound($SearArr) = -1
	ReDim $searArr[0] $SearArr[0] = $add
	EndIf
	$counter = 0 
	While Ubound($SearArr)+1 <> $counter 
	If $add = $searArr[$counter]
	$on = 1 
	EndIf
	$counter = $counter + 1 
	Loop
	$counter = 0 
	If $on = 0 ReDim preserve $SearArr[Ubound($SearArr)+1] $SearArr[Ubound($SearArr)] = $add EndIf
	$on = 0
Next 
$StripCopies = $SearArr 
EndFunction

Argh! Sorry for some reason I can't get it to post with the proper spaceing.

Duhh! Code tags.
 
 [ 30. August 2002, 18:31: Message edited by: Vig ]83254StrSidToHexSid172Howard BullockStrSidToHexSid() - Converts String Sid to Hex Sid01) Changed use of UDF BaseConverter() to builtin function DecToHex.

code:

;FUNCTION         StrSidToHexSid($StringSid)
;
;AUTHOR           Howard A. Bullock (hbullock@comcast.net)
;
;ACTION           Converts a Sid in string (S-1-5-21-...) format to Hex format.
;
;SYNTAX           StrSidToHexSid($StringSid)
;
;PARAMETERS       $StringSid (Required) -  String value
;
;REMARKS          Do not prefix the computer name with "\\"'s.
;
;RETURNS          String
;
;DEPENDENCIES     KiXtart 4.02
;
;EXAMPLES         StrSidToHexSid("S-1-5-21-24129212-1035812195-1543859470-1401")
;         returns "010500000000000515000000BC2E7001633DBD3D0E6D055C79050000"
;
Function StrSidToHexSid($StringSid)
   dim $i, $j, $Parts, $Sac, $Sid, $x

   $Sid = ""
   If Left($StringSid,4) = "S-1-"
      $Parts = split($StringSid, "-")

      $Sid = $Sid + PadStr(DecToHex($Parts[1]),0,2)  ;Authority
      $Sac = Ubound($Parts) - 2                      ;Sub-Authority Count
      $Sid = $Sid + PadStr($Sac,0,2)
      $Sid = $Sid + PadStr(DecToHex($Parts[2]),0,12) ;Identifier-Authority (48 bits)

      For $i=1 to $Sac                               ;Sub-Authorities
         $x = PadStr(DecToHex($Parts[$i+2]),0,8)
         For $j=7 to 1 Step -2
            $Sid = $Sid + Substr($x,$j,2)
         Next
      Next
   Else
      ? "StrSidToHexSid - Invalid input"
      Exit 1
   Endif
   $StrSidToHexSid = $Sid
   Exit 0
Endfunction


 
 [ 15 June 2002, 17:51: Message edited by: Howard Bullock ]82215Subnet28BryceSubnet() - will tell if a given ip# is in a specified subnet.0

code:


; Subnet
;   will Identify if a given IP address is in a specified subnet
;
; Requirements: BInaryIP()
;
; SYNTAX: SUBNET([ipaddress], [ipmask], [subnetmask])
;   [ipaddress]	is the Ip Address that you wnat to check against.
;   [IPmask]	Is the ip mask of the subnet you are compairing [ipaddress] to
;   [subnet]	is the subnet range of the [ipmask]
;
; Return Codes
;   1 = [ipaddress] is in the subnet specified
;   0 = [ipaddress] is NOT in the subnet specified
;	
; Example:
;	if subnet("10.0.0.1", "10.0.0.0", "255.0.0.0") = 1
;		? "this ipaddress is in the specified subnet."
;	else
;		? "this ipaddress is not in the specified subnet."
;	endif
Function Subnet($ipaddress, $ipmask, $subnetmask)
	if instr(binaryip($subnetmask),"0") <> 0
		$subnetmask = substr(binaryip($subnetmask),1,instr(binaryip($subnetmask),0)-1)
	else
		$subnetmask = binaryip($subnetmask)
	endif

	if substr(binaryip($ipaddress),1,len("$subnetmask")) = substr(binaryip($ipmask),1,len("$subnetmask"))
		$subnet = 1
	else
		$subnet = 0
	endif
endfunction

[ 26 November 2001: Message edited by: Bryce ]83184SubStrRev588SchuliebugSubStrRev()0I saw a question about a SubStrRev() function. Maybe my UDF can help?

code:

;Author         Jan.Schulenburg@tui.nl
;
;Function       SubStrRev
;
;Parameters     1: required, The string from which to extract a substring
;               2: required, Numeric value representing the offset (from the right)
;                  in the string where the substring begins
;               3: required, Optional numeric value representing the length of the
;                  substring. If omitted or if there are fewer than Length characters
;                  in the text (including the character at start), all characters from
;                  the start position to the end of the string are returned
;
;Remarks        none
;
;Returns        The substring indicated by start and length
;
;Dependencies   none
;
;Example(s)     ? SubStrRev('0123456789',4,3) returns '456'
;               ? SubStrRev(This is a string',5) returns 'This is a s'
;
Function SubStrRev($Str,$StPos,optional $Len)
	Dim $St

	; Variable checks..
	$StPos=0+$StPos
	If Not VarType($Len)
		$Len=Len($Str)+1-$StPos
	Else
		$Len=0+$Len
		If ($Len+$StPos)>Len($Str)+1
			$Len=Len($Str)+1-$StPos
		EndIf
	EndIf

	$St=2+Len($Str)-$StPos-$Len
	$SubStrRev=SubStr($Str,$St,$Len)
EndFunction


 
 [ 28. October 2002, 19:46: Message edited by: Radimus ]82987SVCStatus609MasterOfDesasterSVCStatus() - Shows the status of a Service on a NetworkComputer0Hi,

with following UDF you can see the status of one or all Services on Computer.

There are some ohter udf posted here in the board, but they work with the Xnet.exe file. With this script you don't need this file extra.

You must have ADSI installed on your PC where the script is running. (ADSI is installed on W2K and WinXP. For NT4 you must download it from www.microsoft.com/adsi  )

This script is only made to show, how you can get infos with the ADSI-COM. 

code:

  

;Function svcstatus()
;
;Author M. Szekely
;
;Action Shows the status of a NT Service 
;
;Syntax svcstatus("Computername", Optional "Service")
;
;Parameters 
;  - Computername
;   The Computername must be the normal machinename whithout '\\'
;
;  - Service
;   This parameter is optional. You can enter a servicename, but it must be
;   'short' name, not the displayname.
;
;
;The status  of the service shows following:
;
;    Status = 4      Service is running
;    Status = 1      Service is stopped
; 
;Example(s) svcstatus("MyComputer","Spooler")
; 
;Source


function svcstatus($Computer, optional $Service)

$AD=GetObject("WinNT://"+$Computer+",computer")
$AD.Filter="Service",""

if $Service=""
 for each $e in $ad
  ? "Service: "+$e.name
  ? "Displayname: " $e.displayname
  ? "Status: "+$e.status
 next

else 

 for each $e in $ad
   if $e.name=$Service
    ? "Service: "+$e.name
    ? "Displayname: " $e.displayname
    ? "Status: "+$e.status
   $Svcstatus=$e.status
   endif
 next
endif
  
endfunction

[ 11 February 2002: Message edited by: MasterOfDesaster ]

[ 11 February 2002: Message edited by: MasterOfDesaster ]

[ 11 February 2002: Message edited by: DrillSergeant ]83557Syntax119LonkeroSyntax() - check correctness of your script0

code:

;Function:	 syntax()
;
;Author:	Lonkero
;
;Version:	0.1
;
;Action:	checks syntax correctness of script file
;
;Syntax:	syntax("FILE")
;
;Parameters:
;		FILE	- full path to file
;
;Returns:
;		Nothing or errorcode on error.
;
;Dependencies:
;		none
;
;Remarks:
;		Keyword table is like old... 4.0 or something.
;		no UDF support...
;		this was really like first version and is really hard
;		to even update. later is the time when comes new
;		improved version
;
;Example:	
;		syntax("c:\here.kix")
;
;Source:
function Syntax($file)
dim $s[11],$c,$,$i,$legal,$co,$fu,$ma,$r,$line,$pre,$error
$legal="<>()[]=+-*/,1234567890?'$ :	"+chr(34)+chr(10)
$co='Beep','Big','Call','CD','CLS','Color','Cookie1','Copy','Del','Dim','Display','Exit','FlushKb','Get','GetS',
'Global','Go','GoSub','GoTo','MD','Play','Quit','RD','Redim','Return','Run','Set','SetL','SetM','SetTime','Shell',
'Sleep','Small','Use'
$fu='AddKey','AddPrinterConnection','AddProgramGroup','AddProgramItem','Asc','At','BackupEventLog','Box','Chr',
'ClearEventLog','Close','CompareFileTimes','CreateObject','DecToHex','DelKey','DelPrinterConnection','DelProgramGroup',
'DelProgramItem','DelTree','DelValue','Dir','EnumGroup','EnumIpInfo','EnumKey','EnumLocalGroup','EnumValue','Execute',
'Exist','ExpandEnvironmentVars','GetDiskSpace','GetFileAttr','GetFileSize','GetFileTime','GetFileVersion','GetObject',
'InGroup','InStr','InStrRev','KbHit','KeyExist','LCase','Len','Left','LoadHive','LoadKey','LogEvent','Logoff','LTrim',
'MessageBox','Open','ReadLine','ReadProfileString','ReadType','ReadValue','RedirectOutput','Right','Rnd','RTrim',
'SaveKey','SendKeys','SendMessage','SetAscii','SetConsole','SetDefaultPrinter','SetFileAttr','SetFocus','SetOption',
'SetSystemState','SetTitle','SetWallpaper','ShowProgramGroup','ShutDown','SidToName','Split','SRnd','Substr','Trim',
'Ubound','UCase','UnloadHive','Val','VarType','VarTypeName','WriteLine','WriteProfileString','WriteValue'
$ma='Address','Build','Comment','CRLF','CSD','CurDir','Date','Day','Domain','DOS','Error','FullName','HomeDir',
'HomeDrive','HomeShr','HostName','InWin','IPAddress','KiX','LanRoot','LDomain','LDrive','LM','LongHomeDir','LServer',
'MaxPWAge','MDayNo','MonthNo','Month','MSecs','PrimaryGroup','Priv','ProductSuite','ProductType','PWAge','RAS',
'RServer','ScriptDir','SError','SID','Site','StartDir','SysLang','Ticks','Time','UserID','UserLang','WDayNo','Wksta',
'WUserID','YDayNo','Year'
$r="Syntax Check Results:"
$line=1
$=10 while open($,$file) and $ $=$-1 loop
$file=""
$c=readline($)
while @error=0 $file=$file+$c+chr(10) $c=readline($) loop
for $c=0 to len($file)
 $=substr($file,$c,1)
 if $=chr(10) $line=1+$line endif
 select
 case $='"' and 0=$s[1]
	if $s[0] $s[0]=0 else $s[0]=1 endif
 case $="'" and 0=$s[0]
	if $s[1] $s[1]=0 else $s[1]=1 endif
 case $="(" and 0=$s[1]+$s[0]
	$s[2]=$s[2]+1
 case $=")" and 0=$s[1]+$s[0]
	$s[2]=$s[2]-1
 case $="[" and 0=$s[1]+$s[0]
	$s[3]=$s[3]+1
 case $="]" and 0=$s[1]+$s[0]
	$s[3]=$s[3]-1
 case $=";" and 0=$s[1]+$s[0]
	do $c=$c+1 $=substr($file,$c,1) until $=chr(10) or @error
 case not instr($legal,$) and 0=$s[1]+$s[0]
	 $s[4]=''+$s[4]+$
 endselect
 if instr($legal,$)
  if $s[4]
	if $s[4]="breakon" or $s[4]="breakoff" $s[4]='' endif
	if $s[4]="debugon" or $s[4]="debugoff" $s[4]='' endif
	if $s[4] and '$'=$pre $s[4]='' endif
	if $s[4] and ':'=$pre $s[4]='' endif
	if $s[4]='do' $s[5]=$s[5]+1 $s[4]='' endif
	if $s[4]='until' $s[5]=$s[5]-1 $s[4]='' endif
	if $s[4]='while' $s[6]=$s[6]+1 $s[4]='' endif
	if $s[4]='loop' $s[6]=$s[6]-1 $s[4]='' endif
	if $s[4]='foreach' $s[7]=$s[7]+1 $s[4]='' endif
	if $s[4]='in' $s[7]=$s[7]+2 $s[4]='' endif
	if $s[4]='next' and $s[7]>2 $s[7]=$[7]-3 $s[4]='' endif
	if $s[4]='for' $s[8]=$s[8]+1 $s[4]='' endif
	if $s[4]='to' $s[8]=$s[8]+2 $s[4]='' endif
	if $s[4]='step' and $s[8]>2 $s[4]='' endif
	if $s[4]='next' and $s[8]>2 $s[8]=$s[8]-3 $s[4]='' endif
	if $s[4]='function'
	 if $s[9]=0 $s[9]=1 else $r=$r+"?error on line:"+$line+"-> nested functions not allowed" endif
	 $s[4]=''
	endif
	if $s[4]='endfunction'
	 if $s[9]=1 $s[9]=0 else $r=$r+"?error on line:"+$line+"-> endfunction without function" endif
	 $s[4]=''
	endif
	if $s[4]='if' $s[10]=$s[10]+1 $s[4]='' endif
	if $s[4]='else' $s[10]=$s[10]+2 $s[4]='' endif
	if $s[4]='endif'
	 if $s[10]>2 $s[10]=$s[10]-3 else $r=$r+"?error on line:"+$line+"-> endif without if" endif
	 $s[4]=''
	endif
	if $s[4]='select' $s[11]=$s[11]+1 $s[4]='' endif
	if $s[4]='case'
	 if $s[11]<1 $r=$r+"?error on line:"+$line+"-> case without select" endif
	 $s[4]=''
	endif
	if $s[4]='endselect'
	 if $s[11] $s[11]=$s[11]-1 else $r=$r+"?error on line:"+$line+"-> endselect without select" endif
	 $s[4]=''
	endif
	if $s[4]
	 for each $i in $co
	  if $i=$s[4] $s[4]='' endif
	 next
	endif
	if $s[4]
	 for each $i in $fu
	  if $i=$s[4] and $='(' $s[4]='' endif
	 next
	endif
	if $s[4]
	 for each $i in $ma
	  if '@'+$i=$s[4] $s[4]='' endif
	 next
	endif
	if $s[4] $r=$r+"?error on line:"+$line+"-> unknown command:"+$s[4] $s[4]='' endif
  endif
  $pre=$
 endif
next
$error='','','','','','do until loop','while loop','for each loop','for next loop',
'function declaration','if else endif structure','select case structure'
for $c=5 to 11
 if 0<>$s[$c]  $r=$r+"?error in "+$error[$c] endif
next
$syntax=split($r,"?")
if 0<ubound($syntax) exit 1 endif
endfunction


 
 [ 01. December 2002, 04:28: Message edited by: Lonkero ]121374Tail28BryceTail() - return the last Line or Lines of a file1111597289Code:


;Function: 
;     Tail(FILE,[LINES],[SKIP])
; 
;Author: 
;     Bryce
; 
;Version: 
;     1.2
; 
;Version history: 
;     1.0 June 16 2004 First publish
;     1.1 June 16 2004 Minor changes to better support the SKIP feature
;     1.2 JUly 14 2004 Fixed a bug when returning all fo a file, that was 
;                      causing array out of bounds on empty/overskipped files.
;
;Action: 
;     Returns the last line or lines of a given file.  With out locking the file!
; 
;Syntax: 
;     Tail(FILE,[LINES],[SKIP])
; 
;Parameters: 
;     FILE     - the Fullpath to the file
;     [LINES]  - OPTIONAL arguments to return X number of lines from the end of a file.
;                To return ALL lines use a -1
;     [SKIP]   - OPTIONAL this setting will bypass the first X amount of bytes in a file.
;                use this to speed up finding the tail on a large file.
;
;Returns: 
;     An array of data containing the last line or lines of a file.
; 
;Errors Returned: 
;     0 = Function ran with out errors
;     2 = the file was not found
; 
;Dependencies: 
;     This UDF uses the "Scripting.FileSystemObject"
;
;Remarks: 
;     Modled after the UNIX Tail command.
;
;Example: 
;	$file = "C:\Program Files\Syslogd\Logs\syslog.old"
;	for each $line in tail($file,50)
;		? $line
;	next
;
;	;a 23meg log file.
;	$tail = tail($file,10,22000000)
;
;Source: 
Function Tail($file,optional $lines, optional $skip)
	dim $fso, $f,$fs,$i,$all
	if not $lines $lines = 1 endif
	if not $skip $skip = 0 endif
	$fso = CreateObject("Scripting.FileSystemObject")
	$f = $fso.GetFile($file)
	if @error exit(2) endif
	$fs = $f.OpenAsTextStream(1)
	if $skip $fs.Skip($skip) endif
	$all = split($fs.Read($f.size-$skip),@crlf)
	if $lines = -1
		$tail = $all
		exit(0)
	endif
	dim $out[$lines]
	for $i = ubound($all)-$lines to ubound($all)
		$out[$i-(ubound($all)-$lines)] = $all[$i]
	next
	redim preserve $out[ubound($out)-1]
	$tail=$out Exit(0)
endfunction

83256TaskBar119LonkeroTaskBar() - get&set size&side v1.6.10

code:

;Function TaskBar()
;
;Author	Lonkero
;
;Version 1.6.1 (24.06.2002)
;
;Action Sets or gets taskbar height or side on desktop.
;
;Syntax TaskBar($Set, $To, $Style)
;
;Parameters
;	$Set - 0/1
;	0 - get size
;	1 - get side
;	2 - set size
;	3 - set side
;
;	$To (optional) - Integer value. used only on set.
;	Must be set when setting size or side.
;	Ignored on get.
;	Setting side: 0=left, 1=top, 2=right, 3=bottom (style ignored)
;	Size can be any value from 1 to 255
;
;	$Style (optional) -can be used only with top and bottom size values.
;	0 - pixels
;	1 - lines
;
;Remarks
; 	Nice, pure KiXsolution!
;	setting is done when explorer is restarted. so if you
;	want to set it when user is logged (not during logon process)
;	restart explorer.exe for changes to take effect.
;
;
;Returns
;	on get,taskbar height or amount of lines as integer value
;	or side values as descriped in set section.
;	on set, nothing.
;	or error (check valtype. if string, error occurred):
;	-Unsupported OS %ostype% when used with win9x
;	-Input value(s) too high!
;	-Input value(s) too low!
;
;Todo
;	not extensively tested on nt (works thou)
;
;Dependencies
;	None
;
;Examples
;	"taskbar side is " taskbar(1) ?
;	"taskbar is " taskbar(0,,1) "lines high" ?
;	$z=taskbar(3,1) if 8=valtype($z) $z else "taskbar set to top" endif
;
;
;Source
Function TaskBar($_Set, optional $_To, optional $_Style)
$_Style=0+$_Style $_Set=0+$_Set $_To=0+$_To
if 2=@inwin $TaskBar="Unsupported OS @producttype" exit 0 endif
if @dos=="4.0" $_S="StuckRects" else $_S="StuckRects2" endif
if $_Style>2 or $_Set>3 or $_To>255 $TaskBar="INPUT value(s) too high!" exit 0 endif
if $_Style<0 or $_Set<0 or $_To<0 $TaskBar="INPUT value(s) too low!" exit 0 endif
$_=readvalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\$_S","settings")
if $_Set>1
if $_Set=3 $_=substr($_,1,25)+$_To+substr($_,27) else
if 1=substr($_,26,1) or 3=substr($_,26,1)
if $_style $_=substr($_,1,40)+DECTOHEX(5+25*$_To)+substr($_,43) else $_=substr($_,1,40)+DECTOHEX($_To)+substr($_,43) endif
else $_=substr($_,1,32)+DECTOHEX($_To)+substr($_,35) endif
endif
$_z=writevalue("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\$_S","settings",$_,REG_BINARY)
else
if not $_Set $TaskBar=val("&"+substr($_,41,2)) if $_Style $TaskBar=($TaskBar-5)/25 endif else $TaskBar=0+substr($_,26,1) endif
endif
endfunction


 
 [ 24 June 2002, 14:30: Message edited by: Lonkero ]83821TaskScheduleControl2980Glenn BarnasTaskScheduleControl() - Library of UDFs to manage Windows Task Scheduler0tsControl is a library of UDFs to control the Windows Task Scheduler. It consists of initialization, 12 main functions, and a short collection of supporting functions.

Using these functions, you can add, modify, delete, copy, or query scheduled tasks running on any machine.

This posting is one of 2 parts:
 This post, simple documentation and the UDF library at the end. The code should be copied & pasted into a file. 

Another Post of sample code to test / demonstrate use of the functions.

To use this UDF library, just insert 

code:

Call tscontrol.udf

in the beginning of your script.

The sample code in the other post should be copied/pasted into a test.kix file, and the parameters specific to your system edited. When the test script is run, it will pause after each function and allow you to review the scheduled tasks folder to examine the changes. You can safely delete any of the tasks it schedules after the test is complete.

The entire package - tsControl.udf, tsAdm, test.kix (a tsControl test/demo script, install notes, the entire Microsoft JT.zip, and MS-Word docs for JT, tsControl, and tsAdm - are available in a zip file at the following location(s):
http://www.wheelerfam.com/Documents/tstools.zip - Thanks to Radimus! http://www.kixhelp.com/Downloads/tstools.zip - Thanks to NTDOC!
Enjoy!

Glenn

Theory of Operation
OVERVIEW
tsControl allows your scripts to control Windows Task Scheduler events on local or remote systems. It uses two arrays to hold the event parameters. One array holds information about the TASK - "who, what, and where" kind of information. The other array is two-dimensional, and holds TRIGGER information - the "when and how often" values. 

There are twenty TASK parameters, but many have acceptable default values. Only the name and path of the Command to execute is required, although Working Directory and Parameters might be required by your specific command, and Comment is always useful. 

The TRIGGER array consists of ten Event parameters, plus a flag to indicate that it has been loaded with user data. Again, default values are loaded for many of the values. The start time defaults to the beginning of the next hour. You must specify the Type value, and optionally the TypeArguments value, which specify when and how often to run the trigger. The TRIGGER array is initialized with 10 triggers in the second array dimension, allowing ten separate triggers (0-9) to be associated with a TASK. The number 10 was chosen arbitrarily and can be easily changed by modifying the $tsMAXTRIGGER variable in the header section.

The name of the TASK and TRIGGER arrays are defined by the user, but initialized by the tsInitTask and tsInitTrigger functions. The name of these arrays are then passed to other functions to be modified or loaded into a Task Scheduler event. By allowing the user to control the array names, multiple events can be managed simultaneously.

Of particular note is the concept of the UDF Library. By loading the single library, all required parameters are initialized, and functions loaded and registered. The Header section of the library is not a UDF - it simply defines six variables that are used by the functions, and provides a convenient place for the user to modify the two configurable parameters. If you want to permanently change these values, edit the definition in the header. If you instead want to override them, simply load the tsControl library and then redefine them. One parameter is $tsMAXTRIGGER, which defaults to 10 and controls the number of individual triggers in the TRIGGER array. The second is $tsOUTPUT, which defines where the output of the JT command is sent. By default, it is " >NUL:". You can specify a file (" >mytask.log") or simply set it to the null string ("") to display the output in the console window. This is useful only for curiosity or debugging.

PROCESS
I'll quickly describe how the library functions. You should print out the "tsTEST.KIX" script to see the details.

We start by defining two array names - TASK and TRIGGER - and initialize them with the Init functions.

code:

$myTASK = tsInitTask()
$myTRIG = tsInitTrigger()

We also need to decide on a few common parameters. We'll define $EVENT, $HOST, $USER, and $PASS to hold the event name, name of the target system, and the user and password that the task will execute under. These are defined in the test script, but in "real-life" the password should be secured in some manner, or prompted for.

Next, we need to define the task and trigger parameters specific to our event. Instead of using the long parameter names of JT.EXE, I've implemented 3 character mnemonics to represent them. My thought was that it was too easy to mis-type one of the longer names while writing code. The example below passes the TASK and TRIGGER array names to the functions that interpret the parameter list and place the values into the array. Note that the parameter strings are free-form, but must be enclosed in quotes. Also, when an "=" is required in a value, it must be "escaped" by typing it twice.

This sample runs 'kix32 myscript.kix $ARG=c:\temp' every Friday at 9pm.

code:

tsDefineTask("myTASK", 'APP=kix32.exe PRM=myscript.kix $ARG==c:\temp')
tsDefineTrigger("myTRIG", 0, 'TYP=WEEKLY ARG=1,.....F.  STM=21:00')

All that's left to do is set the account credentials and activate the event. The account credentials are associated with the TASK array. Recall that these variables were discussed earlier..

code:

tsSetCredentials("myTASK", $USER, $PASS)
tsActivateEvent($HOST, $EVENT, "myTASK", "myTRIG")

Now, after 6 quick UDF calls, the task is scheduled and ready to go! Of course, in production code you'll want to examine the @ERROR value returned by the functions and perform appropriate recovery if it doesn't work.

The other UDFs provide the means to manage existing events within the Windows Task Scheduler. 

There are two functions that return True/False values representing whether a named task or trigger exists. Two other functions will delete an event or trigger in an event. Finally, one function returns a list of task names from the scheduler, and another function loads the specified TASK and TRIGGER arrays with the data from a specified event.

Update History
3/16/03
 - Fix to tsGetTasks() - failed to return empty array - returned 1 null element instead.
5/30/03
 - Correct minor typos in commentary and header.

And now, the tsControl.udf...


;HEADER:tsControl:AÿcollectionÿofÿTaskÿSchedulerÿcontrolÿfunctions:GlennÿBarnas;
;
;LIBRARYÿ ÿ ÿ ÿ tsControl
;
;AUTHORÿ ÿ ÿ ÿ ÿGlennÿA.ÿBarnas
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ(gbarnas@yahoo.com)
;
;INSPIRATIONÿ ÿ JensÿMeyerÿ(sealeopard@usa.net)ÿ&ÿhisÿScheduleTaskÿudf
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿThanksÿtoÿseveralÿothersÿforÿtheirÿfeedbackÿandÿcomments
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿduringÿtheÿcode-wranglingÿphase.
;
;VERSIONÿ ÿ ÿ ÿ 1.2
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ1.0ÿ -ÿ Initialÿrelease
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ1.1ÿ -ÿ Addedÿ$tsMAXTRIGGERS,ÿ$tsJTEXEÿtoÿdefineÿtoolÿlocation
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿCleanedÿupÿvariableÿnaming
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ1.2ÿ -ÿ AddedÿstatusÿfieldsÿtoÿtsGetEvent()ÿ
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿAddedÿ$tsVerÿglobalÿvariableÿtoÿidentifyÿlibraryÿversion
;
;OVERVIEWÿ ÿ ÿ ÿAÿcollectionÿofÿWindowsÿTaskÿSchedulerÿcontrolÿfunctions
;
;REQUIRESÿ ÿ ÿ ÿJT.EXEÿ-ÿMicrosoftÿWin-2KÿResourceÿKitÿTool
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ(Availableÿfromÿftp://ftp.microsoft.com/reskit/win2000/jt.zip)
;
;SUMMARYÿ ÿ ÿ ÿ TASKÿ=ÿ"whatÿtoÿrun"ÿ-ÿprogramÿ&ÿparameters,ÿsecurity
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿTRIGGERÿ=ÿ"whenÿtoÿrunÿit"ÿ-ÿoneÿorÿmoreÿperÿtask
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿEVENTÿ=ÿ"taskÿandÿrelatedÿtriggers"
;
;ÿ ÿ ÿ ÿtsInitTask()ÿ ÿ ÿ ÿ ÿ ÿ InitializeÿaÿTaskÿarrayÿtoÿdefaults/nulls
;ÿ ÿ ÿ ÿtsInitTrigger()ÿ ÿ ÿ ÿ ÿInitializeÿaÿTriggerÿarrayÿtoÿdefaults/nulls
;ÿ ÿ ÿ ÿtsDefineTask()ÿ ÿ ÿ ÿ ÿ LoadÿaÿTaskÿarrayÿwithÿuserÿdata
;ÿ ÿ ÿ ÿtsDefineTrigger()ÿ ÿ ÿ ÿLoadÿaÿTriggerÿarrayÿwithÿuserÿdata
;ÿ ÿ ÿ ÿtsSetCredentials()ÿ ÿ ÿ DefineÿtheÿuserÿIDÿ/ÿpasswordÿforÿaÿtask
;ÿ ÿ ÿ ÿtsSetEventCredentials()ÿUpdateÿtheÿuserIDÿ/ÿpasswordÿofÿanÿevent
;ÿ ÿ ÿ ÿtsActivateEvent()ÿ ÿ ÿ ÿCreateÿorÿmodifyÿanÿevent
;ÿ ÿ ÿ ÿtsDeleteEvent()ÿ ÿ ÿ ÿ ÿDeleteÿanÿentireÿeventÿ(Taskÿ&ÿallÿTriggers)
;ÿ ÿ ÿ ÿtsDeleteTrigger()ÿ ÿ ÿ ÿDeleteÿaÿspecificÿtrigger
;ÿ ÿ ÿ ÿtsGetTasks()ÿ ÿ ÿ ÿ ÿ ÿ Loadÿanÿarrayÿwithÿtaskÿlistÿfromÿtarget
;ÿ ÿ ÿ ÿtsGetEvent()ÿ ÿ ÿ ÿ ÿ ÿ Loadsÿarraysÿwithÿspecificÿtaskÿ&ÿtriggerÿinfo
;ÿ ÿ ÿ ÿtsIsTask()ÿ ÿ ÿ ÿ ÿ ÿ ÿ Determinesÿifÿaÿspecificÿtaskÿexists
;ÿ ÿ ÿ ÿtsIsTrigger()ÿ ÿ ÿ ÿ ÿ ÿDeterminesÿifÿaÿspecificÿtriggerÿexists
;
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿSupportingÿFunctionsÿ-ÿusedÿinternallyÿonly
;ÿ ÿ ÿ ÿtsValidHostName()ÿ ÿ ÿ ÿInsuresÿthatÿserverÿnamesÿhaveÿleadingÿ"\\"
;ÿ ÿ ÿ ÿtsTmpFile()ÿ ÿ ÿ ÿ ÿ ÿ ÿReturnsÿaÿstringÿwithÿaÿuniqueÿtempÿfileÿname
;ÿ ÿ ÿ ÿtsSplitParms()ÿ ÿ ÿ ÿ ÿ ReturnsÿanÿarrayÿofÿMNM=valÿpairsÿfromÿaÿsingleÿstring
;======================================================================
;ÿDefineÿUDFÿvariablesÿandÿconstants
;
Globalÿ$tsTASKCODES,ÿ$tsTRIGCODES,ÿ$tsTASKPARMS,ÿ$tsTRIGPARMS
Globalÿ$tsMAXTRIGGERS,ÿ$tsOutput,ÿ$tsJTEXE,ÿ$tsVer
;
;ÿDefineÿOUTPUTÿ-ÿUseÿ""ÿtoÿsentÿJTÿoutputÿtoÿconsole,ÿ"NUL:"ÿtoÿdiscard,
;ÿorÿdefineÿaÿfilepathÿtoÿlogÿit.ÿNoteÿtheÿleadingÿspaceÿbeforeÿtheÿ">"!
$tsOUTPUTÿ=ÿ"ÿ>NUL:"
;
;ÿDefineÿtheÿpathÿtoÿtheÿJE.EXEÿcommand.ÿThisÿshouldÿbeÿsimplyÿ"jt.exe"
;ÿifÿJT.EXEÿisÿinÿtheÿsystemÿPATH.
$tsJTEXEÿ=ÿ"jt.exe"
;
;ÿDefineÿtsMAXTRIGGERSÿ-ÿhowÿmanyÿtriggersÿperÿeventÿwillÿbeÿmanaged
$tsMAXTRIGGERSÿ=ÿ10
;
;ÿENDÿOFÿUSER-DEFINEDÿVALUESÿ==========================================
;
$tsVerÿ=ÿ1.2ÿ ÿ ÿ ÿ ÿ ÿ ;ÿreleaseÿversionÿofÿthisÿlibrary
;
SRnd(@TICKS)ÿ ÿ ÿ ÿ ÿ ÿ ;ÿseedÿtheÿrandom-numberÿgeneratorÿ-ÿusedÿforÿtmpÿfiles
;
;ÿTaskÿ&ÿTriggerÿMnemonicsÿ-ÿDOÿNOTÿCHANGE!
ÿ
;ÿUsedÿbyÿtsDefineTaskÿfunctionÿ-ÿlinearÿarrayÿofÿ3-charÿmnemonics
$tsTASKCODESÿ=ÿ"APPPRMWKDCMTCTRPRIMRTIDLDSBKGBRLOSRQDWDSUSSIIKIERIRHIDITVHOE"
ÿ
;ÿUsedÿbyÿtsDefineTaskÿandÿtsActivateEventÿfunctionsÿ-ÿTASKÿparameterÿnames
$tsTASKPARMSÿ=ÿ"ApplicationName",ÿ "Parameters",ÿ "WorkingDirectory",ÿ "Comment",ÿ "Creator",ÿ "Priority",ÿ "MaxRunTime",ÿ "Idle",ÿ "DontStartIfOnBatteries",ÿ "KillIfGoingOnBatteries",ÿ "RunOnlyIfLoggedOn",ÿ "SystemRequired",ÿ "DeleteWhenDone",ÿ "Suspend",ÿ "StartOnlyIfIdle",ÿ "KillOnIdleEnd",ÿ "RestartOnIdleResume",ÿ "Hidden",ÿ "Interactive",ÿ "HaltOnError"
ÿ
;ÿUsedÿbyÿtsDefineTriggerÿfunctionÿ-ÿlinearÿarrayÿofÿ3-charÿmnemonics
$tsTRIGCODESÿ=ÿ"SDTEDTSTMDURINTHEDKADDISTYPARG"
ÿ
;ÿUsedÿbyÿtsDefineTriggerÿandÿtsActivateEventÿfunctionsÿ-ÿTRIGGERÿparameterÿnames
$tsTRIGPARMSÿ=ÿ"StartDate",ÿ"EndDate",ÿ "StartTime",ÿ "MinutesDuration",ÿ "MinutesInterval",ÿ "HasEndDate",ÿ "KillAtDuration",ÿ "Disabled",ÿ "Type",ÿ "TypeArguments"
ÿ
;ÿTheÿ"linear-arrays"ÿaboveÿcouldÿbeÿreplacedÿwithÿnormalÿarraysÿandÿuseÿASCAN
;ÿtoÿdetermineÿtheÿposition,ÿbutÿthisÿwouldÿlimitÿtheÿlibraryÿtoÿKixÿ4.20ÿandÿhigher   
;======================================================================
ÿ
ÿ
;
;======================================================================
;
;FUNCTIONÿ ÿ ÿ ÿtsInitTask([Flag])
;
;ACTIONÿ ÿ ÿ ÿ ÿInitializesÿaÿTaskÿarray
;
;SYNTAXÿ ÿ ÿ ÿ ÿ$TaskArrayÿ=ÿtsInitTask([Flag])
;
;PARAMETERSÿ ÿ ÿFlagÿ(optional)ÿ-ÿifÿset,ÿloadsÿarrayÿwithÿnullsÿinsteadÿofÿdefaults
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿThisÿisÿrecommendedÿpriorÿtoÿtheÿtsGetEventÿfunction
;
;REMARKSÿ ÿ ÿ ÿ Thisÿfunctionÿcreatesÿanÿarrayÿcontainingÿallÿ22ÿparameters
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿrequiredÿtoÿcreateÿaÿtask.ÿAnyÿparameterÿrequiringÿuser
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿdefinitionÿwillÿcontainÿ"RQ",ÿindicatingÿthatÿitÿwasÿnotÿyetÿ
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿinitializedÿbyÿtheÿuser.ÿParametersÿ0-19ÿareÿpassedÿtoÿJTÿto
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿdefineÿtheÿtask.ÿParametersÿ20ÿ&ÿ21ÿwillÿholdÿtheÿcredentials.
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿParametersÿ18ÿ&ÿ19ÿ(Interactiveÿ&ÿHaltOnError)ÿareÿinitialized
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿbutÿnotÿyetÿusedÿbyÿjt.exe.
;
;UPDATEÿ ÿ ÿ ÿ ÿEnhancedÿtoÿincludeÿ5ÿstatusÿvaluesÿ-ÿelementsÿ22-26ÿnowÿcontain
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿMostRecentRun,NextRun,StartError,ExitCode,ÿandÿStatus.ÿTheseÿfields
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿareÿinitializedÿtoÿNULL,ÿcannotÿbeÿsetÿmanuallyÿbyÿtsControlÿfunctions,
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿandÿareÿloadedÿbyÿtheÿtsGetEvent()ÿfunction.
;
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿTheÿdefaultÿvaluesÿ-ÿWorkingDirectory,ÿComment,ÿandÿMaxRunTimeÿ-
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿareÿallÿpossibleÿpointsÿofÿcustomization.
;
;RETURNSÿ ÿ ÿ ÿ Array
;
;DEPENDENCIESÿ ÿNone
;
;EXAMPLESÿ ÿ ÿ ÿ$TaskArrayÿ=ÿtsInitTask()
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿLoadsÿ$TaskArrayÿwithÿdefaultÿelements
ÿ
FunctionÿtsInitTask(OPTIONALÿ$tsNullFlag)
ÿ
ÿ Ifÿ$tsNullFlagÿ<>ÿ""
ÿ ÿ ;ÿreturnÿanÿarrayÿwithÿnullÿorÿzeroÿvalues
ÿ ÿ $tsInitTaskÿ=ÿ"","","","","","","","0ÿ 0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "",ÿ "",ÿ "",ÿ "",ÿ "",ÿ "",ÿ ""
ÿ ÿ Exitÿ0
ÿ EndIf
ÿ
ÿ ;ÿreturnÿanÿarrayÿwithÿdefaultÿvalues
ÿ $tsInitTaskÿ=ÿ"RQ",ÿ "",ÿ "%SYSTEMDRIVE%\TEMP",ÿ "CreatedÿwithÿtsTool",ÿ "@USERID",ÿ "NORMAL",ÿ "3600000",ÿ "10ÿ60",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "0",ÿ "default",ÿ "default",ÿ "",ÿ "",ÿ "",ÿ "",ÿ ""
ÿ
ÿ Exitÿ0
ÿ
EndFunction
ÿ
ÿ
;
;======================================================================
;
;FUNCTIONÿ ÿ ÿ ÿtsInitTrigger([Flag])
;
;ACTIONÿ ÿ ÿ ÿ ÿInitializesÿaÿTriggerÿarray
;
;SYNTAXÿ ÿ ÿ ÿ ÿ$RTNÿ=ÿtsInitTrigger()
;
;PARAMETERSÿ ÿ ÿFlagÿ(optional)ÿ-ÿifÿset,ÿloadsÿarrayÿwithÿnullsÿinsteadÿofÿdefaults
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿThisÿisÿneededÿpriorÿtoÿtheÿtsGetEventÿfunction
;
;REMARKSÿ ÿ ÿ ÿ Createsÿaÿ10x11ÿarrayÿwithÿdefaultÿvaluesÿforÿtriggers.
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿDefaultÿdateÿisÿtoday,ÿdefaultÿtimeÿisÿbeginningÿofÿnextÿhour
;
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿTheÿdefaultÿvaluesÿ-ÿespeciallyÿtheÿStartTimeÿ-ÿ
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿareÿallÿpossibleÿpointsÿofÿcustomization.
;
;RETURNSÿ ÿ ÿ ÿ array
;
;DEPENDENCIESÿ ÿNone
;
;EXAMPLESÿ ÿ ÿ ÿ$TriggerArrayÿ=ÿtsInitTrigger()
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿLoadsÿtheÿarrayÿ$TriggerArrayÿwithÿdefaultÿvalues
ÿ
FunctionÿtsInitTrigger(OPTIONALÿ$tsNullFlag)
ÿ
ÿ Dimÿ$fDate,ÿ$fTime,ÿ$fH,ÿ$aryfTrigger[10,11],ÿ$fKey,ÿ$fIdx
ÿ
ÿ Ifÿ$tsNullFlagÿ<>ÿ""
ÿ ÿ ;ÿReturnÿanÿarrayÿwithÿNullÿvalues
ÿ ÿ $aryfDefaultsÿ=ÿ"","","","","","","","","","","F"
ÿ
ÿ ÿ Forÿ$fIdxÿ=ÿ0ÿtoÿ($tsMAXTRIGGERSÿ-ÿ1)ÿ ÿ ÿ ÿ;ÿ10ÿTriggers,ÿ0-9
ÿ ÿ ÿ Forÿ$fKeyÿ=ÿ0ÿtoÿ10ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿ11ÿelements,ÿ0-10
ÿ ÿ ÿ ÿ $aryfTrigger[$fIdx,$fKey]ÿ=ÿ$aryfDefaults[$fKey]
ÿ ÿ ÿ Next
ÿ ÿ Next
ÿ ÿ $tsInitTriggerÿ=ÿ$aryfTrigger
ÿ ÿ Exitÿ0
ÿ EndIf
ÿ
ÿ ;ÿcreateÿaÿdefaultÿstartÿtimeÿatÿtheÿtopÿofÿtheÿnextÿhour
ÿ ;ÿfDateÿasÿmm/dd/yyyyÿ&ÿfTimeÿasÿhh:mmÿ(24-hour)
ÿ $fDateÿ=ÿ"@MONTHNO/@MDAYNO/@YEAR"
ÿ $fHÿ=ÿVal(Left("@TIME",2))ÿ+ÿ1ÿ ÿ ÿ ÿ ;ÿgetÿnextÿhour
ÿ
ÿ Ifÿ$fHÿ=ÿ24ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿaccountÿforÿmidnight
ÿ ÿ $fHÿ=ÿ0
ÿ EndIf
ÿ
ÿ Ifÿ$fHÿ<ÿ10ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿPadÿwithÿzero
ÿ ÿ $fHÿ=ÿ"0"ÿ+ÿ$fH
ÿ EndIf
ÿ
ÿ $fTimeÿ=ÿCStr($fH)ÿ+ÿ":00"ÿ ÿ ÿ ÿ ÿ ÿ ;ÿconvertÿtoÿtimeÿformat
ÿ
ÿ ;ÿcreateÿaÿtempÿarrayÿwithÿtheÿ10ÿdefaultÿvalues,ÿplusÿaÿ"configured"ÿflag
ÿ $aryfDefaultsÿ=ÿ"$fDate","","$fTime","0","0","0","0","0","RQ","RQ","F"
ÿ
ÿ ;ÿLoadÿtheÿtempÿarrayÿintoÿeachÿindexÿofÿaÿ10x10ÿarray
ÿ Forÿ$fIdxÿ=ÿ0ÿtoÿ9
ÿ ÿ Forÿ$fKeyÿ=ÿ0ÿtoÿ10
ÿ ÿ ÿ $aryfTrigger[$fIdx,$fKey]ÿ=ÿ$aryfDefaults[$fKey]
ÿ ÿ Next
ÿ Next
ÿ
ÿ $tsInitTriggerÿ=ÿ$aryfTrigger
ÿ
ÿ Exitÿ0
ÿ
EndFunction
ÿ
ÿ
;
;======================================================================
;
;FUNCTIONÿ ÿ ÿ ÿtsDefineTask(TaskAry,ÿTaskParms)
;
;ACTIONÿ ÿ ÿ ÿ ÿLoadsÿtheÿspecifiedÿarrayÿwithÿtheÿtaskÿparameterÿpairs.
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿTheÿparameterÿpairsÿconsistÿofÿaÿ3-characterÿmnemonic,ÿ"=",
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿandÿaÿvalue.ÿMnemonicsÿrepresentÿtheÿ20ÿJTÿparameterÿnames,
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿandÿareÿidentifiedÿinÿtheÿtableÿbelow.
;
;SYNTAXÿ ÿ ÿ ÿ ÿtsDefineTask("TaskAry",ÿTaskParm=val,...)
;
;PARAMETERSÿ ÿ ÿUsrAryÿ ÿ-ÿNameÿofÿtaskÿarrayÿtoÿpopulateÿ(asÿstring,ÿw/oÿ"$")
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿTaskParmÿ-ÿListÿofÿmnemonic=ValueÿParameterÿpairs,ÿcomma-delimited
;
;ÿ ÿ ÿ ÿ ÿ ÿ Mnemonicÿ ParameterÿNameÿ ÿ ÿ ÿ ÿ ÿDataÿType
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿAPPÿ:ÿApplicationNameÿ ÿ ÿ ÿ ÿ ÿStringÿ-ÿcommandÿtoÿrun
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿPRMÿ:ÿParametersÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ Stringÿ-ÿappÿparameters
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿWKDÿ:ÿWorkingDirectoryÿ ÿ ÿ ÿ ÿ Stringÿ
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿCMTÿ:ÿCommentÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿString
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿCTRÿ:ÿCreatorÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿString
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿPRIÿ:ÿPriorityÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ STring:ÿIDLE,ÿNORMAL,ÿHIGH,ÿREALTIME
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿMRTÿ:ÿMaxRunTimeÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ Integerÿ(ms)
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿIDLÿ:ÿIdleÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ Integerÿ#ÿ#ÿ(waitÿ&ÿdeadlineÿmin)
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿDSBÿ:ÿDontStartIfOnBatteriesÿ ÿ Boolean
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿKGBÿ:ÿKillIfGoingOnBatteriesÿ ÿ Boolean
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿRLOÿ:ÿRunOnlyIfLoggedOnÿ ÿ ÿ ÿ ÿBoolean
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿSRQÿ:ÿSystemRequiredÿ ÿ ÿ ÿ ÿ ÿ Boolean
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿDWDÿ:ÿDeleteWhenDoneÿ ÿ ÿ ÿ ÿ ÿ Boolean
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿSUSÿ:ÿSuspendÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿBoolean
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿSIIÿ:ÿStartOnlyIfIdleÿ ÿ ÿ ÿ ÿ ÿBoolean
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿKIEÿ:ÿKillOnIdleEndÿ ÿ ÿ ÿ ÿ ÿ ÿBoolean
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿRIRÿ:ÿRestartOnIdleResumeÿ ÿ ÿ ÿBoolean
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿHIDÿ:ÿHiddenÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ Boolean
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿITVÿ:ÿInteractiveÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿBooleanÿ(currentlyÿunsupportedÿbyÿJT)
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿHOEÿ:ÿHaltOnErrorÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿBooleanÿ(currentlyÿunsupportedÿbyÿJT)
;
;REMARKSÿ ÿ ÿ ÿ Thisÿfunctionÿparsesÿtheÿparameter=valueÿpairsÿandÿloadsÿtheÿ
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿvalueÿintoÿtheÿcorrectÿarrayÿposition.ÿParameterÿpairsÿareÿseparated
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿbyÿwhitespace.ÿAnyÿcharacterÿisÿpermittedÿinÿtheÿvalueÿportion,ÿbut
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿequalÿsignsÿ(=)ÿmustÿbeÿescapedÿasÿ"==".
;
;RETURNSÿ ÿ ÿ ÿ nothingÿ-ÿsetsÿ@ERROR
;
;DEPENDENCIESÿ ÿnone
;
;EXAMPLEÿ ÿ ÿ ÿ tsDefineTask("MyTaskArray",ÿ'APP=kix32.exeÿPRM=$arg==3ÿWKD=C:\TEMP')
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ"MyTaskArray"ÿisÿtheÿnameÿofÿtheÿarrayÿthatÿwillÿbeÿloaded
;
FunctionÿtsDefineTask($tsTaskAryName,ÿ$tsTaskParmArgs)
ÿ
ÿ Dimÿ$fParm,ÿ$fCode,ÿ$fCidx,ÿ$fPVal,ÿ$fValid
ÿ
ÿ ;ÿconvertÿtheÿnameÿofÿtheÿuserÿarrayÿtoÿaÿlocalÿcopy
ÿ $RCÿ=ÿExecute('$$TmpTsk="$$"+$$tsTaskAryName')
ÿ $RCÿ=ÿExecute('$$RTNÿ=ÿIsDeclared($TmpTsk)')
ÿ Ifÿ$RTNÿ=ÿ0
ÿ ÿ "TASK:ÿArrayÿnameÿundefined!"ÿ?
ÿ ÿ Exitÿ87ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿfailÿifÿnotÿdefined!
ÿ EndIf
ÿ $RCÿ=ÿExecute('$$tsTaskAry=$TmpTsk')
ÿ
ÿ ;ÿIsolateÿtheÿparameterÿpairs
ÿ $aryfTaskParmsÿ=ÿtsSplitParms($tsTaskParmArgs)
ÿ ForÿEachÿ$fParmÿinÿ$aryfTaskParms
ÿ ÿ $fParmÿ=ÿTrim($fParm)ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿremoveÿleading/trailingÿspaces
ÿ ÿ $fCodeÿ=ÿLeft($fParm,3)ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿgetÿtheÿmnemonicÿpart
ÿ ÿ $fCIdxÿ=ÿInStr($tsTASKCODES,ÿ$fCode)-1ÿ ÿ ÿ ;ÿfindÿtheÿposition,ÿzero-based
ÿ ÿ $fValidÿ=ÿ$fCIdxÿModÿ3ÿ
ÿ ÿ Ifÿ$fValidÿ=ÿ0ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ;ÿgotÿvalidÿmnemonic
ÿ ÿ ÿ $fCIdxÿ=ÿ$fCIdxÿ/ÿ3ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿconvertÿtoÿarrayÿindex
ÿ ÿ ÿ $fPValÿ=ÿSubStr($fParm,ÿ5,ÿ99)ÿ ÿ ;ÿgetÿtheÿvalueÿpart
ÿ ÿ ÿ $tsTaskAry[$fCIdx]ÿ=ÿ$fPValÿ ÿ ÿ ÿ;ÿstuffÿvalueÿintoÿarray
ÿ ÿ Else
ÿ ÿ ÿ "InvalidÿTASKÿmnemonic!"ÿ?
ÿ ÿ ÿ Exitÿ87ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿinvalidÿmnemonic
ÿ ÿ EndIf
ÿ Next
ÿ
ÿ ;ÿcopyÿlocalÿarrayÿvarÿbackÿtoÿtheÿoriginal
ÿ $RCÿ=ÿExecute('$TmpTsk=$$tsTaskAry')
ÿ
ÿ Exitÿ0
ÿ
EndFunction
ÿ
ÿ
;
;======================================================================
;
;FUNCTIONÿ ÿ ÿ ÿtsDefineTrigger(UsrAry,ÿTrigId,ÿTrigParm)
;
;ACTIONÿ ÿ ÿ ÿ ÿLoadsÿtheÿspecifiedÿarrayÿwithÿtheÿtriggerÿparameters.ÿTrigIDÿ
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿspecifiesÿoneÿofÿtheÿ10ÿ(0-9)ÿtriggersÿinÿtheÿarray.ÿTheÿ
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿparameterÿmnemonicsÿareÿdefinedÿinÿtheÿtableÿbelow.
;
;SYNTAXÿ ÿ ÿ ÿ ÿtsDefineTrigger(UsrAry,ÿTrigId,ÿTrigParm=value,...)
;
;PARAMETERSÿ ÿ ÿUsrAryÿ ÿ-ÿNameÿofÿtriggerÿarrayÿtoÿpopulateÿ(asÿstring,ÿw/oÿ"$")
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿTrigIdÿ ÿ-ÿIdÿ(index)ÿofÿtheÿtrigger
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿTrigParmÿ-ÿListÿofÿmnemonic=ValueÿParameterÿpairs,ÿcomma-delimited
;
;ÿ ÿ ÿ ÿ ÿ ÿ Mnemonicÿ ParameterÿNameÿ ÿ ÿ ÿ ÿ ÿDataÿType
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿSDTÿ:ÿStartDateÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿDate
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿEDTÿ:ÿEndDateÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿDate
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿSTMÿ:ÿStartTimeÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿTime
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿDURÿ:ÿMinutesDurationÿ ÿ ÿ ÿ ÿ ÿIntegerÿ(minutes)
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿINTÿ:ÿMinutesIntervalÿ ÿ ÿ ÿ ÿ ÿIntegerÿ(minutes)
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿHEDÿ:ÿHasEndDateÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ Boolean
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿKADÿ:ÿKillAtDurationÿ ÿ ÿ ÿ ÿ ÿ Boolean
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿDISÿ:ÿDisabledÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ Boolean
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿTYPÿ:ÿTypeÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ String:ÿDAILY,WEEKLY,ONCE...
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿARGÿ:ÿTypeArgumentsÿ ÿ ÿ ÿ ÿ ÿ ÿVarious,ÿdependsÿonÿTYPE
;
;REMARKSÿ ÿ ÿ ÿ Thisÿfunctionÿparsesÿtheÿparameter=valueÿpairsÿand
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿloadsÿtheÿvalueÿintoÿtheÿcorrectÿarrayÿposition
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿToÿloadÿtheÿ$aryMyTriggerÿarray,ÿUsrAryÿmustÿbeÿ"aryMyTrigger",
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿwhichÿisÿtheÿnameÿofÿtheÿarray,ÿnotÿtheÿarrayÿitself.ÿAnyÿcharacter
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿisÿpermittedÿinÿtheÿvalueÿportion,ÿbutÿequalÿsignsÿ(=)ÿmustÿbe
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿescapedÿasÿ"==".
;
;RETURNSÿ ÿ ÿ ÿ Nothingÿ-ÿsetsÿ@ERROR
;
;DEPENDENCIESÿ ÿnone
;
;EXAMPLEÿ ÿ ÿ ÿ tsDefineTrigger("MyTriggerArray",ÿ3,ÿ'STM=21:45ÿTYP=WEEKLYÿARG=1,.M.....')
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿDefinesÿtriggerÿ#3ÿtoÿrunÿeveryÿMondayÿatÿ9:45pm
;
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ"MyTaskArray"ÿisÿtheÿnameÿofÿtheÿarrayÿthatÿwillÿbeÿloaded,ÿwithoutÿanyÿ"$"
;
FunctionÿtsDefineTrigger($tsTrigAryName,ÿ$tsTrigId,ÿ$tsTrigParmArgs)
ÿ
ÿ Dimÿ$fParm,ÿ$fCode,ÿ$fCidx,ÿ$fPVal,ÿ$fValid
ÿ
ÿ ;ÿconvertÿtheÿnameÿofÿtheÿuserÿarrayÿtoÿaÿlocalÿcopy
ÿ $RCÿ=ÿExecute('$$TmpTrg="$$"+$$tsTrigAryName')
ÿ $RCÿ=ÿExecute('$$RTNÿ=ÿIsDeclared($TmpTrg)')
ÿ Ifÿ$RTNÿ=ÿ0
ÿ ÿ "TRIGGER:ÿArrayÿnameÿundefined!"ÿ?
ÿ ÿ Exitÿ87ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿfailÿifÿnotÿdefined!
ÿ EndIf
ÿ $RCÿ=ÿExecute('$$tsTrigAry=$TmpTrg')
ÿ
ÿ ;ÿIsolateÿtheÿparameterÿpairsÿ-ÿMnemonic=Valueÿ-ÿfromÿtheÿargumentÿlist
ÿ $aryTrigParmsÿ=ÿtsSplitParms($tsTrigParmArgs)
ÿ
ÿ ForÿEachÿ$fParmÿinÿ$aryTrigParms
ÿ ÿ $fParmÿ=ÿTrim($fParm)ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿremoveÿanyÿleading/trailingÿspaces
ÿ ÿ $fCodeÿ=ÿLeft($fParm,3)ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿgetÿtheÿmnemonicÿpart
ÿ ÿ $fCIdxÿ=ÿInStr($tsTRIGCODES,ÿ$fCode)-1ÿ ÿ ÿ ;ÿfindÿtheÿposition,ÿzero-based
ÿ ÿ $fValidÿ=ÿ$fCIdxÿModÿ3ÿ
ÿ ÿ Ifÿ$fValidÿ=ÿ0ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ;ÿgotÿaÿvalidÿmnemonicÿifÿremainderÿisÿ0
ÿ ÿ ÿ $fCIdxÿ=ÿ$fCIdxÿ/ÿ3ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿconvertÿtoÿarrayÿindex
ÿ ÿ ÿ $fPValÿ=ÿSubStr($fParm,ÿ5,ÿ99)ÿ ÿ ;ÿgetÿtheÿvalueÿpart
ÿ ÿ ÿ $tsTrigAry[$tsTrigId,$fCIdx]ÿ=ÿ$fPValÿ ÿ ÿ;ÿstuffÿvalueÿintoÿtheÿarray
ÿ ÿ Else
ÿ ÿ ÿ "InvalidÿTRIGGERÿmnemonic!"ÿ?
ÿ ÿ ÿ Exitÿ87ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿinvalidÿmnemonicÿ-ÿreturnÿwithÿerror
ÿ ÿ EndIf
ÿ Next
ÿ
ÿ $tsTrigAry[$tsTrigId,10]ÿ=ÿ"T"ÿ ÿ ÿ ÿ ;ÿsetÿflagÿtoÿshowÿthisÿtriggerÿisÿ"configured"ÿ
ÿ
ÿ ;ÿCertainÿTriggerÿtypesÿdoÿnotÿrequireÿtheÿTypeArgumentsÿvalueÿtoÿbeÿset.ÿThe
ÿ ;ÿ"RQ"ÿflagÿinÿelementÿ9ÿisÿremovedÿautomaticallyÿforÿthose...
ÿ IfÿInStr("ONCE,ONIDLE,ATSTARTUP,ATLOGON",ÿ$tsTrigAry[$tsTrigId,8])ÿ<>ÿ0
ÿ ÿ $tsTrigAry[$tsTrigId,9]ÿ=ÿ""ÿ ÿ ÿ ÿ ;ÿremoveÿReQuiredÿflagÿforÿtheseÿTypes
ÿ EndIf
ÿ
ÿ ;ÿcopyÿlocalÿvarÿbackÿtoÿoriginal
ÿ $RCÿ=ÿExecute('$TmpTrg=$$tsTrigAry')
ÿ
ÿ Exitÿ0
ÿ
EndFunction
ÿ
ÿ
;
;======================================================================
;
;FUNCTIONÿ ÿ ÿ ÿtsSetCredentials(TaskAry,ÿUserID,ÿ[Password])
;
;ACTIONÿ ÿ ÿ ÿ ÿLoadsÿtheÿspecifiedÿarrayÿwithÿtheÿcredentialsÿunder
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿwhichÿtheÿtaskÿwillÿrun.
;
;SYNTAXÿ ÿ ÿ ÿ ÿ$Resultÿ=ÿtsDefineTask("TaskAry",ÿ"UserName",ÿ["Password"])
;
;PARAMETERSÿ ÿ ÿUsrAryÿ ÿ-ÿNameÿofÿtaskÿarrayÿtoÿpopulateÿ(asÿstring,ÿw/oÿ"$")
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿUserIDÿ ÿ-ÿUserÿNameÿtoÿrunÿtheÿtaskÿunder
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿPasswordÿ-ÿPasswordÿforÿtheÿaboveÿaccount
;
;REMARKSÿ ÿ ÿ ÿ Thisÿfunctionÿloadsÿtheÿnamedÿarrayÿwithÿtheÿuserÿcredentials.
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿItÿwillÿreturnÿanÿerrorÿifÿtheÿspecifiedÿarrayÿisÿundefined.
;
;RETURNSÿ ÿ ÿ ÿ Nothing
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿMightÿconfirmÿvalidÿUserIDÿandÿreturnÿ@ERRORÿinÿfutureÿrelease
;
;DEPENDENCIESÿ ÿnone
;
;EXAMPLESÿ ÿ ÿ ÿtsSetCredentials("MyTaskArray",ÿ"my_account",ÿ"my_password")
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿaddsÿtheÿcredentialsÿtoÿtheÿTaskÿarray
;
FunctionÿtsSetCredentials($tsTaskAryName,ÿ$tsUID,ÿOPTIONALÿ$tsPWD)
ÿ
ÿ ;ÿconvertÿtheÿnameÿofÿtheÿuserÿarrayÿtoÿaÿlocalÿcopy
ÿ $RCÿ=ÿExecute('$$TmpTsk="$$"+$$tsTaskAryName')
ÿ $RCÿ=ÿExecute('$$RTNÿ=ÿIsDeclared($TmpTsk)')
ÿ Ifÿ$RTNÿ=ÿ0
ÿ ÿ "UndefinedÿTASKÿarrayÿname!"ÿ?
ÿ ÿ Exitÿ87ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿfailÿifÿnotÿdefined!
ÿ EndIf
ÿ $RCÿ=ÿExecute('$$tsTaskAry=$TmpTsk')
ÿ
ÿ $tsTaskAry[20]ÿ=ÿ$tsUIDÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿDefineÿUser
ÿ $tsTaskAry[21]ÿ=ÿ$tsPWDÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿDefineÿPassword
ÿ
ÿ ;ÿcopyÿlocalÿvarÿbackÿtoÿoriginal
ÿ $RCÿ=ÿExecute('$TmpTsk=$$tsTaskAry')
ÿ
ÿ Exitÿ0
ÿ
EndFunction
ÿ
ÿ
;
;======================================================================
;
;FUNCTIONÿ ÿ ÿ ÿtsSetEventCredentials(Host,ÿTaskName,ÿUserID,ÿPassword)
;
;ACTIONÿ ÿ ÿ ÿ ÿLoadsÿtheÿspecifiedÿarrayÿwithÿtheÿcredentialsÿunder
;ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿwhichÿtheÿtaskÿwillÿrun.
;
;SYNTAXÿ ÿ ÿ ÿ ÿ$Resultÿ=ÿtsDefineTask(Host,ÿTaskName,ÿUserName,ÿPassword)
;
;PARAMETERSÿ ÿ ÿHostÿ ÿ ÿ-ÿNameÿofÿtheÿtargetÿhost
;ÿ ÿ ÿ ÿ &n83812TaskScheduleControl2980Glenn BarnasTaskScheduleControl() - sample script to test/exercist the tsControl() library0This is a sample program to exercise the task scheduler function library. It checks for and deletes the test event, then defines and creates a new "Test 1" event. Next, it modifies it. After finishing with "Test 1", it enumerates the names of all the tasks and displays them. To complete "Test 1" functions, it enumerates the parameters from the Task Scheduler, copies them into arrays, and creates a copy called "New Test".

The last set of tests creates a new job with one of every type of trigger, just to demonstrate how triggers are manipulated.

I suggest that you open Explorer to the Task Scheduler and watch the action. You can examine the tasks that are created and see what changes, as the test script waits for you to press a key after each action.

Finally - this is test/demo code - its output isn't meant to be pretty!         


;======================================================================
;ÿSTARTÿTESTÿCODE
;======================================================================
BreakÿON
ÿ
;ÿLoadÿtheÿfunctionÿLibrary
ÿ
;ÿMODIFYÿTHISÿTOÿDEFINEÿTHEÿCORRECTÿPATHÿ/ÿLIBRARYÿNAME!!!
CallÿtsControl.udf
ÿ
ÿ
ÿ
;ÿInitializeÿsomeÿvarsÿusedÿthroughoutÿtheÿtestÿscript
ÿ
ÿ
;ÿMODIFYÿTHISÿTOÿSUITÿYOURÿENVIRONMENT!!!
;ÿdefineÿsomeÿconstants
$TASKÿ=ÿ"Testÿ1"ÿ ÿ ÿ ÿ ;ÿtestÿtaskÿname
ÿ
$HOSTÿ=ÿ"wizard"ÿ ÿ ÿ ÿ ;ÿtargetÿhostnameÿ 
ÿ
$USERÿ=ÿ"EMERALDCITY\test"
$PASSÿ=ÿ"password"
ÿ
ÿ
ÿ
;ÿCheckÿtheÿtsIsTask,ÿtsIsTrigger,ÿtsDeleteTrigger,ÿ&
;ÿtsDeleteEventÿfunctions
;============================================================
"Checkingÿtoÿseeÿifÿ$TASKÿisÿalreadyÿdefined:"ÿ?
IfÿtsIsTask($HOST,ÿ$TASK)
ÿ "Theÿtaskÿ'$TASK'ÿexists"ÿ?
ÿ
ÿ ;ÿnowÿcheckÿforÿtriggersÿ2,ÿ1,ÿ&ÿ0,ÿdeleteÿthemÿifÿfound
ÿ
ÿ Forÿ$TRIGÿ=ÿ2ÿtoÿ0ÿStepÿ-1
ÿ ÿ IfÿtsIsTrigger($HOST,ÿ$TASK,ÿ$TRIG)
ÿ ÿ ÿ "Triggerÿ"ÿ+ÿ$TRIGÿ+ÿ"ÿexistsÿ-ÿDeleting:ÿ "
ÿ ÿ ÿ tsDeleteTrigger($HOST,ÿ$TASK,ÿ$TRIG)
ÿ ÿ ÿ Ifÿ@ERRORÿ=ÿ0
ÿ ÿ ÿ ÿ "Succesful!"ÿ?
ÿ ÿ ÿ Else
ÿ ÿ ÿ ÿ "Failed!"ÿ?
ÿ ÿ ÿ EndIf
ÿ ÿ Else
ÿ ÿ ÿ "Triggerÿ"ÿ+ÿ$TRIGÿ+ÿ"ÿwasÿnotÿfound."ÿ?
ÿ ÿ EndIf
ÿ Next
ÿ tsDeleteEvent($HOST,ÿ$TASK)
ÿ Ifÿ@ERROR
ÿ ÿ "Failedÿtoÿremoveÿtaskÿ'$TASK'"ÿ?
ÿ Else
ÿ ÿ "Removedÿtaskÿ'$TASK'"ÿ?
ÿ EndIf
Else
ÿ "Task:ÿ$TASKÿdoesÿnotÿexist"ÿ?
EndIf
ÿ
ÿ
ÿ
?ÿ"Enterÿtoÿcontinue:ÿ"
Beep
Getÿ$X
Ifÿ$Xÿ=ÿ"Q"
ÿ Exit
EndIf
?ÿ?
ÿ
ÿ


;ÿInitializeÿaÿTaskÿandÿTriggerÿarray,ÿprintÿsomeÿvaluesÿtoÿconfirmÿthatÿ
;ÿtheyÿareÿsetÿtoÿdefaults
"InitializingÿtheÿTaskÿ&ÿTriggerÿarrays:"ÿ?
$aryTaskÿ=ÿtsInitTask()
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsInitTaskÿFailed!"ÿ?
EndIf
ÿ
$aryTriggerÿ=ÿtsInitTrigger()
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsInitTriggerÿFailed!"ÿ?
EndIf
ÿ
"ÿ0="ÿ+ÿ$aryTask[0]ÿ?
"ÿ1="ÿ+ÿ$aryTask[1]ÿ?
"ÿ2="ÿ+ÿ$aryTask[2]ÿ?
"ÿ3="ÿ+ÿ$aryTask[3]ÿ?
"ÿ4="ÿ+ÿ$aryTask[4]ÿ?
"20="ÿ+ÿ$aryTask[20]ÿ?ÿ ÿ ;ÿtheseÿareÿtheÿUIDÿ/ÿPWDÿvalues
"21="ÿ+ÿ$aryTask[21]ÿ?
?
"ÿ0="ÿ+ÿ$aryTrigger[0,0]ÿ?
"ÿ1="ÿ+ÿ$aryTrigger[0,1]ÿ?
"ÿ2="ÿ+ÿ$aryTrigger[0,2]ÿ?
"ÿ8="ÿ+ÿ$aryTrigger[0,8]ÿ?
"ÿ9="ÿ+ÿ$aryTrigger[0,9]ÿ?
"10="ÿ+ÿ$aryTrigger[0,10]ÿ?
?
ÿ
ÿ

?ÿ"Enterÿtoÿcontinue:ÿ"
Beep
Getÿ$X
Ifÿ$Xÿ=ÿ"Q"
ÿ Exit
EndIf
?ÿ?

ÿ
ÿ

;ÿDefineTaskÿ&ÿDefineTriggerÿpassÿtheÿnameÿofÿtheÿuser-definedÿarrays
;ÿcreatedÿbyÿtheÿInitTaskÿandÿInitTriggerÿfunctions.
ÿ
;ÿTestÿtheÿDefineTaskÿfunctionÿ-ÿ defineÿparametersÿinÿrandomÿorder,
;ÿwithÿ&ÿwithoutÿspacesÿbetweenÿargs,ÿwithÿquotesÿandÿwithout.
;ÿRuleÿofÿthumbÿ-ÿifÿvalueÿcontainsÿspaces,ÿencloseÿitÿinÿdouble-quotes.ÿ
;ÿTheÿtsActivateEventÿwillÿautomaticallyÿaddÿdouble-quotesÿtoÿanyÿstringÿarg
;ÿthatÿisn'tÿalreadyÿenclosedÿinÿquotes.
ÿ
"CallingÿtsDefineTaskÿandÿtsDefineTriggerÿtoÿsetÿvaluesÿintoÿtheÿarrays"ÿ?
tsDefineTask("aryTask",ÿ'APP=c:\temp\testÿ2.batÿWKD=C:\tempÿ CMT="Myÿcommentÿline"')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTaskÿFailed!"ÿ?
EndIf
tsDefineTrigger("aryTrigger",ÿ0,ÿ'TYP=DAILYÿARG=1ÿ STM=9:00')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTriggerÿFailed!"ÿ?
EndIf
tsDefineTrigger("aryTrigger",ÿ1,ÿ'TYP=DAILYÿARG=1ÿ STM=21:00')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTriggerÿFailed!"ÿ?
EndIf
"ÿ0="ÿ+ÿ$aryTask[0]ÿ?
"ÿ1="ÿ+ÿ$aryTask[1]ÿ?
"ÿ2="ÿ+ÿ$aryTask[2]ÿ?
"ÿ3="ÿ+ÿ$aryTask[3]ÿ?
"ÿ4="ÿ+ÿ$aryTask[4]ÿ?
"20="ÿ+ÿ$aryTask[20]ÿ?ÿ ÿ ;ÿtheseÿareÿtheÿUIDÿ/ÿPWDÿvalues
"21="ÿ+ÿ$aryTask[21]ÿ?
?
"ÿ0="ÿ+ÿ$aryTrigger[0,0]ÿ?
"ÿ1="ÿ+ÿ$aryTrigger[0,1]ÿ?
"ÿ2="ÿ+ÿ$aryTrigger[0,2]ÿ?
"ÿ8="ÿ+ÿ$aryTrigger[0,8]ÿ?
"ÿ9="ÿ+ÿ$aryTrigger[0,9]ÿ?
"10="ÿ+ÿ$aryTrigger[0,10]ÿ?
?
"ÿ0="ÿ+ÿ$aryTrigger[1,0]ÿ?
"ÿ1="ÿ+ÿ$aryTrigger[1,1]ÿ?
"ÿ2="ÿ+ÿ$aryTrigger[1,2]ÿ?
"ÿ8="ÿ+ÿ$aryTrigger[1,8]ÿ?
"ÿ9="ÿ+ÿ$aryTrigger[1,9]ÿ?
"10="ÿ+ÿ$aryTrigger[1,10]ÿ?
?
ÿ
ÿ

?ÿ"Enterÿtoÿcontinue:ÿ"
Beep
Getÿ$X
Ifÿ$Xÿ=ÿ"Q"
ÿ Exit
EndIf
?ÿ?
ÿ
ÿ
;ÿTestÿtheÿSetCredentialsÿfunction
;ÿCredentialsÿareÿsetÿinÿaÿspecificÿtaskÿarray
"SettingÿCredentials"ÿ?
tsSetCredentials("aryTask",ÿ$USER,ÿ$PASS)
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsSetCredentialsÿFailed!"ÿ?
EndIf
"20="ÿ+ÿ$aryTask[20]ÿ?
"21="ÿ+ÿ$aryTask[21]ÿ?ÿ
?
ÿ
ÿ

?ÿ"Enterÿtoÿcontinue:ÿ"
Beep
Getÿ$X
Ifÿ$Xÿ=ÿ"Q"
ÿ Exit
EndIf
?ÿ?
ÿ
ÿ
;ÿTestÿtheÿActivateEventÿfunctionÿ-ÿthisÿwillÿeitherÿcreateÿaÿnewÿtaskÿ&ÿsetÿofÿtr iggers,ÿor
;ÿeditÿanÿexistingÿtaskÿ&ÿtriggerÿset.ÿLogicÿallowsÿanÿexistingÿTaskÿtoÿbeÿedited,ÿ ;and
;ÿtheÿassociatedÿTriggersÿtoÿbeÿfreelyÿaddedÿorÿedited
?ÿ"CallingÿtsActivateEvent"ÿ?
tsActivateEvent($HOST,ÿ$TASK,ÿ"aryTask",ÿ"aryTrigger")
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsActivateEventÿFailed!ÿ<@ERRORÿ:ÿ@SERROR>"ÿ?
Else
ÿ "$TASKÿwasÿactivated!"ÿ?
EndIf
ÿ
ÿ

?ÿ"Enterÿtoÿcontinue:ÿ"
Beep
Getÿ$X
Ifÿ$Xÿ=ÿ"Q"
ÿ Exit
EndIf
?ÿ?
ÿ
ÿ
;ÿChangeÿsomeÿofÿtheÿtask/triggerÿparametersÿandÿre-callÿtheÿActivateEventÿfunctionÿ-ÿtheÿ
;ÿfunctionÿshouldÿdetectÿthatÿtheÿtaskÿexistsÿandÿeditÿit.
ÿ
;ÿTriggerÿ1ÿmovedÿtoÿ9:30ÿpm,ÿdifferentÿapp,ÿworkindÿdir,ÿandÿcomment.
"RedefiningÿparametersÿinÿtheÿaryTaskÿandÿAryTriggerÿarrays"ÿ?
"byÿcallingÿtheÿtsDefineTriggerÿandÿtsDefineTaskÿfunctions."ÿ?
tsDefineTrigger("aryTrigger",ÿ1,ÿ'STM=21:30')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTriggerÿFailed!ÿ<@ERRORÿ:ÿ@SERROR>"ÿ?
EndIf
tsDefineTask("aryTask",ÿ'APP=c:\temp\test2.batÿ WKD=D:\tempÿ CMT="Differentÿcomment"')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTriggerÿFailed!ÿ<@ERRORÿ:ÿ@SERROR>"ÿ?
EndIf
?ÿ"CallingÿtsActivateEventÿtoÿenableÿtheÿchanges."ÿ?
tsActivateEvent($HOST,ÿ$TASK,ÿ"aryTask",ÿ"aryTrigger")
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsActivateEventÿFailed!ÿ<@ERRORÿ:ÿ@SERROR>"ÿ?
Else
ÿ "$TASKÿwasÿmodified!"ÿ?
EndIf
ÿ
ÿ

?ÿ"Enterÿtoÿcontinue:ÿ"
Beep
Getÿ$X
Ifÿ$Xÿ=ÿ"Q"
ÿ Exit
EndIf
?ÿ?
ÿ
ÿ

;ÿGetÿaÿlistÿofÿtasksÿonÿtheÿmachine
;ÿFirstÿcreateÿanÿemptyÿarrayÿtoÿreceiveÿtheÿconfiguration.ÿCallingÿtheÿtsInitT???ÿ
;ÿfunctionsÿwithÿanyÿnon-nullÿparameterÿwillÿinitializeÿtheÿarraysÿwithÿnullsÿinstead
;ÿofÿdefaultÿvalues.
;
"Preparingÿtoÿloadÿtheÿexistingÿtasks..."ÿ?
"InitializingÿTASKÿarrayÿ-ÿAllÿshouldÿbeÿclear"ÿ?
$aryTaskÿ=ÿtsInitTask(1)
"InitializingÿTRIGGERÿarrayÿ-ÿAllÿshouldÿbeÿclearÿexceptÿ@CRLF'F'ÿinÿlastÿelement"ÿ?
$aryTriggerÿ=ÿtsInitTrigger(1)
"ÿ0="ÿ+ÿ$aryTask[0]ÿ?
"ÿ1="ÿ+ÿ$aryTask[1]ÿ?
"ÿ2="ÿ+ÿ$aryTask[2]ÿ?
"ÿ3="ÿ+ÿ$aryTask[3]ÿ?
"ÿ4="ÿ+ÿ$aryTask[4]ÿ?
"20="ÿ+ÿ$aryTask[20]ÿ?ÿ ÿ ;ÿtheseÿareÿtheÿUIDÿ/ÿPWDÿvalues
"21="ÿ+ÿ$aryTask[21]ÿ?
?
"ÿ0="ÿ+ÿ$aryTrigger[0,0]ÿ?
"ÿ1="ÿ+ÿ$aryTrigger[0,1]ÿ?
"ÿ2="ÿ+ÿ$aryTrigger[0,2]ÿ?
"ÿ8="ÿ+ÿ$aryTrigger[0,8]ÿ?
"ÿ9="ÿ+ÿ$aryTrigger[0,9]ÿ?
"10="ÿ+ÿ$aryTrigger[0,10]ÿ?
ÿ
"TestingÿtsGetTasksÿfunction"ÿ?
$EVENTSÿ=ÿtsGetTasks($HOST)
ÿ
;ÿshowÿtheÿcontentsÿofÿtheÿresultingÿEVENTSÿarray..
Ifÿ@ERRORÿ<>ÿ0
ÿ "Errorÿenumeratingÿtasks!ÿ<@ERRORÿ-ÿ@SERROR>"ÿ?
Else
ÿ "GetTasks:ÿSuccess!ÿFoundÿtheÿfollowingÿtasks:ÿ"ÿ?
ÿ ForÿEachÿ$TSKÿinÿ$EVENTS
ÿ ÿ "$TSKÿ ÿ "
ÿ ÿ ;ÿTheÿtsGetEventÿfunctionÿcanÿgetÿcompleteÿdetailsÿaboutÿtheÿtasks
ÿ ÿ ;ÿidentifiedÿbyÿtheÿtsGetTasksÿfunction...
ÿ Next
EndIf
?
ÿ
ÿ

?ÿ"Enterÿtoÿcontinue:ÿ"
Beep
Getÿ$X
Ifÿ$Xÿ=ÿ"Q"
ÿ Exit
EndIf
?ÿ?
ÿ
ÿ
;ÿUseÿtheÿtsGetEventÿfunctionÿwithÿaÿknownÿtaskÿnameÿtoÿcopyÿanÿevent
;ÿtoÿaÿnewÿnameÿ(orÿevenÿtoÿanotherÿserver).
"Copyingÿ'Testÿ1'ÿtoÿ'NewÿTest'"ÿ?
"Loading,ÿ"
tsGetEvent($HOST,ÿ"Testÿ1",ÿ"aryTask",ÿ"aryTrigger")
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsGetEventÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
EndIf
ÿ
;ÿMustÿsetÿcredentialsÿ-ÿtheyÿaren'tÿextractedÿfromÿtheÿhost
"SettingÿCredentials,ÿ"
tsSetCredentials("aryTASK",ÿ"EMERALDCITY\Services",ÿ"password")
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsSetCredentialsÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
EndIf
ÿ
"ActivatingÿEvent"ÿ
tsActivateEvent($HOST,ÿ"NewÿTest",ÿ"aryTask",ÿ"aryTrigger")
Ifÿ@ERRORÿ<>ÿ0
ÿ ?ÿ"tsActivateEventÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
Else
ÿ "ÿ-ÿSuccessful!"ÿ?
EndIf
ÿ
ÿ

?ÿ"Enterÿtoÿcontinue:ÿ"
Beep
Getÿ$X
Ifÿ$Xÿ=ÿ"Q"
ÿ Exit
EndIf
?ÿ?
ÿ
ÿ


;ÿPutÿitÿtogetherÿandÿcreateÿaÿtaskÿwithÿmanyÿkindsÿofÿtriggers
ÿ
"Lastÿtestÿ-ÿcreatingÿanÿeventÿwithÿoneÿofÿeachÿtypesÿofÿtriggers."ÿ?
ÿ
ÿ
IfÿtsIsTask($HOST,ÿ"FullÿTest")
ÿ tsDeleteEvent($HOST,ÿ"FullÿTest")
ÿ "FullÿTestÿtaskÿwasÿdeleted."ÿ?
EndIf
ÿ
$aryTaskÿ=ÿtsInitTask()
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsInitTaskÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
ÿ Exit
Elseÿ
ÿ "InitializedÿTASKÿarray"ÿ?
EndIf
ÿ
$aryTriggerÿ=ÿtsInitTrigger()
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsInitTriggerÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
ÿ Exit
Elseÿ
ÿ "InitializedÿTRIGGERÿarray"ÿ?
EndIf
ÿ
tsSetCredentials("aryTask",ÿ$USER,ÿ$PASS)
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsSetCredentialsÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
ÿ Exit
Elseÿ
ÿ "InitializedÿSecurityÿCredentials"ÿ?
EndIf
ÿ
tsDefineTask("aryTask",ÿ'APP=c:\temp\testall.batÿWKD=C:\tempÿ CMT="Testÿofÿeveryÿtriggerÿtype"')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTaskÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
ÿ Exit
Elseÿ
ÿ "InitializedÿTask"ÿ?
EndIf
ÿ
ÿ
tsDefineTrigger("aryTrigger",ÿ0,ÿ'TYP=DAILYÿARG=9ÿ STM=9:00')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTriggerÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
Else
ÿ "DefinedÿDAILYÿtriggerÿ-ÿeveryÿ9ÿdaysÿatÿ09:00."ÿ?
EndIf
ÿ
ÿ
tsDefineTrigger("aryTrigger",ÿ1,ÿ'TYP=WEEKLYÿARG=2,.M.W.F.ÿ STM=10:00')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTriggerÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
Else
ÿ "DefinedÿWEEKLYÿtriggerÿ-ÿeveryÿ2ÿweeks,ÿMon,ÿWed,ÿ&ÿFriÿatÿ10:00."ÿ?
EndIf
ÿ
ÿ
tsDefineTrigger("aryTrigger",ÿ2,ÿ'TYP=MONTHLYDATEÿARG=15,JanMarMayJulSepNovÿ STM=11:00')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTriggerÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
Else
ÿ "DefinedÿMONTHLYDATEÿtriggerÿ-ÿ15thÿofÿeveryÿotherÿmonthÿatÿ11:00."ÿ?
EndIf
ÿ
ÿ
tsDefineTrigger("aryTrigger",ÿ3,ÿ'TYP=MONTHLYDOWÿARG=5,.M.....,JanMarMayJulSepNovÿ STM=12:00')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTriggerÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
Else
ÿ "DefinedÿMONTHLYDOWÿtriggerÿ-ÿSecondÿMonÿofÿeveryÿotherÿmonthÿatÿ12:00."ÿ?
EndIf
ÿ
ÿ
tsDefineTrigger("aryTrigger",ÿ4,ÿ'TYP=ONCEÿSTM=13:00ÿSDT=2/20/2003')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTriggerÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
Else
ÿ "DefinedÿONCEÿtriggerÿ-ÿ 13:00ÿonÿ2/20."ÿ?
EndIf
ÿ
:IDLE
ÿ
tsDefineTrigger("aryTrigger",ÿ5,ÿ'TYP=ONIDLE')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTriggerÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
Else
ÿ "DefinedÿONIDLEÿtrigger"ÿ?
EndIf
ÿ
ÿ
tsDefineTrigger("aryTrigger",ÿ6,ÿ'TYP=ATSTARTUP')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTriggerÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
Else
ÿ "DefinedÿATSTARTUPÿtrigger"ÿ?
EndIf
ÿ
ÿ
tsDefineTrigger("aryTrigger",ÿ7,ÿ'TYP=ATLOGON')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTriggerÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
Else
ÿ "DefinedÿATLOGONÿtrigger"ÿ?
EndIf
ÿ
ÿ
tsDefineTrigger("aryTrigger",ÿ8,ÿ'TYP=DAILYÿARG=1ÿ STM=8:00ÿDUR=600ÿINT=12')
Ifÿ@ERRORÿ<>ÿ0
ÿ "tsDefineTriggerÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
Else
ÿ "DefinedÿrepeatingÿDAILYÿtrigger@CRLFÿ-ÿeveryÿ12ÿminutesÿstartingÿatÿ08:00ÿforÿ10ÿhours."ÿ ;?
EndIf
ÿ
ÿ
tsActivateEvent($HOST,ÿ"FullÿTest",ÿ"aryTask",ÿ"aryTrigger")
Ifÿ@ERRORÿ<>ÿ0
ÿ ?ÿ"tsActivateEventÿFailed!ÿ@CRLF<@ERRORÿ:ÿ@SERROR>"ÿ?
Else
ÿ "Successfullyÿactivatedÿevent!"ÿ?
EndIf
ÿ
?ÿ"Done"ÿ?
ÿ
ÿ

;======================================================================
;ÿENDÿTESTÿCODE
;======================================================================


 
 [ 23. February 2003, 21:43: Message edited by: Glenn Barnas ]112719tcLib2980Glenn BarnastcLib() - Scheduled Task Control Library for JT.EXE1192449897Alternative to tsControl library. This one Features/Supports:
Simplified interface - single Global array pair
SetOption(Explicit)
SetOption(NoVarsInStrings)

This is a LIBRARY of functions - the entire library should be loaded via CALL 'tcLib.udf'. Some functions are inter-dependent and could fail if this is not done. This library requires JT.EXE, a Microsoft tool for managing the task scheduler. It's the only tool I've found that allows management of multiple event triggers. It's available from MS, or you can download the zip from my web site with the library, JT.exe, and the Word format manual.

Library Header, with function list:

ÿCode:

;KGEN:NOPARSE
;KGEN:HEADER:tcLib:A collection of Task Scheduler control functions:Glenn Barnas;
;
;LIBRARY        tcLib - Task Control Library
;
;AUTHOR         Glenn A. Barnas
;
;VERSION        1.02
;               1.0  -  Initial release, January 2004
;               1.02 -  2004/02/05 - minor correction to better support AtStartup trigger
;			Modified to return error message on failure instead of printing errors
;
;OVERVIEW       An integrated library of Windows Task Scheduler control functions
;
;REQUIRES       JT.EXE - Microsoft Win-2K Resource Kit Tool
;               (Available from ftp://ftp.microsoft.com/reskit/win2000/jt.zip)
;
;SUMMARY        TASK    = 'what to run' - program & parameters, security
;               TRIGGER = 'when to run it' - one or more per task
;               EVENT   = 'task and related triggers'
;
;       tcInit()                Defines/Initialize a pair of Event arrays to defaults/nulls
;       tcDefineTask()          Load a Task array with user data
;       tcDefineTrigger()       Load a Trigger array with user data
;       tcSetEvent()            Create / modify a scheduled event from task & trigger array data
;       tcGetEvent()            Loads arrays with specific task & trigger info
;       tcDelEvent()            Delete an entire event (Task & all Triggers)
;       tcDelTrigger()          Delete a specific trigger
;       tcGetTasks()            Returns an array with list of task names from target
;       tcIsTask()              Determines if a specific task exists
;       tcIsTrigger()           Determines if a specific trigger exists
;	tcExecute()		Executes the named task on the target
;	tcTerminate()		Terminates the named task on the target, if running
;
;               Supporting Functions - used internally only
;       tcSplitParms()          Returns an array of MNM=val pairs from a single string
;
;======================================================================
;


Apparently, this was posted with UBB PostPrep, which the new rev isn't happy about editing. I've uploaded the ZIP with the library and removed the original code posts.

Glenn
82330Tempfile107mvdwTempfile() - generates file with unique name0Guys (And Girls...)

spinning of from the topic PUList by Shawn, here is the udf that will generate you a file when you need one.
Tempfile()
Action:
creates a temporary file with a unique name, to use and abuse in your script.
Author:
Maarten van der Woord
Syntax:
Tempfile([Filenumber][,path][,filename])
Parameters:
filenumber  : the number to use for creation of the temp file, suppply a value that doesn't conflict with the rest of your script. if no value supplied, 10 is used.
path        : The path where the tempfile should be created. if omitted %temp% is used.
filename    : the name of the file to be created. if no filename is passed into the function, it will generate a file called kix*****.tmp where ***** is the lowest number between 00001 and 99999
Returns:
A string containing the full path\filename for the temporary file created.
-1 on error
Remarks:
Remember to clean up the files you use at the end of your script, 99999 you can do it without, but you won't get away with the 100000th time     
Dependencies:
KiXtart 4.0 (Final)
Example(s):
$myfile = Tempfile()
generates : %temp%\kix00001.tmp (when you run subsequently it will generate kix00002.tmp etc...)

$myfile = Tempfile(5,"C:\test","mytempfile.tmp")
generates : c:\test\mytempfile.tmp (if already present, function returns -1) uses file number 5 to create the file (in stead of default 10)

code:

<pre>Function Tempfile (optional $_filenumber,optional $_path,optional $_filename)
dim $path,$filenumber,$filename,$fillstring,$fullpath,$ctr

if (vartype ($_filenumber) <> 3) And ($_filenumber > 0) And ($_filenumber < 11)
	$filenumber = $_filenumber
else
	$filenumber = 10
endif
if close ($filenumber) <> 0
	$Tempfile = -1
	exit
endif
if vartype ($_path) <> 8
	if exist ("%temp%")
		$path = "%Temp%"
	else
		$tempfile = -1
		exit
	endif
else
	$path = $_path
	if exist ($path) = 0
		md ($path)
		if @error <> 0
			$tempfile = -1
			exit
		endif
	endif
endif
if vartype ($_filename) <> 8
	$filename = "kix00001.tmp"
	$fullpath = $path + "\" + $filename
	$ctr = 2
	while exist ("$fullpath") = 1
		$fillstring = $ctr
		while len($fillstring) < 5
			$fillstring = "0" + $fillstring
		loop	
		$filename = "kix" + $fillstring + ".tmp"
		$fullpath = $path + "\" + $filename
		$ctr = $ctr + 1
	loop
	if open ($filenumber,$fullpath,0) = 2
		if open ($filenumber,$fullpath,1) = 0
			$tempfile = $fullpath
		endif
	endif
	if close ($filenumber) = o endif
else
	$filename = $_filename
	$fullpath = $path + "\" + $filename
	if open ($filenumber,$fullpath,0) = 2
		if open ($filenumber,$fullpath,1) = 0
			$tempfile = $fullpath
		else
			$Tempfile = -1
			exit
		endif
	else
		$tempfile = -1
		exit
	endif
endif
Endfunction


 
 [ 16. April 2003, 22:14: Message edited by: mvdw ]127785TimeConvert28BryceTimeConvert()  Convert time format mil/standard1111597332Code:


;Function	TimeConvert
;
;Author		Bryce Lindsay Bryce@isorg.net
;
;Action		Converts Military time to standatd time or 
;		Converts standard time to military time
;
;Syntax		TimeConvert("time")
;
;Version	1.0
;
;Date           10.12.2004
;
;Date Revised   10.12.2004
;
;Parameters 	TIME
;		Any time format.  "HH:MM" or "HH:MM:SS.mm"  or "HH:MM am"
;
;Remarks	simply converts ont time format to another.  Give it a standard
;		time format and military time is returned.  Give it Militart time
;		and standard time is returned.
;
;Returns	a string that is equal to the requested time format
; 
;Dependencies 	None
;
;KiXtart Ver	4.02
; 
;Example(s)	$Mtime = TimeConvert("1:45 pm")
;		;$mtime is equal to "13:45"
;
Function TimeConvert($time)
	dim $ampm
	if right($time,2) = "am" or right($time,2) = "pm"
		$ampm = right($time,2)
		$time = left($time,len($time)-2)
	endif
	$time = split($time,":")
	if ubound($time) < 0
		exit(2)
	endif
	if $ampm
		;imperial to mil
		select
		   case $ampm = "am" 
			if $time[0] = 12
				$time[0] = right("0"+(val($time[0]) - 12),2)
			else
				$time[0] = right("0"+$time[0],2)
			endif
		   case $ampm = "pm"
			if $time[0] <> 12
				$time[0] = val($time[0]) + 12
			endif
		endselect
	else
		;mil time to imperial
		select
			case val($time[0]) > 12
				$time[0] = val($time[0]) - 12
				$time[ubound($time)] = $time[ubound($time)] + " PM"
			case val($time[0]) = 12
				$time[ubound($time)] = $time[ubound($time)] + " PM"
			case val($time[0]) = 0
				$time[0] = 12
				$time[ubound($time)] = $time[ubound($time)] + " AM"
			case val($time[0]) < 12
				$time[0] = val($time[0])
				$time[ubound($time)] = $time[ubound($time)] + " AM"
		endselect
	endif
	$TimeConvert = join($time,":")
endfunction

173022TimeConvert2980Glenn BarnasTimeConvert() - convert between cTime and string time values0 
;; 
;;====================================================================== 
;; 
;;FUNCTION       TimeConvert() 
;; 
;;ACTION         Converts time formats between cTime and Kix Time 
;; 
;;AUTHOR         Glenn Barnas 
;;               Based on Rata Die algorithms of Peter Baum 
;; 
;;VERSION        2.0 / 2007/01/20 - Eliminated 2Gig bug, 
;;                                  Add support of negative cTime values 
;;                                  Fixed Epoch bug, allowing any date value 
;;                                  Allow numeric or string Epoch value 
;;               1.0 / 2006/11/20 - first release 
;; 
;;SYNTAX         TimeConvert(CValue [, Epoch]) 
;; 
;;PARAMETERS     CValue - REQUIRED - The time value to be converted. This may 
;;               be an integer value representing the number of seconds since 
;;               the Epoch, or a Date Time string in the format YYYY/MM/DD hh:mm:ss 
;;               Given one type, the function returns the other type.  
;; 
;;               Epoch - OPTIONAL - A date string (YYYY/MM/DD format) or days value that 
;;               represents the "beginning of time". The default is 1970/1/1 (719163).  
;;               To accurately specify time from the year 1, use an Epoch value of 0. 
;;               Negative Epoch values were not tested. 
;; 
;;REMARKS        This function simply changes a between date strings and cTime values 
;;               and vice-versa. Any time zone conversions should be performed external 
;;               to this function.  
;; 
;;               Validated by generating sequential date values from a range of just over  
;;               8.5 Billion seconds. 
;; 
;;               This function does not take into account changes to the calendar which occurred 
;;               throughout history. 
;; 
;;RETURNS        Time string in Kix format (yyyy/mm/dd hh:mm:ss) if cTime format is provided 
;;               cTime value (double) if Kix format time string is provided 
;; 
;;DEPENDENCIES   none 
;; 
;;TESTED WITH    Kix 4.50, W2K, WXP, W2K3 
;; 
;;EXAMPLES        
;;               ; What time will it be in 15 minutes? 
;;               TimeConvert(TimeConvert(@DATE + ' ' + @TIME) + 900) 
;;               ; Specialized use of EPOCH value 
;;               ; How many seconds before 2007 US taxes are due? (or overdue??) 
;;               TimeConvert(@DATE + ' ' + @TIME, '2007/04/15') ? 
; 
Function TimeConvert($_CValue, OPTIONAL $_Epoch)
 
  Dim $_			; generic counter / increment 
  Dim $_Return			; value calculated by the engine to return to the calling routine 
  Dim $_Date, $_Time		; values used by the Date to cTime routine 
  Dim $_A, $_B, $_C, $_D, $_E	; intermediate variables used in the calendar calculation 
 
  ; Validate/Define the Epoch value 
  If VarType($_Epoch) > 1
 
    If VarType($_Epoch) = 8					; yyyy/mm/dd format 
 
      $_Epoch = Split($_Epoch, '/')
      If UBound($_Epoch) <> 2 Exit 87 EndIf			; Bad Epoch date format! 
 
      For $_ = 0 to 2
        $_Epoch[$_] = Val($_Epoch[$_])				; insure values are numeric 
      Next
 
      ; Adjust for Feb 
      If $_Epoch[1] < 3
        $_Epoch[1] = $_Epoch[1] + 12
        $_Epoch[0] = $_Epoch[0] - 1
      EndIf
 
      ; Calculate days since Year 0, accounting for leap years 
      $_Epoch = CDbl($_Epoch[2]) + (153 * $_Epoch[1] - 457) / 5 + 365 * $_Epoch[0] + $_Epoch[0] 
         / 4 - $_Epoch[0] / 100 + $_Epoch[0] / 400 - 306
 
    EndIf
 
  Else
 
    $_Epoch = 719163						; default to 1970/1/1 
 
  EndIf
 
 
  ; perform the time conversion 
  If $_CValue + 0 = $_CValue					; convert cTime to Date/Time 
 
    $_ = $_CValue
    Dim $_CValue[5]						; Prepare CValue array to hold date/time components 
    $_CValue[5] = $_
 
    $_CValue[2]  = Int($_CValue[5]  / 86400)			; Days for DATE part 
    $_CValue[5]  = $_CValue[5] - (86400.0 * $_CValue[2])	; Remaining seconds for TIME part 
    If $_CValue[5] < 0
      $_CValue[2] =$_CValue[2] - 1				; Adjust for negative cTime values 
    EndIf
    $_CValue[2]  = $_CValue[2] + $_Epoch
 
    $_E          = $_CValue[2] + 306				; Process m/d/y values, accounting for calendar changes 
    $_D          = 100 * $_E - 25				; and leap years 
    $_A          = $_D / 3652425
    $_B          = $_A - $_A / 4
    $_CValue[0]  = (100 * $_B + $_D) / 36525
    $_C          = $_B + $_E - 365 * $_CValue[0] - $_CValue[0] / 4
    $_CValue[1]  = (5 * $_C + 456) / 153
    $_CValue[2]  = $_C - (153 * $_CValue[1] - 457) / 5
 
    If $_CValue[1] > 12						; More than 12 months? 
      $_CValue[0] = $_CValue[0] + 1				; Add a year 
      $_CValue[1] = $_CValue[1] - 12				; subtract 12 months 
    EndIf
 
    $_CValue[3]  = Int($_CValue[5]  / 3600)
    $_CValue[4]  = Int(($_CValue[5]  - $_CValue[3] * 3600) / 60)
    $_CValue[5]  = $_CValue[5] - Int($_CValue[3] * 3600) - $_CValue[4] * 60
 
    ; deal with negative cTime values 
    If $_CValue[5] < 0
      $_CValue[5] = 60 + $_CValue[5]
      $_CValue[4] = $_CValue[4] - 1
    EndIf
    If $_CValue[4] < 0
      $_CValue[4] = 60 + $_CValue[4]
      $_CValue[3] = $_CValue[3] - 1
    EndIf
    If $_CValue[3] < 0
      $_CValue[3] = 24 + $_CValue[3]
    EndIf
 
    ; format the return string 
    $_Return ='' + $_CValue[0] + '/' + right('00'+ $_CValue[1], 2) + '/' + right('00' 
       + $_CValue[2], 2)
    $_Return = $_Return + ' ' + right('00' + $_CValue[3], 2) + ':' + right('00' + $_CValue[4],
      , 2) + ':' + right('00'+$_CValue[5] , 2)
 
  Else							; Convert Date/Time to cTime 
 
    ; convert to array & verify correct # of fields 
    $_CValue = Split(Join(Split(Join(Split($_CValue + ':0', '/'), ' '), ':'), ' '), ' ', 6)
    If UBound($_CValue) <> 5 Exit 87 EndIf	; Bad date/time format! 
 
    ; convert to numeric values 
    For $_ = 0 to 5 $_CValue[$_] = Val($_CValue[$_]) Next
 
    If $_CValue[1] < 3
      $_CValue[1] = $_CValue[1] + 12
      $_CValue[0] = $_CValue[0] - 1
    EndIf
 
    $_Date = CDbl($_CValue[2]) + (153 * $_CValue[1] - 457) / 5 + 365 * $_CValue[0] + $_CValue[0] 
       / 4 - $_CValue[0] / 100 + $_CValue[0] / 400 - 306
    $_Time = (Val(CDbl($_CValue[3])) * 3600) + (Val($_CValue[4]) * 60) + Val($_CValue[5])
    $_Return = (($_Date - $_Epoch) * 86400 + $_Time) 
  EndIf
 
  ; Return the value 
  $TimeConvert = $_Return
  Exit 0
 
EndFunction 
 
   

149808TimeDiff2980Glenn BarnasTimeDiff() - calculate time difference betweeen 2 timestamps1192446323



;; 
;;====================================================================== 
;; 
;;FUNCTION       TimeDiff() 
;; 
;;AUTHOR         Glenn Barnas 
;; 
;;VERSION        2.2 / 2007/10/14 
;;		 Modified to increase accuracy, permit fracional second calculations 
;;		 2.1 / 2007/03/17 
;;               added "now" and "today" options for both start and end times 
;;               2.0 / 2006/11/20 
;;               Changes for code efficiency; added defaults for midnight  
;; 
;;ACTION         Calculates the time difference between two given date/time strings 
;; 
;;SYNTAX         TimeDiff(Start [, End] [, Format] [, MSec]) 
;; 
;;PARAMETERS     Start  - REQUIRED, String value representing the start timestamp 
;;                 Format yyyy/mm/dd hh:mm:ss 
;; 
;;               End    - OPTIONAL, Defaults to "now" 
;;		   String value representing the ending time 
;;                 Format yyyy/mm/dd hh:mm:ss 
;;		   Can be the special value "now" for the current date/time, or "today" 
;;                 for midnight of the current day. 
;; 
;;                 When the time value is not specified, it defaults to 00:00:00.000 (midnight) 
;; 
;;		 Format - OPTIONAL, one of: 
;;		  "m" - return minutes 
;;		  "h" - return hours 
;;		  "d" - return days 
;;		  "y" - return years 
;;		 When a format value is specified, it returns the fractional part (ie 0.5 days for 12 hours). 
;; 
;;		 MSec	- OPTIONAL, True if the fractional seconds should be returned. Default 
;;		  is false, returning whole seconds, to maintain compatibility with earlier versions. 
;;		  MSec only affects the return of fractional seconds, not fractional parts of other time formats. 
;; 
;;REMARKS        Returns a value representing the difference in time between two date/time 
;;		 strings. Assumes that "Start" is in the past, but will properly return a 
;;		 negative value if it is in the future. 
;; 
;;RETURNS        Double - difference between Start and End timestamps in seconds 
;; 
;;DEPENDENCIES   None 
;; 
;;TESTED WITH    Kix 4.2+, NT4, W2K, WXP, W2K3 
;; 
;;EXAMPLES       If TimeDiff(GetFileTime('SomeFile.txt'),  'now', 'h') > 48 
;;		   "File is more than 2 days old!" ? 
;;		 EndIf 
; 
Function TimeDiff($_Start, OPTIONAL $_End, OPTIONAL $_Fmt, OPTIONAL $_MSec)
 
  Dim $_, $_SDate, $a_Start, $_EDate, $a_End, $_Duration
 
  ; Check for special START parameters 
  Select
   Case $_Start = 'now'
    $_Start = @DATE + ' ' + @TIME + '.' + @MSECS
   Case $_START = 'today'
    $_Start = @DATE + ' 00:00:00.000'
  EndSelect
 
  ; Check for special END parameters 
  Select
   Case $_End = 'now' Or $_End = '' 
    $_End = @DATE + ' ' + @TIME + '.' + @MSECS
   Case $_End = 'today'
    $_End = @DATE + ' 00:00:00.000'
  EndSelect
 
  ; Validate parameters 
  ; Parameters passed are "yyyy/mm/dd hh:mm:ss[.sss]" - make sure the default time is added 
  $a_Start = Split(Join(Split(Join(Split($_Start + ' 00:00:00.000', '/'), ' '), ':'), ' '), ' ', 6)
  If UBound($a_Start) <> 5 Exit 87 EndIf		; bad start time parameter 
  For $_ = 0 to 5
    $a_Start[$_] = CDbl($a_Start[$_])		; convert to numeric values 
  Next
 
  $a_End = Split(Join(Split(Join(Split($_End + ' 00:00:00.000', '/'), ' '), ':'), ' '), ' ', 6)
  If UBound($a_End) <> 5 Exit 87 EndIf		; bad start time parameter 
  For $_ = 0 to 5
    $a_End[$_] = CDbl($a_End[$_])		; convert to numeric values 
  Next
 
  ; Convert dates to Days, then convert to seconds and add the time value 
  If $a_Start[1] < 3
    $a_Start[1] = $a_Start[1] + 12
    $a_Start[0] = $a_Start[0] - 1
  EndIf
  $_SDate = $a_Start[2] + ( 153 * $a_Start[1] - 457 ) / 5 + 365 * $a_Start[0] + $a_Start[0] / 4 - $a_Start[0] / 100 + $a_Start[0] / 400 - 306
  $_SDate = CDbl($_SDate) * 86400.0
  $_SDate = $_SDate + $a_Start[3] * 3600 + $a_Start[4] * 60 + $a_Start[5]
 
  If $a_End[1] < 3
    $a_End[1] = $a_End[1] + 12
    $a_End[0] = $a_End[0] - 1
  EndIf
  $_EDate = $a_End[2] + ( 153 * $a_End[1] - 457 ) / 5 + 365 * $a_End[0] + $a_End[0] / 4 - $a_End[0] / 100 + $a_End[0] / 400 - 306
  $_EDate = CDbl($_EDate) * 86400.0
  $_EDate = $_EDate + $a_End[3] * 3600 + $a_End[4] * 60 + $a_End[5]
 
  ; Get the duration between the timestamps 
  $_Duration = CDbl($_EDate - $_SDate)
 
  ; Trim fractional seconds if the MSec flag wasn't set 
  ; Value returned is whole seconds 
  If Not $_MSec
    $_Duration = CInt($_Duration)
  EndIf
 
  ; Return data as a Double - seconds (default), hours, minutes, days, or years 
  Select
    Case $_Fmt = 'm'	; minutes 
      $TimeDiff = $_Duration / 60.0
    Case $_Fmt = 'h'	; hours 
      $TimeDiff = $_Duration / 3600.0
    Case $_Fmt = 'd'	; days 
      $TimeDiff = $_Duration / 86400.0
    Case $_Fmt = 'y'	; years 
      $TimeDiff = $_Duration / 31536000.0
    Case 1
      $TimeDiff = $_Duration
  EndSelect
 
  Exit 0
 
EndFunction
 
 
 
 
 

82281TimeDiff17SealeopardTimeDiff() - Calculates the time difference between two times0

code:

;FUNCTION      TimeDiff
;
;ACTION        Calculates the time difference between two times
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.1
;
;KIXTART       4.20
;
;SYNTAX        TIMEDIFF(TIME1,TIME2)
;
;PARAMETYERS   TIME1
;              Required string containing either a time "HH:MM[:SS.MSECS]" or a value
;              greater than zero and less than 86400 representing seconds and fractions
;              e.g 20.040 for 20 seconds and 40 milliseconds
;
;              TIME2
;              Required string containing either a time "HH:MM[:SS.MSECS]" or a value
;              greater than zero and less than 86400 representing seconds and fractions
;              e.g 20.040 for 20 seconds and 40 milliseconds
;
;RETURNS       Returns difference between TIME1 and TIME2
;
;REMARKS       none
;
;DEPENDENCIES  SERIALTIME() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000039
;
;EXAMPLE       $rc=TIMEDIFF('23:20:33','01:01:01.245')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000040
;
function timediff($time1,$time2)
  Dim $difference

  select
  case instr($time1,':')
    $time1=serialtime($time1)
  case $time1<>''
    $time1=cdbl($time1)
  case 1
    $time1=0.0
  endselect

  select
  case instr($time2,':')
    $time2=serialtime($time2)
  case $time2<>''
    $time2=cdbl($time2)
  case 1
    $time2=0.0
  endselect

  if $time1>$time2
    $difference=$time1-$time2
  else
    $difference=$time2-$time1
  endif

  $timediff=serialtime($difference)
  exit 0
endfunction


 
 [ 02. March 2003, 17:07: Message edited by: sealeopard ]84452Titlecase114NetsuperTitlecase() (converts string to Title Case)0I've just worked on this, let me know what you think?
 

code:

;FUNCTION TitleCase
;
;AUTHOR Scott Hickerson
;
;ACTION Converts any string to titlecase string delimited on <space>.
;
;SYNTAX TitleCase($Title)
;
;PARAMETERS String - string of text to be converted
;
;RETURNS the TitleCase version of the ASCII string
;
;DEPENDENCIES none.
;
;EXAMPLE
; $title = 'make THIS all TITLE case'
; ? TitleCase($Title)
;
;CODE

FUNCTION TitleCase($Title)
     DIM $Title, $NumOfWords, $x
     $NumOfWordsString = $Title
     $NumOfWords = 1
     WHILE INSTR($NumOfWordsString,' ') and @error = 0
          $NumOfWordsString = SUBSTR($NumOfWordsString,INSTR($NumOfWordsString,' ') + 1)
          $NumOfWords = $NumOfWords + 1
     LOOP
     DIM $Word[$NumOfWords]
     $SplitString= split($Title,' ')
     $x = 0
     WHILE $x < $NumOfWords 
          $Word[$x] = UCASE(LEFT($SplitString[$x],1)) + LCASE(SUBSTR($SplitString[$x],2))
          IF $TitleCase = ''
               $TitleCase = $Word[$x] 
          ELSE
               $TitleCase = $TitleCase + ' ' + $Word[$x]
          ENDIF
          $x = $x + 1
     LOOP
ENDFUNCTION 

code:

EXAMPLE:
break on
? TitleCase('make THIS all TITLE case')
 
RETURNS:
Make This All Title Case

82535TotalMem79KdyerTotalMem() - Determine amount of memory installed using WMI0O.K. O.K.

I have seen you guys post up functions for a while now..  I guess it is time for me to get off my duff.

NAME          TOTALMEM

AUTHOR        Kent Dyer (leptonator@hotmail.com)

ACTION        Returns amount of memory installed from a system using WMI
   
SYNTAX        TotalMem($Systemname)
  
PARAMETERS    Systemname
              Required string containing the name of the system you are interested in,
              you could use @WKSTA

RETURNS       Amount of memory installed ($MEMINSTALLED)
 
REMARKS       Reference - http://cwashington.netreach.net/depo/view.asp?Index=341&ScriptType=vbscript 
              No need to use MEM, WINMSD, etc.  The "natives" should be clamoring for this!
              The MSDN LINK is - http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wmisdk/     wmi/wmi_classes.asp?frame=true 
              MSDN says - "Windows NT/2000/XP: Requires Windows NT 4.0 SP4 or later" but I am working on
              this with Windows ME

DEPENDENCIES  Kixtart 4.0, WMI
  
EXAMPLE(s)       $retcode=TotalMem('S8C6B5')
                 $retcode=TotalMem('\\S8C6B5')
                 $retcode=TotalMem(@WKSTA)

		  $Systemname = @WKSTA
		  $retcode=TotalMem( $Systemname )
		  ? "Memory installed is: " + $MEMINSTALLED

code:

FUNCTION TotalMem($Systemname)
DIM $LSTRING,$Systemname,$winmgmt,$strQuery,$ObjEnumerator,$objInstance,$MEMINSTALLED

IF 0<>InStr($Systemname,"\\") ; -- Parse off the UNC PATH IF Found
$LSTRING=LEN($Systemname)
$Systemname=SUBSTR($Systemname,3,$LSTRING)
ENDIF


$winmgmt1 = "winmgmts:{impersonationLevel=impersonate}!//" + $Systemname
$strQuery = "Select TotalPhysicalMemory From Win32_LogicalMemoryConfiguration"

$objEnumerator = GetObject($winmgmt1).ExecQuery($strQuery)

For Each $objInstance in $objEnumerator
If @Error <> 0 Then
RETURN     
     Else
          If $objInstance = ""
               ?"Could not get memory."
          Else
          	$MEMINSTALLED = $objInstance.TotalPhysicalMemory + " KB"
                ?$MEMINSTALLED
          EndIf
     EndIf
Next
ENDFUNCTION

Have Fun!               

- Kent
 
 [ 28. October 2003, 16:40: Message edited by: kdyer ]188150Touch22Richard H.Touch() - Set the last modified timestamp on a file0
;Function: 
;     touch()
; 
;Author: 
;     R. Howarth (rhowarth@sgb.co.uk)
; 
;Version: 
;     1.0
; 
;Version history: 
;     1.0 RMH 11 June 2008 Initially created
;
;Action: 
;     Sets the last modified timestamp on a file, creates the file if it does not exist
; 
;Syntax: 
;     touch(filepath,OPTIONAL timestamp)
; 
;Parameters: 
;     filepath      Regular file to be touched
;     timestamp     Optional date / time to use.  If not specified then
;                   the current time is used.
; 
;Returns: 
;     Error code
; 
;Dependencies: 
;     None
;
; 
;Remarks: 
;       The touch UDF cannot be used to set folder timestamps.
;       If you specify only a date then the time will be set to "00:00"
;       If you specify only a time then the date will be set to epoch
;       Most date formats appear to work as expected
; 
;Examples: 
;      $iResult=Touch("C:\temp\foo.txt")
;      $iResult=Touch("C:\temp\foo.txt","31 Dec 1999")
;      $iResult=Touch("C:\temp\foo.txt","23/02/2068 08:00 PM")
;


Function touch($sFile,Optional $sTimeStamp)
    Dim $fd, $oShell,$oFolder,$sFolder,$oFile
    If Not Exist($sFile)
        $fd=FreeFileHandle()
        If @ERROR $touch=@ERROR Exit @ERROR EndIf
        If Open($fd,$sFile,1+4) $touch=@ERROR Exit @ERROR EndIf
        If Close($fd) $touch=@ERROR Exit @ERROR EndIf
    EndIf


    If InStr($sFile,"\") $sFolder=Left($sFile,InStrRev($sFile,"\")) Else $sFolder=@CURDIR EndIf
    $sFile=SubStr("\"+$sFile,InStrRev("\"+$sFile,"\")+1)


    If Not $sTimeStamp $sTimeStamp=@DATE+" "+@TIME EndIf
    $oShell=CreateObject("Shell.Application")
    If @ERROR OR VarType($oShell)<>9 $touch=@ERROR Exit @ERROR EndIf
    $oFolder=$oShell.NameSpace($sFolder)
    If @ERROR OR VarType($oFolder)<>9 $touch=@ERROR Exit @ERROR EndIf
    $oFile=$oFolder.ParseName($sFile)
    If @ERROR OR VarType($oFile)<>9 $touch=@ERROR Exit @ERROR EndIf
    $oFile.ModifyDate=$sTimeStamp
    $touch=@ERROR
    Exit $touch
EndFunction
; vim:ai ts=4 sw=4 fdc=4 fdm=marker
83802TraceRoute31RadimusTraceRoute() - returns an array of IPs from a tracert0Returns an array of the IPs from a tracert

Dependencies: WSHPipe() -> WSH, kix4.xx

Example:

code:

for each $element in TraceRoute('www.msn.com')
	? $element
	next


Function TraceRoute($destination)
dim $ipraw, $left, $return, $line, $loop, $Shell
dim $trace[0]

if $destination
$loop=0
$shell='%comspec% /c tracert $destination'
$return=WSHPipe($shell,1)
for each $line in $return
if val(left($line,5)) >0
$ipraw= trim(right($line,len($line)-32))
$left=instr($ipraw,"[")
if $left
$ipraw=split(split($ipraw,"[")[1],"]")[0]
endif
redim preserve $trace[$loop]
$trace[$loop]=$ipraw
$loop=$loop+1
endif
next
$TraceRoute=$trace
endif
endfunction



Renamed to make Lonk happy...
 
 [ 23. March 2003, 18:02: Message edited by: Radimus ]83002TranslateName172Howard BullockTranslateName() - converts a name from one type to another0


;FUNCTION         TranslateName()

;

;AUTHOR           Howard A. Bullock (hbullock@tycoelectronics.com)

;

;VERSION          2.0

;

;ACTION           Translates from one name type to another. Good for converting an NT4 name

;                 like domain\user into an LDAP distinguished name or the reverse.

;

;SYNTAX           TranslateName ($InitType, $BindName, $LookupNameType, $LookupName, $ReturnNameType)

;

;PARAMETERS       $InitType (Required)

;                  -  Integer value

;                     1 = ADS_NAME_INITTYPE_DOMAIN

;                     Initializes a NameTranslate object by setting the domain that the object will bind to.

;

;                     2 = ADS_NAME_INITTYPE_SERVER

;                     Initializes a NameTranslate object by setting the server that the object will bind to.

;

;                     3 = ADS_NAME_INITTYPE_GC

;                     Initializes a NameTranslate object by locating the global catalog to which the object

;                     will bind.

;

;                 $BindName (Required)

;                  -  String value

;                     If an $InitType = 3 (ADS_NAME_INITTYPE_GC), then the $BindName = "".

;                     InitTypes 1 and 2 require a name of a domain or server to be input. 

;                     Note: "" may default to the current server or domain.

;

;                 $LookupNameType (Required)

;                  -  Integer value

;

;                 $LookupName (Required)

;                  -  String value see below

;

;                 $ReturnNameType (Required)

;                  -  Integer value see below

;

;                  Documentation of Name Types. Lookup the more info on http://MSDN.Microsoft.com

;                  Not all name types work. "1", "2", and "3" have been the most useful. 

;

;                 1 = ADS_NAME_TYPE_1779

;                 Name format as specified in RFC 1779. For example, "CN=Jane Doe,CN=users, DC=Microsoft, DC=com".

;

;                 2 = ADS_NAME_TYPE_CANONICAL

;                    Canonical name format. For example, "Microsoft.com/Users/Jane Doe".

;

;                 3 = ADS_NAME_TYPE_NT4

;                 Account name format used in Microsoft® Windows© NT® 4.0. For example, "Microsoft\JaneDoe".

;

;                 4 = ADS_NAME_TYPE_DISPLAY

;                 Display name format. For example, "Jane Doe".

;

;                 5 = ADS_NAME_TYPE_DOMAIN_SIMPLE

;                 Simple domain name format. For example, "JaneDoe@Microsoft.com".

;

;                 6 = ADS_NAME_TYPE_ENTERPRISE_SIMPLE

;                 Simple enterprise name format. For example, "JaneDoe@Microsoft.com".

;

;                 7 = ADS_NAME_TYPE_GUID

;                 Global Unique Identifier format. For example, {95ee9fff-3436-11d1-b2b0-d15ae3ac8436}.

;

;                 8 = ADS_NAME_TYPE_UNKNOWN

;                 Unknown name type. The system will try to make the best guess.

;

;                 9 = ADS_NAME_TYPE_USER_PRINCIPAL_NAME

;                 User principal name format. For example, "JaneDoe@Fabrikam.com".

;

;                 10 = ADS_NAME_TYPE_CANONICAL_EX

;                 Extended canonical name format. For example, "Microsoft.com/Users Jane Doe".

;

;                 11 = ADS_NAME_TYPE_SERVICE_PRINCIPAL_NAME

;                 Service principal name format. For example, "www/www.microsoft.com@microsoft.com"

;

;                 12 = ADS_NAME_TYPE_SID_OR_SID_HISTORY_NAME

;                 A SID string, as defined in the Security Descriptor Definition Language (SDDL), for either

;                 the SID of the current object or one from the object's SID history.

;                 For example, "O:AOG:DAD:(A;;RPWPCCDCLCSWRCWDWOGA;;;S-1-0-0)" For more information see

;                 Security Descriptor String Format under "Security" in the Microsoft Platform SDK documentation.

;

;REMARKS          Not name types seem to work.

;

;RETURNS          This function returns an ARRAY of three values:

;                               Name of the type specified by $ReturnNameType (String)

;                               Error number (Long Integer)

;                               Error text (String).

;

;DEPENDENCIES     OS: Active Directory aware client

;

;EXAMPLES         $DN = TranslateName (3, "", 3, "@Domain\@wksta$", 1)

;                 ? "DN = " + $DN[0]

;                 ? "Error = " + $DN[1]

;                 ? "ErrorText = " + $DN[2]

;

;                 $DN = TranslateName (3, "", 3, "@LDomain\@userid", 1)

;                 ? "DN = " + $DN[0]

;                 ? "Error = " + $DN[1]

;                 ? "ErrorText = " + $DN[2]

;

;

Function TranslateName ($InitType, $BindName, $LookupNameType, $LookupName, $ReturnNameType)



   Dim $InitType, $BindName, $LookupNameType, $LookupName, $ReturnNameType

   Dim $NameTranslate, $ReturnName, $Error, $ErrorText



   $Error = 0

   $ErrorText = ""

   $ReturnName = ""

   $NameTranslate = CREATEOBJECT ("NameTranslate")

   $Error = @error

   $ErrorText = @serror

   if $Error = 0

      $NameTranslate.Init ($InitType, $BindName)

      $Error = @error

      $ErrorText = @serror

      if $Error = 0

         $NameTranslate.Set ($LookupNameType, $LookupName)

         $Error = @error

         $ErrorText = @serror

         if $Error = 0

            $ReturnName = $NameTranslate.Get($ReturnNameType)

            $Error = @error

            $ErrorText = @serror

         endif

      endif

   endif

   $TranslateName = $ReturnName, $Error, $ErrorText

Endfunction


 
 [ 22. June 2003, 23:23: Message edited by: Howard Bullock ]83531udfAnagram22Richard H.udfAnagram() - Generate anagrams.0This tiny udf will generate all possible anagrams of a string.

Note, it will not check for duplicates or non-words.

code:

;FUNCTION	udfAnagram()
;
;ACTION		Calculates the anagrams of a string
;
;AUTHOR		Richard Howarth (rhowarth@sgb.co.uk)
;
;SYNTAX		udfAnagram(String, Action)
;
;PARAMETERS	String		Seed string to produce anagrams from
;		Action		KiXtart script to apply to each anagram
;
;KIXTART VER	4.x
;
;DEPENDENCIES	none
;
;REMARKS	The "Action" code is simply a bit of KiXtart script to execute each
;		time an anagram is found, substituting "$$sAnagram" for the actual
;		anagram found,
;		The simplest would be "? $$sAnagram", which would display the anagram.
;		If your wanted to do something more complex, pass it to a UDF using the
;		form "myUDF($$sAnagram)"
;		Don't supply anything to the optional parameter, you'll only confuse things.
;
;EXAMPLES
;1) Display all the anagrams of "cat":
;      udfAnagram("cat","$$sAnagram ?")
;   Displays:
;      cat
;      cta
;      act
;      atc
;      tca
;      tac
;
;2) Pass each anagram of "radical" through a spell check function:
;      udfAnagram("radical","SpellCheck($$sAnagram)")
	
Function udfAnagram($sSeed,$sFunction,Optional $sAnagram)
	Dim $i
	If($sSeed)
		For $i=1 to Len($sSeed)
			$udfAnagram=udfAnagram(Left($sSeed,$i-1)+SubStr($sSeed,$i+1),$sFunction,$sAnagram+SubStr($sSeed,$i,1))
		Next
	Else
		$=Execute($sFunction)
	EndIf
EndFunction

84430udfFormatDate22Richard H.udfFormatDate() strftime like function to format date tokens0


; vim: filetype=kix ai sw=3 ts=3 fdm=marker fdc=3

;Function       udfFormatDate() strftime like date formatting
;
;Author         Richard Howarth (rhowarth@sgb.co.uk)
;
;Contributors   Week number calculation transliterated from a GAWK script
;               created by J R Stockton http://www.merlyn.demon.co.uk/index.htm
;
;Action         Formats date and time information - very similar to C strftime()
;
;Syntax         udfFormatDate($sFormat, Optional $sDateAndTime
;
;Version        1.0
;
;Date           15 July 2003
;
;
;Parameters     $sFormat   Format string that the date information is inserted into.
;                          Each part of the information is introduced by the "!"
;                          character - change $sIntro if you prefer to use a
;                          different character.  I didn't use "%" as it clashes with
;                          the KiXtart environment variable character
;
;               $sDateAndTime OPTIONAL, in format "YYYY/MM/DD HH:MM:SS"
;                          If not set defaults to the current date and time.  You may
;                          specify just the date if you are using only date tokens.  If
;                          you only want to use the time tokens, you will need to insert
;                          a dummy date.
;                          
;
;
;Remarks   (1)  If you use the tokens marked "*" in the list, you will need to include the
;               SerialDate() function from the ScriptLogic site:
;                  http://scriptlogic.com/Kixtart/FunctionLibrary_ViewFunction.aspx?ID=SerialDate
;
;          (2)  The week number returned conforms to ISO8601.  This is commonly used in the UK, but
;               may not be valid in the US. The value returned is "YYYY/WW", where YYYY is the year
;               that the week falls into, and WW is the week number.
;
;          (3)  Unrecognised tokens including a trailing introduction character are returned as-is.
;
;          (4)  The values returned by this function are KiXtart oriented, so if you are used to the
;               values returned by strftime() be sure you understand the differences.
;
;          (5)  The "a","A" and "W" tokens are only valid for years 1970-2099
;
;Returns        Formatted string.
; 
;Dependencies   If tokens marked "*" are used then SerialDate() is required.
;
;KiXtart Ver    4.02
; 
; Token  SerialDate  Action
; -----  ----------  ------
;   a         *      Abbreviated week day name (Mon...Sun)
;   A         *      Full week day name (Monday...Sunday)
;   b                Abbreviated month name (Jan...Dec)
;   B                Full month name (January...December)
;   c         *      Local long time and date representation
;   d                Day of month (01...31)
;   D                Local date representation, synonym for "x"
;   H                Hour (24 hour clock)
;   I                Hour (12 hour clock)
;   j         *      Day of year (1...366)
;   m                Month (01...12)
;   M                Minute(00...59)
;   o                Ordinal suffix (1st, 2nd, 3rd...)
;   p                AM or PM indicator
;   S                Second (00...59)
;   T                Local time representation, synonym for "X"
;   w                Week day number (1...7) 1 is Monday
;   W         *      Week Number. ISO 8601
;   x                Local date representation
;   X                Local time representation
;   y                Year without century (00...99)
;   Y                Year with century
;
;Examples:
;   (1) Create a filename based on todays date:
;          $sFileName=udfFormatDate(%TEMP%+"\File!Y!m!d.txt")
;
;   (2) On which day did the (popular   ) new millenium fall:
;          udfFormatDate("New millenium started on a !A!","2000/01/01")
;
;   (3) Get the ISO week number of the 1st of Jan 2005 (puts year into element 0, week into element 1)
;          $aiISOWeek=Split(udfFormatDate("!W","2005/01/01"),"/")
;          "Year is " $aiISOWeek[0] ?
;          "Week is " $aiISOWeek[1] ?
;       Note, this example is included because 1st Jan 2005 falls on week 53 of 2004
; 
Function udfFormatDate($sFormat,Optional $sDate) ; {{{
   Dim $asTwelveHourSplit,$asDayName,$asMonthName,$asOrdinal
   Dim $aiDateBits,$aiTimeBits
   Dim $sIntro,$bTokenNext
   Dim $sLocalTime,$sLocalDate,$sLocalDateAndTime
   Dim $sAction

   ; Token intro character.  Change if you don't like it.
   $sIntro="!"
   ; Define locale defaults - UK *CHANGEME* for your locale
   $sLocalTime=$sIntro+"H:"+$sIntro+"M:"+$sIntro+"S"
   $sLocalDate=$sIntro+"d/"+$sIntro+"m/"+$sIntro+"Y"
   $sLocalDateAndTime=$sIntro+"a "+$sIntro+"b "+$sIntro+"d"+$sIntro+"o "+$sLocalTime+" "+$sIntro+"Y"

   ; Define name constants - UK English *CHANGEME* for your locale
   $asTwelveHourSplit="am","pm"
   $asDayName="Monday","Tuesday","Wednesday","Thursday",
                  "Friday","Saturday","Sunday"
   $asMonthName="January","February","March","April",
                  "May","June","July","August",
                  "September","October","November","December"
   $sOrdinal="stndrdthththththththththththththththththstndrdthththththththst"

   If Not $sDate $sDate=@DATE+" "+@TIME EndIf

   $aiDateBits=Split(Split($sDate)[0],"/")
   $aiTimeBits=Split(Split($sDate)[1],":")

   While $sFormat
      $sAction=Left($sFormat,1)
      $sFormat=SubStr($sFormat,2)
      If $bTokenNext
         $bTokenNext=0
         Select
         Case $sAction==$sIntro ; No action - use token intro character
         Case $sAction=="a"
            $sAction=(SerialDate($sDate)-SerialDate("1969/01/01")+2) mod 7 + 1
            $sAction=Left($asDayName[$sAction-1],3)
         Case $sAction=="A"
            $sAction=(SerialDate($sDate)-SerialDate("1969/01/01")+2) mod 7 + 1
            $sAction=$asDayName[$sAction-1]
         Case $sAction=="b" $sAction=Left($asMonthName[CInt($aiDateBits[1])-1],3)
         Case $sAction=="B" $sAction=$asMonthName[CInt($aiDateBits[1])-1]
         Case $sAction=="c" $sAction="" $sFormat=$sLocalDateAndTime+$sFormat
         Case $sAction=="d" $sAction=$aiDateBits[2]
         Case $sAction=="D" $sAction="" $sFormat=$sLocalDate+$sFormat
         Case $sAction=="H" $sAction=$aiTimeBits[0]
         Case $sAction=="I"
            $sAction=$aiTimeBits[0]
            If CInt($sAction)>12 $sAction=Right("0"+(CInt($sAction)-12),2) EndIf
         Case $sAction=="j" $sAction=1+SerialDate($sDate)-SerialDate(CStr($aiDateBits[0])+"/01/01")
         Case $sAction=="m" $sAction=$aiDateBits[1]
         Case $sAction=="M" $sAction=$aiTimeBits[1]
         Case $sAction=="o" $sAction=SubStr($sOrdinal,CInt($aiDateBits[2])*2-1,2)
         Case $sAction=="p"
            $sAction=IIf(Cint($aiTimeBits[0])>=12,$asTwelveHourSplit[1],$asTwelveHourSplit[0])
         Case $sAction=="S" $sAction=$aiTimeBits[2]
         Case $sAction=="T" $sAction="" $sFormat=$sLocalTime+$sFormat
         Case $sAction=="w"
            $sAction=(SerialDate($sDate)-SerialDate("1969/01/01")+2) mod 7 + 1
         Case $sAction=="W"
            Dim $iDate,$iNearestThursday,$iExcess,$iQuadYears,$iYear,$iDay
            $iDate=CInt(SerialDate($sDate)-SerialDate("1969/01/01"))
            $iNearestThursday=$iDate+4-(($iDate+2) mod 7 + 1)
            $iExcess=$iNearestThursday mod 1461
            $iQuadYears=($iNearestThursday-$iExcess)/1461
            $iDay=$iExcess mod 365
            $iYear=($iExcess-$iDay)/365
            If ($iYear=4) $iYear=3 $iDay=365 EndIf
            $sAction=Cstr(1969+4*$iQuadYears+$iYear)+"/"+Right("0"+Cstr(1+($iDay-($iDay mod 7))/7),2)
         Case $sAction=="x" $sAction="" $sFormat=$sLocalDate+$sFormat
         Case $sAction=="X" $sAction="" $sFormat=$sLocalTime+$sFormat
         Case $sAction=="y" $sAction=Right($aiDateBits[0],2)
         Case $sAction=="Y" $sAction=$aiDateBits[0]
         Case "Unknown Token" $sAction=$sIntro+$sAction
         EndSelect
         $udfFormatDate=$udfFormatDate+CStr($sAction)
      Else
         If $sAction==$sIntro
            $bTokenNext=1
         Else
            $udfFormatDate=$udfFormatDate+$sAction
         EndIf
      EndIf
   Loop

   If $bTokenNext $udfFormatDate=$udfFormatDate+$sIntro EndIf

EndFunction ; }}}
Exit 0

{EDIT}
Oops. Missed a "th" in $sOrdinal
Double-oops. Wrong month returned.
{/EDIT}
 
 [ 15. July 2003, 15:15: Message edited by: Richard H. ]82331udfGet22Richard H.udfGet(), udfGetS() - Extended keyboard input03 December 2001 - cross posted from scripts

The attached script is actually a library containing three UDFs.  These functions supplement the KiXtart commands of the same name and can be used as direct replacements.  The functions and their features are:

udfFlushKB()
Flushes all keyboard input.  Also flushes the library input buffer.

udfGet()
Returns a key press.  A timeout parameter can be given in milliseconds.  A default return value can also be specified.  If a function key is pressed it is returned using the same semantics as "SendKeys()".  There are some small differences which are documented in the UDF.
Examples
; Wait 5 seconds for a key to be pressed.  If no key is pressed return "Y"
$sKey=udfGet(5000,"Y")
; Wait for Alt-Home key to be pressed
While udfGet() <> "~{HOME}" Loop

udfGetS()
Returns a string of characters up to an "ENTER" key.
- A timeout expressed in millisecond may be specified.
- A default value to initialise the string may be specified.
- A maximum length to input may be specified.
- A password character may be specified to disguise the input - this character may be null ("") in which case no input is displayed.
If a function key is hit while waiting the UDF will return immediately with the function key value.
Examples
; Wait 30 seconds for a 10 character string.
$sInput=udfGetS(30000,"",10)
; Get a password, displaying "*" instead of characters type.
; Note, the while-loop construct handles function key presses and ignores them
$sInput=udfGetS(0,"",0,0,"*")
While @ERROR=2
   $sInput=udfGetS(0,"",0,0,"*")
Loop

The best way to see how the UDFs work is to try the demo script.

See the HTML version of the script here
Get the text version here
Get the demo script here

I recommend you get the script from the links above to preserve indenting and so-on, but here it is anyway.  If you are going to use the demo script make sure you save the UDFs as "libinput.kix", or change the "CALL" in the demo script to the file name and path that you save it as.

code:

; ____________________________________________________________
; ################ LIBRARY DEFINITION SECTION ################
;
; LIBRARY FILENAME:	libinput.kix
;
; LIBRARY DESCRIPTION:	Extended keyboard input routines
;
; LIBRARY COMMENTS:	Comprises the following functions:
;			udfGet()	Get a character from keyboard input
;			udfGetS()	Get a string from keyboard input
;			udfFlushKB()	Flush input buffers
;
;			KBHIT() Not available until KiXtart 4.00 RC3
;
; DEPENDENCIES:		KiXtart Version 4.00 RC3
;			British keyboard layout
;
; VERSION:		1.00
;
; MAINTAINER:		rhowarth@sgb.co.uk
;
; AMENDMENT HISTORY:
;     Date     Version  Name / details
; ------------ -------  -----------------------------
; 19 Nov 2001     1.00  Richard Howarth
;                       Initial creation and public release
;
; Exported library information
$_sLIBName="libinput"
$_sLIBVersion="100"
$_sLIBLastUpdate="15 November 2001"
$_sLIBDesc="libinput: Extended keyboard input"
$_sLIBUpdate="Search Kixtart BB http://www.kixtart.org/" 
$_sLIBMaintainerFullName="Richard Howarth"
$_sLIBMaintainerEmail="rhowarth@@sgb.co.uk"
$_sLIBRequires="KiXtart=4.00"
$_sLIBProvides="udfGet udfGetS udfFlushKB"
If VarType($_libinput__INCLUDED) = 0
	$_libinput__INCLUDED=1
; ____________________________________________________________
; ################# GLOBAL DEFINITION SECTION ################
; Global variables local to this library
; These are only initialised the first time the library is loaded.
	$_libinput_sInputBuffer=""	; Buffer string input for udfGetS()
	$_libinput_iInputBuffer=0	; Number of character in buffer
	$_libinput_iSleepTicks=5	; Give up processing while awaiting input
	$_libinput_METAKEY=224		; Get value for function key metakey
	$_libinput_FUNCTIONKEY=&02	; Extended function key code returned
	$_libinput_UNMODIFIED=" "	; Character to indicate an unmodified funtion key
	$_libinput_SHIFTKEY="+"		; Shift key pressed
	$_libinput_CONTROLKEY="^"	; Control key pressed
	$_libinput_ALTKEY="~"		; Alt key pressed
	$_libinput_BACKSPACE=8		; Backspace key
	$_libinput_RETURN=13		; Return key
	$_libinput_DELETECHAR=Chr($_libinput_BACKSPACE) + " " + Chr($_libinput_BACKSPACE)
	$_libinput_sKeyString1=""
	$_libinput_sKeyString1=$_libinput_sKeyString1+"{HOME}    "
	$_libinput_sKeyString1=$_libinput_sKeyString1+"{UP}      "
	$_libinput_sKeyString1=$_libinput_sKeyString1+"{PGUP}    "
	$_libinput_sKeyString1=$_libinput_sKeyString1+"{UNKNOWN} "
	$_libinput_sKeyString1=$_libinput_sKeyString1+"{LEFT}    "
	$_libinput_sKeyString1=$_libinput_sKeyString1+"{UNKNOWN} "
	$_libinput_sKeyString1=$_libinput_sKeyString1+"{RIGHT}   "
	$_libinput_sKeyString1=$_libinput_sKeyString1+"{UNKNOWN} "
	$_libinput_sKeyString1=$_libinput_sKeyString1+"{END}     "
	$_libinput_sKeyString1=$_libinput_sKeyString1+"{DOWN}    "
	$_libinput_sKeyString1=$_libinput_sKeyString1+"{PGDN}    "
	$_libinput_sKeyString1=$_libinput_sKeyString1+"{INS}     "
	$_libinput_sKeyString1=$_libinput_sKeyString1+"{DEL}     "
	$_libinput_sKeyString2=""
	$_libinput_sKeyString2=$_libinput_sKeyString2+"{LEFT}    "
	$_libinput_sKeyString2=$_libinput_sKeyString2+"{RIGHT}   "
	$_libinput_sKeyString2=$_libinput_sKeyString2+"{END}     "
	$_libinput_sKeyString2=$_libinput_sKeyString2+"{PGDN}    "
	$_libinput_sKeyString2=$_libinput_sKeyString2+"{HOME}    "
	$_libinput_sKeyString3=""
	$_libinput_sKeyString3=$_libinput_sKeyString3+"{UP}      "
	$_libinput_sKeyString3=$_libinput_sKeyString3+"{UNKNOWN} "
	$_libinput_sKeyString3=$_libinput_sKeyString3+"{UNKNOWN} "
	$_libinput_sKeyString3=$_libinput_sKeyString3+"{UNKNOWN} "
	$_libinput_sKeyString3=$_libinput_sKeyString3+"{DOWN}    "
	$_libinput_sKeyString3=$_libinput_sKeyString3+"{INS}     "
	$_libinput_sKeyString3=$_libinput_sKeyString3+"{DEL}     "
EndIf	; If VarType($_libinput_INCLUDED)
; ____________________________________________________________
; ################ FUNCTION DEFINITION SECTION ###############
;
; FUNCTION:	udfGet()
;
; ACTION:	Returns a character from the keyboard queue
;		Extended characters are returned in the "{KEY}" format
;
; SYNTAX:	udfGet(optional TimeOut,optional Default)
;
; PARAMETERS:	TimeOut  Integer Optional
;                        Mimumum time to wait for keypress in milliseconds.
;                        If not set then wait is infinite.
;		Default  String  Optional
;			 String to return if no key pressed.
;			 If not set the null string is returned.
;
; RETURNS:	The following table describes the return values:
;		TimeOut Default Keypressed?  =  Returned     @ERROR
;               ------- ------- -----------     --------     ------
;                  N       Y         Y       =  Keypress        0 or 2
;                  N       N         Y       =  Keypress        0 or 2
;                  Y       Y         Y       =  Keypress        0 or 2
;                  Y       Y         N       =  Default         0 or 2
;                  Y       N         Y       =  Keypress        0 or 2
;                  Y       N         N       =  Empty string    1
;		
;		If an function key is pressed then @ERROR = 2
;		Function keys are the same as for SENDKEYS() with the
;		following differences:
;		1) The keys "{","}","+","^" and "~" are returned just as simple
;		   characters.
;		2) Unmodified function keys are prepended with a space character
;		3) Control characters such as backspace are returned as simple
;		   characters
;
;
; REMARKS:	There is not a millisecond sleep function yet, so
;		I don't know how to give up CPU in a sensible manner.
;		The pseudocode is commented out at the *TODO* line.
;		If a metacharacter is received indicating an arrow key
;               or similar the process drops out of the timeout state
;		and waits permanently for the key indicator.  This may
;		be a bug.
;		All the coding and values are for a UK keyboard. YMMV.
;		On My keyboard F12 and Control-PageUp are the same !?
; SOURCE:
Function udfGet(
	OPTIONAL $iTimeOut,
	OPTIONAL $sDefault
	)
	;
	; Local variables
	Dim $iMetaReceived
	Dim $iFKey

	; Sanity check on timeout.
	$iTimeOut=Val("$iTimeOut")
	If $iTimeOut $iTimeOut=$iTimeOut+@TICKS EndIf

	While "true" ; Key parse loop
		If $iTimeOut=0 OR KBHit()
			Get $udfGet
			$iFKey=@ERROR
			$udfGet=Asc($udfGet)
			Select  ; MAIN Select
			Case $udfGet=0 ; Function key pressed.
				Select ; FUNCTION KEY Select
				Case $iFKey < 59	; Unknown function key.
					$udfGet=" {UNKNOWN FKEY $iFKey}"
					Exit 1
				Case $iFKey < 69	; Unmodified function key.
					$iFKey=$iFKey-58
					$udfGet=" {F$iFKey}"
				Case $iFKey < 84	; Unknown function key.
					$udfGet=" {UNKNOWN FKEY $iFKey}"
					Exit 1
				Case $iFKey < 94	; Shift function key.
					$iFKey=$iFKey-83
					$udfGet="$_libinput_SHIFTKEY{F$iFKey}"
				Case $iFKey < 104	; Control function key.
					$iFKey=$iFKey-93
					$udfGet="$_libinput_CONTROLKEY{F$iFKey}"
				Case $iFKey < 114	; ALT function key.
					$iFKey=$iFKey-103
					$udfGet="$_libinput_ALTKEY{F$iFKey}"
				Case $iFKey < 151
					$udfGet=" {UNKNOWN FKEY $iFKey}"
				Case $iFKey < 164
					$udfGet="$_libinput_ALTKEY" + RTrim(substr($_libinput_sKeyString1,(($iFKey-151)*10)+1,10))
				Case "true"
					$udfGet=" {UNKNOWN FKEY $iFKey}"
					Exit 1
				EndSelect ; FUNCTION KEY Select
				Exit $_libinput_FUNCTIONKEY
			Case $udfGet=$_libinput_METAKEY
				$iTimeOut=0
				$iMetaReceived=1
			Case $iMetaReceived
				Select ; METAKEY Select
				Case $udfGet < 71
					$udfGet=" {UNKNOWN METAKEY $udfGet}"
					Exit 1
				Case $udfGet < 84
					$udfGet=" " + RTrim(Substr($_libinput_sKeyString1,(($udfGet-71)*10)+1,10))
				Case $udfGet < 115
					$udfGet=" {UNKNOWN METAKEY $udfGet}"
					Exit 1
				Case $udfGet < 120
					$udfGet="$_libinput_CONTROLKEY" + RTrim(Substr($_libinput_sKeyString2,(($udfGet-115)*10)+1,10))
				Case $udfGet < 133
					$udfGet=" {UNKNOWN METAKEY $udfGet}"
					Exit 1
				Case $udfGet < 135
					$udfGet=" {F" + ($udfGet-122) + "}"
				Case $udfGet < 137
					$udfGet="$_libinput_SHIFTKEY{F" + ($udfGet-124) + "}"
				Case $udfGet < 139
					$udfGet="$_libinput_CONTROLKEY{F" + ($udfGet-126) + "}"
				Case $udfGet < 141
					$udfGet="$_libinput_ALTKEY{F" + ($udfGet-128) + "}"
				Case $udfGet < 141
					$udfGet="{UNKNOWN METAKEY $udfGet}"
					Exit 1
				Case $udfGet < 148
					$udfGet="$_libinput_CONTROLKEY" + RTrim(Substr($_libinput_sKeyString3,(($udfGet-141)*10)+1,10))
				Case "true"
					$udfGet="{UNKNOWN METAKEY $udfGet}"
					Exit 1
				EndSelect ; METAKEY Select
				Exit $_libinput_FUNCTIONKEY
			Case "true"
				$udfGet=Chr($udfGet)
				Exit 0
			EndSelect ; MAIN Select
		EndIf ; If $iTimeOut=0 OR KBHit()
		If $iTimeOut
			If @TICKS > $iTimeOut
				If $sDefault = "" Exit 1 Endif
				$udfGet="$sDefault"
				If Len($udfGet) > 1 Exit $_libinput_FUNCTIONKEY Else Exit 0 EndIf
			EndIf
		EndIf
		; USleep($_libinput_iSleepTicks) ; *TODO* Give up CPU when available.
	Loop ; Key parse loop

EndFunction ; udfGet()
; ____________________________________________________________
; ################ FUNCTION DEFINITION SECTION ###############
;
; FUNCTION:	udfGetS()
;
; ACTION:	Returns a string from the keyboard queue
;
; SYNTAX:	udfGetS(optional TimeOut,optional Default,optional MaxLength,optional Redisplay,Optional Password)
;
; PARAMETERS:	TimeOut   Integer Optional
;                         Mimumum time to wait for string in milliseconds.
;                         If not set then wait is infinite.
;		Default   String  Optional
;			  Initial buffer set to this value
;			  If not set buffer is left as-is.
;			  If set Redisplay is also set.
;		MaxLength Integer Optional
;                         Maximum length of string, 0=system maximum
;		Redisplay Boolean Option
;			  If true, current buffer content is displayed
;		Password  Password character.
;			  If set, this character is displayed instead of what it typed.
;			  If blank, characters are not displayed as they are typed.
;			  If not set, characters are displayed normally.
;
; RETURNS:	The following table describes the return values:
;		TimeOut Enter Key?  =  Returned     @ERROR
;               ------- ----------     --------     ------
;                  N        Y       =  Buffer         0
;                  Y        Y       =  Buffer         0
;                  Y        N       =  Buffer         1
;		
;		If an function key is pressed then @ERROR = 2 and the function key pressed
;		is returned.  This happens immediately.  If you want to ignore function keys
;		then use the following contstruct:
;		  $sString=udfGetS()
;		  While @ERROR=2
;		      udfGetS()
;                 Loop
;
;		Function keys are the same as for udfGet()
;
; REMARKS:	There is not a millisecond sleep function yet, so
;		I don't know how to give up CPU in a sensible manner.
;		The pseudocode is commented out at the *TODO* line.
;		If a metacharacter is received indicating an arrow key
;               or similar the process drops out of the timeout state
;		and waits permanently for the key indicator.  This may
;		be a bug if it is possible for the metacharacter to be
;		typed on it's own.
;		All the coding and values are for a UK keyboard. YMMV.
; SOURCE:
Function udfGetS(
	OPTIONAL $iTimeOut,
	OPTIONAL $sDefault,
	OPTIONAL $iMaxLength,
	OPTIONAL $bRedisplay,
	OPTIONAL $sPassChar,
	)

	DIM $vKeyPressed	; Key pressed
	DIM $bHasPass		; Password character present

	; Sanity checks
	$iMaxLength=Val("$iMaxLength")
	$iTimeOut=Val("$iTimeOut")
	If VarType($sPassChar)
		$bHasPass=1
		$sPassChar=SubStr($sPassChar,1,1)
	Else
		$bHasPass=0
	EndIf

	If $iTimeOut $iTimeOut=$iTimeOut+@TICKS EndIf

	If $sDefault <> ""
		$_libinput_sInputBuffer=$sDefault
		$_libinput_iInputBuffer=Len($_libinput_sInputBuffer)
		$bRedisplay=1 ; Initialising the string implies this.
	EndIf

	If $iMaxLength AND $_libinput_iInputBuffer > $iMaxLength
		$_libinput_iInputBuffer=$iMaxLength
		$_libinput_sInputBuffer=SubStr($_libinput_sInputBuffer,1,$_libinput_iInputBuffer)
	EndIf

	; Redisplay current buffer contents
	If $bRedisplay
		If $bHasPass
			For $i = 1 To $_libinput_iInputBuffer $sPassChar Next
		Else
			$_libinput_sInputBuffer
		EndIf
	EndIf

	While "true" ; MAIN while loop
		If $iTimeOut=0 OR KBHit()
			$vKeyPressed=udfGet()
			If @ERROR=$_libinput_FUNCTIONKEY $udfGetS=$vKeyPressed Exit $_libinput_FUNCTIONKEY Endif
			$vKeyPressed=Asc($vKeyPressed)
			Select
			Case $vKeyPressed=$_libinput_BACKSPACE
				If $_libinput_iInputBuffer
					$_libinput_iInputBuffer=$_libinput_iInputBuffer-1
					$_libinput_sInputBuffer=SubStr($_libinput_sInputBuffer,1,$_libinput_iInputBuffer)
					If $bHasPass
						If $sPassChar <> "" $_libinput_DELETECHAR EndIf
					Else
						$_libinput_DELETECHAR
					EndIf
				Else
					Beep()
				EndIf
			Case $vKeyPressed=$_libinput_RETURN
				$udfGetS=$_libinput_sInputBuffer
				$_libinput_sInputBuffer=""
				$_libinput_iInputBuffer=0
				Exit 0
			Case "true"
				If $iMaxLength AND ($_libinput_iInputBuffer >= $iMaxLength)
					Beep()
				Else
					$_libinput_iInputBuffer=$_libinput_iInputBuffer+1
					$_libinput_sInputBuffer="$_libinput_sInputBuffer" + Chr($vKeyPressed)
					If $bHasPass
						$sPassChar
					Else
						Chr($vKeyPressed)
					EndIf
				EndIf
			EndSelect
		EndIf ; If $iTimeOut=0 OR KBHit()

		If $iTimeOut
			If @TICKS > $iTimeOut
				$udfGetS=$_libinput_sInputBuffer
				$_libinput_sInputBuffer=""
				$_libinput_iInputBuffer=0
				Exit 1
			EndIf
		EndIf
		; USleep($_libinput_iSleepTicks) ; *TODO* Give up CPU when available.
	Loop ; MAIN while loop
EndFunction ; udfGetS()
; ____________________________________________________________
; ################ FUNCTION DEFINITION SECTION ###############
;
; FUNCTION:	udfFlushKB()
;
; ACTION:	Flushes the keyboard queue and anything already read into the input buffer.
;
; SYNTAX:	udfFlushKB()
;
; PARAMETERS:	None
;
; RETURNS:	None
;
; REMARKS:	The FlushKB() bug has been fixed, buy I'm leaving the kludge in as
;		I'm still running a pre-fix version of KiXtart.
; SOURCE:
Function udfFlushKB()
	$_libinput_sInputBuffer=""
	$_libinput_iInputBuffer=0
	FlushKB() ; Occasionally buggy, so...
	While KBHit() Get $ Loop
EndFunction
; ____________________________________________________________
; ###################### END OF LIBRARY ######################


... and here is the demo script...

code:

Color w/n
Break ON CLS

CALL libinput.kix

If $_libinput__INCLUDED
Else
	"Dependant library missing - cannot continue." ?
EndIf
"udfGet() demo 1" ?
"---------------" ?

" Hit keys on the keyboard. Try the function keys with shift, control and alt." ?
" Hit the 'End' key when you get bored..." ?
While $sKey <> " {END}"
	Color c/n
	"Enter key: " 
	$sKey=udfGet()
	Color w/n
	Chr(13)
	Color w/n
	If @ERROR = 2
		 "You hit function key $sKey" ?
	Else
		 "You hit key $sKey : (" Asc($sKey) ")" ?
	EndIf
Loop

Cls
Color w/n
"udfGet() demo 2" ?
"---------------" ?
"Hit any key to begin: "
Color w/n
$sKey=udfGet()
Color c/n
AT(3,0) "Hit the '*' key before the countdown reaches zero!!"
$iCountDown=10
While $iCountDown > 0
	$iCountDown=$iCountDown-1
	Select
	Case $iCountDown < 4 Color r+/n
	Case $iCountDown < 8 Color y+/n
	Case "true" Color g+/n
	EndSelect
	AT(5,8) Big $iCountDown Small Color w/n
	If udfGet(1000) = "*" $iCountDown=(-1) EndIf
Loop

CLS

If $iCountDown=0
	Color r+/n Big "**BOOM**" ? Small
	"You Were too slow!" ?
Else
	Color w/n "Phew! you found it in time!" ?
EndIf

Color c/n
"Hit a key to continue immediately or wait 10 seconds" 
Color w/n
$=udfGet(10000)


Cls
"udfGetS() Demo 1" ?
"----------------" ?
Color c/n
"Enter a password, you will only see '*' characters as you type: "
$sInput=udfGetS(0,"",0,0,"*") ?
Color w/n
"Your password was : " $sInput ?
Color c/n
"Enter another password, you will not see anything as you type: "
$sInput=udfGetS(0,"",0,0,"") ?
Color w/n
"Your second password was : " $sInput ?
Color c/n
"Hit a key to continue immediately or wait 10 seconds" 
Color w/n
$=udfGet(10000)

Cls
"udfGetS() Demo 2" ?
"----------------" ?
" Notice how the clock keeps changing, even while you are typing..."
udfFlushKB() ; Start afresh
$sClock=@TIME
Color y+/n
AT(4,8) BIG $sClock SMALL
Color c/n
AT(12,10) " Enter string: [          ]" 
Color w/n
AT(12,26) $sInput=udfGetS(900,"",10,0)
While @ERROR	; Function key or timeout.
	If @ERROR=2 $sInput="" EndIf ; Ignore function keys
	If $sClock <> @TIME
		$sClock=@TIME
		Color y+/n
		AT(4,8) BIG $sClock SMALL
	EndIf
	Color w/n
	AT(12,26) $sInput=udfGetS(900,$sInput,10,1)
Loop

[ 03 December 2001: Message edited by: Richard Howarth ]82472udfIsType22Richard H.udfIsType() - Returns true if character is "Type"0This short library implements the 'C' character type functions.

Each function returns "True" is the character is the matches the type.

The functions implemeted are:
udfIsLower()	Returns TRUE if first character is lower case letter (a-z)
udfIsUpper()	Returns TRUE if first character is upper case letter (A-Z)
udfIsAlpha()	Returns TRUE if first character is a letter (a-z,A-Z)
udfIsDigit()	Returns TRUE if first character is a digit (0-9)
udfIsAlNum()	Returns TRUE if first character is a letter or digit (a-z,A-Z,0-9)
udfIsXDigit()	Returns TRUE if first character is a hexadecimal digit (a-f,A-F,0-9)
udfIsPrint()	Returns TRUE if first character is ASCII printable (' ' to '~')
udfIsCntrl()	Returns TRUE if first character is NOT ASCII printable (' ' to '~')
udfIsPunct()	Returns TRUE if first character is printable but not letter, digit or space


code:

; udfCType.kix
;	Character type check
;
; ACTION:
;	 Check first character type and return 1 (True) or 0 (False)
;
; SYNTAX:
; 	udfIsLower()	Returns TRUE if first character is lower case letter (a-z)
; 	udfIsUpper()	Returns TRUE if first character is upper case letter (A-Z)
; 	udfIsAlpha()	Returns TRUE if first character is a letter (a-z,A-Z)
; 	udfIsDigit()	Returns TRUE if first character is a digit (0-9)
; 	udfIsAlNum()	Returns TRUE if first character is a letter or digit (a-z,A-Z,0-9)
; 	udfIsXDigit()	Returns TRUE if first character is a hexadecimal digit (a-f,A-F,0-9)
; 	udfIsPrint()	Returns TRUE if first character is ASCII printable (' ' to '~')
; 	udfIsCntrl()	Returns TRUE if first character is NOT ASCII printable (' ' to '~')
; 	udfIsPunct()	Returns TRUE if first character is printable but not letter, digit or space
;
; PARAMETERS:
;	String (or less usefully number) to check.
;
; RETURNS:
;	True (1) or False (0)
;
; REMARKS:
;	Only the first character of the parameter is checked.
;
; DEPENDANCIES:
;	KixTart 4.01
;
; EXAMPLE:
;	; Display the TRUE/FALSE character type table for all characters (1-254)
;	; Call in subroutines.
;	CALL udfCType.kix
; 
;	For $i = 1001 to 1254
;		If ($i-(20*($i/20))) = 1
;			?
;			"Char   IsXDigit  Alpha   Digit   AlNum   Lower   Upper   Print   Cntrl   Punct" ?
;			"----   --------  -----   -----   -----   -----   -----   -----   -----   -----" ?
;		EndIf
;		$c=Chr($i-1000)
;		Substr((""+$i),2,3) " ("
;		If udfIsPrint($c) $c Else ' ' EndIf
;		")      "
;		udfIsXDigit($c) "     "
;		udfIsAlpha($c) "       "
;		udfIsDigit($c) "       "
;		udfIsAlNum($c) "       "
;		udfIsLower($c) "       "
;		udfIsUpper($c) "       "
;		udfIsPrint($c) "       "
;		udfIsCntrl($c) "       "
;		udfIsPunct($c) ?
;	Next
;
If VarType($_udfCType_DEFINED) ; Code already called.
	RETURN
EndIf
GLOBAL $_udfCType_DEFINED	$_udfCType_DEFINED=1
;
GLOBAL $_udfCType_LowerA	$_udfCType_LowerA=Asc('a')
GLOBAL $_udfCType_LowerF	$_udfCType_LowerF=Asc('f')
GLOBAL $_udfCType_LowerZ	$_udfCType_LowerZ=Asc('z')
GLOBAL $_udfCType_UpperA	$_udfCType_UpperA=Asc('A')
GLOBAL $_udfCType_UpperZ	$_udfCType_UpperZ=Asc('Z')
GLOBAL $_udfCType_Digit0	$_udfCType_Digit0=Asc('0')
GLOBAL $_udfCType_Digit9	$_udfCType_Digit9=Asc('9')
GLOBAL $_udfCType_PrintFirst	$_udfCType_PrintFirst=Asc(' ')
GLOBAL $_udfCType_PrintLast	$_udfCType_PrintLast=Asc('~')
;-------------------------------------------------------------------------udfIsLower()
Function udfIsLower($c)
	$udfIsLower=1
	$c=Asc(Substr("" + $c,1,1)) ; Parameter sanity check
	If $c < $_udfCType_LowerA OR $c > $_udfCType_LowerZ $udfIsLower=0 EndIf
EndFunction
;-------------------------------------------------------------------------udfIsUpper()
Function udfIsUpper($c)
	$udfIsUpper=1
	$c=Asc(Substr("" + $c,1,1)) ; Parameter sanity check
	If $c < $_udfCType_UpperA OR $c > $_udfCType_UpperZ $udfIsUpper=0 EndIf
EndFunction
;-------------------------------------------------------------------------udfIsDigit()
Function udfIsDigit($c)
	$udfIsDigit=1
	$c=Asc(Substr("" + $c,1,1)) ; Parameter sanity check
	If $c < $_udfCType_Digit0 OR $c > $_udfCType_Digit9 $udfIsDigit=0 EndIf
EndFunction
;-------------------------------------------------------------------------udfIsAlpha()
Function udfIsAlpha($c)
	$udfIsAlpha=udfIsLower($c) OR udfIsUpper($c)
EndFunction
;-------------------------------------------------------------------------udfIsAlNum()
Function udfIsAlNum($c)
	$udfIsAlNum=udfIsAlpha($c) OR udfIsDigit($c)
EndFunction
;-------------------------------------------------------------------------udfIsXDigit()
Function udfIsXDigit($c)
	$c=substr(LCase("" + $c),1,1) ; Parameter sanity check
	$udfIsXDigit=udfIsDigit($c) OR (Asc($c)>=$_udfCType_LowerA AND Asc($c)<=$_udfCType_LowerF)
EndFunction
;-------------------------------------------------------------------------udfIsPrint()
Function udfIsPrint($c)
	$udfIsPrint=1
	$c=Asc(Substr("" + $c,1,1)) ; Parameter sanity check
	If $c < $_udfCType_PrintFirst OR $c > $_udfCType_PrintLast $udfIsPrint=0 EndIf
EndFunction
;-------------------------------------------------------------------------udfIsCntrl()
Function udfIsCntrl($c)
	$udfIsCntrl=NOT udfIsPrint($c)
EndFunction
;-------------------------------------------------------------------------udfIsPunct()
Function udfIsPunct($c)
	$c=substr("" + $c,1,1) ; Parameter sanity check
	$udfIsPunct=udfIsPrint($c) AND (NOT (udfIsAlNum($c) OR $c=' '))
EndFunction

[ 10 December 2001: Message edited by: Richard Howarth ]84630UDFparse119LonkeroUDFparse() - scan input string for defined UDFs0;FUNCTION  

;	UDFparse()  

;  

;AUTHOR  

;	Lonkero (Jooel_Nieminen@hotmail.com)  

;  

;ACTION  

;	returns the UDFs defined in input string  

;  

;VERSION  

;	2.1 

;  

;VERSION HISTORY  

;	2.1 

;		13. October 2003 

;		 - added mode for selecting input-type 

;	2.0 

;		13. October 2003 

;		 - Total rework from top to bottom 

;	1.0 

;		11. October 2003 

;		 - Initial release based on PP engine 

;  

;SYNTAX  

;	UDFparse(DATA, MODE) 

;  

;PARAMETERS  

;  

;	DATA	- string to scan the UDFs for  

;	MODE	- 0/1, 0 for string, 1 for file (optional) 

;  

;RETURNS  

;	array of defined UDFs 

;	if no UDFs, returns nothing 

;  

;REMARKS  

;	none  

;  

;DEPENDENCIES  

;	kixtart     

;  

;EXAMPLEs 

;	$=open(1,@scriptdir+"\Postprep1.0.3.2.kix")  

;	do $file=$file+readline(1)+@crlf until @error  

;	for each $UDFname in udfparse($file)  

;	 $UDFname ?  

;	next  

; 

;	for each $UDFname in udfparse(@scriptdir+"\Postprep1.0.3.2.kix",1)  

;	 $UDFname ?  

;	next 

; 

;	for each $UDF in UDFparse("function somename() endfunction"+ 

;		@crlf+"function someothername() endfunction") 

;	 $UDFname ?  

;	next  

;	get $ 

;  

;SOURCE  

function UDFparse($data,optional $mode)

dim $,$1,$2,$3

 if $mode

  $=open(1,$data) $data='' do $data=$data+readline(1)+@crlf until @error $=close(1)

 endif

 $=join(split(join(split(join(split($data,'	'),' '),chr(13)),''),chr(10)),chr(10)+' ')

 do

  $1=instr($,"'")

  $2=instr($,'"')

  $3=instr($,';')

  select

   case $1<$2 and $1<$3 $=substr($,1,$1-1)+substr($,instr(substr($,$1+1),"'")+1)

   case $2<$1 and $2<$3 $=substr($,1,$2-1)+substr($,instr(substr($,$2+1),'"')+1)

   case $3<$1 and $3<$2 $=substr($,1,$2-1)+substr($,instr(substr($,$2+1),chr(10))+1)

  endselect

 until 0=$1+$2+$3

 for each $ in split(' '+$,'endfunction')

  $=split($,' function ')

  if ubound($)=1

   $=trim(split($[1],'(')[0])

   if 0=instr($,'$$') and 0=instr($,'*') and 0=instr($,'+') and 0=instr($,'?') and 0=instr($,'\') and

   0=instr($,'/') and 0=instr($,'%%') and 0=instr($,'@@') and 0=instr($,'-') and 0=instr($,'.') and 0=instr($,',')

    $1=ubound($UDFparse)+1 redim preserve $UDFparse[$1] $UDFparse[$1]=$

  endif

endfunction


 
 [ 13. October 2003, 22:35: Message edited by: Lonkero ]83161udfPiper22Richard H.udfPiper() - Piping without temporary files!0With the advent of WSH there is no longer a requirement for an external program to perform this task - see Chris S. WshPipe() udf as an example: http://www.kixtart.org/ubbthreads/showflat.php?Cat=0&Number=82578&an=&page=0&vc=1 

Changes 12 June 2002
PIPER.EXE now at version 1.1
I've removed the blocking call to avoid potential dead-locking.
The Sleep() is now only executed if the script hasn't already picked up the data, which will potentially speed things up.

This is yet another pipe UDF.

This one uses an wrapper executable to gather the output and pass it back to KiXtart via the registry, so doesn't use temporary files.

On WinNT+ the registry call should block which will make it efficient - on Win95 I've had to kludge a 10ms sleep as the call is unsupported.

To use this UDF you will need the executable piper.exe  It is very small (5k) and is available  from this link.

For those of you that are paranoid and would prefer to compile the source yourself you can get it  here.
Anyhoo, here is the UDF:
Code:


;Function	udfPiper()
;
;Author		Richard Howarth (rhowarth@sgb.co.uk)
;
;Version	1.1
;
;Amendment History
;               11 June 2002 Version 1.1 RMH
;                   Well that didn't last long!
;                   Missing "EndIfs" spotted by SHAWN
;		11 June 2002 Version 1.0 RMH First released
;
;Action 	Starts a command and returns input
;
;Syntax		udfPiper(optional COMMAND,optional REGKEY)
;
;Parameters 
; 		COMMAND		: Dos command to start
;				  If not specified, returns a string from a
;				  previously piped command
;		REGKEY		: Optional registry subkey
;				  If not specified, "DEFAULT" is used
;
;Remarks
;		Spawns a program and returns the output a line at a time.
;		Doesn't require a temporary file to work.
;
;Returns	The nex available line.
;		Sets @ERROR=1 when all output exhausted.
; 
;Dependencies	Requires the "piper.exe" executable.
; 
; Example:
; Break ON
; udfPiper("dir")
; $sInput=udfPiper()
; While @ERROR=0
; 	$sInput ?
; 	$sInput=udfPiper()
; Loop
;
;Source
Function udfPiper(optional $sCommand, optional $sKey)
	Dim $ret

	If $sKey="" $sKey="DEFAULT" EndIf
	$sFullKey="HKEY_CURRENT_USER\SOFTWARE\KiXtart\Piper\$sKey"
	If $sCommand <> ""
		$ret=AddKey($sFullKey)
		If($ret) Exit $ret EndIf
		$ret=WriteValue($sFullKey,"Status",0,"REG_DWORD")
		Run('piper $sKey "$sCommand"')
	Else
		$ret=ReadValue($sFullKey,"Status")
		If @ERROR @ERROR ": " @SERROR Exit @ERROR EndIf
		While $ret <> 1
			If $ret=3 ; All input drained.
				$ret=DelKey($sFullKey)
				Exit 1
			Endif
			$ret=ReadValue($sFullKey,"Status")
			If @ERROR @ERROR ": " @SERROR Exit @ERROR EndIf
		Loop
		$udfPiper=ReadValue($sFullKey,"Input")
		$ret=WriteValue($sFullKey,"Status",2,"REG_DWORD")
	EndIf
	Exit 0
EndFunction 

Function udfPiperAbort(optional $sKey)
	If $sKey="" $sKey="DEFAULT" EndIf
	$sKey="HKEY_CURRENT_USER\SOFTWARE\KiXtart\Piper\$sKey"
	$ret=WriteValue($sKey,"Status",99,"REG_DWORD")
EndFunction

83047udfReadProfileString22Richard H.udfReadProfileString() - Enhanced KiX function.0The native KiXtart ReadProfileString() has a few problems.

It doesn't always return an error for a missing file.

There is no way to tell the difference between a missing section / key, and a key that has a null value.
This drop in replacement fixes both these problems.  The error numbers that I have chosen for missing section and missing key are the ones that made some sort of sense in the contaxt - or at least the english ones do     If you don't like them then change the "ERROR_" constants.
Note, I've also chosen to identify a missing file as one that has no sections.  Kludgy, but it should be OK.

code:

;Author         Richard Howarth <rhowarth@sgb.co.uk>
;
;Parameters     As ReadProfileString vis:
;		$sFilename: Name of file in "ini" format.
;               $sSection: Name of section to read. If null, all section names are returned.
;               $sKey: Name of value to read.  If null all values in section are returned.
;
;Remarks        If there is no path in the filename specification KiXtart will look in C:\WINDOWS
;		or equivalent.  If the file is local use a relative path ".\filename" to read it.
;		I've chosen to make the section and value parameters optional.
;
;Returns        Value, Value list or Section list on success depending on parameters.
;               @ERROR on error.  I use the following values:
;			2 - File missing, or has no sections
;			3 - Section missing
;			6 - Value missing
;		Change the $ERROR_* constants if you don't like these numbers.
;
;Dependencies   None
;
;Example(s)	$sSectionList=udfReadProfileString(".\config.ini","","")
;			Returns all sections in file "config.ini"
;		$sSectionList=udfReadProfileString(".\config.ini")
;			Same as first example, but trailing parameters are omitted
;		$sSectionList=udfReadProfileString(".\config.ini","printers")
;			Returns all entries in the "printers" section
;		$sSectionList=udfReadProfileString(".\config.ini","printers","LaserJet")
;			Returns the value for the "LaserJet" entry in the "printers" section
;
Function udfReadProfileString($sFilename,optional $sSection,optional $sKey)
	$ERROR_FORMAT=2		; Error returned if file missing or has no sections.
	$ERROR_SECTION=3	; Error returned if section is not present
	$ERROR_VALUE=6		; Error returned if value is not present
	$CHR10=Chr(10)		; Seperator used by ReadProfileString
;
	$udfReadProfileString=""
;
	$sResult=ReadProfileString($sFileName,"","")
	If @ERROR Exit @ERROR EndIf  ; Return true errors
	If $sResult="" Exit $ERROR_FORMAT EndIf ; Kludge for missing file.
	If $sSection="" $udfReadProfileString=$sResult Return EndIf
	If InStr($CHR10 + $sResult,$CHR10 + $sSection + $CHR10) = 0 Exit $ERROR_SECTION EndIf
;
	$sResult=ReadProfileString($sFileName,$sSection,"")
	If @ERROR Exit @ERROR EndIf  ; Return true errors
	If $sKey="" $udfReadProfileString=$sResult Return EndIf
	If InStr($CHR10 + $sResult,$CHR10 + $sKey + $CHR10) = 0 Exit $ERROR_VALUE EndIf
;
	$sResult=ReadProfileString($sFileName,$sSection,$sKey)
	If @ERROR Exit @ERROR EndIf  ; Return true errors
	$udfReadProfileString=$sResult 
;
	Return
EndFunction

84413udfScreenProperty22Richard H.udfScreenProperty() - Return a property of the screen0

code:

;Function	udfScreenProperty()
;
;Author		Richard Howarth (rhowarth@sgb.co.uk)
;
;Contributors	
;
;Action		Returns a property of the visible screen
;
;Syntax		udfScreenProperty("PropertyToReturn")
;
;Version	1.0
;
;Date           1 July 2003
;
;Date Revised   
;
;Parameters 	Property 
;
;Remarks	The property is not validated, to allow for new properties
;		to be supported as they come along.
;		Garbage in, garbage out
;               Check MS documentation for properties available
;               from the "Screen" object.  Some useful properties
;               have been included in the sample code.
;
;Returns	Returns the property value if present
;		@ERROR non-zero on an error
; 
;Dependencies 	IE (Probably 5.5)
;
;KiXtart Ver	4.02
; 
;Example
;	$asProperties="height","width","pixelDepth","colorDepth","bufferDepth",
;			"availHeight","availWidth","availTop","availLeft",
;			"deviceXDPI","deviceYDPI","logicalXDPI","logicalYDPI",
;			"fontSmoothingEnabled","updateInterval"
;	For Each $sProperty in $asProperties
;		$sProperty+" = "+udfScreenProperty($sProperty)+@CRLF
;	Next
;
  
Function udfScreenProperty($sProperty)
	Dim $oIE
	 
	$oIE=CreateObject("InternetExplorer.Application")
	If $oIE
		$oIE.navigate("about:blank") While $oIE.busy and $oIE.readystate<>4 and @ERROR=0 Loop
		$oIE.document.write("<HTML><HEAD>
		  <SCRIPT Language=JavaScript>
		   function funReadInfo() { frmScreen.property.value=screen."+$sProperty+"; }
		  </SCRIPT>
		 </HEAD>
		 <BODY onLoad='funReadInfo()'>
		  <FORM Name=frmScreen><INPUT Type=Hidden Name=property></FORM>
		 </BODY>
		</HTML>")
		; Refresh to execute "onLoad"
		$oIE.refresh() While $oIE.busy and $oIE.readystate<>4 and @ERROR=0 Loop
		$udfScreenProperty=$oIE.document.frmScreen.property.value
		$oIE.quit
	Else
		Exit 1406
	EndIf
	Exit 0
EndFunction

{EDIT}
Oops. Forgot to comment out example code.
{/EDIT}
 
 [ 07. July 2003, 09:44: Message edited by: Richard H. ]83351udfSqueeze22Richard H.udfSqueeze() - Reduce repeated characters in a string.0

code:

;
; FUNCTION:	udfSqueeze()
;
; AUTHOR:	Richard Howarth (rhowarth@sgb.co.uk)
;
; HISTORY:	18 Jul 2003   RMH   Initial release.
;
; ACTION:	Removes repeated characters from a string
;
; SYNTAX:	udfString(String, Delimiters, TrimFlag)
;
; PARAMETERS:	
;	String		(MANDATORY) String to remove characters from.
;	Delimiters	(OPTIONAL)  Characters to squeeze - default is space " "
;	TrimFlag	(OPTIONAL)  Boolean flag. Trim characters from start and end of string
;				    as well as squeezing.
;
; RETURNS:	Squeezed string
;
; REMARKS:	If a single delimiter is defined a faster method is used to squeeze the string.
;		If multiple delimiters are defined they are replaced with the first character
;		in the delimiter paramater, i.e.
;			udfSqueeze("5432","123456789") would return "1"
;		Multiple delimiters are most useful for example when parsing sentences and you
;		want to split the input up into words, or parsing a file where the fields may
;		be delimited by both space and tab characters.
;
; DEPENDENCIES:	KiXtart 4.00
; 
; EXAMPLE:
;   Example - A sentence parser.
;   ----------------------------
;	$sSentence="This is a sentence, which will be tokenised (into words)."
;	$asWordList=Split(udfSqueeze($sSentence," ,.()","true"))
;	For $iIndex=0 To Ubound($asWordList)
;		"Word # " $iIndex+1 " = " $asWordList[$iIndex] ?
;	Next
;
;   Example output:
;   ---------------
;	Word # 1 = This
;	Word # 2 = is
;	Word # 3 = a
;	Word # 4 = sentence
;	Word # 5 = which
;	Word # 6 = will
;	Word # 7 = be
;	Word # 8 = tokenised
;	Word # 9 = into
;	Word # 10 = words
; 
; SOURCE:
	
Function udfSqueeze($sSource,Optional $sDelimiters, Optional $bTrim)
	Dim $iSourceLength	$iSourceLength=0
	Dim $iIndex		$iIndex=0
	Dim $iLastGood		$iLastGood=0
	Dim $bFound		$bFound=0
	
	$udfSqueeze=""
	
	; --------------------------
	; Defaults and sanity checks
	; --------------------------
	If $sDelimiters="" $sDelimiters=" " EndIf
	If $bTrim $bTrim=1 Else $bTrim=0 EndIf
	
	; ----------------------------------------
	; High speed squeeze for single characters
	; ----------------------------------------
	If Len($sDelimiters)=1
		$sDelimiters=""+$sDelimiters+$sDelimiters
		$iIndex=InStr($sSource,$sDelimiters)
		While $iIndex
			$sSource=""+SubStr($sSource,1,$iIndex)+SubStr($sSource,$iIndex+2,Len($sSource))
			$iIndex=InStr($sSource,$sDelimiters)
		Loop
		If $bTrim
			$sDelimiters=SubStr($sDelimiters,1,1)
			; -------------
			; Trim leading.
			; -------------
			While SubStr($sSource,1,1)=$sDelimiters
				$sSource=SubStr($sSource,2,Len($sSource))
			Loop
			; --------------
			; Trim Trailing.
			; --------------
			$iIndex=Len($sSource)
			While SubStr($sSource,$iIndex,1)=$sDelimiters
				$sSource=SubStr($sSource,1,$iIndex-1)
				$iIndex=Len($sSource)
			Loop
		EndIf
		$udfSqueeze=$sSource
	Else
	; --------------------------------------
	; Slower squeeze for multiple characters
	; --------------------------------------
		$iSourceLength=Len($sSource)
		For $iIndex = 1 To $iSourceLength
			$cChar=SubStr($sSource,$iIndex,1)
			If InStr($sDelimiters,$cChar)
				If $bFound=0 AND ( $iLastGood OR $bTrim=0 )
					$udfSqueeze=""+$udfSqueeze+SubStr($sDelimiters,1,1)
				EndIf
				$bFound=1
			Else
				$bFound=0
				$udfSqueeze=""+$udfSqueeze+$cChar
				If $bTrim $iLastGood=Len($udfSqueeze) EndIf
			EndIf
		Next
		If $iLastGood $udfSqueeze=SubStr($udfSqueeze,1,$iLastGood) EndIf
	EndIf
	
EndFunction

82814udfStrToBin22Richard H.udfStrToBin() - Return binary representation of a string0

code:

; Function:	udfStrToBin()
;
; Action:	Returns the binary representation of a string
;
; Author:	Richard Howarth (rhowarth@sgb.co.uk)
;
; History:	11 Jan 2002 RMH : Inital release
;
; Syntax:	$udfStrToBinRepresentation=udfStrToBin("string")
;
; Parameters:	String, constant or variable 
;
; Returns:	Binary representation of string
;
; Remarks:	Developed as a response to a problem in the Scripts forum,
;		but may be useful for writing binary coded strings to the
;		registry.
;		NB You will be restricted by KiXtarts string length, which IIRC
;		is 32K, so as each character requires 8 bytes the longest string
;		that you can convert will be 32K/8, or 4095 characters (one
;		character is reserved for the end-of-string '\0'
;		The binary representation is taken from lookup tables as this makes
;		the code far simpler and it should be much quicker than calculating
;		it.
;
;Dependencies:	None
; 
;Example:	udfStrToBin("Example") 
;		Returns: 01000101011110000110000101101101011100000110110001100101
; 
;Source
Function udfStrToBin($sParameter)
	
; Local variable declaration
Dim $sChar
Dim $iParameterLen
Dim $iCounter
Dim $iMSB
Dim $iLSB
Dim $sBinValues[15]	; *TODO* Possibly convert to string if arrays are not efficient.
			; *TODO* Benchmark sometime if the urge overcomes me, heh.
	
; Local variable initialisation
 $sBinValues[0]="0000"
 $sBinValues[1]="0001"
 $sBinValues[2]="0010"
 $sBinValues[3]="0011"
 $sBinValues[4]="0100"
 $sBinValues[5]="0101"
 $sBinValues[6]="0110"
 $sBinValues[7]="0111"
 $sBinValues[8]="1000"
 $sBinValues[9]="1001"
$sBinValues[10]="1010"
$sBinValues[11]="1011"
$sBinValues[12]="1100"
$sBinValues[13]="1101"
$sBinValues[14]="1110"
$sBinValues[15]="1111"
	
$udfStrToBin=""	; Initialise as an empty, force to string type
$iParameterLen=Len($sParameter)
$iCounter=0
$iMSB=0
$iLSB=0
	
; The code.
While $iCounter < $iParameterLen
	$iCounter=$iCounter+1
	$iChar=Asc(SubStr($sParameter,$iCounter,1))
	$iMSB=$iChar/16
	$iLSB=$iChar-($iMSB*16)
	$udfStrToBin="" + $udfStrToBin + $sBinValues[$iMSB] + $sBinValues[$iLSB]
Loop
	
; That's all folks.
Return
EndFunction

EDIT: Added the CODE tags to format correctly.

[ 16 January 2002: Message edited by: Richard Howarth ]83186udfSubStr22Richard H.udfSubStr(): Flexible replacement for substr()0...and in second place...

The udfSubStr() function is a direct replacement for the native SubStr().

The improvements are that the start and length parameters may be negative, in which case they are counted from the end of the file.

code:

; Author	Richard Howarth (rhowarth@sgb.co.uk)
;
; Version	1.0
;
; Amendmend History
;		13 June 2002 RMH Version 1.0 Initially released.
;
; Function	udfSubStr()
;
; Parameters
;		$iString:        String to perform substring on.
;		$iStartPosition: Position to start substring.
;				 May be negative to indicate a count from
;                                the end of the string.
;		$iLength:	 (Optional) Number of characters to substring.
;                                May be negative to indicate a count from
;                                the end of the string.
;                                If not present defaults to the end of the string.
;
; Remarks	May be used as a direct replacement for native SubStr()
;
; Dependencies	None
;
; Examples
;   udfSubStr("ABCDE",3,1)       Returns "C"
;   udfSubStr("ABCDE",3,-1)      Returns "CDE"
;   udfSubStr("ABCDE",2,-2)      Returns "BCD"
;   udfSubStr("ABCDE",-3,-3)     Returns "C"

Function udfSubStr($sString,$iStartPosition,optional $iLength)
	Dim $iStringLength

	$udfSubStr=""
	; Cast parameters to correct type
	$iStartPosition=Val($iStartPosition)
	$sString="" + $sString

	$iStringLength=Len($sString)
	If $iStartPosition < 0 $iStartPosition=$iStringLength+1+$iStartPosition EndIf
	If $iStartPosition < 1 Exit 1 Endif
	Select
	Case VarType($iLength)=0
		$iLength=$sStringLength-$iStartPosition+1
	Case Val($iLength)<0
		$iLength=$iStringLength-$iStartPosition+$iLength+2
	Case "True"
		$iLength=Val($iLength)
	EndSelect
	If $iLength < 1 Exit 1 EndIf

	$udfSubStr=SubStr($sString,$iStartPosition,$iLength)
EndFunction


 
 [ 13 June 2002, 16:25: Message edited by: Richard Howarth ]84239uniq2980Glenn Barnasuniq() - remove duplicates from a sorted array0I found that when generating lists of servers using WMI tools, I would occasionally get duplicate names. Sometimes a server would respond to queries from multiple domains.

I wrote this UDF to remove the duplicates after sorting the array via the QS() udf.

Glenn

5/16 - added the DIM and comment for the pointer vars


;;
;;======================================================================
;;
;;FUNCTIONÿ ÿ ÿ ÿuniq()
;;
;;ACTIONÿ ÿ ÿ ÿ ÿRemovesÿduplicatesÿfromÿaÿsorted,ÿ1-dimensionÿarray
;;
;;AUTHORÿ ÿ ÿ ÿ ÿGlennÿBarnasÿ/ÿFRIT-EROC
;;
;;SYNTAXÿ ÿ ÿ ÿ ÿuniq(array)
;;
;;PARAMETERSÿ ÿ ÿarrayÿ-ÿarrayÿtoÿremoveÿduplicatesÿfrom
;;
;;REMARKSÿ ÿ ÿ ÿ Arrayÿmustÿbeÿsortedÿfirstÿ-ÿnoÿcheckÿforÿsortÿisÿperformed
;;
;;RETURNSÿ ÿ ÿ ÿ arrayÿwithÿduplicateÿitemsÿremoved
;;
;;DEPENDENCIESÿ ÿnone
;;
;;TESTEDÿWITHÿ ÿ NT4,ÿW2K,ÿWXP
;;
;;EXAMPLESÿ ÿ ÿ ÿ$Singlesÿ=ÿUniq($has_dups)
;
FunctionÿUniq($A)

ÿ ;ÿ$TOPÿisÿlastÿentry,ÿ$Xÿisÿsourceÿpointer,ÿ$Yÿisÿdestinationÿpointer
ÿ Dimÿ$Top,ÿ$X,ÿ$Y
ÿ $Topÿ=ÿUBound($A)ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿFindÿsizeÿofÿoriginalÿarray
ÿ Dimÿ$WA[$Top]ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿCreateÿworkingÿarray

ÿ $Yÿ=ÿ1ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ;ÿoutputÿarrayÿpointer
ÿ $WA[0]ÿ=ÿCStr($A[0])ÿ ÿ ÿ ÿ ÿ ;ÿcopyÿfirstÿelement
ÿ Forÿ$Xÿ=ÿ1ÿtoÿ$Top
ÿ ÿ Ifÿ$WA[$Yÿ-ÿ1]ÿ<>ÿ$A[$X]ÿ ÿ ;ÿisÿcurrentÿvalueÿdifferentÿfromÿlast?
ÿ ÿ ÿ $WA[$Y]ÿ=ÿCStr($A[$X])ÿ ÿ ;ÿaddÿitÿtoÿoutput
ÿ ÿ ÿ $Yÿ=ÿ$Yÿ+ÿ1ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿincrementÿoutputÿpointer
ÿ ÿ EndIf
ÿ Next

ÿ ReDimÿPreserveÿ$WA[$Yÿ-ÿ1]ÿ ÿ ;ÿresizeÿoutputÿarray
ÿ $uniqÿ=ÿ$WAÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ ÿ;ÿreturnÿtheÿarrayÿofÿuniqueÿelements

EndFunction


 
 [ 16. May 2003, 16:03: Message edited by: Glenn Barnas ]83442unLink119LonkerounLink() - Delete shortcuts by target0

;Function:

;	unLink()

;

;Author:

;	Lonkero

;

;Version:

;	1.1 (18th of july 2003)

;

;Version hisotry:

;	1.0 (20th of november 2002)

;

;Action:

;	deletes shortcuts from specified path if it points to given target

;

;Syntax:

;	unLink(PATH,TARGET)

;

;Parameters:

;	PATH	- Place to search for the shortcuts

;	TARGET	- target for the shortcut to match against

;

;Returns:

;	nothing or relevant error

;

;Dependencies:

;	none

;

;Remarks:

;	tested to work with link-files pointing to file/folder/drive/share

;

;Example:   

;      "deleting old links from desktop..."

;      unLink("%userprofile%\Desktop","\\oldPDC\testers")

;

;Source:

function unlink($path,$target)

 dim $explorer,$item

 $explorer=createobject("shell.application")

 if @error exit @error endif

 for each $item in $explorer.namespace($path).items

	if $item.islink

	 if $target=$item.getlink.path

	  del $item.path

	  if @error exit @error endif

	 endif

	endif

 next

endfunction


 
 [ 18. July 2003, 01:10: Message edited by: Lonkero ]165309unmap10723Mike_Malsedunmap() - unmaps all printers1154461229Code:


;Function		UnMapPrinters()
;
;Author			Micheal Malsed (mike.malsed@cmc.edu)
;
;Action			Unmaps all printers currently mapped. 
;
;Syntax			unmap()
;
;Version:		2.0
;
;Date:           8-1-06
;
;Parameters: 	none, really. No variables get passed.
;
;Remarks:		Very simple - I run multiple labs and in order to deal with 
;		multiple printers on multiple servers in multiple labs 
;		all from one script, I need to clear the list before I remap.
;		Sounds stupid - why not just map over them? Well, I do move computers
;		from one lab to another (some are classrooms and thus are critical)
;		and one lab has multiple queues while others have only one. . .
;		This gives every computer a blank slate from which to work.
;
;Returns:		nothing
; 
;Dependencies;	None
;
;KiXtart Ver;	4.51, 3.50+
; 
;Example:		unmap()
; 


Function unmap("")

;==================================================================
;create an array of the currently installed printers
;==================================================================
	Dim $UNC[10]
	Dim $Index, $valuename, $servername, $remainder, $sharename,$i

	$Index = -1
	While @ERROR = 0 

		$Index = $Index + 1
		ReDim preserve $UNC[$index]
		If EnumKey( "HKEY_CURRENT_USER\Printers\Connections" , $Index ) <> ""
			$ValueName = EnumKey( "HKEY_CURRENT_USER\Printers\Connections" , $Index )
			$ValueName = SubStr($ValueName,3,999)
			$SERVERNAME= SubStr($Valuename,1,InStr($ValueName,",")-1)
			$Remainder = SubStr($ValueName,InStr($ValueName,",")+1,999)
			$SHARENAME= SubStr($Remainder,1,InStr($Remainder," ")-1)
			$UNC[$Index] = "\\"+$Servername+"\"+$Remainder
		EndIf
	Loop
;==================================================================
;unmap printers
;unmap all printers in previous array
;==================================================================
	$i = 0;

	For $i = 0 to $index-1
		If DelPrinterConnection($unc[$i]) = 0
			? Chr(9) + "Successfully removed printer " $i "- " $unc[$i] + "."
		Else
			? Chr(9) + "Error removing printer " $i "- " $unc[$i]  ": "@ERROR
		EndIf
	Next $i
EndFunction
   

 83593UnmapPrinters17SealeopardUnmapPrinters() - Removes mapped printers not listed in an .INI file0

;FUNCTION      UnmapPrinters 

; 

;AUTHOR        Jens Meyer (sealeopard@usa.net) 

; 

;ACTION        Removes mapped printers not listed in an .INI file 

; 

;VERSION       1.41 added missing dependency 

;              1.4  added optional LIST parameter 

;              1.3 

; 

;DATE CREATED  2002/10/21 

; 

;DATE MODIFIED 2003/11/06 

; 

;KIXTART       4.12+ 

; 

;SYNTAX        UNMAPPRINTERS(INIFILE [,LIST]) 

; 

;PARAMETERS    INIFILE 

;              Required string containing filename of am initialization file containing 

;              a list of mappable printers 

; 

;              LIST 

;              Optional boolean indicating whether to return a list of unmapped printers 

; 

;RETURNS       0 or the error code @error 

; 

;REMARKS       Companion function to MapPrinter at http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000109 

;              The printer.ini file has the following format: 

;              [Printer name] = Name of the printer share 

;              Win2K3         = Name of the printserver(s) for Windows 2003 Server computers 

;              WinXP          = Name of the printserver(s) for Windows XP computers 

;              Win2K          = Name of the printserver(s) for Windows 2K computers 

;              WinNT          = Name of the printserver(s) for Windows NT computers 

;              GroupInclude   = User groups to be included in the printer connection 

;              CompExplude    = Computers to be excluded from the printer connection 

;              Users          = Users to be included in the printer connection 

;              FullName       = Full name of the printer 

;              Default        = Boolean indicating whether this printer will be the default printer 

; 

;DEPENDENCIES  ARRAYENUMKEY() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000064 

; 

;EXAMPLE       $list = unmapprinters('printers.ini',0) 

;              for each $printer in $list 

;                ? 'Unmapped '+$printer 

;              next 

; 

;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000284 

; 

function unmapprinters($inifile, optional $list)

  dim $regkey, $rc, $kernel, $printername, $printserverkey

  dim $printserverlist, $printserver, $delprinter, $printer, $primaryprintserver

  dim $printerlist



  if not exist($inifile)

    $unmapprinters=2

    exit 2

  endif



  if val($list)

    $list=1

  else

    $list=0

  endif



  select

  case instr(@PRODUCTTYPE,'Windows 2003')

    $kernel='Win2K3'

  case instr(@PRODUCTTYPE,'Windows XP')

    $kernel='WinXP'

  case instr(@PRODUCTTYPE,'Windows 2000')

    $kernel='Win2K'

  case instr(@PRODUCTTYPE,'Windows NT')

    $kernel='WinNT'

  case 1

    return

  endselect



  $regkey='HKEY_CURRENT_USER\Printers\Connections'

  $printserverlist=arrayenumkey($regkey)

  for each $printserver in $printserverlist

    $printserverkey='HKEY_CURRENT_USER\Printers\Connections\'+$printserver

    $delprinter=0

    $printer=split($printserver,',')

    $printserver=trim($printer[2])

    $printer=trim($printer[3])

    $regkey='HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Print\Providers\LanMan Print Services\Servers'

    $regkey=$regkey+'\'+$printserver+'\Printers\'+$printer

    $printername=trim(readvalue($regkey,'Share Name'))

    $primaryprintserver=trim(readprofilestring($inifile,$printername,$kernel))

    if $primaryprintserver=''

      ; printer and/or print server is not in list of shared printers 

      $delprinter=1

    else

      $primaryprintserver=split($primaryprintserver,',')

      if trim($primaryprintserver[0])<>$printserver

        ; print server is backup print server 

        $delprinter=1

      endif

    endif

    if $delprinter

      if $printername

        $printername='\\'+$printserver+'\'+$printername

        $rc=delprinterconnection($printername)

        if $list

          redim preserve $printerlist[ubound($printerlist)+1]

          $printerlist[ubound($printerlist)]=$printername

        endif

      endif

      if keyexist($printserverkey)

        $rc=deltree($printserverkey)

      endif

    endif

  next

  if $list

    $unmapprinters=$printerlist

  else

    $unmapprinters=@ERROR

  endif

  exit @ERROR

endfunction


 
 [ 06. November 2003, 18:26: Message edited by: sealeopard ]82507UpdateApps31RadimusUpdateApps() - wrapper for scripted installs0This doesn't install apps, it is a wrapper to offer manual or silent installs to allow the user to select whether to install it now or later. It creates a subkey in the reg to monitor when an app was offered, how many times it has been offered, and when it was accepted.

the optional 'number of offers' only changes the text of the messagebox if exceeded. the force displays an OK instead of yes/no. 

Syntax:
$RC=updateapp("Application Name",optional Number of offers,optional Force)
if $RC="yes" 

endif

Returns:
Yes, No, Failed  (failed is for inability for user to write to registry)

code:

Function updateapp($appname,optional $attempts, optional $force)
	dim $yesno, $buttontype
	dim $mbtitle, $mbtext1, $mbtext2, $mbtext3
	dim $LastOffer, $Offers, $FirstOffer

	if keyexist("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps")=0
		if addkey("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps")<>0
			$updateapp="Failed"
			return
			endif
		endif
	if keyexist("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname")=0
		if addkey("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname")<>0
			$updateapp="Failed"
			return
		else
			$=writevalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","FirstOffer","@date",REG_SZ)
			$=writevalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","LastOffer","@date",REG_SZ)
			$=writevalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","Offers","0",REG_SZ)
			$FirstOffer=@date	$LastOffer=@date	$Offers=0
			endif
	else
		$FirstOffer=readvalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","FirstOffer")
		$LastOffer=readvalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","LastOffer")
		$Offers=readvalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","Offers")
		endif
	$buttontype=68
	$mbtitle="Update of $appname"
	$mbtext1=" The program $appname needs to be updated on this PC. @CRLF"
	$mbtext2=" If you select YES it will install now. @CRLF If you select NO you will be asked at next logon. @CRLF"
	$mbtext3=" This has been offerred $Offers previous times between $FirstOffer and $LastOffer"
	if $Offers > $attempts and $attempts<>""
		$MBtext2=" The update of $appname MUST be installed now. @CRLF"
		$buttontype=64
		endif
	$yesno=messagebox("$mbtext1$mbtext2$mbtext3","$mbtitle",$buttontype)
	if $yesno=6 
		$=writevalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","Accepted","@date",REG_SZ)
		$=writevalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","LastOffer","@date",REG_SZ)
		$=writevalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","Offers",1+$Offers,REG_SZ)
		$updateapp="yes" 
		endif
	if $yesno=7
		$=writevalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","LastOffer","@date",REG_SZ)
		$=writevalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","Offers",1+$Offers,REG_SZ)
		$updateapp="no" 
		endif
	if $yesno=1
		$=writevalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","Accepted","@date",REG_SZ)
		$=writevalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","LastOffer","@date",REG_SZ)
		$=writevalue("HKEY_LOCAL_MACHINE\SOFTWARE\Updateapps\$appname","Offers",1+$Offers,REG_SZ)
		$updateapp="yes" 
		endif
	endfunction


 
 [ 28. October 2002, 15:21: Message edited by: Radimus ]83514UpdateDictionary52NTDOCUpdateDictionary() - Updates Microsoft Office with a prebuilt custom dictionary0Function	UpdateDictionary()

Author		Ron Lewis (NTDOC) wdintdocman@hotmail.com

Acknowlegements:       Code help and Ideas from Chris and Howard

Action		Adds a premade custom dictionary to Microsoft Office 97-2000-XP
					Works on 95/98/ME/NT/2000/XP

Syntax		$ud=UpdateDictionary()

Parameters	Shared folder where your custom dictionary is located and the name
					of the custom dictionary to use.  The path must have a trailing \
					Modify these 2 variables:
					$FileToCopyLocation="\\myserver\share\"
					$FileToCopy="MyCustom.dic"

Dependencies	KiXtart v4.02 or above a Server, some Users to use it on, etc...
 
Example
					$UD=UpdateDictionary()
Source

code:

Function UpdateDictionary()
Break On
$HKLMSF = "HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
$HKLMSMWCV = "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion"
$HKLMAppPaths = "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths"
$app = "winword.exe"
$path = readvalue("$HKLMAppPaths\$app","")
$WordVer = val(getfileversion("$path","Productversion"))
$WordVerFull = GetFileVersion("$path","Productversion")
$FileToCopyLocation="\\myserver\share\"
$FileToCopy="MyCustom.dic"
$CopyPath=ReadValue("$HKLMSF", "AppData")+"\Microsoft\Proof\"
$Find = ($CopyPath+"MyCustom.dic")
$EnumRegKey	= "HKCU\Software\Microsoft\Shared Tools\Proofing Tools\Custom Dictionaries"

If $WordVer = 8
	$CopyPath=ReadValue("$HKLMSMWCV","ProgramFilesDir")+"\Common Files\Microsoft Shared\proof\"
	$EnumRegKey	= "HKLM\Software\Microsoft\Shared Tools\Proofing Tools\Custom Dictionaries"
	$Find = ($CopyPath+"MyCustom.dic")
Endif
If ReadValue("HKCU\Software\Microsoft\Shared Tools\Proofing Tools\", "DisableCompanyCustomDic")=1
  Return
Endif
If ReadValue("HKCU\Software\Microsoft\Shared Tools\Proofing Tools\", "DisableCompanyCustomDic")=""
		$dc=WriteValue("HKCU\Software\Microsoft\Shared Tools\Proofing Tools", "DisableCompanyCustomDic", "0", "REG_DWORD")
endif
If ReadValue("HKCU\Software\Microsoft\Shared Tools\Proofing Tools", "Update")=""
		$dc=WriteValue("HKCU\Software\Microsoft\Shared Tools\Proofing Tools", "Update", "0", "REG_DWORD")
endif
If ReadValue("HKCU\Software\Microsoft\Shared Tools\Proofing Tools", "Update")=1
  Return
endif
If Exist("$CopyPath$FileToCopy")=0
	Copy "$FileToCopyLocation$FileToCopy" "$CopyPath"
Endif

If KeyExist($EnumRegKey)
		$Index = 0
		Dim $ValueName[100], $ValueData[100]
		$loopcontrol=0
		While $loopcontrol = 0
			$ValueName[$Index] = ENUMVALUE($EnumRegKey, $Index)
			$loopcontrol=@Error
				if $loopcontrol =0
				$ValueData[$Index] = READVALUE($EnumRegKey,$ValueName[$Index])
				If $ValueData[$Index] = $Find 	$Found = 1  Endif
				$Index = $Index + 1
				If $Index = ubound($ValueName)
					ReDim Preserve $ValueName[$Index+100], Preserve $ValueData[$Index+100]
				Endif
			Endif
		Loop

		$Index = $Index -1
		ReDim Preserve $ValueName[$Index], Preserve $ValueData[$Index]
		 
		If Not $Found
			$nul = WRITEVALUE($EnumRegKey, val($ValueName[ubound($ValueName)])+1, $Find, "REG_SZ")
			$dc=WriteValue("HKCU\Software\Microsoft\Shared Tools\Proofing Tools", "Update", "1", "REG_DWORD")
		Endif
		Return
Endif
Return
Endfunction


 
 [ 19. September 2002, 08:24: Message edited by: NTDOC ]82878UpdateFile17SealeopardUpdateFile() - Updates file if  fileversion or filetime is different0

code:

;FUNCTION        UpdateFile
;
;AUTHOR          Jens Meyer (sealeopard@usa.net)
;
;ACTION          Updates a file with a newer version if either the fileversion or the filetime is newer
;
;VERSION         1.5
;
;KIXTART         4.12+
;
;SYNTAX          UPDATEFILE(SOURCE,DESTINATION [, FORCED])
;
;PARAMETERS      SOURCE
;                Required string containing the source filename
;
;                DESTINATION
;                Required string containing the destination filename
;
;                FORCED
;                Optional parameter that forces a fileupdate disregarding the fileversion or filetime
;
;RETURNS         1 if the file has been updated, otherwise 0
;
;REMARKS         none
;
;DEPENDENCIES    none
;
;EXAMPLE         $success = UPDATEFILE('newversion.exe', 'oldversion.exe')
;
;KIXTART BBS     http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000149
;
function updatefile($source, $destination, optional $updateflag)
  Dim $sourceversion, $destversion, $sourceext, $destext, $filetimes
  Dim $validextensions, $level, $maxlevel, $ver1, $ver2, $pad, $maxpad

  if not exist($source)
    $updatefile=0
    exit 2
  endif

  $updateflag=val($updateflag)

  if not exist($destination)
    $updateflag=1
  endif

  if $updateflag=0
    $filetimes=comparefiletimes($source,$destination)
    if $filetimes=1 or $filetimes=-3
      $updateflag=1
    else
      $updateflag=0
    endif
  endif

  if $updateflag=0
    $sourceversion=getfileversion($source,'ProductVersion')
    $destversion=getfileversion($destination,'ProductVersion')
    if instr($sourceversion,'.')
      $sourceversion=split($sourceversion,'.')
    else
      $sourceversion=split($sourceversion,',')
    endif
    if instr($destversion,'.')
      $destversion=split($destversion,'.')
    else
      $destversion=split($destversion,',')
    endif
    $level=0
    $maxlevel=ubound($sourceversion)
    if $maxlevel<ubound($destversion)
      $maxlevel=ubound($destversion)
    endif
    redim preserve $sourceversion[$maxlevel], preserve $destversion[$maxlevel]
    do
      $ver1=trim($sourceversion[$level])
      $ver2=trim($destversion[$level])
      if len($ver1)>len($ver2)
        $maxpad=len($ver1)
      else
        $maxpad=len($ver2)
      endif
      for $pad=1 to $maxpad
        $ver1=$ver1+'0'
        $ver2=$ver2+'0'
      next
      $ver1=left($ver1,$maxpad)
      $ver2=left($ver2,$maxpad)
      if $ver1>$ver2
        $updateflag=1
      endif
      $level=$level+1
    until $level>$maxlevel or $updateflag
  endif

  if $updateflag
    copy $source $destination
    if @ERROR
      $updatefile=0
      exit @ERROR
    else
      $updatefile=1
      exit 0
    endif
  endif

  $updatefile=0
  exit 0
endfunction


 
 [ 02. March 2003, 20:13: Message edited by: sealeopard ]82844UpdateFileOnReboot17SealeopardUpdateFileOnReboot()- Schedules a file to be replaced on reboot0

code:

;FUNCTION      UpdateFileOnReboot
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;ACTION        Schedules a file to be replaced on reboot
;
;VERSION       1.1
;
;KIXTART       4.12+
;
;SYNTAX        UPDATEFILEONREBOOT(SOURCE,DESTINATION)
;
;PARAMETERS    SOURCE
;              Required string containing the source file
;
;              DESTINATION
;              Required string containing the destination file
;
;RETURNS       0 if successful, otherwise error code
;
;REMARKS       Destination file must be local file with the full pathname. Can be used to replace files
;              that are in use, e.g. DLLs
;
;DEPENDENCIES  none
;
;EXAMPLE       $rc = UPDATEFILEONREBOOT("c:\temp\test.sys","c:\winnt\system32\test.sys")
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000142
;
function updatefileonreboot($source, $destination)
  Dim $regsubkey, $regentry, $regvalue, $rc, $existingregvalue, $fileext, $replace

  $updatefileonreboot=0

  if exist($source)
    if instr($destination,'.')
      $fileext=right($destination,len($destination)-instrrev($destination,'.')+1)
    else
      $fileext=''
    endif
    $replace=left($destination,len($destination)-len($fileext))+'.bak'

    copy $source $replace
    if @ERROR
      $updatefileonreboot=@ERROR
      exit @ERROR
    endif

    if @INWIN=1
      $regsubkey='HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager'
      $regentry='PendingFileRenameOperations'
      $regvalue='\??\'+$replace+'|'+'!\??\'+$destination

      $existingregvalue=readvalue($regsubkey,$regentry)
      if $existingregvalue<>''
        $regvalue=$existingregvalue+'|'+$regvalue
      endif

      $updatefileonreboot=writevalue($regsubkey,$regentry,$regvalue,'REG_MULTI_SZ')
    else
      $rc=writeprofilestring('%WINDIR%\wininit.ini','rename',$destination,$replace)
      $updatefileonreboot=0
    endif
  else
    $updatefileonreboot=2
    exit 2
  endif
  exit 0
endfunction


 
 [ 02. March 2003, 20:12: Message edited by: sealeopard ]83594UpdateKiXForms52NTDOCUpdateKiXForms() - Updates the KiXForms DLL that is written by Shawn Tassie0

Function UpdateKiXForms()

Author Ron Lewis / NTDOC (wdintdocman@hotmail.com)

Version 1.4

Date 2002/22/10 Updated 2002/25/10

Action Unregisters KiXForms.dll and backs up the old version to
a supplied directory and the version number. Then copies the new one from
a supplied SOURCE to %windir%\system or system32 and then re-registers the new one.

Example Break On
$nul=SetOption("Explicit", "On")
UpdateKiXForms("C:\NEWKIXFORMS\kixforms.dll", "C:\BACKUP2\")

Parameters $Source {location where you keep the new kixforms.dll}
and $Backup {location where you want to keep incremental backups}

Dependencies KiXtart 4.02, and a copy of KIXFORMS.DLL from 
Kixforms web site

Source



  

code:

Function UpdateKiXForms($Source, $Backup)
Dim $Location, $Destination, $FormFileVer, $ID, $CurrentVersion, $SourceVersion, $ShellCMD
$ID=readvalue("HKEY_CLASSES_ROOT\Kixtart.Form\CLSID","")
$Location=readvalue("HKEY_CLASSES_ROOT\CLSID\"+$id+"\InprocServer32","")
$CurrentVersion=GetFileVersion($Location,"SpecialBuild")
$SourceVersion=GetFileVersion($Source,"SpecialBuild")
If @inwin=1
    IF NOT INGROUP("\\@WKSTA\Administrators")
      EXIT 5  ;user is not an admin so can't update KiXForms... set error to 5
    EndIf
    $Destination=READVALUE("HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion","SystemRoot")+'\system32\'
Else
    $Destination=READVALUE("HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion","SystemRoot")+'\system\'
EndIf
If Not Exist ($Destination+"kixforms.dll")
  Copy $Source $Destination
    If @Error=0
      $ShellCMD=$destination+'regsvr32.exe ' +$destination+'kixforms.dll /s'
      Shell $ShellCMD
    EndIf
Return
EndIf
If Not Exist ("$Backup")
  MD ("$Backup")
Endif
If $SourceVersion > $CurrentVersion
  If Not Exist($Backup+$CurrentVersion)
    MD ($Backup+$CurrentVersion)
  EndIf
  $ShellCMD=$destination+'regsvr32.exe ' +$destination+'kixforms.dll /u /s'
  Shell $ShellCMD
  Copy $Location $Backup+$CurrentVersion+"\"
  If @Error=0
    Del $Location
    COPY $Source $Destination
      If @Error=0
        $ShellCMD=$destination+'regsvr32.exe ' +$destination+'kixforms.dll /s'
        Shell $ShellCMD
      EndIf
  Else
    $ShellCMD=$destination+'regsvr32.exe ' +$destination+'kixforms.dll /s'
    Shell $ShellCMD
  EndIf
Endif
EndFunction

[Edit]  I updated this code to better handle generic updates.  Now copies if file not found due to system never having had KiXForms installed.  By request of Author, checks build version by number instead of by string.

TESTED: On Windows 98/NT/2000/XP please post comments or questions in the other forum:

http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=2;t=003905

[EDIT] Modified per suggestions by Lonkero
[EDIT] Modified per suggestions by Les
[EDIT] Modified per suggestions by Kent
 
 [ 25. October 2002, 03:56: Message edited by: NTDOC ]82692UpdateRegistry17SealeopardUpdateRegistry() - Updates a registry setting0

code:

;FUNCTION      UpdateRegistry
;
;ACTION        Updates a registry setting
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.3 (added error codes)
;              1.2
;
;DATE CREATED  2001/12/20
;
;DATE MODIFIED 2003/05/17
;
;KIXTART       4.12+
;
;SYNTAX        UPDATEREGISTRY(REGSUBKEY, REGENTRY, REGVALUE [, REGTYPE])
;
;PARAMETERS    REGSUBKEY
;              Required string containing a registry subkey
;
;              REGENTRY
;              Required string containing a registry entry
;
;              REGVALUE
;              Required string containing a registry value
;
;              REGTYPE
;              Optional string containing a registry type, defaults to REG_SZ
;
;RETURNS       1 if registry value has been updated, otherwide 0 and an error code will be set
;
;REMARKS       this UDF indicates whether a registry value has been changed due to different value or regtype
;
;DEPENDENCIES  none
;
;EXAMPLE       $rc=updateregistry('HKEY_CURRENT_USER\Demo','Kixtart','Version 4 RC1','REG_SZ')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000110
;
function updateregistry($regsubkey, $regentry, $regvalue, optional $regtype)
  Dim $currentregvalue, $currentregtype, $rc

  $updateregistry=0

  if $regtype=''
    $regtype='REG_SZ'
  endif

  $currentregtype=readtype($regsubkey,$regentry)
  $currentregvalue=readvalue($regsubkey, $regentry)
  if $currentregvalue<>$regvalue or $currentregtype<>$regtype
    $rc=writevalue($regsubkey,$regentry,$regvalue,$regtype)
    if @ERROR
      exit @ERROR
    endif
    $updateregistry=1
  endif
  exit @ERROR
endfunction


 
 [ 19. May 2003, 00:23: Message edited by: sealeopard ]112524UpdateUserParameters17SealeopardUpdateUserParameters() - updates per-user system p1075142224Code:


;FUNCTION      UpdateUserParameters

;

;ACTION        updates per-user system parameters

;

;AUTHOR        Jens Meyer (sealeopard@usa.net)

;

;VERSION       1.0

;

;DATE CREATED  01/26/2004

;

;DATE MODIFIED 01/26/2004

;

;KIXTART       4.x

;

;SYNTAX        UpdateUserParameters()

;

;PARAMETERS    none

;

;RETURNS       none

;

;REMARKS       used to refresh e.g. the desktop wallpaper or screensaver

;

;DEPENDENCIES  none

;

;EXAMPLE       $rc=writevalue('HKCU\Control Panel\Desktop\','Wallpaper','C:\WINDOWS\Web\Wallpaper\Bliss.bmp','REG_SZ')

;              $rc=UpdateUserParameters()

;              ? 'Press any key to continue...'

;              get $rc

;              $rc=writevalue('HKCU\Control Panel\Desktop\','Wallpaper','','REG_SZ')

;              $rc=UpdateUserParameters()

;

;KIXTART BBS   http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=111232

;

function UpdateUserParameters()

  SHELL 'RUNDLL32.EXE user32.dll,UpdatePerUserSystemParameters'

  exit @error

endfunction

 84092Uptime119LonkeroUptime - returns time system has been running since last boot0


;FUNCTION	Uptime

;

;AUTHOR		Lonkero (Jooel_Nieminen@hotmail.com)

;

;ACTION		returns time system has been running without reboot

;

;VERSION	1.1 (27.4.2003)

;

;CHANGES	1.0 (27.4.2003) - initial release

;		1.1 (27.4.2003) - removed all dependencies to buggy codes

;

;SYNTAX		Uptime()

;

;PARAMETERS	none

;

;RETURNS	system uptime

;

;REMARKS	properly working replacement for the old uptime UDF

;		it returned incorrect uptimes as it didn't understand over 25 day uptimes

;

;DEPENDENCIES	WMI

;

;EXAMPLE	$uptime=Uptime()

;		if $uptime>"0000/00/30 00:00:00"

;		 "system has been up $uptime"

;		 "it's recommended that you boot your system."

;		endif

;

;SOURCE

function Uptime()

 dim $,$!,$y,$m,$d,$t

 For Each $ in GetObject("winmgmts:").InstancesOf("Win32_OperatingSystem")

  $! = split($.LastBootUpTime,".")[0]

  $t=3600*substr($!,9,2)+60*substr($!,11,2)+substr($!,13,2)

  $y=left($!,4)

  $m=substr($!,5,2)

  $d=substr($!,7,2)

  $!=split(@time,":")

  $t=3600*$![0]+60*$![1]+$![2]-$t

  $!=split(@date,"/")

  if $t<0

   $t=$t+86400

   $![2]=0+$![2]-1

  endif

  if $d>$![2]

   select

   case 3=$![1]

     $![2]=28+$![2]

   case instr("2468911",$![1])

     $![2]=31+$![2]

   case "Lonk"

     $![2]=30+$![2]

   endselect

   $![1]=0+$![1]-1

  endif

  $![2]=0+$![2]-$d

  if $m>$![1]

   $![1]=12+$![1]

   $![0]=0+$![0]-1

  endif

  $![1]=0+$![1]-$m

  $![0]=right("000"+(0+$![0]-$y),4)

  $![1]=right("0"+$![1],2)

  $![2]=right("0"+$![2],2)

  $Uptime=join($!,"\")

  $!=$t/3600

  $t=$t-3600*$!

  $Uptime=$Uptime+" "+$!

  $!=$t/60

  $t=$t-60*$!

  $Uptime=$Uptime+":"+$!+":"+$t

 Next

endfunction
 
 [ 29. April 2003, 13:57: Message edited by: Lonkero ]83330Uptime675Dean B.Uptime() - Converts @ticks to days, hours, minutes, seconds, and milliseconds0My small contribution to celebrate the release of KiXtart 4.10.  This function will tell you how long your computer has been up and running.

 

code:

;Function:	uptime
;Author:	Dean E. Behrman
;Action:	Converts ticks (in milliseconds) to days, hours, minutes, seconds, and milliseconds
;Version:	1.0
;Syntax:	uptime([milliseconds], [format])
;Parameters:	Ticks OPTIONAL (milliseconds)
;		Format OPTIONAL (integer)
;			0 = return a string
;			1 = return an integer array
;Returns:	String or integer array
;		String results:  "##d ##h ##m ##s ##ms"
;		Array results are stored in the following indices:  
;			[0] = days
;			[1] = hours
;			[2] = minutes
;			[3] = seconds
;			[4] = milliseconds
;Dependencies:	KiXtart 4.10 or higher
;Example:	$elapsed = uptime()
;		? $elapsed
;		$time = uptime(,1)
;		? "Days: " + $time[0]
;		? "Hrs : " + $time[1]
;		? "Mins: " + $time[2]
;		? "Secs: " + $time[3]
;		? "ms  : " + $time[4]
function uptime(optional $_ticks,optional $type)
dim $_days,$_hrs,$_mins,$_secs,$_ms,$tmp[5]
if $_ticks = 0 or $_ticks = ""
	$_ticks = @ticks
endif
$_days = int($_ticks / (24 * 60 * 60 * 1000))
$_hrs = ($_ticks / (60 * 60 * 1000)) mod 24
$_mins = ($_ticks / (60 * 1000)) mod 60
$_secs = ($_ticks / 1000) mod 60
$_ms = $_ticks mod 1000
if $type = 0 or $type = ""
	$uptime = "" + $_days + "d " + $_hrs + "h " + $_mins + "m " + $_secs + "s " + $_ms + "ms"
else
	$tmp = $_days,$_hrs,$_mins,$_secs,$_ms
	$uptime = $tmp
endif
endfunction
  


 
 [ 08 July 2002, 17:01: Message edited by: Dean B. ]181568UserAccountsCommonDialog5694WittoUserAccountsCommonDialog() - Dialog Box to select one or more files0;UserAccountsCommonDialog()
; 
;ACTION Creates Dialog Box to select one or more files. 
; 
;AUTHOR Wim Rotty 
; 
;CONTRIBUTORS Catherder2000 (Actually, the function is originally his function) 
; http://www.kixtart.org/forums/ubbthreads.php?ubb=showprofile&User=10904 
; 
;VERSION 0.1 
; 0.2 Waiting for suggestions 
; 
;DATE CREATED 2007-10-12 
; 
;DATE MODIFIED 2007-10-13 
; 
;KIXTART 4.00 and higher 
; 
;SYNTAX UserAccountsCommonDialog([InitialDir], [Filter], [FilterIndex], [Flags]) 
; 
;PARAMETERS $InitialDir 
; Optional parameter, String 
; Set the initial directory. 
; 
; $Filter 
; Optional parameter, String 
; Populates the "List files of type" combobox or dropdownlist 
; Build list like this example: 
; "Text Files|*.txt|Comma Separated Values|*.csv|All Files|*.*" 
; 
; $FilterIndex 
; Optional parameter, Integer 
; Sets the default choice in the "List files of type" combobox 
; or dropdownlist 
; 3 would set the default choice in the example given for 
; $Filter to "All Files" 
; 
; $Flags 
; Optional parameter, Long Integer Bitwise Code
; Controls the UserAccountsCommonDialog box operation
; I presume the most important ones are: 
; 
; &H0004 4 Hides the Read-only checkbox. 
; 
; &H0200 512 Allows multiple file selection in a fixed-size list-style dialog
; Box with all path And file names containing spaces reduced to SFNs, And
; returns multiple selections via a string list delimited by spaces. 
; 
;RETURNS String, with full path and filename
; For the multiselection style dialog box, the path and the filenames are 
; reduced to Short File Names, the path and the filenames are separated by 
spaces 
; 
; Error codes: 0 = Success, all other = Error 
; 
;REMARKS If the CommonDialog Object cannot be created, 
; an event is written to the application log 
; 
; I presume the "Read-Only" tick box is useless 
; because of the lack of returned information 
; 
; BUG 
; I think the use of the multi-select style dialog box 
; should be discouraged 
; If the returned string is no longer than 258 characters, 
; the result is OK 
; If the returned string should be 259 characters, 
; the last char is lost 
; If the returned string should be 260 characters, 
; the returned string is empty 
; 
;More information:
;http://www.kixtart.org/forums/ubbthreads.php?ubb=showflat&Number=83851&fpart=2
;http://www.microsoft.com/technet/scriptcenter/resources/qanda/jan05/hey0128.mspx
;http://www.microsoft.com/technet/scriptcenter/resources/qanda/mar05/hey0301.mspx
;http://blogs.msdn.com/gstemp/archive/2004/02/17/74868.aspx
;http://blogs.msdn.com/gstemp/archive/2004/02/18/75600.aspx
;http://www.webmasterkb.com/Uwe/Forum.aspx/vbscript/4253/BrowseForFolder
;http://www.codecomments.com/archive299-2004-3-162174.html
;http://www.tech-archive.net/Archive/Scripting/microsoft.public.scripting.vbscript/2004-03/1840.html
; 
;DEPENDENCIES Windows XP 
; 
;EXAMPLE 
; ;Script Options
; If Not @LOGONMODE
; Break On
; Else
; Break Off
; EndIf
; Dim $RC
; $RC = SetOption("Explicit","On")
; $RC = SetOption("NoMacrosInStrings","On")
; $RC = SetOption("NoVarsInStrings","On")
; If @SCRIPTEXE = KIX32.EXE
; $RC = SetOption("WrapAtEOL","On")
; EndIf
; 
; ;Declare variables
; Dim $InitialDir, $Filter, $FilterIndex, $Flags
; Dim $Files, $i
; 
; ;Initialize variables
; $InitialDir = %HOMEDRIVE%
; $Filter = "Text Files|*.txt|Comma Separated Values|*.csv|All Files|*.*"
; $FilterIndex = 3
; $Flags = "&H0204"
; 
; ;Code
; $Files = UserAccountsCommonDialog($InitialDir, $Filter, $FilterIndex, $Flags)
; $Files ?
; If Not $Files = ""
; $Files = Split($Files," ")
; For $i = 0 to UBound($Files)
; If $i = 0
; "Path: "
; Else
; "File "$i": "
; EndIf
; $Files[$i] ?
; Next
; Else
; "Nothing Selected" ?
; EndIf
; 
;KIXTART BBS http://www.kixtart.org/forums/ubbthreads.php?ubb=showflat&Number=181568#Post181568 
; 
Function UserAccountsCommonDialog(Optional $InitialDir, Optional $Filter, 
Optional $FilterIndex, Optional $Flags)
;Declare variables
Dim $objDialog, $RC
;Initialize variables
$objDialog = CreateObject("UserAccounts.CommonDialog")
;If Dialog object cannot be created, write reason to application log and return 
error
If @ERROR <> 0
Dim $ErrMsg
$ErrMsg = @CRLF+@CRLF+@SCRIPTDIR+'\'+@SCRIPTNAME
$ErrMsg = $ErrMsg+' failed to create object for "UserAccounts.CommonDialog"'
$ErrMsg = $ErrMsg+@CRLF+'Error '+@ERROR+': '+@SERROR
$RC = LogEvent(1,1,$ErrMsg)
Exit @ERROR
EndIf
;code
;Set initial directory
If Not $InitialDir = ""
$objDialog.InitialDir = $InitialDir
EndIf
;Set Filter
If Not $Filter = ""
$objDialog.Filter = $Filter
EndIf
;Set FilterIndex
If Not $FilterIndex = ""
$objDialog.FilterIndex = $FilterIndex
EndIf
;Set Flags, if no flags are given, hide "Read Only" tick box
If Not $Flags = ""
$objDialog.Flags = $Flags
Else
$objDialog.Flags = "&H0004"
EndIf
;Show dialog
$RC = $objDialog.ShowOpen
;Set Return Value of Function
If $RC = -1
$UserAccountsCommonDialog = $objDialog.FileName
EndIf
;Dispose object
$objDialog = 0
;Exit function
Exit @ERROR
EndFunction 
82148UserCreate28BryceUserCreate() - Creates a new user account.0

code:


Function UserCreate($target,$user)
;UserCreate Function
;
;Syntax:
;	UserRename(,)
;		= the domain or computer you want to create a new account in
;			= the name of the account to create
;
;Examples:
;	;This will create a user account called "thing1" in the local domain
;	UserCreate(@domain,"Thing1")
;
;	;This will create a user account called thing2 on the workstation 
;	;beanbag in the kixtart domain
;	usercreate("kixtart/beanbag","thing2")

	if instr($target,"/") <> 0 
		$target = getobject("WinNT://$target,computer")
		if @error <> 0  and vartype($target) <> 9 exit(@error) endif
	else
		$target = getobject("WinNT://$target")
		if @error <> 0  and vartype($target) <> 9 exit(@error) endif
	endif

	$user = $target.create("user","$user")
	if @error <> 0  and vartype($user) <> 9 exit(@error) endif

	$user.setinfo
	exit(@error)
endfunction

82145UserGroups28BryceUserGroups() - returns all groups of a given user0


Function UserGroups($target,$user,OPTIONAL $datatype)
;UserGroups, returns the groups of a specified user
;
;Returns:
; An array containing all groups of the given user. the array data type
; is controlled by the flag
;
;Syntax:
; $groups = usergroups({Target},{Userid},[OPTIONAL datatype])
;
; {Target}................the domain or local computer you want to preform the action on.
; for faster workstation access include the domain name "domain/computer"
;
; {Userid}................The userid you want to lookup
;
; [datatype]..............Optional flag for what type of data to return
; 0 = default, the groupname
; 1 = the ADSI group object
; 2 = the ADSI group's ADSPath
;
;Examples:
; ;this will return all groups of a given user in the the local domain
; $groups = UserGroups(@domain,@userid)
;
; ;this will give you all the ADSI groupobjects of the user jsmith in the kixtart domain
; $group = UserGroups("Kixtart","jsmith",2)
DIM $group, $temp[2], $i
$user = getobject("WinNT://$target/$user,user")
if @error <> 0 and vartype($user) <> 9 exit(@error) endif
for each $group in $user.groups
select
case $datatype = 0 ;return the group.name
$temp[$i] = $group.name
case $datatype = 1 ;return the groupobject
$temp[$i] = $group
case $datatype = 2 ;return the group.adspath
$temp[$i] = $group.adspath
case 1
exit(1)
endselect
if $i = ubound($temp)
redim preserve $temp[$i+2]
endif
$i = $i+1
next
if $i <> 0 
redim preserve $temp[$i-1]
$UserGroups = $temp
else
redim preserve $temp[$i]
$usergroups = ""
endif
exit(0)
endfunction


 
 [ 04. February 2003, 04:44: Message edited by: Bryce ]82149UserRename28BryceUserRename() - Renames a user account0

code:

Function userRename($target, $olduser, $newuser)
;UserRename function
;
;Syntax:
;	UserRename({target}, {Current Account Name}, {New Account Name})
;	{Target}		= the name of the remote computer/domain you want to rename an account on
;	{Current Account Name}	= the name of the user account you want to rename.
;	{New Account Name}	= the name you are renaming to.
;
;Examples:
;	;this will rename the local administrator account to admin (if you have the security right to do so.)
;	UserRename(@wksta, "Administrator","Admin")
;
;	;This will rename the Administrator account on the workstation Beanbag
;	UserRename("beanbag", "Administrator", "Admin")
;
;	;this will rename the Domain user testuser to superuser
;	UserRename("@domain","Testuser","SuperUser")
;
;Requirements: 
;	ADSI interface
	
	DIM $computer, $computerOBJ, $userOBJ, $nul, $target

	$TargetOBJ = getobject("WinNT://$target")
	if vartype($TargetOBJ) <> 9 exit(@error) endif

	$userOBJ = getobject("WinNT://$target/$olduser,user")
	if vartype($userOBJ) <> 9 exit(@error) endif

	$nul = $TargetOBJ.MoveHere($userOBJ.adspath,$newuser)
	exit(@error)
endfunction


 
 [ 07 March 2002, 16:24: Message edited by: Bryce ]172573UseUSBDrives1024MartUseUSBDrives() - Disallow or Allow USB mass storage devices1168418873

Code:

;Function:	UseUSBDrives()
;  
;Author:	Mart 
; 
;Version:	1.0 - January 9th 2007.
;			Initial release.
;		1.1 - January 9th 2007.
;			Minor change to capture the RC of writevalue.
;		2.0 - January 9th 2007.
;			Added support for remote computers.
;		2.1 - January 10th 2007.
;			Changes Radimus suggested.
;  
;Action:	Allows or disallows the use of USB mass storage devices.  
;  
;Syntax:	UseUSBDrives($value, optional $computer)
;  
;Parameters:	$value - Required. 
;		1 allows the use of USB mass storage devices.
;		0 disallows the use of USB mass storage devices.
;		$computer - Optional. 
;		Computer to write to.
;		If no computer name is supplied the local system is used.
; 
;Dependencies:	Tested on WinXPSP2 and Kix4.53.
;		Requires Admin privileges to write to HKLM.
;
;Returns: Result code of writevalue.
;
; 
;Remarks:	This can also be done by GPO.
;		See: http://www.petri.co.il/disable_usb_disks.htm
;  
;Example:	UseUSBDrives(1, "system2") ;Allows USB mass storage devices.
;		UseUSBDrives(0) ;Disallows USB mass storage devices.
;
Function UseUSBDrives($value, optional $computer)
	Dim $key

	If $value <> 0 And $value <> 1
		Exit 13
	EndIf
	
	If $computer = ""
		$computer = "\\" + @WKSTA + "\"
	Else
		$computer = "\\" + $computer + "\"
	EndIf

	$key = $computer + "HKLM\SYSTEM\CurrentControlSet\Services\USBSTOR"
	;3 = enable, 4 = disable
	Select
		Case $value = 0
			$UseUSBDrives = WriteValue ($key, "Start", "4", "REG_DWORD")
		Case $value = 1
			$UseUSBDrives = WriteValue ($key, "Start", "3", "REG_DWORD")
	EndSelect

EndFunction
82314UsrMustChgPwd46kholmUsrMustChgPwd() - Force a user to change password at next login0UsrMustChgPwd($User)
 
Action:
Force a user to change password at next login
 
Syntax:
$RC = UsrMustChgPwd($User)
 
Parameters:
$User: UserID to force to change password at next login
 
Returns:
Success:
Returns 0
 
Errors:
Possitive numbers, error from: ADS_USER.SetInfo
 
-1 : Password not required for this account
-2 : Not a normal account
-9 : ADSI not installed or user not found
 
 
Dependencies:
KiXtart 4.01
ADSI installed, if used from Win9x/NT workstation

Function Not_Or(), included in the source
You can remove the dependency of function: Not_Or()
By substituting the line:
	$Flags = Not_Or($Flags,&40 + &10000)
With:
	$Flags = ($Flags | &10040) - &10040
It is only used here, to make the script easier to read. (I hope   )


 
Example:

code:

? 'UserID to force to change password: '
GetS $User
$RC = UsrMustChgPwd($User)
If $RC
	? 'Force change password not set for: ' + $User + ' Error: ' + $RC
EndIf


Source:

code:

Function UsrMustChgPwd($User)
; Force $User to change password at next login
	Dim $oUser,$Flags
 
	$oUser = GetObject("WinNT://" + @Domain + "/" + $User + ",user")
	If $oUser
		$Flags = $oUser.Get("UserFlags")
 
		If ($Flags & &20) = &20 ; Password not required for this account
			$UsrMustChgPwd = -1
			Return
		EndIf
		If ($Flags & &200) <> &200 ; Not a normal account
			$UsrMustChgPwd = -2
			Return
		EndIf
 
		$Flags = Not_Or($Flags,&40 + &10000)
		; Uncheck flag-values conflicting with PasswordExpired:
		;  Flag-value Hex 40:Password can't change
		;  Flag-value Hex 10000: Password never expires
		$oUser.Put("UserFlags",$Flags)
 
		$oUser.Put("PasswordExpired", 1) ; User must change password at next login
 
		$oUser.SetInfo ; Save changes
		$UsrMustChgPwd = @Error
		$oUser = 0
	Else
		$UsrMustChgPwd = -9
	EndIf
EndFunction
 
 
Function Not_Or($Num,$NotBin)
; Binary Not Or
; Clears the bits set in $Num, that are also set in $NotBin
	$Num = 0 + $Num
	$NotBin = 0 + $NotBin
	$Not_Or = ($Num | $NotBin) - $NotBin
EndFunction


 
Erik
 
 
ps.
If anyone wants to investigate other flagvalues, here is a cut'n paste from the ADSI helpfile.
 
Flag-values returned by ADS_USER.Get("UserFlags"):
typedef enum ADS_USER_FLAG {
    ADS_UF_SCRIPT                           =  0X0001,
    ADS_UF_ACCOUNTDISABLE                   =  0X0002,
    ADS_UF_HOMEDIR_REQUIRED                 =  0X0003,
    ADS_UF_LOCKOUT                          =  0X0010,
    ADS_UF_PASSWD_NOTREQD                   =  0X0020,
    ADS_UF_PASSWD_CANT_CHANGE               =  0X0040,
    ADS_UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED  =  0X0080,
    ADS_UF_TEMP_DUPLICATE_ACCOUNT           =  0X0100,
    ADS_UF_NORMAL_ACCOUNT                   =  0X0200,
    ADS_UF_INTERDOMAIN_TRUST_ACCOUNT        =  0X0800,
    ADS_UF_WORKSTATION_TRUST_ACCOUNT        =  0X1000,
    ADS_UF_SERVER_TRUST_ACCOUNT             =  0X2000,
    ADS_UF_DONTEXPIREPASSWD                 =  0X10000,
    ADS_UF_MNS_LOGON_ACCOUNT                =  0X20000,
    ADS_UF_SMARTCARD_REQUIRED               =  0X40000,
    ADS_UF_TRUSTED_FOR_DELEGATION           =  0X80000,
    ADS_UF_NOT_DELEGATED                    =  0X100000
    }
 
 
pps.
ADS_UF_HOMEDIR_REQUIRED                 =  0X0003
ADS_UF_SCRIPT + ADS_UF_ACCOUNTDISABLE   =  0X0003
Is this an error in the documentation ???

[ 02 December 2001: Message edited by: kholm ]186720UUID2netbootGUID5931apronkUUID2netbootGUID() - Convert UUID to netbootGUID0While this UDF serves no great purpose to anyone really other then those writing their own Windows Deployment software.
It does show you these things:

1. How RIS generates the netbootGUID
2. How the RIS tab of a computer account is created.
3. How the Server name is filled in on the RIS tab.
4. Probably the most important part: How to create a Byte[] Array variable.

ÿCode:

;Function         UUID2netbootGUID() - Convert UUID to netbootGUID
;
;Author		Arend Pronk (arendpronk@gmail.com)
;
;Action		Convert UUID from WMI to netbootGUID for ADSI
;
;Syntax		UUID2netbootGUID("CN=Computer01,OU=Computers,DC=domain,DC=local","E27F9077-FB1E-11DB-11A0-66990E1B8129","Server01.domain.local")
;
;Version  	1.0
;
;Date 		04-04-2008
;
;Parameters 	$ldapname (Required)  - String value, ie: "CN=Computer01,OU=Computers,DC=domain,DC=local"
;		$strUUID (Optional)   - String value, ie: "E27F9077-FB1E-11DB-11A0-66990E1B8129"
;		$strServer (Optional) - String value, ie: "Server01.domain.local"
;
;Returns  	Nothing
; 
;Dependencies 	WMI, ADSI, at least Account Operator privilidges.
;
;KiXtart Ver.	4.60
; 
;Example(s)	UUID2netbootGUID("CN=Computer01,OU=Computers,DC=domain,DC=local","E27F9077-FB1E-11DB-11A0-66990E1B8129","Server01.domain.local")
;		Will generate the netbootGUID from the specified UUID and apply it to the specified computer account (this creates the RIS tab)
;		Also sets the Remote Installation Server property to the specified server.
;
;		UUID2netbootGUID("CN=Computer01,OU=Computers,DC=domain,DC=local",,"Server01.domain.local")
;		Will generate the netbootGUID from the WMI of the computer this is script is running on and apply it to the specified computer
;		account (this creates the RIS tab)
;		Also sets the Remote Installation Server property to the specified server.
;
;		UUID2netbootGUID("CN=Computer01,OU=Computers,DC=domain,DC=local",,)
;		Will generate the netbootGUID from the WMI of the computer this is script is running on and apply it to the specified computer
;		account (this creates the RIS tab)
;		This does NOT set the Remote Installation Server property to the specified server.
;
Function UUID2netbootGUID($ldapname,optional $strUUID,optional $strServer)
  If $strUUID = ""
    ;Retrieve Local UUID
    ;---------------------------------------------------------------------
    Dim $WMIService, $WMIObject, $UUID
    $WMIService = GetObject("winmgmts:").ExecQuery("select UUID from Win32_ComputerSystemProduct")
    For Each $WMIObject in $WMIService
      $UUID = $WMIObject.UUID
    Next
  Else
    $UUID = $strUUID
  EndIf

  ;Remove Dashes and put them between every 2 characters
  ;---------------------------------------------------------------------
  Dim $rguid, $delimiter, $i, $UUID2
  $UUID2 = Join(Split($UUID,"-"),"")
  For $i=1 To LEN($UUID2) Step 2
    $rguid=$rguid+$delimiter+SubStr($UUID2,$i,2)
    $delimiter="-"
  Next

  ;Convert the right order to the wrong order
  ;---------------------------------------------------------------------
  Dim $wguid
  $wguid=Split($rguid,"-")
  Dim $a,$b,$c,$d
  $a=$wguid[0]
  $b=$wguid[1]
  $c=$wguid[2]
  $d=$wguid[3]
  $wguid[0]=$d
  $wguid[1]=$c
  $wguid[2]=$b
  $wguid[3]=$a
  $a=$wguid[4]
  $b=$wguid[5]
  $wguid[4]=$b
  $wguid[5]=$a
  $a=$wguid[6]
  $b=$wguid[7]
  $wguid[6]=$b
  $wguid[7]=$a
  $wguid=Join($wguid,"-")

  ;Convert the WRONG string to a Byte[] array and put it into the AD
  ;(AD itself will convert it back when you submit it to the AD)
  ;---------------------------------------------------------------------
  Dim $stream, $x, $octetstring, 
  $stream = CreateObject("ADODB.Stream")
  If @ERROR Exit @ERROR EndIf
  $stream.Type = 2
  $stream.CharSet = "windows-1252"
  $stream.Open
  $x = Split($wguid,"-")
  For $i=0 to Ubound($x)
    $stream.WriteText(Chr(Val("&"+$x[$i])))
  Next
  $stream.Position = 0
  $stream.Type = 1
  $octetstring = $stream.Read
  $stream.Close

  ;Write the Octetstring (Byte[] array) to the AD
  ;---------------------------------------------------------------------
  Dim $obj
  $obj = GetObject($ldapname)
  If @ERROR Exit @ERROR EndIf
  $obj.Put("netbootGUID",$octetstring)
  If @ERROR Exit @ERROR EndIf
  If $strServer <> ""
    $obj.Put("netbootMachineFilePath",$strServer)
  EndIf
  $obj.SetInfo
  If @ERROR Exit @ERROR EndIf
EndFunction
84610vbs2Kix119Lonkerovbs2Kix() - automated VBScript to KiX-script conversion0;FUNCTION 

;	vbs2Kix() 

; 

;AUTHOR 

;	Lonkero (Jooel_Nieminen@hotmail.com) 

; 

;ACTION 

;	Converts VBScript to kix 

; 

;VERSION 

;	0.5 

; 

;VERSION HISTORY 

;	0.5	10. October 2003	 - First UDF version and improved logic 

;	0.4	11. October 2002	 - Last script-style version coded 

;	0.3	11. October 2002	 - First version found named on board 

; 

;SYNTAX 

;	 vbs2KiX( SOURCE , DESTINATION ) 

; 

;PARAMETERS 

; 

;	SOURCE		- The VBScript file to translate 

;	DESTINATION	- Kix-script file where to save the code 

; 

;RETURNS 

;	nothing. check @error for success/failure. 

; 

;REMARKS 

;	you find something where this does not worky, please report 

;	I'm no VBS dude, so don't know what all need to be translated. 

; 

;DEPENDENCIES 

;	kixtart      

; 

;EXAMPLE 

;	"Running logonscript..." 

;	vbs2KiX(@ldrive+"\logon.vbs","%temp%\logon.kxs") 

;	if not @error 

;	 call "%temp%\logon.kxs" 

;	endif 

; 

; 

;SOURCE 

function vbs2KiX($src,$dst)

dim $file,$,$!,$_,$s,$t,$u,$c

 $file=freefilehandle if not $file exit 1 endif $=open($file,$src) if @error exit @error endif

 $=readline($file) redim $src while @error=0 $u=ubound($src)+1 redim preserve $src[$u] $src[$u]=$ $=readline($file) loop $=close($file)

 $file=0+freefilehandle if not $file exit 1 endif if exist($dst) del $dst endif $=open($file,$dst,5) if @error exit @error endif

 redim $dst[$u]



 for $=0 to $u

  $l=$src[$] $s="" $!=0 $_=len($l)

  for $!=1 to $_

   $c=substr($l,$!,1)

   select

    case $c='"' $s=$s+$c do if $!>=$_ $dst[$]=$s $=$+1 $l=$src[$] $s='' $!=0 $_=len($l) endif do $!=$!+1 $c=substr($l,$!,1) $s=$s+$c until $c='"' or $!=>$_ until $c='"' or $=$u

    case $c='"' $s=$s+$c do if $!>=$_ $dst[$]=$s $=$+1 $l=$src[$] $s='' $!=0 $_=len($l) endif do $!=$!+1 $c=substr($l,$!,1) $s=$s+$c until $c="'" or $!=>$_ until $c="'" or $=$u

    case $c="	" or $c=" " $s=$s+$c

    case $c="&" $s=$s+"+"

    case 1

	$t="" do $t=$t+$c $!=$!+1 $c=substr($l,$!,1) until instr(" 	",$c) $!=$!-1

	select

	 case $t="_" or $t="then" or $t="wscript.echo"

	 case $t="const"  do $!=$!+1 $c=substr($l,$!,1) until $c<>" " and $c<>"	" $!=$!-1 $s=$s+"Global $$"

	 case $t="dim"  do $!=$!+1 $c=substr($l,$!,1) until $c<>" " and $c<>"	" $!=$!-1 $s=$s+"Dim $$"

	 case $t="set"  do $!=$!+1 $c=substr($l,$!,1) until $c<>" " and $c<>"	" $!=$!-1 $s=$s+"$$"

	 case $t="wscript.quit" $s=$s+"Quit"

	 case $t="true" $s=$s+"not 0"

	 case $t="false" $s=$s+"not 1"

	 case $t+substr($l,$!,3)="end if" $s=$s+"EndIf"

	 case 1 $s=$s+$t

	endselect

   endselect

  next

  $dst[$]=$s

 next

 for $=0 to $u $!=writeline($file,$dst[$]+@crlf) next

endfunction


 
 [ 10. October 2003, 09:53: Message edited by: Lonkero ]123219Vigenere119LonkeroVigenere() - crypt/decrypt with vigenere cipher0Code:


;Function:

;	Vigenere()

;

;Author:

;	Lonkero (Jooel_Nieminen@hotmail.com)

;

;Version:

;	1.0

;

;Version History:

;	1.0	19.7.2004	initial release

;

;Action:

;	crypts/decrypts text using vigenere cipher

;

;Syntax:

;	Vigenere(TEXT,KEY[,DECRYPT])

;

;Parameters:

;	TEXT	Text to be converted

;	KEY	Keyword to use as a mask

;	DECRYPT	optional. set this to decrypt

;

;Remarks:

;	read the new golf task has something to do with this

;	 and then found bryce's udf. decided to make it my way. 

;

;Returns:

;	the text translated

;

;Dependencies:

;	none

;

;Examples:

;	vigenere("TOBEORNOTTOBE","WHATTHEF") ?

;	vigenere(vigenere("TOBEORNOTTOBE","WHATTHEF"),"WHATTHEF",1) ?

;	get $

;

;Source:

function vigenere($text,$key,optional $_)

dim $,$!,$c,$t

 for $=1 to len($text)

  $c=ucase(substr($text,$,1))

  if $c=>"A" and $c<="Z"

   $t=$t+$c

  endif

 next

 for $=1 to len($text)

  $! = $ mod len($key)

  if $!=0 $!=len($key) endif

  $c=asc(substr($text,$,1))-65

  if $_

   $c=$c-(asc(substr($key,$!,1))-65)

   if $c<0 $c=$c+26 endif

  else

   $c=$c+(asc(substr($key,$!,1))-65)

   if $c>25 $c=$c-26 endif

  endif

  $vigenere=$vigenere+chr($c+65)

 next

endfunction

 83582Vinge28BryceVinge() - Vigenere Encryption0I saw the Rot13 and decided to share.....

PMBE TYX ZWTXR FY UQUMAIM!!

This is the Vigenere Encryption routine.
You need the following Functions.

Vinge('text to crypt/decrypt', 'Keyword to use', Optional decrypt flag)

these are internal functions for the Vinge() function.
-Csplit()
-LTN()
-NTL()

code:

Function Vinge($plaintext, $key ,optional $decode)

	dim $alpha, $pointer, $keypointer, $cipher

	$alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
	if not vartype($data)
		$data = csplit($alpha)
	endif

	$key = csplit("$key")

	if $decode
		dim $pointer
		for $pointer = 0 to ubound($key)
			if (26 - ltn($key[$pointer])) = 26
				$key[$pointer] = ntl(0)
			else
				$key[$pointer] = ntl(26 - ltn($key[$pointer])) 
			endif
		next
	endif
	
	$keypointer = 0
	$cipher = ""
	
	for $pointer = 1 to len($plaintext)
		if $keypointer > ubound($key)
			$keypointer = 0
		endif
		if instr($Alpha,substr($plaintext,$pointer,1)) <> 0
			$temp = ltn(substr($plaintext,$pointer,1))+ltn($key[$keypointer])
			$cipher = $cipher + ntl(val($temp mod 26))
			$keypointer = $keypointer+1
		else
			$cipher = $cipher+substr($plaintext,$pointer,1)
		endif
	next
	$vinge = $cipher
endfunction

code:

Function Csplit($data)
	DIM $datapointer
	Dim $temparray[len($data)-1]
	for $datapointer = 1 to len($data)
		$temparray[$datapointer-1] = substr($data,$datapointer,1)
	next
	$csplit = $temparray
endfunction

code:

Function LTN($aletter)
	DIM $pointer

	if not vartype($data)
		$data = csplit("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
	endif

	for $pointer = 0 to ubound($data)
		if $data[$pointer] = $aletter
			$LTN = val($pointer)
			exit(0)
		endif
	next	
endfunction

code:

Function NTL($ANumber)
	DIM $pointer

	if not vartype($data)
		$data = csplit("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
	endif
	
	$ntl = $data[$anumber]
endfunction


 
 [ 28. October 2002, 19:44: Message edited by: Radimus ]82621Warning17SealeopardWarning() - Prints a warning message on screen and logs it in error log0

code:

;FUNCTION      Warning
;
;ACTION        Prints a warning message on screen
;
;AUTHOR        Jens Meyer (sealeopard@usa.net)
;
;VERSION       1.32 (changed DisplayText parameter order)
;              1.31
;
;DATE CREATED  2001/12/19
;
;DATE MODIFIED 2003/07/30
;
;KIXTART       4.20
;
;SYNTAX        WARNING(STRING)
;
;PARAMETERS    STRING
;              Required string containing the warning message
;
;RETURNS       0 if successful, otherwise errorcode
;
;REMARKS       Warning messages are not logged into an error log
;
;DEPENDENCIES  DISPLAYTEXT() @ http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000036
;
;EXAMPLE       $rc=warning('This is a warning!')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000099
;
function warning($sText)
  if $sText
    $warning=displaytext('Warning: '+$sText,1,'r/n')
  endif
endfunction


 
 [ 30. July 2003, 21:29: Message edited by: sealeopard ]84721Weblnk79KdyerWeblnk() - Create a web shortcut0

 ;Function Weblnk($url,$site) 

 ; 

 ;Author  Kent Dyer (leptonator@hotmail.com) 

 ; 

 ;Contributors 

 ; 

 ;Action  Create a web shortcut. 

 ; 

 ;Syntax  Weblnk('urlfile','webaddress') 

 ; 

 ;Version 1.3 

 ; 

 ;Date           30-October 2003 

 ; 

 ;Date Revised   2 November 2003 

 ; 

 ;Parameters  urlfile 

 ;  file.url created on the client desktop 

 ; 

 ;  webaddress 

 ;  http/https address to the site you want the user to go to 

 ; 

 ;  icon 

 ;  Optional Parameter to define an icon for the URL file you are creating 

 ; 

 ;Remarks Creates a desktop shortcut to a webpage - there are WMISHORTCUT, SHORTCUT.EXE methods to do this 

 ;  But, this does it all internal to KiXtart 

 ;  Version 1.0 original version 

 ;  Version 1.1 Took the $desktop var out of the feed into the Function 

 ;  Version 1.2 Added in $icon and Dimmed 

 ;  Version 1.3 Removed $icon 

 ; 

 ;Returns Nothing 

 ; 

 ;Dependencies  Internet Explorer, have not tested on Netscape 

 ; 

 ;KiXtart Ver 4.02 

 ; 

 ;Example(s) $desktop=READVALUE('HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders','Desktop') 

 ; IF 0=EXIST($desktop+'\Microsoft.url') 

 ;    weblnk($desktop+'\Microsoft.url','http://www.microsoft.com') 

 ; ENDIF 

 ; 

 

 FUNCTION weblnk($url,$site)

    DIM $rc,$iconindex,$iconfile,$icon

    $rc=WRITEPROFILESTRING($url,'DEFAULT','BASEURL',$site)

    $rc=WRITEPROFILESTRING($url,'InternetShortcut','URL',$site)

 ENDFUNCTION
 
 [ 03. November 2003, 01:36: Message edited by: kdyer ]83815WebsiteStatus52NTDOCWebsiteStatus()  Checks to verify a website is up and running0


;Function WebsiteStatus($ChkString, $url, $Email)
;
;Author Ron Lewis/NTDOC (ntdoc@kixhelp.com)
;
;Action Checks to verify a website is up and running
;
;Syntax WebsiteStatus("string to check for", "URL of website to check", "your email address don't forget to doubl e the @@ signs")
;
;Date 2003-FEB-17, updated 2003-FEB-17
;
;Version 1.02
;
;Update Changes Changed the object to "microsoft.xmlhttp" and implemented with ARGUMENTS
;
;Remarks Not tested, but I think if it acts like browser, if site is down you get different page.. so should email you.
;
;Dependencies NT/2000/XP - Not tested or designed for Windows 9x
; KiXtart Ver 4.12 or newer, Outlook (not Express)
; Requires IE 5.0 or newer
; 
;Example wkix32.exe geturl.kix /i
; BREAK On
; WHILE @ERROR = 0
; WebsiteStatus("KiXHelp.com", "http://www.kixhelp.com/", "john.doe@@my.company.com")
; SLEEP 300
; LOOP
;
;Code

Function WebsiteStatus($ChkString, $url, $Email)
$HTTP = CreateObject("microsoft.xmlhttp")
$HTTP.Open("GET", $url, NOT)
$HTTP.Send
$SiteStatus=($HTTP.ResponseText)
IF NOT INSTR($SiteStatus, $ChkString)
$Root = CreateObject("Outlook.Application")
$MailItem = $Root.CreateItem( 0 )
$MailItem.Importance=2
$MailItem.Subject = "Website Status"
$MailItem.To = $Email
$MailItem.Body = "The website $url appears to be down at @DATE @TIME"
$MailItem.Send
$Root=""
ENDIF
EndFunction


 
 [ 18. February 2003, 08:56: Message edited by: NTDOC ]158359WindowsInstallFolder52NTDOCWindowsInstallFolder() - Get remote/local Windows install folder1141753166

;Function	WindowsInstallFolder() - Get remote or local Windows install folder  
;   
;Author		NTDOC   
;   
;Contributors 
;   
;Action		Checks the remote or local installation path for Windows  
;   
;Syntax		WindowsInstallFolder(optional $sComputer,$UNC)   
;   
;Version	1.0   
;   
;Date		2006-Mar-05   
;   
;Date Revised	xxxx-xxx-xx   
;   
;Revision   
;		1.0:	Initial release  
;   
;Parameters	Name of the remote system to check. If blank current workstation is used 
;		Use a 1 to return the UNC as part of the path which will include the system as well 
;   
;Remarks	Tested on NT/2000/XP/2003   
;   
;Returns	Windows installation folder and Error Code  
;   
;Dependencies	KiXtart v4.5   
;		Written and tested with KiXtart v4.52 beta 2   
;   
;Example:   
;		Dim $WinPath 
;		$WinPath = WindowsInstallFolder('ZANGETSU',1)  
;		If @ERROR  
;		  'An error occurred while checking for Windows path.  ERROR:' + @ERROR + ' - ' + @SERROR ? 
;		Else 
;		  'Windows path is: ' + $WinPath ? 
;		EndIf 
; 
;		Using the optional $UNC produces similar to this 
;		\\ZANGETSU\E$\WINDOWS 
;		Not using the optional $UNC produces similar to this 
;		E:\WINDOWS 
;   
;Source   
 
Function WindowsInstallFolder(optional $sComputer,$UNC)
  Dim $sComputer,$WinDir
  $sComputer=IIf(Not $sComputer,'','\\'+Join(Split($sComputer,'\'),'',3)+'\')
  If $sComputer And $UNC
    $WinDir = $sComputer+Join(Split(ReadValue($sComputer+'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion','SystemRoot'),':'),'$')
  Else
    $WinDir = ReadValue($sComputer+'HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion','SystemRoot')
  EndIf
  If @ERROR
    $WindowsInstallFolder = ''
    Exit Val('&' + Right(DecToHex(@ERROR), 4))
  Else
    $WindowsInstallFolder = $WinDir
  EndIf
  Exit @ERROR
EndFunction
 
122688WMIChangeService3123Rory DanielsWMIChangeService - WMI Change Service Details0 Code:

 ;Function	WMIChangeService($Hostname,$ServiceName,Optional $DisplayName,Optional $PathName,Optional $StartType,Optional $Username,Optional $Pass)
;
;Author		Rory Daniels
;
;Contributors	NTDOC, Platform SDK: Windows Management Instrumentation
;
;Action		Changes service settings on Windows 2000 and Windows XP machines using WMI interface.
;
;Syntax		WMIChangeService(@WKSTA,"Alerter","Alerter",,"Automatic","domain\user","password")
;
;Version	1.0
;
;Date           12/07/2004
;
;Date Revised   n/a
;
;Parameters:
;			$Hostname : 	netbios name of the machine to change 
;			$ServiceName:	name of the service to change
;			
;Optional Parameters:
;			DisplayName : 	Display name of the service. This string has a maximum length of 256 characters. 
;						The name is Case-preserved in the service control manager. DisplayName comparisons 
;						are always Case-insensitive. Constraints: accepts the same value as the Name property, 
;						For example, "Atdisk".
 
;			$PathName: 	Fully-qualified path to the executable file that implements the service, For example, 
;						"\SystemRoot\System32\drivers\afd.sys".

;			$StartType:	Start mode of the Windows base service. 
;						Value			Meaning
;						Boot 		Device driver started by the operating system loader. 
;						System 		Device driver started by the IoInitSystem method. This value is valid 
;									only For driver services. 
;						Automatic 	Service to be started automatically by the service control manager 
;									during system startup. 
;						Manual 		Service to be started by the service control manager when a process 
;									calls the StartService method. 
;						Disabled 		Service that can no longer

;			$Username:	Account name the service runs under. Depending on the service type, the account name 
;						may be in the form of DomainName\Username OR .\Username. The service process will be 
;						logged using one of these two forms when it runs. If the account belongs to the built-in
;						domain, .\Username can be specified. If NULL is specified, the service will be logged on
;						as the LocalSystem account. For kernel OR system-level drivers, StartName contains the 
;						driver object name (that is, \FileSystem\Rdr OR \Driver\Xns) that the input AND output 
;						(I/O) system uses to load the device driver. If NULL is specified, the driver runs with a 
;						default object name created by the I/O system based on the service name, 
;						For example, DWDOM\Admin.
;						Windows XP:  You can Use the UPN format to specify the StartName, 
;						For example, Username@DomainName.

;			$Pass		Password to the account name specified by the StartName parameter. Specify NULL If you are 
;						NOT changing the Password. Specify an empty string If the service has no Password. 
;						Note  When changing a service from local system to network, OR from network to local system,
;						StartPassword must be an empty string ("") AND NOT NULL.
;
;
;Returns	
;			0 	Success 
;			1 	NOT Supported 
;			2 	Access Denied 
;			3 	Dependent Services Running 
;			4 	Invalid Service Control 
;			5 	Service Cannot Accept Control 
;			6 	Service NOT Active 
;			7 	Service Request Timeout 
;			8 	Unknown Failure 
;			9 	Path NOT Found 
;			10 	Service Already Running 
;			11 	Service Database Locked 
;			12 	Service Dependency Deleted 
;			13 	Service Dependency Failure 
;			14 	Service Disabled 
;			15 	Service Logon Failure 
;			16 	Service Marked For Deletion 
;			17 	Service No Thread 
;			18 	Status Circular Dependency 
;			19 	Status Duplicate Name 
;			20 	Status Invalid Name 
;			21 	Status Invalid Parameter 
;			22 	Status Invalid Service Account 
;			23 	Status Service Exists 
;			24 	Service Already Paused 
;;
; 
;Dependencies 	WMI is included in Windows XP, Windows 2000 Professional.
;
;KiXtart Ver	4.22
; 
;Example(s)	WMIChangeService(@WKSTA,"Alerter","Alerter",,"Automatic","domain\user","password")
; 

Function WMIChangeService($Hostname,$ServiceName,Optional $DisplayName,Optional $PathName,Optional $StartType,Optional $Username,Optional $Pass)
	? "Function WMIChangeService: Started"
	$WMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\$Hostname\root\cimv2")
	If @ERROR = 0 
		? "Function WMIChangeService: WMI Connected"
		$ServiceList = $WMIService.ExecQuery("Select * from Win32_Service")
		If @ERROR = 0
			For Each $service in $ServiceList
				If $Service.name = $ServiceName
					$err = $Service.Change( $DisplayName,$PathName, , ,$StartType , ,$Username,$Pass)
					If $err = 0
						? "Function WMIChangeService: Change was successful"
						$WMIChangeService=0
					Else
						? "Function WMIChangeService: Change was unsuccessful error $err"
						$WMIChangeService=1
					EndIf
				EndIf 
			Next
		Else
			? "Function WMIChangeService: WMI Query Failed"
		EndIf
	Else
		? "Function WMIChangeService: WMI Failed"
		$WMIChangeService=1
		Exit
	EndIf
	? "Function WMIChangeService: Finished"
EndFunction 

  115296WMIConfirm52NTDOCWMIConfirm() - Confirm access and version of WMI1141264452

;Function	WMIConfirm() - Confirm access to WMI  
;  
;Author		NTDOC  
;  
;Contributors	Glenn Barnas, Jens  
;  
;Action		Checks the version of WMI and confirms successful connection  
;  
;Syntax		WMIConfirm(Optional $sComputer)  
;  
;Version	1.3  
;  
;Date		2004-Mar-01  
;  
;Date Revised	2006-Mar-01  
;  
;Revision  
;		1.2:	Modified to simpler method that can handle Windows 9x as well  
;		1.3:	NTDOC: Renamed from ConfirmWMI to WMIConfirm() to be in line with CLASS / Function name 
;		1.3:	Glenn: Changed return values. Returns WMI version if successful, 0 if not.  
;			This allows "If WMIConfirm()" testing. Also changed exit codes.  
;			Now exits 0 on success and error code on error. Returning Version in the exit status  
;			prevented success/fail checking 
;  
;Parameters	Name of the remote system to check. If blank current workstation is used  
;  
;Remarks	Tested on NT/2000/XP/2003  
;  
;Returns	Version of WMI and Error Code 
;  
;Dependencies	KiXtart v4.5  
;		Written and tested with KiXtart v4.52 beta 2  
;  
;Example:  
;		Dim $WMICheck 
;		$WMICheck = WMIConfirm('MyServer') 
;		If $WMICheck 
;		  'WMI version is: ' + $WMICheck ? 
;		  ;WMI appears to be okay - run your query here... 
;		Else 
;		  'An error occurred while checking for WMI access.  ERROR:' + @ERROR + ' - ' + @SERROR ? 
;		EndIf 
;  
;Additional WMI Info  
;		Platform	WMI  
;		Windows 95	1085.0005 (1.5)  
;		Windows 98	1085.0005 (1.5)  
;		Windows NT 4.0	1085.0005 (1.5)  
;		Windows 2000	1085.0005 (1.5)  
;		Windows XP	2600.0000  
;		Server 2003	3790.0000 
;  
;Source  
 
Function WMIConfirm(optional $sComputer) 
  Dim $objWMIService, $objWMISetting, $colWMISettings 
  $sComputer = IIf(Not $sComputer,'','\\'+Join(Split($sComputer,'\'),'',3)+'\') 
  $objWMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!"+$sComputer+'root\cimv2') 
  ; Failed - return 0 and exit with error value  
  If @ERROR 
    $WMIConfirm = 0 
    Exit Val('&' + Right(DecToHex(@ERROR), 4)) 
  EndIf 
  $colWMISettings = $objWMIService.ExecQuery("Select * from Win32_WMISetting") 
  For Each $objWMISetting In $colWMISettings 
    $WMIConfirm = $objWMISetting.BuildVersion 
  Next 
  Exit 0 
EndFunction
 

 
122802WMICreateService3123Rory DanielsWMICreateService()1089794985 Code:

 ;WMICreateService($Hostname,$ServiceName,$DisplayName,$PathName,$StartType,Optional $Username,Optional $Pass)

;

;Author		Rory Daniels

;

;Contributors	Radimus, Platform SDK: Windows Management Instrumentation

;

;Action		Creates a new service on Windows 2000 and Windows XP machines using WMI interface.

;

;Syntax		WMICreateService("Hostname","Service Name","Display Name","Path on machine","Startup Type","UserName","Password",$Verbose)

;

;Version	1.0

;

;Date           13/07/2004

;

;Date Revised   n/a

;

;Parameters:

;			$Hostname : 	netbios name of the machine to create 

;			$ServiceName:	name of the service to create

;			

;Optional Parameters:

;			DisplayName : 	Display name of the service. This string has a maximum length of 256 characters. 

;						The name is Case-preserved in the service control manager. DisplayName comparisons 

;						are always Case-insensitive. Constraints: accepts the same value as the Name property, 

;						For example, "Atdisk".

 

;			$PathName: 	Fully-qualified path to the executable file that implements the service, For example, 

;						"\SystemRoot\System32\drivers\afd.sys".



;			$StartType:	Start mode of the Windows base service. 

;						Value			Meaning

;						Boot 		Device driver started by the operating system loader. 

;						System 		Device driver started by the IoInitSystem method. This value is valid 

;									only For driver services. 

;						Automatic 	Service to be started automatically by the service control manager 

;									during system startup. 

;						Manual 		Service to be started by the service control manager when a process 

;									calls the StartService method. 

;						Disabled 		Service that can no longer



;			$Username:	Account name the service runs under. Depending on the service type, the account name 

;						may be in the form of DomainName\Username OR .\Username. The service process will be 

;						logged using one of these two forms when it runs. If the account belongs to the built-in

;						domain, .\Username can be specified. If NULL is specified, the service will be logged on

;						as the LocalSystem account. For kernel OR system-level drivers, StartName contains the 

;						driver object name (that is, \FileSystem\Rdr OR \Driver\Xns) that the input AND output 

;						(I/O) system uses to load the device driver. If NULL is specified, the driver runs with a 

;						default object name created by the I/O system based on the service name, 

;						For example, DWDOM\Admin.

;						Windows XP:  You can Use the UPN format to specify the StartName, 

;						For example, Username@DomainName.



;			$Pass		Password to the account name specified by the StartName parameter. Specify NULL if you are 

;						NOT changing the Password. Specify an empty string If the service has no Password. 

;

;			$Verbose		Outputs error text if set to Y

;

;

;Returns	

;			0	The request was accepted. 

;			1 	The request is NOT supported. 

;			2 	The user did NOT have the necessary access. 

;			3 	The service cannot be stopped because other services that are running are dependent on it. 

;			4 	The requested control code is NOT valid, OR it is unacceptable to the service. 

;			5 	The requested control code cannot be sent to the service because the state of the service 

;				(Win32_BaseService State property) is equal to 0, 1, OR 2. 

;			6 	The service has NOT been started. 

;			7 	The service did NOT respond to the start request In a timely fashion. 

;			8 	Interactive Process. 

;			9 	The directory path to the service executable file was NOT found. 

;			10 	The service is already running. 

;			11 	The database to add a new service is locked. 

;			12 	A dependency For which this service relies on has been removed from the system. 

;			13 	The service failed to find the service needed from a dependent service. 

;			14 	The service has been disabled from the system. 

;			15 	The service does NOT have the correct authentication to Run on the system. 

;			16 	This service is being removed from the system. 

;			17 	There is no execution thread For the service. 

;			18 	There are circular dependencies when starting the service. 

;			19 	There is a service running under the same name. 

;			20 	There are invalid characters In the name of the service. 

;			21 	Invalid parameters have been passed to the service. 

;			22 	The account which this service is to Run under is either invalid OR lacks the permissions to Run the 

;				service. 

;			23 	The service exists In the database of services available from the system. 

;			24 	The service is currently paused In the system. 

;;

; 

;Dependencies 	WMI is included in Windows XP, Windows 2000 Professional.

;

;KiXtart Ver	4.22

; 

;Example(s)	WMICreateService(@WKSTA,"Alerter","Alerter","C:\WINNT\System32\services.exe","Automatic","domain\user","password",$Verbose)

; 



Break on

WMICreateService(@WKSTA,"Alerter","Alerter","C:\WINNT\System32\services.exe","Automatic","domain\user","password",Y)



Function WMICreateService($Hostname,$ServiceName,$DisplayName,$PathName,$StartType,Optional $Username,Optional $Pass, Optional $Verbose)

	Dim $Hostname,$ServiceName,$DisplayName,$PathName,$StartType,$Username,$Pass,$WMIService,$WMIServiceCreateProperties,$GetError,$GotErr, $Verbose 

	Dim $ReturnText[25]

	If $Verbose = Y

		? "Function WMICreateService: Started"

	EndIf

	$WMIService = GetObject("winmgmts:{impersonationLevel=impersonate}!\\$Hostname/root/cimv2:Win32_Service")

	If @ERROR = 0 

		If $Verbose = Y

			? "Function WMICreateService: WMI Connected"

		EndIf

		$WMIServiceCreateProperties = $WMIService.Methods_("Create")

		$Properties = $WMIServiceCreateProperties.inParameters.SpawnInstance_()

		$Properties.Name = $ServiceName

		$Properties.DisplayName = $DisplayName

		$Properties.PathName = $PathName

		$Properties.StartMode = $StartType

		$Properties.StartName = $UserName

		$Properties.StartPassword = $pass

		$GetError = $WMIService.ExecMethod_("Create", $Properties)

		$GotErr = $GetError.ReturnValue

		?

		$ReturnText[0] = "Function WMICreateService: Service " + $ServiceName + " has been created successfully"

		$ReturnText[1] = "Function WMICreateService: Not Supported"

		$ReturnText[2] = "Function WMICreateService: Access Denied"

		$ReturnText[3] = "Function WMICreateService: Dependent Services Running"

		$ReturnText[4] = "Function WMICreateService: Invalid Service Control"

		$ReturnText[5] = "Function WMICreateService: Service Cannot Accept Control"

		$ReturnText[6] = "Function WMICreateService: Service Not Active"

		$ReturnText[7] = "Function WMICreateService: Service Request Timeout"

		$ReturnText[8] = "Function WMICreateService: Unknown Failure"

		$ReturnText[9] = "Function WMICreateService: Path Not Found"

		$ReturnText[10] = "Function WMICreateService: Service Already Running"

		$ReturnText[11] = "Function WMICreateService: Service Database Locked"		

		$ReturnText[12] = "Function WMICreateService: Service Dependency Deleted"

		$ReturnText[13] = "Function WMICreateService: Service Dependency Failure"

		$ReturnText[14] = "Function WMICreateService: Service Disabled"

		$ReturnText[15] = "Function WMICreateService: Service Logon Failure"		

		$ReturnText[16] = "Function WMICreateService: Service Marked For Deletion"

		$ReturnText[17] = "Function WMICreateService: Service No Thread"

		$ReturnText[18] = "Function WMICreateService: Status Circular Dependency"

		$ReturnText[19] = "Function WMICreateService: Status Duplicate Name"

		$ReturnText[20] = "Function WMICreateService: Status Invalid Name"

		$ReturnText[21] = "Function WMICreateService: Status Invalid Parameter"

		$ReturnText[22] = "Function WMICreateService: Status Invalid Service Account"

		$ReturnText[23] = "Function WMICreateService: Status Service Exists"

		$ReturnText[24] = "Function WMICreateService: Service Paused"

		$WMICreateService = $ReturnText[$GotErr]

		Exit $GotErr

	Else

		If $Verbose = Y

			? "Function WMICreateService: WMI Failed"

		EndIf

		$WMICreateService=1

		Exit

	EndIf

	If $Verbose = Y

		? "Function WMICreateService: Finished"

	EndIf

EndFunction

  84324WMIDate17SealeopardWMIDate() - Converts between KiXtart and WMI datetime strings0

code:

;FUNCTION      WMIDate()
;
;ACTION        Converts between KiXtart and WMI datetime strings
;
;AUTHOR        Jens Meyer
;
;VERSION       1.0
;
;DATE CREATED  2002/05/26
;
;DATE MODIFIED 2003/05/26
;
;KIXTART VER   4.12
;
;SYNTAX        RETCODE = WMIDATE([DATETIME])
;
;PARAMETERS    DATETIME
;              Optional string containing either a datetimestring or a WMI datestring. If only a time is passed,
;              the current date will be used. Format must be 'YYY/MM/DD HH:MM:SS', 'YYY/MM/DD', or 'HH:MM:SS'
;
;RETURN        WMI datetime string or KiXtart datetime string
;
;REMARKS       replaces ConvertFromWMIDate() and ConvertToWMIDate()
;
;DEPENDENCIES  WMI
;
;EXAMPLE       ; converts current date/time
;              $wmidate = WMIDate()
;              ; converts time for current date
;              $wmidate = WMIDate('00'10'32')
;              ; converts date (midnight)
;              $wmidate = WMIDate('2002/09/22')
;              ; converts WMI date to KiXtart date
;              $wmidate('20030526182933.000000-240')
;
;KIXTART BBS   http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic&f=12&t=000417
;
function WMIDate(optional $datetime)
  dim $date, $time, $timezone
  dim $objWMIService, $colItems, $objItem

  if instr($datetime,'.')
    $WMIDate=left($datetime,4)+'/'+substr($datetime,5,2)+'/'+substr($datetime,7,2)+' '
    $WMIDate=$WMIDate+substr($datetime,9,2)+':'+substr($datetime,11,2)+':'+substr($datetime,13,2)
  else
    $objWMIService = getObject('winmgmts:{impersonationLevel=impersonate}!//./root/cimv2')
    if @ERROR
      exit @ERROR
    endif
    $colItems = $objWMIService.ExecQuery('Select CurrentTimeZone from Win32_ComputerSystem')

    for each $objItem in $colItems
      $timezone = $objItem.CurrentTimeZone
    next

    $objWMIService = 0
    $colItems = 0
    $objItem = 0

    $datetime=trim($datetime)

    select
    case instr($datetime,' ')
      $datetime=split($datetime,' ')
      $date=$datetime[0]
      $time=$datetime[1]
    case instr($datetime,'/')
      $date=$datetime
      $time='00:00:00'
    case instr($datetime,':')
      $date=@DATE
      $time=$datetime
    case 1
      $date=@DATE
      $time=@TIME
    endselect
    $WMIDate=join(split($date,'/'),'')+join(split($time,':'),'')+'.000000'+$timezone
  endif

  exit @ERROR
endfunction


 
 [ 27. May 2003, 00:27: Message edited by: sealeopard ]83051WMIKill127BreakerWMIKill() - stops a process0Ooh! My first UDF! I'm so excited! This is based on a Perl script by Dave Roth in his very excellent book for Win32 Admins.

WMIKill() - stops a process

Syntax:  WMIKill("process",["computer"])

Params:  "process" - the name of the process you wish to kill
         "computer" - the (remote) machine on which you wish to stop the process. Optional - if not specified, defaults to @WKSTA.

Returns: 0 if process stopped successfully
         1 if could not stop process
         2 if WMI not present on target machine

Dependencies:  Kix 4.00 or greater for COM support
               WMI installed on target machine

Examples:  $x = WMIKill("notepad.exe","my_workstation")
           $x = WMIKill("iexplore.exe")

           If not WMIKill("payserve.exe","corp16")
               ? "Stopped Pay/2 server app on Corp16."
           Endif

Source:

 

code:

Function WMIKill($proc_to_kill,optional $computer)
        Dim $wmistring, $wmi, $process, $processes
	If not $computer $computer = @WKSTA Endif
	$wmistring = "winmgmts:{impersonationlevel=impersonate}!//" + $computer
	$wmi = getobject($wmistring)
	If $wmi
		$processes = $wmi.instancesof("win32_process")
		For Each $process In $processes
			If $process.name = $proc_to_kill
				$kill = $process.terminate(0)
				If @ERROR = 0
					$wmi = 0
					Exit 0
				Else
					$wmi = 0
					Exit 1
				Endif
			Endif
		Next
	Else
		Exit 2
	Endif
Endfunction
  

Hope it proves useful to someone out there!!

Breaker
 
 [ 15 April 2002, 15:52: Message edited by: Breaker ]119988wmiPing46kholmwmiPing() - Ping an IP-address,return responsetime0Code:

;FUNCTION   wmiPing()
;
;ACTION:
;   Ping an IP-address/name and return the responsetime in msecs.
; 
;AUTHOR:
;   KHOLM
; 
;VERSION:
;   1.0
;
;DATE CREATED:
;   23 may 2004
;
;KIXTART:
;   4.22
; 
;SYNTAX;
;   wmiPing($Address[,$Timeout [,$BlockSize]]) 
;
;PARAMETERS:
;   $Address:   Name and IP-address of target to ping
;   $Timeout:   Optional, max waittime for reply in msecs. Default is 1000
;   $BlockSize: Optional, size of send/recieve block in bytes. Default is 32
;
;RETURNS:
;   Time of response in msecs. if successfull
;   otherwise noting and @Error = 1
;
;DEPENDENCIES:
;   Windows XP or Server 2003
;
;EXAMPLE:
;   $Add = '195.140.240.55' ; Same as $Add = 'kixtart.org'
;   $Res = wmiPing($Add,5000)
;   If @Error
;      ? 'No response from: ' + $Add
;   Else
;      ? 'Responsetime for: ' + $Add + ' is ' + $Res + ' ms'
;   EndIf
;
;SOURCE:
Function wmiPing($Address,Optional $Timeout,Optional $BlockSize)
   Dim $Query,$oWMI,$oItem,$cItems
   
   $Query = "Select ResponseTime,StatusCode From Win32_PingStatus Where Address='" + $Address + "'"
   If $Timeout
      $Query = $Query + " And TimeOut=" + $Timeout
   EndIf
   If $BlockSize
      $Query = $Query + " And BufferSize=" + $BlockSize
   EndIf
   $oWMI = GetObject("winmgmts:root\cimv2")
   $cItems = $oWMI.ExecQuery($Query)
   For Each $oItem In $cItems
      If (VarTypeName($oItem.StatusCode) = 'Null') Or $oItem.StatusCode
         Exit 1
      Else
         $wmiPing = $oItem.ResponseTime
      EndIf
   Next
EndFunction



-Erik  184899WMIPing119LonkeroWMIPing() - reworked version0

;FUNCTION   wmiPing()
;
;ACTION:
;   Ping an IP-address/name and return the responsetime in msecs.
; 
;AUTHORs:
;   KHOLM
;   Jooel
; 
;VERSION:
;   1.1
;
;DATE CREATED:
;   11 Dec 2006
;
;REVISION HISTORY:
;   Original release from 2004 can be found here
;KIXTART:
;   4.22
; 
;SYNTAX;
;   wmiPing($Address[,$Timeout [,$BlockSize]]) 
;
;PARAMETERS:
;   $Address:   Name and IP-address of target to ping
;   $Timeout:   Optional, max waittime for reply in msecs. Default is 1000
;   $BlockSize: Optional, size of send/recieve block in bytes. Default is 32
;
;RETURNS:
;   Time of response in msecs if successfull
;   otherwise @error is set to statuscode.
;
;DEPENDENCIES:
;   Windows XP or Server 2003
;
;EXAMPLE:
;   $Add = '195.140.240.55' ; Same as $Add = 'kixtart.org'
;   $Res = wmiPing($Add,5000)
;   If @Error
;      ? 'No response from: ' + $Add
;   Else
;      ? 'Responsetime for: ' + $Add + ' is ' + $Res + ' ms'
;   EndIf
;
;SOURCE:
Function wmiPing($Address,Optional $Timeout,Optional $BlockSize)
   Dim $Query,$oWMI,$oItem,$cItems
   
   $Query = "Select ResponseTime,StatusCode From Win32_PingStatus Where Address='" + $Address + "'"
   If $Timeout
  $Query = $Query + " And TimeOut=" + $Timeout
   EndIf
   If $BlockSize
  $Query = $Query + " And BufferSize=" + $BlockSize
   EndIf
   $oWMI = GetObject("winmgmts:root\cimv2")
   $cItems = $oWMI.ExecQuery($Query)
   For Each $oItem In $cItems
  If (VarTypeName($oItem.StatusCode) = 'Null') Or $oItem.StatusCode
	Exit $oItem.StatusCode
  Else
	$wmiPing = $oItem.ResponseTime
  EndIf
   Next
EndFunction
181587WMIProcessList2980Glenn BarnasWMIProcessList() - returns detail of one or all processes0 
;; 
;;====================================================================== 
;; 
;;FUNCTION       WMIProcessList() 
;; 
;;ACTION         Return a list of process info from a computer 
;; 
;;AUTHOR         Glenn Barnas 
;; 
;;VERSION        1.0 / 2007/10/12 
;;		 Written as a replacement for PSList(), which uses SysInternals PSList.exe 
;; 
;;SYNTAX         WMIProcessList([Process] [, Computer] [, AuthPtr]) 
;; 
;;PARAMETERS     Computer - OPTIONAL, Name of computer to query 
;; 
;;		 Process - return information about a specific process (group) by name 
;;		   or individual process ID (PID) 
;; 
;;               AuthPtr - OPTIONAL - pre-authenticated WMI object pointer 
;;                 Use WMIAuthentication() udf to create the AuthPtr value 
;;                 AuthPtr is not needed if user has admin rights 
;; 
;;REMARKS        By default, returns a detailed list of all processes from the local computer. An 
;;		   alternate computer can be specified, as can a specific process. When specifying 
;;		   processes, you can use a name (cmd.exe) or process ID. If you specify a name, all 
;;		   processeses matching that name will be returned, while specifying a PID will return 
;;		   exactly one element that matches that process (if it was found) 
;;		   If no match is found, the function exits with status 1911 (object not found) 
;; 
;;RETURNS        Array of comma-delimited values, one element per process: 
;;			Process Name 
;;			Process ID (PID) 
;;			Thread Count 
;;			Handle Count 
;;			Memory Usage (Bytes) 
;;			User Time	D:HH:MM:SS.sss format 
;;			Kernel Time	D:HH:MM:SS.sss format 
;;			Elapsed Time	D:HH:MM:SS.sss format 
;; 
;;DEPENDENCIES   WMI, TimeDiff() external UDF 
;; 
;;TESTED WITH    W2K, WXP, W2K3, Vista, Vista64 
;; 
;;EXAMPLES        
; 
Function WMIProcessList(Optional $_Target, OPTIONAL $_Process, OPTIONAL $_pAuth)
 
  Dim $_objWMIService, $_colItems, $_objItem	; WMI object vars 
  Dim $_Line					; line string 
  Dim $_aTmp[0], $_I				; return array, index 
  Dim $_					; temp var 
  Dim $_BTime, $_CTime				; boot and current times from target system 
 
  $_I = -1
 
  $_Target = IIf($_Target, $_Target, '.')
  If InStr($_Target, '\') $_Target = Join(Split($_Target, '\'), '') EndIf
  If $_pAuth
    $_objWMIService = $_pAuth
  Else
    $_objWMIService = GetObject('winmgmts:{impersonationLevel=impersonate}!\\' + $_Target + '\root\cimv2')
    If @ERROR Exit Val('&' + Right(DecToHex(@ERROR), 4)) EndIf
  EndIf
 
  ; Get the current and boot times from the client system 
  $_colItems = $_objWMIService.ExecQuery("Select * from Win32_OperatingSystem",,48)
  For each $_objItem in $_colItems
    $_BTime = $_objItem.LastBootUpTime			; host-local boot time 
    $_CTime = $_objItem.LocalDateTime			; host-local current time 
  Next
  $_colItems = 0
  ; convert to a normalized time string 
  $_CTime = SubStr($_CTime, 1,4) + '/' + SubStr($_CTime, 5,2) + '/' +SubStr($_CTime, 7,2) + ' '
         + SubStr($_CTime, 9,2) + ':' + SubStr($_CTime, 11,2) + ':' + SubStr($_CTime, 13,6)
 
  ; get the collection of process objects 
  $_colItems = $_objWMIService.ExecQuery("Select * from Win32_Process",,48)
  If @ERROR   $_colItems = 0 Exit Val('&' + Right(DecToHex(@ERROR), 4)) EndIf
 
  ; Enumerate the collection of process data 
  For Each $_objItem in $_colItems
    ; add the data to the array if no process is specified, or if a specific process name or ID is specified 
    If Not $_Process Or $_Process = $_objItem.Name Or $_Process = $_objItem.ProcessID 
      $_Line =  $_objItem.Name
      $_Line = $_Line + ',' + $_objItem.ProcessID
      $_Line = $_Line + ',' + $_objItem.Priority
      $_Line = $_Line + ',' + $_objItem.ThreadCount
      $_Line = $_Line + ',' + $_objItem.HandleCount
      $_Line = $_Line + ',' + $_objItem.WorkingSetSize
      ; convert the following to d:hh:mm:ss.sss format 
      $_Line = $_Line + ',' + _WMIPLTC(CDbl($_objItem.UserModeTime) * 0.0000001)
      $_Line = $_Line + ',' + _WMIPLTC(CDbl($_objItem.KernelModeTime) * 0.0000001)
      ; Use the system boot time if creation date is not set 
      $_ = IIf($_objItem.CreationDate , $_objItem.CreationDate, $_BTime)
      ; calculate elapsed time and convert to d:hh:mm:ss.sss format 
      $_Line = $_Line + ',' +  _WMIPLTC(_WMIPLET($_, $_CTime))
      ; Update the array 
      $_I = $_I + 1
      ReDim Preserve $_aTmp[$_I]
      $_aTmp[$_I] = $_Line
    EndIf
  Next
 
  ; return the array, close the collection, and gripe if no items were found 
  $WMIProcessList = $_aTmp
  $_colItems = 0
  If $_Process and $_I < 0 Exit 1911 EndIf
  Exit 0
 
EndFunction
 
 
; support function to calculate elapsed time as Seconds 
; Dependent on TimeDiff UDF! 
Function _WMIPLET($_Time, $_CTime)
 
  Dim $_CurrentTime
 
  ; Break into Date and Time parts, including 3 decimal points 
  $_Time = SubStr($_Time, 1,4) + '/' + SubStr($_Time, 5,2) + '/' +SubStr($_Time, 7,2) + ' '
         + SubStr($_Time, 9,2) + ':' + SubStr($_Time, 11,2) + ':' + SubStr($_Time, 13,6)
 
  ; return the value with 3 decimal places 
  $_WMIPLET = TimeDiff($_Time, $_CTime, '', 1); FormatNumber(, 3, -1, 0, 0) 
  Exit 0
 
EndFunction
 
 
; support function to conver the time value (100ns units) to D:H:M:S.s format 
Function _WMIPLTC($_Units)
 
  Dim $_D, $_H, $_M, $_S		; day, hour, minute, & second values 
 
  ; Find d/h/m and subtract result from units 
  $_D = Int($_Units / 86400)	$_Units = $_Units - $_D * 86400
  $_H = INT($_Units/3600)	$_Units = $_Units - $_H * 3600
  $_M = INT($_Units/60)
  $_S = FormatNumber($_Units - $_M * 60, 3, -1, 0, 0)
 
  ; return a time string 
  $_WMIPLTC = '' + $_D + ':' + $_H + ':' + $_M + ':' + $_S
  Exit 0
 
EndFunction
 
 
 
   

82714WMIQuery31RadimusWMIQuery() - Execute a query against WMI enabled OSs0;FUNCTION     WMIQuery

;

;ACTION        Queries WMI information from supported systems

;

;AUTHOR     Radimus

;

;CONTRIBUTORS    kdyer, Shawn, And Howard

;

;VERSION     2.5

;

;DATE CREATED     12/22/2001

;

;DATE MODIFIED    03/02/2004

;

;KIXTART     4.x

;

;SYNTAX     WMIQuery($what,$from,optional $computer,optional $where, optional $x, Optional $root, Optional $sUserID, Optional $sUserPW)

;

;PARAMETERS     $what

;            

;

;         $from

;            Win32 Collection

;

;        optional $computer

;            defaults to local PC

;

;        optional $where

;            addl parameter for a 'WHERE' clause. Used with $x

;

;        optional $x

;            addl parameter for a 'WHERE' clause. Used with $Where

;

;	 Optional $root

;            addl parameter for different root

;

;	 Optional $sUserID

;            addl parameter for remote authentication

;

;	 Optional $sUserPW

;            addl parameter for remote authentication

;

;RETURNS     Array 

;        @error 1 = Cannot create COM object on target PC

;

;REMARKS    This is chage alters the return from the function into an ARRAY, where the previous version

;        was a pipe '|' delimited string.  If you are updating to this version, check your code closely

;

;DEPENDENCIES     kix 4.x+, WMI

;

;EXAMPLE     $make  = WMIQuery("Manufacturer","Win32_ComputerSystem")[0]

;        $modem = WMIQuery("Description","Win32_POTSModem",$remotePC,"Status","OK")[0]

;        for each $stick in WMIQuery("Capacity","Win32_PhysicalMemory")

;            ? val($stick) / 1048576

;            next

;

;KIXTART BBS     http://www.kixtart.org/board/ultimatebb.php?ubb=get_topic;f=12;t=000117

;        http://download.microsoft.com/download/platformsdk/wmicore/1.5/W9XNT4/EN-US/wmicore.EXE 

Code:


FUNCTION WMIQuery($sWhat, $sFrom, Optional $sComputer, Optional $sWhere, Optional $x, Optional $root, Optional $sUserID, Optional $sUserPW)

	Dim $sQuery, $objEnum, $sValue, $TMP, $SystemSet, $, $objInstance, $objLocator 



	$sComputer = trim(join(split($sComputer,'\'),''))

	If Not $sComputer or $sComputer = @wksta

		$sComputer = '.'

		EndIf

	if not $root

		$root = '\root\cimv2'

		Endif

	$sQuery = 'Select ' + $sWhat + ' From '+ $sFrom

	If $sWhere AND $x

 		$sQuery = $sQuery+" Where "+$sWhere+" = '"+$x+"'"

	 	EndIf

	if $sUserID and $sUserPW and $sComputer <> '.'

		$objLocator = CreateObject('WbemScripting.SWbemLocator')

			If @ERROR or not $objLocator 	Exit VAL("&"+Right(DecToHex(@ERROR),4)) 	EndIf

		$SystemSet  = $objLocator.ConnectServer($sComputer, $root, $sUserID, $sUserPW)

			If @ERROR or not $SystemSet	Exit VAL("&"+Right(DecToHex(@ERROR),4)) 	EndIf

		$SystemSet.Security_.ImpersonationLevel = 3

	else

		$SystemSet = GetObject("winmgmts:{impersonationLevel=impersonate}!\\"+$sComputer+$root)

			If @ERROR or not $SystemSet	Exit VAL("&"+Right(DecToHex(@ERROR),4)) 	EndIf

		Endif

	$objEnum = $SystemSet.ExecQuery($sQuery)

		If @ERROR or not $objEnum	Exit VAL("&"+Right(DecToHex(@ERROR),4)) 	EndIf

	For Each $objInstance in $objEnum

		$=Execute(Chr(36) + 'sValue = ' + Chr(36) + 'objInstance.' + $sWhat)

		if VarType($sValue) & 8192

			$tmp = $tmp +'|' + join($sValue,'|')

		else

			$tmp = $tmp +'|' + $sValue 

			endif

		Next

	$WMIQuery = split(substr($tmp,2),'|')

	Exit VAL("&"+Right(DecToHex(@ERROR),4))

	ENDFUNCTION 

83054WMIService127BreakerWMIService() - Control NT services0Hopefully some will find this useful. 

code:

function WMIService($service,$action,optional $startmode,optional $computer)
;
;ACTION		Use to stop, start, pause and query the status of NT services
;
;SYNTAX		WMIService("service","action" [,"startmode"] [,"computer"])
;
;PARAMETERS	Service
;		The service to perform the action on. Note that this must be the short name
;		of the service, not the display name. For example, "seclogon", not "RunAs Service".
;
;		Action
;		The action you wish to perform. Options are: START, STOP, PAUSE, RESUME, QUERY, STARTMODE.
;
;		StartMode
;		The Start Mode option allows you to specify the startup mode of the service. Possible values:
;								"Boot"
;								"System"
;								"Automatic"
;								"Manual"
;								"Disabled"
;		If no StartMode parameter is specified with the STARTMODE action parameter, the function
;		will return the current setting.
;
;		Computer
;		You may specify the remote computer to perform the action on. If unspecified, defaults
;		to local machine.
;
;RETURNS	QUERY will return the current state of the queried service, possible values are:
;								"Stopped"
;								"Start Pending"
;								"Stop Pending"
;								"Running"
;								"Continue Pending"
;								"Pause Pending"
;								"Paused"
;								"Unknown"
;
;		STARTMODE returns current setting if no new setting is specified. Possible values
;		are listed above.
;
;		Other return codes (@ERROR is set):	0	Success
;							1	Failure
;							2	WMI not present
;							3	WMIService syntax error
;
;DEPENDENCIES	WMI is required on the target computer where the action will be performed.
;
;EXAMPLES	$x = WMIService("seclogon","start","some_server")
;
;		If UCase(WMIService("mssqlserver","query","database01")) = "RUNNING"
;			$x = WMIService("mssqlserver","stop","database01")
;		Endif
;		...do something while service is stopped...
;
;		$x = WMIService("winvnc","startmode",)
;		? $x
;		$x = WMIService("winvnc","stop")
;		$x = WMIService("winvnc","startmode","manual")
;		$x = WMIService("winvnc","start")
;		$x = WMIService("winvnc","startmode",)
;		? $x + " should be Manual."
;
;
	Dim $wmistring,$wmi,$svc,$services
	$wmistring = "winmgmts:{impersonationlevel=impersonate}!//" + $computer
	$wmi = getobject($wmistring)
	if $wmi
		$services = $wmi.InstancesOf("Win32_Service")
		for each $svc in $services
			if $svc.name = $service
				select
					case Ucase($action) = "START"
						$x = $svc.StartService()
						if @ERROR = 0
							$wmi = 0
							exit 0
						else
							$wmi = 0
							exit 1
						endif
					case Ucase($action) = "STOP"
						$x = $svc.StopService()
						if @ERROR = 0
							$wmi = 0
							exit 0
						else
							$wmi = 0
							exit 1
						endif
					case Ucase($action) = "PAUSE"
						$x = $svc.PauseService()
						if @ERROR = 0
							$wmi = 0
							exit 0
						else
							$wmi = 0
							exit 1
						endif
					case Ucase($action) = "RESUME"
						$x = $svc.ResumeService()
						if @ERROR = 0
							$wmi = 0
							exit 0
						else
							$wmi = 0
							exit 1
						endif
					case Ucase($action) = "QUERY"
						$WMIService = $svc.State
						$wmi = 0
						exit 0
					case UCase($action) = "STARTMODE"
						select
							case UCase($startmode) = ""
								$WMIService = $svc.StartMode
								$wmi = 0
								exit 0
							case UCase($startmode) <> ""
								$x = $svc.ChangeStartMode($startmode)
								if @ERROR = 0
									$wmi = 0
									exit 0
								else
									$wmi = 0
									exit 1
								endif
							case 1
								$wmi = 0
								exit 3
						endselect
					case 1
						$wmi = 0
						exit 3
				endselect
			endif
		next
	else
		exit 2
	endif
endfunction
  

173023WMIUptime2980Glenn BarnasWMIUptime() - Calculates uptime of a system0 
;; 
;;====================================================================== 
;; 
;;FUNCTION       WMIUptime() 
;; 
;;ACTION         Reads the boot and current time from a defined host and 
;;               calculates the length of time the system has been up. 
;; 
;;AUTHOR         Glenn Barnas 
;; 
;;VERSION        1.1 / 2007/04/05 - Authentication, rename to WMIUptime 
;;			Adjustment for uptime across timezone changes 
;; 
;;SYNTAX         WMIUptime([host] [,AuthPtr]) 
;; 
;;PARAMETERS     host    - OPTIONAL - name of system to query 
;; 
;;               AuthPtr - OPTIONAL - pre-authenticated WMI object pointer 
;;                 Use WMIAuthentication() udf to create the AuthPtr value 
;;                 AuthPtr is not needed if user has admin rights 
;; 
;;REMARKS        Gets both the boot and local time from the remote system,  
;;               eliminating issues with timezone differences between target 
;;               and client.  
;; 
;;RETURNS        Array containing Days, Hours, Minutes, and Seconds of uptime. 
;;               Also returns the cTime value in element 4 
;; 
;;DEPENDENCIES   WMI support 
;; 
;;TESTED WITH    W2K, WXP, W2K3 
;; 
;;EXAMPLES       $Host = '' 
;;               $Up   = WMIUptime($Host) 
;;               $Host has been up for ' $Up[0] ' days!' 
;; 
;;               $Host = 'server' 
;;               $objWMI = WMIAuthenticate('computer', 'userid', 'User-P@ss!') 
;;               $Up = WMIUptime($Host, $objWMI) 
;;               'Secure host ' $Host ' has been up for ' $Up[0] ' days!' 
; 
Function WMIUpTime(OPTIONAL $_Target, OPTIONAL $_pAuth)
 
  Dim $_Bt[3], $_Ct[3], $_U[4]			; time arrays for boot, current, and uptime 
  Dim $_, $_O					; Index var, Offset flag 
  Dim $_B, $_C					; boot and current time strings 
  Dim $_Bo, $_Co				; boot and current time offsets 
  Dim $objWMIService, $colItems, $objItem	; WMI object vars 
 
  $_Target = IIf($_Target, $_Target, '.')
  If InStr($_Target, '\') $_Target = Join(Split($_Target, '\'), '') EndIf
  If $_pAuth
    $objWMIService = $_pAuth
  Else
    $objWMIService = GetObject('winmgmts:{impersonationLevel=impersonate}!\\' + $_Target 
       + '\root\cimv2')
    If @ERROR Exit Val('&' + Right(DecToHex(@ERROR), 4)) EndIf
  EndIf
  $colItems = $objWMIService.ExecQuery("Select * from Win32_OperatingSystem",,48)
 
  For each $objItem in $colItems
 
    $_B = $objItem.LastBootUpTime	; host-local boot time 
    $_C = $objItem.LocalDateTime	; host-local current time 
 
    ; format is YYYYMMDDhhmmss.ssssss+ooo (or -ooo) 
    ; Get the timezone offset. The offset will not play into the calculation unless 
    ; the timezone switched between reboots, such as going from Standard to DaylightSavings 
    If InStr($_B, '-') Or InStr($_B, '+')
      $_Bo = Val(SubStr($_B, 23))	; boot timezone offset 
      $_Co = Val(SubStr($_C, 23))	; current timezone offset 
      $_O = ($_Co - $_Bo) * 60		; find the difference, usually will be zero 
    EndIf
 
    ; strip off the fractional seconds and time zone offset value 
    $_B = Split($_B, '.')[0]
    $_C = Split($_C, '.')[0]
 
    ; format is now YYYYMMDDhhmmss - put into array 
    $_Bt[0] = Val(SubStr($_B, 1, 4)) - 2000
    $_Bt[1] = Val(SubStr($_B, 5, 2))
    $_Bt[2] = Val(SubStr($_B, 7, 2))
    $_Bt[3] = 1.0 * SubStr($_B,13) + 60.0 * SubStr($_B,11,2) + 3600.0 * SubStr($_B,9,2)
    $_Ct[0] = Val(SubStr($_C, 1, 4)) - 2000
    $_Ct[1] = Val(SubStr($_C, 5, 2))
    $_Ct[2] = Val(SubStr($_C, 7, 2))
    $_Ct[3] = 1.0 * SubStr($_C,13) + 60.0 * SubStr($_C,11,2) + 3600.0 * SubStr($_C,9,2)
 
 
    ; Convert dates to Days, then convert to seconds and add the time value 
    If $_Bt[1] < 3
      $_Bt[1] = $_Bt[1] + 12
      $_Bt[0] = $_Bt[0] - 1
    EndIf
    $_B = $_Bt[2] + ( 153 * $_Bt[1] - 457 ) / 5 + 365 * $_Bt[0] + $_Bt[0] / 4 - $_Bt[0] 
       / 100 + $_Bt[0] / 400 - 306
    $_B = CDbl($_B) * 86400.0
    $_B = $_B + $_Bt[3]
    If $_Ct[1] < 3
      $_Ct[1] = $_Ct[1] + 12
      $_Ct[0] = $_Ct[0] - 1
    EndIf
    $_C = $_Ct[2] + ( 153 * $_Ct[1] - 457 ) / 5 + 365 * $_Ct[0] + $_Ct[0] / 4 - $_Ct[0] 
       / 100 + $_Ct[0] / 400 - 306
    $_C = CDbl($_C) * 86400.0
    $_C = $_C + $_Ct[3]
 
    ; Calculate uptime as cTime, then convert to days / hours / minutes / seconds 
    $_ = $_C - $_B + $_O
    $_U[4] = $_			; return the cTime value 
    $_U[0] = Int($_ / 86400)
    $_ = $_ Mod 86400
    $_U[1] = $_ / 3600
    $_ = $_ Mod 3600
    $_U[2] = $_ / 60
    $_U[3] = $_ Mod 60
 
 Next
 
  $WMIUptime = $_U
 
EndFunction
 
 
   

82794Word487New Mexico MarkWord() and Words() UDFs0I found the following string functions very handy in 4DOS/4NT, so I translated them into UDF's in KiXtart.

Essentially, Words() will return the number of words in a string. Standard delimeters (space, tab, comma) will be used unless a string containing other delimiters is passed as the second argument.

Word() will return the Nth word from a string. Again, delimiters may be specified.

These functions are very handy for parsing lists without having to split them to arrays first.

; ------------ Begin Code ---------------
FUNCTION Word($strStr, $intWrdNum, optional $strWS)
; Syntax: Word("string",number, ["white space characters"])
; Word number may be negative, in which case, words will be counted
; from the right of the string. I.e. -1 will return the last word in the string.
; Dependencies: ABS()
	DIM $intWrdCtr, $intLen, $intStart, $intFinish, $intStep
	DIM $strWord
	$strStr    = "" + $strStr
	$intWrdNum = 0 + $intWrdNum
	$strWS     = "" + $strWS
	$intLen    = Len($strStr)
	$intWrdCtr = 0
	IF $strWS = ""       ; $strWS is a string containing "white space" chars
		$strWS = "	 ,"  ; Contains tab, space, comma
	ENDIF
	IF $intWrdNum > 0    ; Setup to parse string forward
		$intStart  = 1
		$intFinish = $intLen
		$intStep   = 1
	ELSE                 ; Setup to parse string backward
		$intStart  = $intLen
		$intFinish = 1
		$intStep   = -1
	ENDIF
	IF $strStr = "" OR $intWrdNum = 0
		$strWord = ""
	ELSE
		FOR $intCtr = $intStart TO $intFinish step $intStep
			IF InStr($strWS,SubStr($strStr,$intCtr,1)) ; IF whitespace
				WHILE InStr($strWS,SubStr($strStr,$intCtr,1)) AND ($intCtr <= $intLen) ; skip it
					$intCtr = $intCtr + $intStep
				LOOP
			ELSE  ; If non-whitespace
				$intWrdCtr = $intWrdCtr + 1 ; increment word counter
				IF $intWrdCtr = abs($intWrdNum) ; requires "ABS()" UDF
				; If this is the correct word number, extract it TO $strWrd
					WHILE NOT InStr($strWS,SubStr($strStr,$intCtr,1)) AND ($intCtr <= $intLen)
						; Extract it in the right order!
						IF $intStep = 1
							$strWord = $strWord + SubStr($strStr,$intCtr,1)
						ELSE
							$strWord = SubStr($strStr,$intCtr,1) + $strWord
						ENDIF
						$intCtr = $intCtr + $intStep
					LOOP
				ELSE
				; otherwise, skip the word
					WHILE NOT InStr($strWS,SubStr($strStr,$intCtr,1)) AND ($intCtr <= $intLen)
						$intCtr = $intCtr + $intStep
					LOOP
				ENDIF
			ENDIF
			; "Undo" last manual increment/decrement
			$intCtr = $intCtr - $intStep
		NEXT
	ENDIF
	$Word = $strWord   ; Return the word, if found
ENDFUNCTION

FUNCTION Words($strStr, optional $strWS)
; Syntax: Words("string" [,"white space character(s)])
	DIM $intWrdCtr, $intLen
	$strStr    = "" + $strStr ; cast to string
	$strWS     = "" + $strWS  ; cast to string
	$intLen    = Len($strStr)
	$intWrdCtr = 0
	IF $strWS = ""       ; $strWS is a str containing the "white space" chars
		$strWS = "	 ,"  ; Contains tab, space, comma
	ENDIF
	IF $strStr = ""      ; Return 0 for empty string
		$intWrdCtr = 0
	ELSE
		FOR $intCtr = 1 TO $intLen ; Parse entire string
			IF InStr($strWS,SubStr($strStr,$intCtr,1)) ; If white space
				WHILE InStr($strWS,SubStr($strStr,$intCtr,1)) AND ($intCtr <= $intLen)  ; Skip it
					$intCtr = $intCtr + 1
				LOOP
			ELSE ; otherwise (if not white space)
				$intWrdCtr = $intWrdCtr + 1  ; increment word counter
				WHILE NOT InStr($strWS,SubStr($strStr,$intCtr,1)) AND ($intCtr <= $intLen) ; skip TO WS
					$intCtr = $intCtr + 1
				LOOP
			ENDIF
			$intCtr = $intCtr - 1  ; "undo" last manual increment
		NEXT
	ENDIF
	$Words = $intWrdCtr
ENDFUNCTION82799Write487New Mexico MarkWrite() - Write a string to one or more destinations0This is an pretty simple function. However I was intrigued that even Microsoft created and used a WriteLine() function in all their NT4RK VBS scripts. By doing so, they were able to easily switch between logged output and "wscript.echo"ed output.

I'm doing something similar with Write(), but adding the ability to write to multiple locations like MessageBox(), LogEvent(), and the Messenger service as well.

Lines of code - 20
Lines of documentation and comments - 'bout a million

code:

  
;Function	Write()
;
;Author		New Mexico Mark (wmarkh@aol.com - include "KiXtart" in the
;		header to prevent filtering), Radimus, kholm, sealeopard
;
;Action		Outputs a supplied string to a file, console, LogEvent, 
;		Net Send, or MessageBox()
;
;Syntax		Write(String, Integer)
;
;Parameters
;
;		String
;		Any expression that evaluates to a string.
;
;		Integer
;		Any expression that evaluates to a positive integer 1 - 10.
;		This will write to that file number. If the function cannot 
;		write to the file number, the output will go to the console 
;		instead.
;		-AND/OR-
;		Any expression that evaluates to 0 (or simply don't supply
;		anything) will write to the console (default behavior).
;		-AND/OR-
;		Any expression that contains 16. Write to console (specified).
;		Any expression that contains 32. Write to MessageBox.
;		Any expression that contains 64. Write to the eventlog.
;		Any expression that contains 128. This will use SHELL and
;		"net send" to send a message to the workstation.
;		Any expression that contains 512. This will suppress the 
;		default behavior of failing over to console output.
;
;Remarks 	Simple, yet it allows for elegant scripts with flexible output.
;		The advantages to using Write() rather than other methods are:
;		1. Flexibility. A string may be directed to one of five 
;		destinations.
;		2. Ease of use. The CRLF is automatically appended to the 
;		WriteLine() function.
;		3. Nothing is returned, so there is no need to check error 
;		codes.
;		4. Any error generated within Write() by WriteLine, 
;		LogEvent(), or "Net Send" will cause the function to
;		automatically write to the console unless that is suppressed.
;
;Returns	Nothing.
;
;Dependencies	A file must be open to write to a file. However, this is 
;		deliberate. For instance, one may control whether to write to
;		a log file or the console simply by whether the log file is
;		opened or not. There are no UDF dependencies. The LogEvent
;		function requires NT/2000/XP.
;
;Example(s)		
;		Write(@TIME + " - Default to console output.")
;		$RC = Open(1,"%temp%\test.txt",5) ; Open a log for output
;		Write(@TIME + " - Write to log only.",1)
;		Write(@TIME + " - Write to Log and Console.",65)
;		$RC = Close(1) ; Close the log
;		Write(@TIME + " - Forced console output and failover.",1 + 16)
;		Write(@TIME + " - Failover to console output only... no log open.",1)
;		Write(@TIME + " - No log open, but console failover suppressed.",512 + 1)
;		Write(@TIME + " - Specified write to console.",16)
;		Write(@TIME + " - Write to MessageBox and console.",32 + 16)
;		Write(@TIME + " - Write to EventLog and console.",64 + 16)
;		Write(@TIME + " - Write to Messenger service and console.",128 + 16)
;		Write(@TIME + " - Write to MessageBox and Messenger service.",128 + 32)
;		$Text = @TIME + " - Potential conflict - " + @CRLF + 
;		"           Force console output AND suppress console failover."
;		Write($Text,16 + 512)
;
;Console Output (Example)
;		14:25:22 - Default to console output.
;		14:25:22 - Forced console output and failover.
;		14:25:22 - Failover to console output only... no log open.
;		14:25:22 - Specified write to console.
;		14:25:22 - Write to MessageBox and console.
;		14:25:24 - Write to EventLog and console.
;		14:25:24 - Write to Messenger service and console.
;		14:25:26 - Potential conflict -
;		           Force console output AND suppress console failover.
;Source
FUNCTION Write($strText, OPTIONAL $intDest)
; Summary      - Write string to one or more destinations.
; $strText     - Text string - may contain CRLF's
; $intDest     - Integer sum of the following options
; Bit(s)  Dec.   Specifies Destination(s)...
; 0-3   1...10 = File number (must be opened for write already - adds CRLF)
;   4       16 = Console (No formatting done. CRLF's must be imbedded)
;   5       32 = MessageBox (Title="Message...", Default style and timeout) 
;   6       64 = EventLog (Type=Info, ID=1, Target=local, Source=Kix32)
;   7      128 = Messenger service (Net Send to @WKSTA)
;   8      256 = Reserved
; Bit(s)  Dec.   Specifies Behavior(s)...
;   9      512 = Suppress default failover to console output.
; Dependencies:  LogEvent() dependent upon NT/2K/XP
; Returns:       Nothing
	$strText = "" + $strText
	$intDest = 0  + $intDest
	DIM $RC, $Dmy
	IF (($intDest & 15) - 11) < 0 
		$RC = WriteLine(($intDest & 15), $strText + @CRLF)
	ENDIF
	IF $intDest & 32 $Dmy = MessageBox($strText,"Message...",0) ENDIF
	IF $intDest & 64 $RC  = LogEvent(4,1,$strText) ENDIF
	IF $intDest & 128
		SHELL '%comspec% /c net send "@WKSTA" "$strText" > nul'
		$RC = @ERROR
	ENDIF
	IF $intDest & 16
		? $strText
	ELSE
		IF (($intDest = 0) OR $RC) AND (($intDest & 512) = 0)
			? $strText
		ENDIF
	ENDIF
ENDFUNCTION ; Write()

[ 09 January 2002: Message edited by: New Mexico Mark ]122351WriteFile5439acmpWriteFile() - write a file from delimited text1090234689 Code:

  

;Function	WriteFile()

;

;Author		acmp

;

;Contributors	The idea for this script came from 'Writelog2'

;		I don't know who the author is, but it's a very useful UDF

;		code modifications were suggested by Richard H. Thanks

;		Radimus showed me his similar UDF that took an array as the input. I have included this 

;		feature as I think it is very useful.

;

;Action		Will write a file with the delimited string or an array of information

;

;Syntax		WriteFile($file,$string,Optional $delim, Optinal $reset)

;

;Version	2.1

;

;Date		8/Jul/04

;

;Date Revised	11/Jul/04	Updated code to use join(split()) 

;		19/Jul/04 Funked it up to accept either a text string or an array, thanks to radimus 

;			For pointing out a similar UDF that used an array.

;

;Parameters 	File, String, Delim, Reset

;		File is a valid path including the file name

;		String is the delimited information to write to the file, either a string or an array

;		Delim is the delimiting character used, if not specified then the existing line breaks 

;		are used also each element in the array as a seperate line

;		Reset, whether to delete the existing file if it exists or not

;

;Remarks		I wrote this UDF so I could build a file if needed,

;		you just give give the UDF the path, string and delimiter information

;		and it will create or append to the file.

;		I have added a 'Reset' parameter so that you can optionally recreate the file if desired.

;		I have also added the ability to send an array to the function to allow for greater flexability

;

;Returns		If the Open command fails it will return the reason,

;		If the WriteLine() fails it will return the reason else it returns 0 

;		to show that all is OK.

; 

;Dependencies 	None

;

;KiXtart Ver	4.22 (not tested with previous versions but may work. Feed back appreciated)

; 

;Example(s)	$OK=WriteFile("c:\test.txt","Line1|line2||line4","|")

;		This will create or append the 4 lines to the file 

;		$OK=WriteFile("C:\info.ini","[section1]|Item1=value|Item2=value||[section2]|item=value","|",1)

;		This will reset the file and write the items to the file

; 		For an array:

;			$myarray="line1","line2","line3"

;			$OK=WriteFile("c:\test.txt",$myarray,,1)

;			You will get a new line for each element in an array. You can of course include

;			a delimiter if desired that will _also_ add a new line when encoucnted.



Function WriteFile($File, $Text, Optional $Delimiter, optional $reset)

	Dim $FH, $VT

	If $reset = 1 AND Exist($File) Del($File) EndIf

	$FH=FreeFileHandle

	

	If $Delimiter

		If VarType($Text)>17 ;must be an array

			For Each $element In $Text

				$VT=$VT+$element+$Delimiter

			Next

			$Text=$VT

		EndIf

		$Text=Join(Split($Text,$Delimiter),@CRLF) 

	Else

		If VarType($Text)>17 ;must be an array

			For Each $element In $Text

				$VT=$VT+$element+@CRLF

			Next

			$Text=$VT

		EndIf

		$Text=Join(Split($Text,Chr(10)),@CRLF)

	EndIf

	

	; Write text

	If NOT Open($FH,$File,5)

		$WriteFile=WriteLine($FH,$Text)

		$=Close($FH)

	Else

		$WriteFile=@ERROR

	EndIf

	Exit $WriteFile

EndFunction

 



version 2 of the UDF. The script has been rewritten to change a for each loop with the split(join()) code provided by Richard H, thanks.



Version 2.1 includes the ability to send an array to the UDF and have it output to a file. Thanks to Radimus for his input.



Comments welcome  



acmp<><





   84659WriteFile31RadimusWriteFile() - Write an array to a file0

;Function	WriteFile()  

;  

;Author		Radimus  

;  

;Contributors	Lonky  

;  

;Action		Writes an array as a file  

;  

;Syntax		WriteFile('filename','array')  

;  

;Version	1.1  

;  

;Date           10/21/2003  

;  

;Date Revised   11/13/2003  

;  

;Parameters 	file   

;		destination filename  

;		array   

;		an array of data to write to a file  

;  

;Remarks	Pair this with ReadFile() to read and write an entire file easily  

;  

;Returns	@error if failed  

;   

;Dependencies 	None  

;  

;KiXtart Ver	4.02  

;   

;Example(s)	$=WriteFile('c:\file.txt',$array)  



Function WriteFile($file,$array)

	Dim $, $f, $line

	If Not VarType($Array) & 8192    Exit(1)        EndIf

	$f=freefilehandle

	$=open($f,$file,5)

		if @error   exit @error   endif

		for each $line in $array

			$=writeline($f,$line+@crlf)

			if @error   exit @error   endif

			next

		$=close($f)

	EndFunction


 
 [ 13. November 2003, 10:50: Message edited by: Radimus ]83040WriteLog172Howard BullockWriteLog() - Generic logging facility for scripts0

code:

;FUNCTION         WriteLog()
;
;AUTHOR           Howard A. Bullock (hbullock@tycoelectronics.com)
;
;ACTION           Generic logging facility for scripts. Appends a time stamped log entry to a file.
;
;SYNTAX           WriteLog($text)
;
;PARAMETERS       $text (Required)
;                  -  String value
;
;REMARKS          This function writes (appends) a time stamped log entry to the file defined in function. In order
;                 to increase speed and reduce operations, the function attempts to write to the specified file handle
;                 assuming it is opened. If it isn't the file is opened and the function recursively called. Do not
;                 open the same file handle number to a different file before calling WriteLog. If you do all logged
;                 text will be directed to the other file. Once WriteLog open a file handle it remains open until the
;                 script session terminates.
;
;RETURNS          Nothing
;
;DEPENDENCIES     None
;
;EXAMPLES         WriteLog("")
;                 WriteLog("Starting Kixtart script")
;
;
Function WriteLog($text)
   dim $RC, $text, $LogFile, $Filehandle
   $Filehandle = 1
   $LogFile = "%temp%\logon.log"
   $RC=Writeline ($Filehandle, "@Date @Time - $Text" + Chr(13) + Chr(10))
   if $RC<0
      $RC=Close ($Filehandle)
      $RC=Open ($Filehandle, "$LogFile", 5)
      Select
         Case $RC=-1
            $RC=MessageBox ("Invalid file name ($LogFile) specified for log file.","Logon Script Error",48)
         Case $RC=0
            WriteLog ($Text)
         Case $RC=>0
            $RC=MessageBox ("Error($RC) while attempting to open log file ($LogFile).","Logon Script Error",48)
      Endselect
   Endif
EndFunction

83049WriteLog2172Howard BullockWriteLog2() - Writes to a specified log file with optional TimeStamp0


;FUNCTION WriteLog2()
;
;AUTHOR Howard A. Bullock (hbullock@tycoelectronics.com)
;
;ACTION Generic logging facility for scripts. Appends log entry to a file with an optional TimeStamp.
;
;SYNTAX WriteLog2($File, $text, [0|1])
;
;PARAMETERS $File (Required) - String value
; $text (Required) - String value
; $TimeStamp (Optional) Default(0) no TimeStamp (1 or 0)
;
;
;REMARKS This function writes (appends) an optionally time stamped log entry to the file defined in function.
; This function searches for the first unused file handle, open the file, and write the entry. T he file handle
; is then closed. When the function is unable to perform its it write the error is displayed&nbs p;in a message box.
;
;RETURNS Nothing
;
;DEPENDENCIES None
;
;EXAMPLES WriteLog2("junk.txt","This is a test")
; WriteLog2("junk.txt","This is a test",0)
; WriteLog2("junk.txt","This is a test",1)
;
;
Function WriteLog2($File, $Text, optional $TimeStamp)
;ACTION: Writes text to a specified log file.
dim $RC, $File, $text, $FH, $TimeStamp
$FH=1
$RC=Open ($FH, $File, 5)
while $RC = -3
$FH=$FH +1
$RC=Open ($FH, $File, 5)
Loop
Select
Case $RC=0
if ($TimeStamp=1)
$TimeStamp = @Date + " " + @Time + " - "
else
$TimeStamp = ""
endif
$RC=Writeline ($FH, $TimeStamp + $Text + @CRLF)
$RC=Close ($FH)
Case $RC=-2
$text = "WriteLog2: Invalid file handle ($FH) specified when trying to Open $File."
$RC=MessageBox ($text,"Script Error",48)
Case $RC=-1
$text = "WriteLog2: Invalid file name ($File) specified for log file."
$RC=MessageBox ($text,"Script Error",48)
Case $RC=>0
$text = "System Error($RC) while attempting to open log file ($File)."
$RC=MessageBox ($text,"Script Error",48)
Endselect
EndFunction


 
 [ 05. April 2003, 17:57: Message edited by: Howard Bullock ]116657WriteRegFromExport288jtokachWriteRegFromExport() -Writes .REG files to the reg1083778725 Code:

;FUNCTION 	    WriteRegFromExport()

;

;ACTION 	    Given an exported registry file, write it to the registry

; 

;AUTHOR         James Tokach

; 

;CONTRIBUTORS 	Richard H.(Many thanks!)

;

;VERSION        1.4 - Was removing the escape chars from REG_EXPAND_SZ key.

;                     That's a no no.

;               1.3 - Data values containing environment variables will be

;                     expanded prior to writing the value

;               1.2 - Added more error checking

;                     Supports "-" for deleting entries

;                     Correctly writes paths by removing the escape character

;                     More dependencies...

;               1.1 - Added IsUnicode() checking

;               1.0 - Released

; 

;DATE CREATED 	2004/10/23

; 

;DATE MODIFIED 	N/A

; 

;KIXTART 	    Tested only with 4.22

; 

;SYNTAX 	    WriteRegFromExport($RegFile[, $ViewOutPut])

;

;PARAMETERS     $RegFile

; 		        The path and filename of the .REG to be imported

;

; 		        $ViewOutPut

; 		        Optional - Set to any non-zero value to view output during

;               processing

;

;RETURNS 	    ERRORLEVEL Zero on success, ERRORLEVEL non-zero on failure

;

;REMARKS 	    1. Not ALL registry types are supported, only the most common.

;               To be honest I haven't run across the other types that often and

;               writing them in was out-of-scope of this project. The following

;               types are supported:

;                   REG_SZ

;                   REG_EXPAND_SZ

;                   REG_BINARY

;                   REG_DWORD

;                   REG_MULTI_SZ

;               The following types are NOT supported and will cause the 

;               function to throw an error:

;                   REG_NONE

;                   REG_DWORD_LITTLE_ENDIAN

;                   REG_DWORD_BIG_ENDIAN

;                   REG_LINK

;                   REG_RESOURCE_LIST

;                   REG_FULL_RESOURCE_DESCRIPTOR

;               If you have the time and the desire, I'll be happy to update 

;               this post. Please include exported registry data to test with.

;

;               2. This UDF includes code to readin data from UNICODE files.

;               Therefore it will process registry exports from all existing 

;               versions of Regedit.

;

;               3. There is a subroutine in this UDF. I don't like it, but it

;               works. Alternatives are welcome.

;

;DEPENDENCIES   base2dec() @ http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=115413&page=0&view=collapsed&sb=5&o=all&fpart=&vc=1

;               RegMultiSzToArray() @ http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=115416&page=0&view=collapsed&sb=5&o=&fpart=1

;               UpdateRegistry() @ http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=82157&page=6&view=collapsed&sb=3&o=all&fpart=1

;               IsUnicode() @ http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=115616&page=0&view=collapsed&sb=5&o=&fpart=&vc=

;               EscapeCharRemove() @ http://www.kixtart.org/ubbthreads/showflat.php?Cat=&Number=115999&page=0&view=collapsed&sb=5&o=&fpart=&vc=

;

;EXAMPLE        Break On

;               $nul=SetOption("WrapAtEOL","On")

;               $ModifiedRegExport="C:\TEMP\EXPRT.REG"

;               WriteRegFromExport($ModifiedRegExport,1)

;

;KIXTART BBS 	http://www.kixtart.org/cgi-bin/ultimatebb.cgi?ubb=get_topic;f=12;t=000000

;

Function WriteRegFromExport($RegFile, Optional $ViewOutPut)

    Dim $FSO,$FileData,$Line,$CurrentSubKey,$Type,$Array

    Dim $Value,$Data,$RC,$Element,$Newdata

    $FSO = CreateObject("Scripting.FileSystemObject")



    If IsUnicode($RegFile)=0

        $FileData = $FSO.OpenTextFile($RegFile,,,-1) ; The -1 says use unicode

    Else

        $FileData = $FSO.OpenTextFile($RegFile) ; DOS Format

    Endif

    $Line = $FileData.ReadLine

    If Not @Error=0 

        $FSO=""

        Exit @Error

    EndIf



    While @Error=0

        $Line=Trim($Line)

        Select

            Case Substr($Line,1,1)="["

                $CurrentSubKey=Substr($Line,2,Len($Line)-2)

                If $ViewOutPut ? "Subkey "+$CurrentSubKey+@crlf EndIf



            Case Instr($Line,'"=-')

                If $ViewOutPut ? "Delete Entry"+@crlf EndIf

                $Array=Split($Line,'"=')

                $Value=Substr($Array[0],2)

                $Data=Substr($Array[1],1,Len($Array[1])-1)

                $RC=DelValue($CurrentSubKey, $Value)



            Case Instr($Line,'"="') or Left($Line,1)="@@"

                $Type="REG_SZ"

                If Left($Line,1)="@@"

                    $Array=Split($Line,'="')

                    $Value=""

                    $Data=Substr($Array[1],1,Len($Array[1])-1)

                Else

                    $Array=Split($Line,'"="')

                    $Value=Substr($Array[0],2)

                    $Data=Substr($Array[1],1,Len($Array[1])-1)

                EndIf

                $Data=EscapeCharRemove($Data)

                $Data=ExpandEnvironmentVars($Data)

                If $ViewOutPut ? "Value "+$Value+@crlf+"Data "+$Data+@crlf+"Type "+$Type+@crlf EndIf

                $RC=UpdateRegistry($CurrentSubKey, $Value, $Data, $Type)

                If $RC=1 or $RC=0

                Else

                    Exit @Error

                EndIf



            Case Instr($Line,'"=dword:')

                $Type="REG_DWORD"

                $Array=Split($line,'"=dword:')

                $Value=Substr($Array[0],2)

                $Data=Base2Dec(Substr($Array[1],1),16)

                $Data=EscapeCharRemove($Data)

                $Data=ExpandEnvironmentVars($Data)

                If $ViewOutPut ? "Value "+$Value+@crlf+"Data "+$Data+@crlf+"Type "+$Type+@crlf EndIf

                $RC=UpdateRegistry($CurrentSubKey, $Value, $Data, $Type)

                If $RC=1 or $RC=0

                Else

                    Exit @Error

                EndIf



            Case Instr($Line,'"=hex(7):')

                $Type="REG_MULTI_SZ"

                $Array=Split($line,'"=hex(7):')

                $Value=Substr($Array[0],2)

                $Data=Substr($Array[1],1)

                Gosub ParseHex

                ; Parse the Hex

                $Data=RegMultiSzToArray($Data)

                ; Format the data for WriteValue()

                $Data=Join($Data,"|")

                If Right($Data,1)<>"|"

                    $Data=$Data+"|"

                EndIf

                $Data=EscapeCharRemove($Data)

                $Data=ExpandEnvironmentVars($Data)

                If $ViewOutPut ? "Value "+$Value+@crlf+"Data "+$Data+@crlf+"Type "+$Type+@crlf EndIf

                $RC=UpdateRegistry($CurrentSubKey, $Value, $Data, $Type)

                If $RC=1 or $RC=0

                Else

                    Exit @Error

                EndIf



            Case Instr($Line,'"=hex:')

                $Type="REG_BINARY"

                $Array=Split($Line,'"=hex:')

                $Value=Substr($Array[0],2)

                ; Remove commas

                If InStr($Array[1],",") $Data=Join(Split($Array[1],","),"") EndIf

                Gosub ParseHex

                $Data=EscapeCharRemove($Data)

                $Data=ExpandEnvironmentVars($Data)

                If $ViewOutPut ? "Value "+$Value+@crlf+"Data "+$Data+@crlf+"Type "+$Type+@crlf EndIf

                $RC=UpdateRegistry($CurrentSubKey, $Value, $Data, $Type)

                If $RC=1 or $RC=0

                Else

                    Exit @Error

                EndIf



            Case Instr($Line,'"=hex(2):')

                $Type="REG_EXPAND_SZ"

                $Array=Split($line,'"=hex(2):')

                $Value=Substr($Array[0],2)

                $Data=Substr($Array[1],1)

                Gosub ParseHex



                $Array=Split($Data,",")

                $Newdata=""

                For Each $Element in $Array

                    $NewData=$NewData+Chr(Base2Dec($Element,16))

                Next

                $Data=$Newdata

                ;$Data=EscapeCharRemove($Data)

                $Data=ExpandEnvironmentVars($Data)

                If $ViewOutPut ? "Value "+$Value+@crlf+"Data "+$Data+@crlf+"Type "+$Type+@crlf EndIf

                $RC=UpdateRegistry($CurrentSubKey, $Value, $Data, $Type)

                If $RC=1 or $RC=0

                Else

                    Exit @Error

                EndIf



            Case Instr($Line,"Windows Registry Editor Version 5.00") or

                 Instr($Line,"REGEDIT 4") or

                 Instr($Line,"REGEDIT")

                If $ViewOutPut ? "Title Line"+@crlf EndIf



            Case $Line=""

                If $ViewOutPut ? "Blank Line"+@crlf EndIf



            Case 1

                Exit 1804 ;Invalid datatype



        EndSelect



        $Line = $FileData.ReadLine

    Loop



    $FileData.Close

    $FSO=0



    Exit 0



    ; This subroutine is called when a data string exists on more than one line

    ; It parses for the continuation character \ and concatenates as necessary

    :ParseHex

    While Right($Data,1)="\"

        $Data=Left($Data,len($Data)-1) ; This removes the slash \



        $Line = $FileData.ReadLine

        If @error=0 and Left(Trim($Line),1)<>'"' and Left(Trim($Line),1)<>'[' and Trim($Line)<>""

            $Data=$Data+Trim($Line)

        EndIf

    Loop

    Return



EndFunction 

 82411WshEnumDrives11ShawnWshEnumDrives() - Enumerate drives on your local machine0WshEnumDrives()

Action:

Enumerate drives on your local machine

Syntax:

WshEnumDrives()

Parameters:

none

Returns:

Returns a Drives collection consisting of all Drive objects available on the local machine. Returns a null string "" on error with @ERROR is set to relevant error code.

Remarks:

Dependencies:

KiXtart 4.0 (Final)
Windows Scripting Runtimes

Example(s):

code:

 
Example 1
 
for each $drive in WshEnumDrives()
 
 ? "DriveLetter .... " $drive.driveletter
 ? "DriveType ...... " $drive.drivetype
 ? "ShareName ...... " $drive.sharename
 ? "IsReady ........ " $drive.isready ; -1 is yes
 ? "FileSystem ..... " $drive.filesystem
 ? "VolumeName ..... " $drive.volumename
 ? "SerialNumber ... " $drive.serialnumber
 ?
 ? "Press any key to continue ..." get $k
 ?
 
next
 
Example 2
  
for each $drive in WshEnumDrives()
 
 ? $drive.driveletter ": "
 
 select
 
  case $drive.drivetype = 0 "unknown"
  case $drive.drivetype = 1 "removable drive"
  case $drive.drivetype = 2 "fixed drive"
  case $drive.drivetype = 3 "network drive on " $drive.sharename
  case $drive.drivetype = 4 "cd-rom drive"
  case $drive.drivetype = 5 "ram disk"
 
  endselect

next

Source:

code:

function WshEnumDrives()
 dim $fso 
 $WshEnumDrives = ""
 $fso = createobject("scripting.filesystemobject")
 if $fso
  $WshEnumDrives = $fso.drives
 endif
 exit @error
endfunction

Author:

-Shawn
 
 [ 22. February 2003, 02:05: Message edited by: Shawn ]83235WSHPing31RadimusWSHPing() - WSH ping routine... no temp files0ping function based upon Chris S. WSHPipe Function                             

Author Radimus              
Action Performs a ping to the hostname
Returns the IP of the PC or 0.0.0.0 , number of 'hits', and the average ping time
Parameters The name of the target, optional number of 'ping replies
Dependencies WshPipe() (kix4.02 and WSH 5.6)
Examples 
$p=WSHPing("server",5)
? @error @serror
$ipaddress=$p[0]
$goodreplies=$p[1]
$averageping=$p[2]

code:

FUNCTION WSHPing($Computer,optional $replies)
	dim $ip, $l, $r, $count, $return, $line ,$pos, $avg
	if not $replies		$replies=1	endif
	$ip=0		$Count=0
	$shell='%comspec% /c ping $Computer -n $replies '
	$return=WSHPipe($shell,1)
	if not @error
		for each $line in $return
			select
				case instr($line,"[")		$l=instr($line,"[")+1
								$r=instr($line,"]")
								$ip=substr($line,$l,$r-$l)
				case instr($line,"reply from")	$Count=$Count+1
				case instr($line,"Average")	$pos=instr($line,"Average")+8
								$avg=val(right("$line",len($line)-$pos))
				endselect
			if instr($line,"timed out")	$Count=$Count-1		endif
			next
		$WSHPing=$ip,$count,$avg
	else
		$WSHPing="0.0.0.0","0","0"
		exit(487)
		endif
	ENDFUNCTION


 
 [ 13. September 2002, 14:10: Message edited by: Radimus ]83201WshPipe953Chris S.WshPipe() - Pipes the results of a shell command to an array.1077745899Code:


; 

;Function: 

;   WshPipe() 

; 

;Author: 

;   Christopher Shilt (christopher.shilt@relizon.com) 

; 

;Version: 

;   1.3 

; 

;Version History: 

; 

;   13 Feb 2004  Version 1.3 - Removed Status Loop. 

; 

;   18 June 2003 Version 1.2 - Cleaned up code. Added error checking for support of the  

;                              WScript.Shell.Exec method. 

; 

;   14 June 2002 Version 1.0 - Original Version. 

; 

;Action: 

;   Runs an application in a child command-shell, providing access to the StdOut/StdErr  

;   streams. Pipes the output to an array and returns the ExitCode of the command to the 

;   @ERROR macro. 

; 

;Syntax: 

;   WshPipe(COMMAND, optional NOECHO) 

; 

;Parameters: 

;   COMMAND : REQUIRED. String value indicating the command line used to run the script. 

;                       The command line should appear exactly as it would if you typed 

;                       it at the command prompt.  

; 

;   NOECHO  : OPTIONAL. Suppress the command's output to the console, ouput is still 

;                       stored in an array. 

; 

;Remarks: 

; 

;Returns: 

;   Output of COMMAND in an array, ExitCode of the COMMAND in the @ERROR macro. By 

;   default, the output is echoed to the screen but can be suppressed. 

;  

;Dependencies: 

;   KiX 4.02 

;   WSH 5.6 (Included with Microsoft Internet Explorer 6.0. Also available for download 

;           from Microsoft's MSDN website.) 

;  

;Example: 

; 

; ; Display all KiX files in C:\ directory 

; $rc=WshPipe("dir c:\*.kix") 

; @ERROR " | " @SERROR ? 

; 

; ; Display all KiX files in C:\ directory, but suppress output to screen 

; $rc=WshPipe("%comspec% /c dir c:\*.kix",1) 

; @ERROR " | " @SERROR ? 

; 

; ; Display all KiX files in C:\ directory, suppress output to screen. Then use FOR/NEXT 

; ; to exclude data. 

; $rc=WshPipe("%comspec% /c dir c:\*.kix",1) 

; for each $line in $rc 

;    if not instr($line, "File Not Found") 

;       ? $line 

;    endif 

; next 

; @ERROR " | " @SERROR ? 

; 

;Source 

Function WshPipe($ShellCMD, OPTIONAL $NoEcho)

	Dim $oExec, $Output

	$oExec = CreateObject("WScript.Shell").Exec($ShellCMD)

	If Not VarType($oExec)=9 $WshPipe="WScript.Shell Exec Unsupported" Exit 10 EndIf

	$Output = $oExec.StdOut.ReadAll + $oExec.StdErr.ReadAll

	If Not $NoEcho $Output Endif

	$WshPipe=Split(Join(Split($Output,CHR(13)),''),CHR(10))

	Exit($oExec.ExitCode)

EndFunction

82220WshShortCut11ShawnWshShortCut() - Create shortcuts programatically with WSH0WshShortCut()

Action:

Creates a shortcut at path linking to file at targetpath (using Windows Scripting Host)

Syntax:

WshShortCut($Path,$TargetPath[,$Arguments[,$StartDir[,$IconPath[,$Style]]]])

Parameters:

$Path (Required) - The fully qualified path to the new shortcut file.

$TargetPath (Required) - The fully qualified path that the shortcut points to.

$Arguments (Optional) - Arguments passed to $targetpath

$StartDir (Optional) - Start directory (or Working Directory) of shortcut

$IconPath (Optional) - The location of the icon used to represent the shortcut.
The string is of the form "path,index", where path is the full path to the file containing 
the icon, and index is the zero-based index of the icon within the specified icon file.

$Style (Optional) - The window style for the program being run. Valid values are:

1 Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and position. 

3 Activates the window and displays it as a maximized window.  

7 Minimizes the window and activates the next top-level window. 

Returns:

@ERROR set to 0 (zero) on success or relevent error code on failure

Remarks:

Insure that all paths are fully qualified (make sure to inlude the .lnk file
extention on $path)

Dependencies:

KiXtart 4.0 (Final)
Windows Scripting Host (ActiveX Control)

Example(s):

WshShortCut("%userprofile%\desktop\my notepad.lnk","c:\winnt\system32\notepad.exe")
WshShortCut("%userprofile%\desktop\my notepad.lnk","c:\winnt\system32\notepad.exe","newdoc.txt")

WshShortCut("%userprofile%\desktop\my notepad.lnk","c:\winnt\system32\notepad.exe","text.txt","c:\")

WshShortCut("%userprofile%\bureau\my notepad.lnk","c:\winnt\system32\notepad.exe",,,"C:\winnt\system32\shell32.dll,3"
)

Skip over optional parmeters like this (example, skipped over $Arguments) :

WshShortCut("%userprofile%\desktop\my notepad.lnk","c:\winnt\system32\notepad.exe",,"c:\")

Source:


function WshShortCut($path,$targetpath,optional $arguments,optional $startdir,optional $iconpath,optional $style)

 dim $shell,$shortcut

 $shell=createobject("wscript.shell")

 if $shell

  $shortcut=$shell.createshortcut($path)

  if $shortcut

   $shortcut.targetpath=$targetpath

   if $arguments

    $shortcut.arguments=$arguments

   endif

   if $startdir

    $shortcut.workingdirectory=$startdir

   endif

   if $iconpath

    $shortcut.iconlocation=$iconpath

   endif

   if $style

    $shortcut.windowstyle=$style

   endif

   $shortcut.save

   $shortcut=0

  endif

  $shell=0

 endif

 exit @error

endfunction



Author:

Shawn Tassie (Shawn)
Ron Lewis (NTDOC)
 
 [ 26. October 2003, 02:39: Message edited by: Shawn ]84115wshShortcut3439AllenwshShortcut() - v1.3 - Create File & Web Shortcuts0

; wshShortCut(),   
;   
;Authors and Contributors:   
; Shawn, Radimus, Al_Po,   
; Richard Farthing, NTDOC   
;   
;Version:   
; 1.3.4   
;   
;Action:   
; Creates Shortcuts for files or Web pages   
;   
;Syntax:   
; wshShortCut($shortcutname,$targetpath,optional $arguments, optional $startdir, optional $iconpath, optional $style, optional $Description)   
;   
;Parameters:   
; SHORTCUTNAME 	Required. Name of Shortcut. If path is omitted, will be saved to desktop.   
; TARGETPATH 	Required. The path the target point to.  To ommit checking if path exists in the function, append the target path 
;                         with ",1"   
; ARGUMENTS 	Optional. Arguments appended to TARGETPATH   
; STARTDIR 	Optional. Working Directory   
; ICONPATH 	Optional. Path to Icon Library. To specify an icon other than the first, separate the icon path with   
;                   	  ",#" where # represents the icon in the library.   
; STYLE 	Optional. 1 = default, 3 = maximized window, 7 = minimized window   
; DESCRIPTION 	Optional. Description or Comment about Shortcut   
; HOTKEY 	Optional. Keyboard Hotkey.  (Note:  Shortcut must be saved to desktop or startmenu for Hotkey to function) 
;   
;Remarks:  
; wshShortCut 1.3.4 
; - Dimmed undimmed var 
; wshShortCut 1.3.3 
; - Added option to bypass TARGETPATH exist check on LNK shortcuts.  Add ,1 to the end of your Targetpath to bypass 
;   See Example below. 
; wshShortCut 1.3.2 
; - Included Option for HotKey(.hotkey)  
; wshShortCut 1.3.1  
; - Bug Fixes when creating URL shortcuts  
; wshShortCut 1.3  
; - Attempts to create directory structure to shortcut if it does not exist  
; wshShortcut 1.2:   
; - Support for NoVarsinStrings   
; - Checks for existence of TargetPath in .lnk files   
; - Included option for Description (.description)   
; wshShortcut 1.1:   
; - fixes a logic bug in wshShortCut 1.0 so you can use more than icons 0-9 in a icon library on URLS.   
; - Unless path is explicity stated in $ShortCutName, icons are created on the desktop   
; - If .lnk or .url is omitted, UDF tries to determine the shortcut type, but defaults to .lnk if it can't figure it out.   
; wshShortCut 1.0   
; http://www.kixtart.org/ubbthreads/showfl...=true#Post81769   
;   
;Examples:   
; $=wshShortcut("KiXtart Web Page","http://www.kixtart.org")   
; $=wshShortcut("Notepad","%systemroot%\system32\notepad.exe")   
; $=wshShortcut$=wshshortcut("Server1","\\Server1,1") 
 

 

function wshShortCut($shortcutname,$targetpath,optional $arguments, optional $startdir, optional $iconpath, optional $style,optional $description,optional $hotkey)
  dim $shell, $desktop, $shortcut, $index, $iconinfo, $iconindex,$scdir,$rc
  $wshshortcut=1
  $shell = createobject("wscript.shell")
  if $shell
    if ucase(right($shortcutname,4))=".URL" or ucase(right($shortcutname,4))=".LNK"
      ;do nothing 
    else
      if ucase(left($targetpath,5))="HTTP:" or ucase(left($targetpath,6))="HTTPS:" or ucase(left($targetpath,4))="FTP:"
        $shortcutname=$shortcutname + ".url"
      else
        $shortcutname=$shortcutname + ".lnk"
      endif
    endif
    if instr($targetpath,",")
      $targetpath=split($targetpath,",")[0]
    else
      if instr($shortcutname,".lnk") and not exist($targetpath)
        exit 2
      endif
    endif
    if instr($shortcutname,"\")=0
      $Desktop = $shell.SpecialFolders("Desktop")
      $shortcutname=$desktop + "\" + $shortcutname
    else
      $scdir=substr($shortcutname,1,instrrev($shortcutname,"\"))
      if not exist($scdir)
        md $scdir
        if @error
          exit @error
        endif
      endif
    endif
    $shortcut = $shell.createshortcut($shortcutname)
    if $shortcut
      $shortcut.targetpath = $targetpath
      if $iconpath and instrrev($shortcutname,".lnk")
        $shortcut.iconlocation = $iconpath
      endif
      if $arguments
        $shortcut.arguments = $arguments
      endif
      if $startdir
        $shortcut.workingdirectory = $startdir
      endif
      if $style
        $shortcut.windowstyle = $style
      endif
      If $description and instrrev($shortcutname,".lnk")
	  $shortcut.description = $description
      EndIf
      if $hotkey
        $shortcut.hotkey = $hotkey
      endif
      $shortcut.save
      if @error
        exit @error
      endif
      if instrrev($shortcutname,".url") and $iconpath
        $index=instrrev($iconpath,",")
        if $index=0
          $iconindex=0
        else
          $iconindex=split($iconpath,",")[1]
          $iconpath=split($iconpath,",")[0]
        endif
        $rc=writeprofilestring($shortcutname,"InternetShortcut","IconFile",$iconpath)
        $rc=writeprofilestring($shortcutname,"InternetShortcut","IconIndex",$iconindex)
      endif
      $shortcut = 0
      $wshshortcut=0
    else
      exit @error
    endif 
  else
    exit @error
  endif 
endfunction   
83592XLGetRightMostColumn29JochenXLGetRightMostColumn() - if your script generates excel files of dynamic width0The other day I had to list non-standard Services on our Servers so I didn't know the amount of colums .. The idea here is to write the second dimensions of an array to a Range of cols (Range("A" + $Row + ":" + $Unknown + $Row)
Code:


;FUNCTION         XLGetRightMostColumn()
;
;AUTHOR           Jochen Polster (jochenDOTpolsterATgmxDOTnet)
;
;VERSION          1.1 08/17/2004 -> fixed version now returns true column values, sorry
;
;ACTION           returns the Column indicator of the Rightmost column of an excel sheet
;
;SYNTAX           XLGetRightMostColumn(Columns,[Leftout])
;
;PARAMETERS       Colums (Required)
;                  -  Integer Value representing the amount of columns
;
;                 Leftout (Optional)
;                  -  If specified , the function will add the amount to Columns
;                     (dunno if this is useful, but hey ...)
;
;REMARKS          In the most cases Columns will be the upper boundary of a header array + 1
;
;RETURNS          String value containing the rightmost column
;
;DEPENDENCIES     None
;
;EXAMPLES         dim $header[ubound($OtherArray)+1]
;                  $header[0] = "Name of Server"
;                  for $i = 1 to ubound($header)
;                    $header[$i] = $OtherArray[$i-1] + chr(10) + '(' + $YetAnotherArray[$i-1] + ')'
;                  next
;                  $Rcol = XLGetRightMostColumn(ubound($header)+1)
;                 $xl.Range("A1:" + $Rcol + "1").Value = $header

function XLGetRightMostColumn($cols,optional $leftout)
    if $cols+$leftout-1 > 255 exit () endif   ;rightmost passed ;)
    dim $Grid
    $Grid = 'A','B','C','D','E','F','G','H','I','J','K','L','M',
            'N','O','P','Q','R','S','T','U','V','W','X','Y','Z'
    if $cols+$leftout > 26
        dim $X_ , $_X
        $X_ = ($cols+$leftout)  /  26 - 1
        $_X = ($cols+$leftout) mod 26 - 1
        if ($cols+$leftout) mod 26 = 0
            $X_ = $X_ - 1
            $_X = 25
        endif
        $XLGetRightMostColumn = $Grid[$X_] + $Grid[$_X]
    else
        $XLGetRightmostColumn = $Grid[($cols+$leftout)-1]
    endif
endfunction


hope someone finds this useful

Jochen
 
[edit: updated version 08/17/2004 -> the function now functions correctly, sorry !]180986xlLib2980Glenn BarnasxlLib() - A library of UDFs for working with Excel Spreadsheets0

ÿCode:

;; xlLib - a library of MS Excel interface functions
;;
;; A collection of UDFs to interface with MS Excel
;; Extensive testing with MS Office XP, and Office 2K3
;;
;; Most functions in this library are dual-purpose. If you specify 
;; a data value, it will be written. If you do not specify data values,
;; the current data or setting values will be returned.
;;
;;
;; Glenn Barnas
;; Version 1.0	2007/10/01	First Published Release
;; Version 0.8	2005/11/08	First test release
;; 
;;	xlInit()		Create the Excel object reference
;;	xlQuit()		Destroy the instantiated object & shut down Excel
;;	xlFile()		Open, Save, or SaveAs file functions
;;	xlBookCreate()		Create a new workbook in the active object
;;	xlBookProperties()	Read / Set the workbook properties
;;
;;	xlSheetAdd()		Create a new worksheet, define properties
;;	xlSheetName()		Read / Set the active worksheet name
;;	xlSheetSelect()		Set the active worksheet by name or index #
;;	xlSheetDelete()		Delete the specified sheet
;;	xlSheetPrint()		Prints the specified sheet
;;	xlSheetCount()	   (EK)	Returns the number of sheets in the workbook
;;
;;	xlRangeValue()		Read / Write a worksheet cell or range
;;	xlRangeClear()		Clear the specified worksheet range
;;	xlRangeDelete()		Delete the specified worksheet range
;;	xlRangeFormat()		Read / Set style formatting attributes on a cell range
;;	xlRangeFormatNum() (EK)	Read / Set number formatting attributes on a cell range
;;	xlRangeFreeze()		Set / Unset display pane freezing at a specific cell
;;	xlRangePrint()		Prints the specified worksheet range
;;	xlRangeSearch()	   (EK)	Searches a range for a value
;;	xlRangeSort()	   (EK)	Sorts the specified range
;;
;;	xlPageSetup()		Read / Set global format and printing options
;;	xlWindow()		Read / Set the Excel application window visibility status
;;
;; The following are utility functions to aid in the manipulation of Excel settings
;;	xlCol()			Translate between alpha and numeric column IDs
;;	xlColRow()		Splits a cell reference (A1) into component reference parts (A, 1)
;;	xlColor()		Translates between color names and index values
;;
;; The functions marked "(EK)" were originally developed by Erik Kaerholm and adapted
;; to this library by Glenn Barnas. Erik's original library can be found at
;; http://www.kixtart.org/forums/ubbthreads.php?ubb=showflat&Number=86576
;;

xlLib.zip file available here - latest version is always available on my web site at http://www.innotechcg.com
The Zip file contains the library file and a .KIX script that tests each of the functions, which is helpful for learning how to use the library. Due to the size of the script (50K), it is not posted in source code form.

Glenn
83159XLSChoice31RadimusXLSChoice() - use xlsinput box to promt the user for a choice0XLSChoice() 
Action: 
Prompts the user with a list of values to enter a choice
Syntax:
XLSChoice($prompt, optional $title, optional $param, optional $default, optional $left, optional $top, optional $type)
Parameters:
Param is deliminated by slashes /, fe 1/2/3/4/5/6/7/8/9
Otherwise is identical to XLSInputBox()
Returns:
the accepted/entered value or -1 for bad $param
Remarks:
Is basically just a wrapper for XLSInputbox. However nothing can make a user to make a decision.
Dependencies:
Kix 4.01+
Excel
XLSInputBox() - included below
Examples:
XLSChoice("Enter a number 1-4", "Title of Window", "1/2/3/4", "1")

code:

Function XLSChoice($prompt, optional $title, optional $param, optional $default, optional $left, optional $top, optional $type)
	dim $return,$valid, $possible, $retry 

	if instr($param,"/")
		$valid=split($param,"/")
	else
		$XLSChoice=-1
		return
		endif
	$retry=1
	while $retry=1
		$return=XLSInputbox($prompt, $title, $default, $left, $top, $type)
		for each $possible in $valid
			if $possible=$return
				$retry=0
				$XLSChoice=$return
				endif
			next
		if $retry=1
			$=messagebox("The value you entered is not permitted. Try again","Error",0)
			endif
		loop
	EndFunction

Function XLSInputbox($prompt, optional $title, optional $default, optional $left, optional $top, optional $type)
	dim $xls 
	$xls = createobject("excel.application")
	if $xls  
		if vartype($default) = 0 	$default = ""  		endif  
		if vartype($type) = 0 		$type = 2		endif
		$xlsInputBox = $xls.inputbox($prompt,$title,$default,$left,$top,,,$type)
		$xls.quit
		$xls = 0
		endif
	EndFunction


 
 [ 03. October 2003, 14:56: Message edited by: Radimus ]82447XlsInputBox11ShawnXlsInputBox() - Displays a dialog box for user input (using excel)0Bryce and I were trying to get this happening inside Internet Explorer but couldn't (properly). But with the recent talk about COM and Excel, I'm reminded that Office has builtin support for inputbox().

XlsInputBox()

Action:

Displays a dialog box for user input (using excel).

Syntax:

XlsInputBox(Prompt [, Title [, Default [, Left [, Top [, Type ]]]]])

Parameters:

Prompt Required String. The message to be displayed in the dialog box. This can be a string, a number, a date, or a Boolean value (Microsoft Excel automatically coerces the value to a String before it's displayed).

Title Optional Variant. The title for the input box. If this argument is omitted, the default title is "Input."

Default Optional Variant. Specifies a value that will appear in the text box when the dialog box is initially displayed. If this argument is omitted, the text box is left empty. This value can be a Range object.

Left Optional Variant. Specifies an x position for the dialog box in relation to the upper-left corner of the screen, in points.

Top Optional Variant. Specifies a y position for the dialog box in relation to the upper-left corner of the screen, in points.

Type Optional Variant. Specifies the return data type. If this argument is omitted, the dialog box returns text. Can be one or a sum of the following values.



 0 A formula 
 1 A number 
 2 Text (a string) 
 4 A logical value (True or False) 
 8 A cell reference, as a Range object 
16 An error value, such as #N/A 
64 An array of values 


Returns:

Returns the information entered in the dialog box.

Remarks:

Use XlsInputBox to display a simple dialog box so that you can enter information to be used in a script. The dialog box has an OK button and a Cancel button. If you choose the OK button, XlsInputBox returns the value entered in the dialog box. If you click the Cancel button, XlsInputBox returns False.

Dependencies:

KiXtart 4.0 (final)
Microsoft Office (Excel)

Example(s):


$name = XlsInputBox("What is your name?","Name","kixtart junky",10,10)

?"Welcome to COM " $name



Source:

function XlsInputBox(
 $prompt,
 optional $title,
 optional $default,
 optional $left,
 optional $top,
 optional $type)
 dim $xls $xls = createobject("excel.application")
 if $xls
  if vartype($default) = 0 ; empty
   $default = ""
  endif
  if vartype($type) = 0 ; empty
   $type = 2
  endif
  $xlsInputBox = $xls.inputbox($prompt,$title,$default,$left,$top,,,$type)
  $xls.quit
  $xls = 0
 endif
endfunction


Author:

-Shawn
 
 [ 21. February 2003, 16:16: Message edited by: Shawn ]83499XOR167BonjiXOR() - Exclusive OR operation using bitwise AND0

code:

;Function	XOR()
;
;Author		Ben Dulaney
;
;Version	1.0
;
;Action		Performs an eXclusive OR operation on a binary value
;
;Syntax		XOR("Binary Value", "Bit to Swap")
;
;Parameters
;		BINARY VALUE	: REQUIRED. The value of the binary number to be manipulated.
;		BIT TO SWAP	: REQUIRED. A Power of 2 Number (i.e. 2,4,8,16,32,512)
;
;Returns	Value of bit-swapped binary number
;		1 if BIT TO SWAP is invalid
;
;Dependencies	KiX 4.10+ 
;
;Example	$VAL1 = XOR(577,64)
;
;Source

Function XOR($BinaryVal,$Bit)
	Dim $TstBit
	$TstBit = $Bit
	WHILE $TstBit MOD 2 = 0 AND $TstBit <> 1
		$TstBit = $TstBit / 2
	LOOP
	IF $TstBit <> 1
		EXIT(1)
		RETURN
	ENDIF
	Dim $TmpVar
	$TmpVar=$BinaryVal - ($BinaryVal & $Bit)
	IF $TmpVar = $BinaryVal   ;The bit was off
		$XOR = $BinaryVal + $Bit
	ELSE                      ;The bit was on
		$XOR = $BinaryVal - $Bit
	ENDIF
EndFunction


 
 [ 13. September 2002, 19:59: Message edited by: Ben Dulaney ]136211XPFirewall1734Tony SummyXPFirewall() - Turns on|off the Windows XP Service Pack 2 firewall0Code:


;FUNCTION
;	XPFirewall()
;
;AUTHOR
;	Anthony Summy
;
;ACTION
;	Turns the Windows XP Service Pack 2 firewall on/off
;
;VERSION
;	1.0
;
;SYNTAX
;	XPFirewall(ACTION)
;
;PARAMETERS
;	1 (TRUE) or 0 (FALSE)
;	1 = Turn on the firewall
;	0 = Turn off the firewall
;
;RETURNS
;	No return value
;
;REMARKS
;
;DEPENDENCIES
;	None (tested with kixtart 4.02, release 1/18/2002)
;
;EXAMPLES
;	XPFirewall(0)
;	XPFirewall(1)
;

Function XPFirewall($Action)

	$WinXPFwKey=$hklm+"\SOFTWARE\Policies\Microsoft\WindowsFirewall"

	$WinXPFwDomKey=$WinXPFwKey+"\DomainProfile"
	if ReadValue($WinXPFwDomKey,"EnableFirewall")<>$Action
		if KeyExist($WinXPFwDomKey)=0
			$err=AddKey($WinXPFwDomKey)
		endif
		$err=WriteValue($WinXPFwDomKey,"EnableFirewall","$Action","REG_DWORD")
	endif

	$WinXPFwStdKey=$WinXPFwKey+"\StandardProfile"
	if ReadValue($WinXPFwStdKey,"EnableFirewall")<>$Action
		if KeyExist($WinXPFwStdKey)=0
			$err=AddKey($WinXPFwStdKey)
		endif
		$err=WriteValue($WinXPFwStdKey,"EnableFirewall","$Action","REG_DWORD")
	endif
EndFunction

136213XPPopUpBlocker1734Tony SummyXPPopUpBlocker() - Turns on|off the Windows XP SP2 Pop-Up Blocker0Code:


;FUNCTION
;	XPPopUpBlocker()
;
;AUTHOR
;	Anthony Summy
;
;ACTION
;	Turns the Windows XP Service Pack 2 Pop-Up Blocker on/off
;
;VERSION
;	1.0
;
;SYNTAX
;	XPPopUpBlocker(ACTION)
;
;PARAMETERS
;	1 (TRUE) or 0 (FALSE)
;	1 = Turn on the Pop-Up Blocker
;	0 = Turn off the Pop-Up Blocker
;
;RETURNS
;	No return value
;
;REMARKS
;
;DEPENDENCIES
;	None (tested with kixtart 4.02, release 1/18/2002)
;
;EXAMPLES
;	XPPopUpBlocker(0)
;	XPPopUpBlocker(1)
;

Function XPPopUpBlocker($Action)

	$WinXPIEPopUpBlockerKey=$hkcu+"\Software\Microsoft\Internet Explorer\New Windows"

	Select
		Case $Action=1
			if ReadValue($WinXPIEPopUpBlockerKey,"PopupMgr")<>"no"
				if KeyExist($WinXPIEPopUpBlockerKey)=0
					$err=AddKey($WinXPIEPopUpBlockerKey)
				endif
				$err=WriteValue($WinXPIEPopUpBlockerKey,"PopupMgr","no","REG_SZ")
			endif

		Case $Action=0
			if ReadValue($WinXPIEPopUpBlockerKey,"PopupMgr")<>"yes"
				if KeyExist($WinXPIEPopUpBlockerKey)=0
					$err=AddKey($WinXPIEPopUpBlockerKey)
				endif
				$err=WriteValue($WinXPIEPopUpBlockerKey,"PopupMgr","yes","REG_SZ")
			endif
	EndSelect

EndFunction

 
